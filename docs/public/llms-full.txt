LLMS_FULL_VERSION: 1
SITE_BASE_URL: https://apostrophecms.com/docs
GENERATED_AT: 2026-01-06T14:28:31.618Z
TOTAL_PAGES: 178

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Introduction
DOC_PATH: guide/introduction.md
URL: https://apostrophecms.com/docs/guide/introduction
================================================================================
# What is ApostropheCMS?

ApostropheCMS is a modern, open source, content management system. It's JavaScript from front to back, with a Vue.js user interface and Node.js on the server. Importantly, it has everything you might want from a modern CMS, including:

- a headless API built-in
- a field schema API to create any kind of content types you need
- extensibility through a module ecosystem
- a great UI for creating content, including in-context editing
- robust localization to support any number of language or locale content variations

For developers, it offers a site building API that gives you the power to fully customize the website experience without needing to be a Node.js expert. For content editors, the _true_ WYSIWYG experience supports improved editorial flow.

In short, it recognizes pain points on both sides of the CMS experience and relieves them.

## Give it a test run

Please [try the Apostrophe demo](http://demo.apostrophecms.com/) for yourself if you haven't yet. That hands-on experience will provide valuable context as you learn about building with Apostrophe. Take notice of key features, including:

- in-context editing
- switching between "Published" and "Draft" modes
- content creation through the admin menu

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Why Apostrophe
DOC_PATH: guide/why-apostrophe.md
URL: https://apostrophecms.com/docs/guide/why-apostrophe
================================================================================
# Why Apostrophe?

<iframe src="https://www.youtube.com/embed/AwprTZ_Ujjk?si=XwD6tpWSuCcNSE_m" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## **Overview**

We developed Apostrophe because we found ourselves repeating the same tasks, making the same changes, and expressing the same complaints whenever we started a project with another framework or CMS.

So what are the advantages of Apostrophe, and how do they make CMS development more efficient and effective? We'll answer those questions here.

## **One programming language: no context switching**

Apostrophe is written entirely in JavaScript. Server-side, Apostrophe is powered by the Node.js runtime environment. Unless you choose to use Apostrophe as a headless CMS, the editor and administration experience is delivered by the popular Vue.js framework. No switching between languages means less mental work for the developer.

### **JavaScript is ubiquitous**

The developer communities for JavaScript and Node.js are huge, which means there is a large amount of expertise and resources available to speed development. Current versions of Node.js and ApostropheCMS provide access to modern JavaScript features like ECMAScript Modules (ESM), enabling cleaner and more maintainable code. And with a customizable webpack build at project level, you can achieve the same results for all browsers. Good examples include [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), the [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax), and the [const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const) and [let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) keywords. For more, watch [ES6 and Beyond: writing better code with Modern JavaScript.](https://www.youtube.com/watch?v=Y1egnF8db34)

### **Vue.js: Javascript in the UI**

Vue.js is a popular, performant, and versatile framework for building reactive web user interfaces. It builds components on top of standard HTML, CSS, and JavaScript, allowing developers to create dynamic and interactive interface components with ease.

It boasts a large and active community of developers, contributing to a rich ecosystem of libraries and tools. This community-driven approach ensures that there are plenty of resources available, from tutorials to plugins, to support both new and experienced developers. Vue's flexibility and community support make it an excellent choice within Apostrophe's architecture.

Apostrophe's built-in webpack allows developers to utilize the latest JavaScript features and CSS preprocessors, aligning with Apostrophe's emphasis on modern, efficient development. By using Vue, Apostrophe offers a unified, JavaScript-centric development environment, furthering the goal of "no context switching" and enabling developers to focus on what matters most: building great web experiences.

### **MongoDB: JavaScript in the database layer**

Apostrophe takes this goal of "no context switching" all the way to the database layer. Rather than a relational database such as Postgres or MySQL, Apostrophe is built on MongoDB, which has a query language directly based on JavaScript objects. This means there are no code injection attacks. But it also means the developer doesn't have to switch mental gears between two languages when making a database query.

Apostrophe's own built-in query builder uses chainable methods, similar to ORMs (Object-Relational Mappers) you may have used, to build queries while automatically taking care of fundamentals like choosing the right type of document and enforcing permissions. However, the door is open to including [MongoDB queries](https://docs.mongodb.com/manual/tutorial/query-documents/) to filter data as you see fit.

## **Performance**

Because Apostrophe is written in JavaScript on both the front and the back end, it can leverage Node.js, which is powered by the same open-source "v8" runtime that powers Chrome. Due to browser competition, the performance of v8 is far superior to that of PHP and most other languages that are traditionally chosen for CMS work.

MongoDB also contributes to the performance of Apostrophe. Because it is designed from the beginning to support structured documents rather than just table rows, MongoDB can efficiently represent and query an entire page as a single document in the database.

## **DRY (Don't Repeat Yourself)**

In some frameworks, CMS work requires a lot of boilerplate code and repetition. Apostrophe is designed from the start to avoid repetition.

### **Pieces: reusable content for your site**

When you want to create a new content type, you can use Apostrophe's object-oriented features to extend our `@apostrophecms/piece-type` module to create a new "piece type" module with all the functionality of the base module but still independently customizable. This is perfect for content types like blog posts or products. Creation of a new module immediately gives you a user interface for managing content, a database layer to store and access said content, and the option of also extending our `@apostrophecms/piece-page-type` module to present the content to your site's audience. All of these features automatically draw on the same schema, avoiding code repetition.

### **Widgets: editable content on the page**

Similarly, Apostrophe offers a widget-type "base class module" that can be extended to create smaller units of editable content with custom functionality without copy-and-paste, hard-to-maintain code generators or boilerplate. Apostrophe's **areas** allow the user to create and manage a series of widgets through a friendly interface. As a developer, all you have to do is define the fields your widget needs, a template to render it, and optionally a JavaScript "player" to add interactive features. Apostrophe manages all of this functionality for you and gives you clear guidance on where to put the code.

## **Flexible schemas**

Apostrophe's [schemas](/guide/content-schema.md) provide a way to define the fields that make up your content types in a single place. Schema field types include the usual choices, like strings, integers, floats, and booleans, but also array fields which can have their own schemas, and relationships that connect documents. This lets you take advantage of MongoDB's support for building nested documents.

## **Smart media handling**

We understand that content creators often struggle to manage media on CMS sites. This can lead to real problems when images of the wrong size or type are inserted into the design.

This is why Apostrophe has built-in features to scale images to a set of suitable sizes, crop images, enforce aspect ratios, and pick "focal points" for better responsive results. Apostrophe also includes a helper function to generate srcset attributes for the best responsive outcome.

## **Scalability**

Not all CMSes are designed to scale up smoothly for the largest audiences. While Apostrophe starts out configured for simple development and production environments, Apostrophe's [uploadfs](https://github.com/apostrophecms/uploadfs?tab=readme-ov-file#readme) module already includes support for storing media with Amazon Web Services, Azure, or Google Cloud Storage. With the addition of a [MongoDB Atlas](https://www.mongodb.com/cloud/atlas/) cloud database, Apostrophe becomes "stateless," allowing you to load-balance as many instances as you need for a high-traffic site.

## **Better for your content creators**

All the features in the world won't help if content creation is an unpleasant process. Apostrophe's user interface provides an intuitive way to edit content right on the page. Throughout Apostrophe, care has been taken to keep the interface clear and friendly for the editor.

## **Extensibility**

Apostrophe is designed to be extended. Any Apostrophe module or group of modules can be publicly or privately published for reuse as an npm module, like [`@apostrophecms/form`](https://www.npmjs.com/package/@apostrophecms/form) or [`@apostrophecms/blog`](https://www.npmjs.com/package/@apostrophecms/blog).

In addition, Apostrophe's `improve` feature allows us to ship "improvements" to core functions without code duplication and maintenance problems. This takes object-oriented programming and inheritance a step further than most frameworks. The [`@apostrophecms/piece-type-exporter`](https://github.com/apostrophecms/piece-type-exporter) npm module is a good example, adding the ability to export CSV and Excel files from any "piece-type" (content type).

## **A rich library of optional modules**

Taking advantage of its extensibility, Apostrophe maintains an official library of optional npm modules. You can [learn more about our official npm modules here](https://apostrophecms.com/extensions).

## **Approvals, localization, and internationalization**

Apostrophe provides an approval flow for content, as well as localization and internationalization capabilities (l10n and i18n) right out of the box. Any document can be translated into multiple languages, with no performance impact on the rest of the site.

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Technical Overview
DOC_PATH: guide/technical-overview.md
URL: https://apostrophecms.com/docs/guide/technical-overview
================================================================================
# Technical overview

<iframe src="https://www.youtube.com/embed/DoOSBfOy6NY?si=ZziVXYUqaSyEVZn2" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## The core tech

In brief, the main technologies behind Apostrophe are:

- [Node.js](https://nodejs.org): **Popular server-side JavaScript runtime.** We originally chose Node.js to achieve a fully-JavaScript development experience for developers. It has continued to improve over time, delivering high performance and powerful features we can use.
- [Express](https://npmjs.org/package/express): **Un-opinionated Node.js web framework.** Express is the most widely used web framework for Node.js. Because it is simple, un-opinionated, and well-known, it was straightforward to extend it to suit Apostrophe's needs.
- [MongoDB](https://www.mongodb.com): **Secure, document-based database engine.** We chose MongoDB for its fluent JavaScript-based API, its safety from "SQL injection"‚Äîstyle attacks, its developer-friendliness, and its support for documents with varying schemas in the same collection.
- [Nunjucks](https://mozilla.github.io/nunjucks/): **Richly featured template language for JavaScript.** Nunjucks provides tons of features, extensibility, and a syntax nearly identical to Twig, Jinja, and other Django-inspired templating languages.

## Directory structure

There are a few directories and top-level files that are especially important in Apostrophe projects. Here is a rough overview of these files and folders you will see in the official boilerplate, starter-kit-essentials.

| Folder/File | What is it? |
| ------ | ------ |
| `app.js` | The heart of the application. This is where you tell Apostrophe what modules are in your project and set a few top-level parameters. |
| `/modules` | All project-level [modules](/reference/glossary.md#module) and configuration for installed modules. |
| `/public` | Public, static files (not managed through the CMS). Apostrophe will generate specific directories inside, but you can also use it as needed.  |
| `/views` | Template files that do not belong to any one module. Apostrophe looks for site wrapper templates here, including `layout.html`. |

::: tip
Core module configuration is all done in a subdirectory of `modules`: `modules/@apostrophecms`. This keeps core modules organized together and out of the way, following [the npm scoping pattern](https://docs.npmjs.com/about-scopes).

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Core Concepts
DOC_PATH: guide/core-concepts.md
URL: https://apostrophecms.com/docs/guide/core-concepts
================================================================================
# **Apostrophe Core Concepts**

<iframe src="https://www.youtube.com/embed/0YSvNb2rMto?si=Zws1VF1XMMdh5x1a" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Overview

In this section, we'll discuss the key concepts to understand in order to architect and build your applications efficiently. We will discuss each concept more deeply in other guides. This is simply an overview to become familiar with the terms.

## Modules

Apostrophe is built using a system of **modules**. We'll get into a more detailed technical review of Apostrophe's module system later in this training, but for now, just understand that everything in Apostrophe comes from a module.

If you're familiar with JavaScript modules, the module concept should already be familiar to you. But if not, a module is self-contained code that defines a specific set of functionality. In other words, each module is responsible for providing one feature, such as a type of widget, a type of customized page, or a service. This could be anything from defining fields for a blog post content type to integrating with third-party services. In short, modules are the building blocks of your application.

One important concept regarding modules in Apostrophe is how they work within the [project's ecosystem](/guide/module-configuration-patterns.html). Project-level modules inherit the functionality of core Apostrophe modules and then extend or improve that functionality. Later in this training, we will provide a more detailed technical review of Apostrophe's module system.

## Schemas

The field schema of a piece, page, or widget defines a set of input fields that are presented to the end user. Not only do these fields create an editing interface, but they also sanitize and save the data on the server side. Commonly used field types include strings, integers, floats, select elements, and "relationship" fields, which allow editors to define connections to other docs.

A module schema is built according to what is defined in its `fields` property configuration via the `add`, `remove`, and `group` properties, as well as to what is inherited from the fields configuration of the parent module. 

For instance, every module that extends `@apostrophecms/widget-type` will by default have the same schema inherited from the parent module and will be able to add, remove, or edit the grouping of the fields inherited.

## Pages

**Pages** in Apostrophe are used for content that is typically edited less frequently and should be organized hierarchically within a page tree rather than by date or taxonomy. Pages are always viewed as a page and are rarely reused for content in other contexts. Pages are (typically) for less structured content so are generally more free-form. Pages can be made as editable as needed or can purely serve static content.

Page types are created by extending the `@apostrophecms/page-type` module and can be configured using schemas. Each page type module created is assigned a page type, such as `blog-page`. This page type enables developers to establish a consistent template that matches the desired layout and functionality for that particular type of page.

Out of the box, Apostrophe defines a `home-page` type for you that is "parked" at the top of the page tree. Other pages are typically sub-pages of the home page.

::: info
üìå For additional information on configuring pages, see [Page Templates](/guide/pages.html) in the Apostrophe docs.

## Pieces

**["Piece types"](/guide/pieces.html)** in Apostrophe are collections of structured content, often referred to as "content types" in other systems. Each item created from a piece type is a **"piece."** Pieces are typically organized by date or taxonomy.

[**Field schemas**](/guide/content-schema.html) are used to define the data modal of a particular piece type. When you define a piece type by extending the `@apostrophecms/piece-type` module, Apostrophe will include basic required schema fields out of the box, such as the title and slug fields. You can then configure your schema with more fields to fit your requirements.

Pieces can be displayed using pieces pages, which are specialized page types, or widgets. Pieces pages can show a collection of pieces through the `index.html` template page, or an individual piece using the `show.html` template page. Using widgets to display pieces allows you to show pieces in the context of other relevant content, like related articles. We'll explore this later, just know for now that there are different ways to display pieces.

Common examples of pieces are articles, events, or products.

::: info
üìå For additional information on schema field types, see the [Schema Field Type reference](/reference/field-types/) in the Apostrophe docs.

## Widgets

**Widgets** in Apostrophe are blocks of editable content that can be added to `area` schema fields within pieces or pages. The developer has control over which and how many widgets can be added to an individual area. Pieces and pages are stored in the database as individual documents within a collection. Widgets are part of a piece or page document, not individual documents themselves. This means any data entered into a widget is associated with the piece or page where that widget was added and can't be retrieved independently from the database.

Widgets are configurable using field schemas, and they can also include options. By providing widget options, you can create variations of widgets that might contain similar content but are visualized differently on the front end.

Apostrophe provides several simple widgets to help you get started building your site. You are free to customize these widgets and add your own completely custom widgets as you see fit.

Common examples of widgets are Rich Text Widgets, Image Widgets, Slideshow Widgets, or an Article Widget.

::: info
üìå For a list of the included widgets, see [Standard (Included) Widgets](/guide/core-widgets.html) in the Apostrophe docs.

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Development Setup
DOC_PATH: guide/development-setup.md
URL: https://apostrophecms.com/docs/guide/development-setup
================================================================================
# Setting Up Your Environment

::: tip Howdy! üëãüèª
This documentation is available in textual and video forms. Watch the video for your operating system, or continue reading if you prefer. Of course, you can also do both!

**Note:** The second video tutorial shows setup for Linux OS and WSL 2 on Windows OS. We now support direct Windows development as well - see the text documentation below for all options. Updated videos coming soon!

<iframe src="https://www.youtube.com/embed/nTjDATerqEg?si=ItkK3gz4-CJmI1WI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<iframe src="https://www.youtube.com/embed/Ep_FvRt8thI?si=XEThrEvtaNyTdKo7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Overview
This article covers the first steps to get started. We're going to make sure your workstation is ready for development and give an overview of the Apostrophe CLI. ApostropheCMS development works on Windows, macOS, and Linux.

::: info üìå Windows Development Options
Windows developers have two options:

**Direct Windows Development (Git Bash + NVM for Windows)**
- Works directly on Windows with Git Bash (included with [Git for Windows](https://git-scm.com/download/win)) as your terminal
- Quick to set up and familiar if you're used to Windows
- All instructions on this page apply unless specifically noted
- We strongly recommend using Git Bash - npm does not work out of the box in PowerShell (this is not an ApostropheCMS issue, but a general npm limitation on Windows). You can pursue PowerShell if you strongly prefer it, but Git Bash ensures the best compatibility.

**Windows Subsystem for Linux (WSL 2)**
- Provides a Linux environment within Windows
- More similar to typical production server environments
- May have better compatibility with some native Node modules
- More predictable behavior with `npm link` and shell scripts
- [Installation guide](https://learn.microsoft.com/en-us/windows/wsl/install)

Both approaches are fully supported. Choose based on your preference and workflow.

## Requirements

Let's get started with what you will need to have installed on your machine to run a project locally:

### 1. Node.js 22+/ npm

Node.js is a JavaScript runtime and it runs server-side JS, including the Apostrophe app. npm is automatically included with Node. While you can download and install these directly from https://nodejs.org, we highly encourage using a Node Version Manager to allow you to switch easily between Node and npm versions.

**For macOS, Linux, and WSL:**
Use NVM (Node Version Manager). You can find the installation instructions [here](https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating).

**For Windows (native):**
Use NVM for Windows. Installation instructions are available [here](https://github.com/coreybutler/nvm-windows#installation--upgrades).

Once installed for any operating system, you can switch between different versions of Node and npm:

```bash
$ nvm install 22
# and
$ nvm use 22
```

### 2. MongoDB 8.0+

You can make a MongoDB instance available to your project in three ways:

**Option 1: MongoDB Atlas**

MongoDB offers a hosted version of the server, [MongoDB Atlas](https://www.mongodb.com/atlas/database), that offers a free tier and doesn't require any local software installation. You can set a connection string for a hosted instance using the `APOS_MONGODB_URI` environment variable or by setting the options of the [`@apostrophecms/db` module](/reference/modules/db.html) at the project level.

For example:
```bash
export APOS_MONGODB_URI="mongodb+srv://username:pa%24%24word@mycluster.1234x.mongodb.net/YOUR-PROJECT-NAME?retryWrites=true&w=majority"
```

**Option 2: Docker**

For offline local development, you can use Docker to host the server. You can follow our instructions [here](/guide/dockerized-mongodb.md) and then skip to the next [section](/guide/development-setup.md#installing-the-apostrophe-cli). By default, Apostrophe attempts to connect to the database using the connection string `mongodb://localhost:27017/<project-shortName>` where the `shortName` is set in the project `app.js` file. The Docker tutorial sets the MongoDB container up to use this port, so no changes are needed.

**Option 3: MongoDB Community Edition (Local Installation)**

The final option, also for local development, is to install the MongoDB Community Edition server. As with the Docker container, the Community Edition server uses port 27017 and Apostrophe will connect to the MongoDB instance without any additional changes.

**The following steps are only required if you intend to develop on a locally hosted MongoDB instance.**

Installation of the MongoDB Community Edition is slightly different for each OS. We advise that you follow the [instructions](https://www.mongodb.com/docs/v8.0/administration/install-community/) on the MongoDB website for your OS.

For Windows users developing directly on Windows (not using WSL), the MongoDB Community Edition installer provides a straightforward graphical installation process that's as simple as using Atlas.

- **Windows users**: Follow the [Windows installation guide](https://www.mongodb.com/docs/v8.0/tutorial/install-mongodb-on-windows/)
- **macOS users**: Follow the [macOS installation guide](https://www.mongodb.com/docs/v8.0/tutorial/install-mongodb-on-os-x/)
- **Linux users**: Follow the guide for your [specific distribution](https://www.mongodb.com/docs/v8.0/installation/#mongodb-installation-tutorials)
- **WSL users**: Install from within WSL and follow the [Ubuntu installation guide](https://www.mongodb.com/docs/v8.0/tutorial/install-mongodb-on-ubuntu/)

::: info üìå When using Ubuntu 22.04, the minimum supported MongoDB version is 8.0. If your production environment requires that you use an earlier version of MongoDB for development, we advise you to use Ubuntu 20.04.

In addition to installing MongoDB Community Edition, there are options in the instructions for restarting MongoDB following a system reboot. You can opt to either follow these instructions or manually start MongoDB each time you reboot.

To check for successful installation of these tools, try the following commands:

```bash
# This will display your Node.js version and npm version (installed with Node),
# if installed successfully.
node -v && npm -v

# This will display your MongoDB version, if installed successfully.
mongod --version
```

### Installing the Apostrophe CLI
There is an [official CLI](https://github.com/apostrophecms/cli) for quickly setting up starter code for your Apostrophe project. Once in a project, the CLI can also help add new module code with a single command so you can focus on the aspects that are unique to your project rather than copying or remembering boilerplate.

The CLI is **not required** to work with Apostrophe, but it makes developing with Apostrophe faster and takes care of the more repetitive tasks during development. This is especially true when creating a new project.

Install the CLI globally through npm.
`npm install --location=global @apostrophecms/cli`

::: info üìå You can review more information about the Apostrophe CLI in the doc [here](https://www.npmjs.com/package/@apostrophecms/cli)

## Creating a project

If you are not using Atlas, make sure your local server has been started before creating a project. MongoDB can be configured to run all the time or started as needed, but it must be up and running to provide a storage option for your initial admin user.

The easiest way to get started with Apostrophe is to use one of the official starter kit projects. If you have the CLI installed, go into your normal projects directory and use the command:

``` bash
apos create apos-app
```

This will install the ["Essentials"](https://github.com/apostrophecms/starter-kit-essentials) starter kit.

::: tip
üí° To install other starter kits, pass the `--starter` flag, along with the short name of one of our [starter kits](https://github.com/orgs/apostrophecms/repositories?q=starter-kit&type=all&language=&sort=). For example:

``` bash
apos create apos-app --starter=ecommerce
```

If you are using a MongoDB Atlas instance, add the `--mongodb-uri` flag, along with the URL of your Atlas instance. It is generally a good idea to enclose the entire connection string in quotes and use percent encoding for any special characters. For example:

``` bash
apos create apos-app --mongodb-uri="mongodb+srv://username:pa%24%24word@mycluster.1234x.mongodb.net/YOUR_PROJECT_NAME?retryWrites=true&w=majority"
```

Where the original unescaped connection string is: `mongodb+srv://username:pa$$word@mycluster.1234x.mongodb.net/?retryWrites=true&w=majority
`

The CLI will take care of installing dependencies and walk you through creating the first user. You can then skip down to the ["Finishing touches"](#finishing-touches) section.

#### *If you don't want to use the CLI*, or if you want to see other things it does for you, continue on.

To get started quickly without the CLI, clone the starter repository:

```bash
git clone https://github.com/apostrophecms/starter-kit-essentials apos-app
```

If you want to change the project directory name, please do so. We will continue referring to `apos-app`.

Open the `app.js` file in the root project directory. Find the `shortName` setting and change it to match your project (only letters, digits, hyphens and/or underscores). This will be used as the name of your database.

<AposCodeBlock>

```javascript
import apostrophe from 'apostrophe';

apostrophe({
  root: import.meta,
  shortName: 'apos-app', // üëà
  modules: {
  // ...
```
<template v-slot:caption>
app.js
</template>
</AposCodeBlock>

Excellent! Back in your terminal, we'll install dependencies:

```bash
npm install
```

Before starting up you'll need to create an admin-level user, either in your Atlas instance or local database, so that you can log in. After running the following command, Apostrophe will ask you to enter a password for this user.

Atlas Database
```bash
APOS_MONGODB_URI="mongodb+srv://username:pa%24%24word@mycluster.1234x.mongodb.net/YOUR-PROJECT-NAME?retryWrites=true&w=majority" node app @apostrophecms/user:add my-user admin
# Replace `my-user` with the name you want for your first user.
```

OR

Local Database
```bash
node app @apostrophecms/user:add my-user admin
# Replace `my-user` with the name you want for your first user.
```

::: tip
* When using MongoDB Atlas, it's a good practice to enclose your entire connection string in quotes to prevent any issues with special characters. Also, use percent-encoding for special characters in your password.

* Consider exporting your `APOS_MONGODB_URI` environment variable to make it available throughout your session. This approach helps in avoiding the repetition of the connection string and reduces the risk of errors.

### Finishing touches

You should also update the [session secret for Express.js](https://github.com/expressjs/session?tab=readme-ov-file#secret) to a unique, random string. The starter project has a placeholder for this option already. If you do not update this, you will see a warning each time the app starts up.

<AposCodeBlock>

```javascript
export default {
  options: {
    session: {
      // If this still says `undefined`, set a real secret!
      secret: undefined
    }
  }
};
```
<template v-slot:caption>
modules/@apostrophecms/express/index.js
</template>
</AposCodeBlock>

### Starting up the website

Start the site with `npm run dev`. If you are using an Atlas instance you need to pass the connection string through the `APOS_MONGODB_URI` environment variable or set the `uri` or other options of the `@apostrophecms/db` at project level. The app will then watch for changes in client-side code, rebuild the packages, then refresh the browser when it detects any. You can log in with the username and password you created at [http://localhost:3000/login](http://localhost:3000/login).

::: tip
If you are starting the site in a production environment or do not want the process to watch for changes, start the site with `node app.js`.

## Next steps

Now that Apostrophe is installed, you're ready to start building. Check out the [guide](/guide/modules.html) to learn about essential features with plenty of code examples. To learn about building a site from scratch, jump to our [tutorial series](/tutorials/introduction.html). If you are looking to explore Apostrophe's inner workings peruse the [reference guide](/reference/glossary.md).

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Windows Development
DOC_PATH: cookbook/windows-development.md
URL: https://apostrophecms.com/docs/cookbook/windows-development
================================================================================
# Windows Development with WSL 2 (Optional)

::: info üìå Multiple Windows Development Options

This guide covers setup using Windows Subsystem for Linux (WSL 2). If you prefer to develop directly on Windows using Git Bash and NVM for Windows, see our main [development setup guide](/guide/development-setup.md) instead. Both approaches are fully supported.

## Why Choose WSL 2?

WSL 2 provides a Linux environment within Windows that closely matches typical production deployment environments. Benefits include:

- Similar environment to Linux production servers
- Better compatibility with some native Node modules
- More predictable behavior with tools like `npm link`
- Easier to follow Linux-oriented documentation and tutorials

If these benefits align with your workflow, follow this guide for complete WSL 2 setup instructions.

## Installing Windows Subsystem for Linux

We'll start by installing WSL (Windows Subsystem for Linux). WSL allows you to run Linux applications without change on any up-to-date Windows 10 or Windows 11 system.

::: warning
We recommend that you use WSL2. If you have WSL1, here are [Microsoft's upgrade instructions.](https://docs.microsoft.com/en-us/windows/wsl/install#upgrade-version-from-wsl-1-to-wsl-2) As described in that article, you may need to take care of several steps including a kernel update and enabling virtualization in your BIOS. The correct steps to enable virtualization depend on your machine.

If you have never installed WSL before, WSL2 will be the default. The rest of this article assumes a first-time install of WSL2.

First, you must [install WSL according to the documentation](https://docs.microsoft.com/en-us/windows/wsl/install). In particular, we strongly recommend that you [install Ubuntu 22.04 LTS, which can also be done from the Windows app store](https://apps.microsoft.com/store/detail/ubuntu-2004/9N6SVWS3RX71?hl=en-us&gl=US). This method was tested for this article. Newer versions of Ubuntu might not support everything covered here, and 22.04 is supported without charge until 2027.

Second, launch Ubuntu 22.04 from the Start menu to access the Linux shell prompt. If you did not install Ubuntu via the Windows Store, you might need to access the prompt a different way, for instance by launching Powershell and typing `wsl ~`.

::: info
From here on out, all commands are intended to be typed at the Ubuntu 22.04 shell prompt, not the regular Windows command or Powershell prompt.

## Installing Node.js and npm

Next, install [nvm](https://github.com/nvm-sh/nvm). `nvm` is a great little utility that lets us run any version of Node.js we want without fussing with operating system packages. The correct command for installation changes over time, so [follow the official nvm installation guide](https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating). **Do not** follow nvm installation guides meant for the Windows command prompt. We want the plain vanilla Linux instructions.

::: warning
You will need to exit the Ubuntu 22.04 window and open a new one after you complete the `nvm` installation step above. Otherwise, the `nvm install` command in the next step will cause a Command Not Found error.

Now, install and start Node.js 18.x with this command:

```bash
nvm install 22
```

In the future, you can just type:

```bash
nvm use 22
```

::: warning
If this produces a "command not found" error, you most likely did not install `nvm` yet, or you did not restart your Ubuntu 22.04 window after installing `nvm`.

## Installing MongoDB

Now we'll need to provide a connection to a MongoDB instance. We can either use Atlas, create a Docker container to serve our database by following these [instructions](/guide/dockerized-mongodb.md), or install the MongoDB community server.

::: info
Follow these instructions to install the community server locally. If using Atlas or Docker, skip to the next [section](/cookbook/windows-development.md#installing-apostrophecms).

While MongoDB is not officially supported on WSL, the regular Linux install commands work fine for development purposes.

First, install the prerequisites if they're not already available:
```bash
sudo apt-get install gnupg curl
```

Now we'll import the MongoDB public GPG key and set up the repository:
```bash
curl -fsSL https://www.mongodb.org/static/pgp/server-8.0.asc | \
  sudo gpg -o /usr/share/keyrings/mongodb-server-8.0.gpg \
  --dearmor

echo "deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-8.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/8.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-8.0.list

sudo apt-get update
sudo apt-get install -y mongodb-org
```
These commands will install MongoDB 8.0.
When that command completes, possibly with a harmless warning or two, we're ready to set up a data folder and launch MongoDB.

### Creating a data folder for MongoDB

MongoDB needs a place to store your database, and the default is a system folder. For development purposes, we want to leave system folders alone. So let's create our own place for it:

```bash
mkdir -p ~/mongodb-data/8.0
```

### Launching MongoDB (every time you start work)

Now we're ready to launch MongoDB. We'll do this at the start of every session of work with ApostropheCMS:

```bash
mongod --dbpath=/home/apostrophe/mongodb-data/8.0
```

::: warning
Since `--dbpath` doesn't understand `~` as a shortcut for "my home directory" in WSL2, we've used the full path to our home directory here. In this case, we chose the username `apostrophe` when we set up Ubuntu 22.04. If you're not sure what username you created when you installed Ubuntu 22.04, type `echo $HOME` to find out.

You'll see quite a bit of output, and the command prompt should **not** return. It should just keep running ‚Äî and that's exactly what we want. You should **leave it running in this window for as long as you're working with ApostropheCMS, and open another, separate Ubuntu Window** to continue your work.

::: warning
If the command prompt does return, and you see a message like `fatal assertion`, then `mongod` was unable to start. Most likely you previously tried to run MongoDB in another way, and you need to fix a permissions problem and try again, like this:

```bash
sudo rm /tmp/mongodb-27017.sock
mongod --dbpath=/home/apostrophe/mongodb-data/8.0
```

You should only have to do this once to clean up the mess. In the future, **just remember: don't use `sudo`, you don't need it and it only makes a mess.** If there's an exception we'll explicitly show that in our tutorials.

Another possibility is that you tried to write `--dbpath=~/mongodb-data/8.0`. Again, you'll need to substitute your home directory name manually for the `~`. Use `echo $HOME` to find your home directory.

::: info
If typing this every time seems like a pain, try adding this line to your `.bashrc` file:

```bash
alias start-mongo="mongod --dbpath=/home/apostrophe/mongodb-data/8.0"
```

Save and close the file, restart your shell, and you can just type:

```bash
start-mongo
```

## Working in WSL: Best Practices

When developing ApostropheCMS and Node.js projects in WSL, it's crucial to choose the right location for your project files. Follow these best practices:

### 1. Use the Linux filesystem

Create and work on your projects within your WSL home directory (e.g., `/home/yourusername/`). This approach offers several benefits:

- Optimal performance for operations like `npm install`, `git` operations, and asset rebuilding
- Consistent line-ending format (LF), avoiding potential issues with mixed line endings
- Proper case-sensitivity, matching the behavior of most production environments
- Correct file permissions, preventing potential problems with script execution and file access

### 2. Avoid Windows-mounted drives

While it's possible to access Windows drives (e.g., `C:` or `D:`) through `/mnt/c` or `/mnt/d` in WSL, working directly from these locations can significantly slow down development tasks.

### 3. Starting in the right place

When beginning a new project or working on an existing one:

- Open your WSL terminal
- Navigate to your home directory: `cd ~`
- Create or access your project folder from here

### 4. Using Visual Studio Code

If you're using VS Code:

- Navigate to your project folder in the WSL terminal
- Type `code .` to open VS Code with the correct WSL context
- VS Code will handle the integration between Windows and WSL

### 5. Accessing Windows files when needed

You can still access your Windows files at `/mnt/c/`, `/mnt/d/`, etc., but use this for referencing files, not as your primary development location.

## Installing ApostropheCMS

Now we're ready to install the Apostrophe CLI (Command Line Interface)! To get started, **open a second Ubuntu 22.04 window**, and in that Window type:

```bash
nvm use 22
```

Now you're ready to use the current stable version of Node.js in this shell.

And from here, we can [follow the regular ApostropheCMS setup guide](/guide/development-setup.md#installing-the-apostrophe-cli). **You can skip the requirements section, since we already have MongoDB and Node.js installed.** Everything else is the same ‚Äî just remember to keep `mongod` running and do your work inside the Ubuntu shell prompt, and you'll be good to go.

::: warning
One more quick reminder: be sure to **leave `mongod` running in a separate Ubuntu window** while you work with Apostrophe.

## Next Steps

Continue with the main [development setup guide](/guide/development-setup.md#creating-a-project) to create your first ApostropheCMS project.

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Dockerized MongoDB
DOC_PATH: guide/dockerized-mongodb.md
URL: https://apostrophecms.com/docs/guide/dockerized-mongodb
================================================================================
# Setting up MongoDB in Docker for Development

Setting up MongoDB in Docker for local ApostropheCMS development streamlines your workflow by providing a consistent, isolated environment that mirrors production setups. This guide will help you configure MongoDB using Docker, ensuring a reliable and efficient database for your ApostropheCMS projects. Whether you're new to Docker or looking to optimize your setup, this step-by-step guide covers everything from initial configuration to troubleshooting.

ApostropheCMS relies on MongoDB for storing content and user data. While MongoDB's flexibility makes it ideal for a CMS, managing a local instance can be challenging due to dependencies and environment configurations. Docker simplifies this process by containerizing MongoDB, reducing conflicts, and maintaining a clean development environment, whether you're building new features, testing configurations, or contributing to a project.

## Docker Installation
In this guide we will assume that you have some basic knowledge of Docker and Docker Compose. We will be using Docker Desktop because it provides an intuitive GUI for performing many operations, but you can elect to just install and use the Docker engine and Docker Compose. To start, if you don't already have Docker Desktop installed on your computer, navigate to the [Docker website](https://docker.com) to download and install the version specific for your machine. You will also need to make an account to log in to your app.

## Creating a Docker Compose File for MongoDB

Docker Compose is a powerful tool that simplifies the management of containerized applications by allowing you to define services, networks, and volumes in a single YAML file. Even when bringing up a single MongoDB container, as we are doing in this guide, Docker Compose offers significant benefits. It ensures consistency and reusability across different environments, streamlines the container lifecycle with easy-to-use commands, and sets the stage for future scalability.

If you are going to be developing multiple ApostropheCMS projects, it makes sense to place the `docker-compose.yml` file in a standalone folder on your development partition. This approach also ensures that you won't later confuse it with any Docker Compose file needed for production deployment

Create a `docker-compose.yml` file in an appropriately located folder and add the following code:

<AposCodeBlock>

```yml
version: '3.8'
services:
  mongo:
    image: mongo:latest
    container_name: apostrophe-mongo
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db

volumes:
  mongo-data:

```
  <template v-slot:caption>
    /Development/mongodb/docker-compose.yml
  </template>
</AposCodeBlock>

Let's break this file down:

- **`version: '3.8'`**: This specifies the version of the Docker Compose file format. Version 3.8 is widely compatible and includes support for most features needed in modern Docker setups.

- **`services:`**: The `services` section defines the containers that Docker Compose will manage. In this case, we are defining a single service called `mongo`.

- **`mongo:`**: This is the name of the service, which you can reference in other parts of your configuration. Here, it defines the MongoDB container.

  - **`image: mongo:latest`**: This specifies the Docker image to use for the MongoDB container. The `mongo:latest` image tag pulls the latest stable version of MongoDB from Docker Hub. If you are going to be using a specific version of MongoDB in production and want your development environment to reflect this you can get the cooresponding version from the [Docker hub](https://hub.docker.com/_/mongo/tags).

  - **`container_name: apostrophe-mongo`**: This assigns a name to the container, making it easier to identify and manage. Naming the container helps avoid confusion if you're running multiple containers. Note that in the Docker Desktop GUI you will see the container listed as the name of the folder the `docker-compose.yml` is contained within.

  - **`ports:`**: The `ports` section maps the container‚Äôs internal port to your local machine. The `"27017:27017"` mapping ensures that MongoDB is accessible on port 27017 on both your local machine and within the container.

  - **`volumes:`**: The `volumes` section mounts a persistent storage volume from your local machine to the container. The `mongo-data:/data/db` mapping ensures that the data stored in MongoDB persists even if the container is stopped or removed. This is crucial for retaining your database information across development sessions.

- **`volumes:`**: The `volumes` section at the bottom of the file defines the volume `mongo-data`, which is referenced in the `mongo` service. Docker will create and manage this volume to store MongoDB's data on your local machine, ensuring that your database persists across container restarts.

When using version control, ensure your `docker-compose.yml` file is included in your repository. However, be cautious with sensitive data like credentials. For security, avoid hard-coding sensitive information like database credentials directly in the `docker-compose.yml` file. Instead, use environment variables or Docker secrets to manage these credentials securely.

## Running the container

![Screenshot of the Docker Desktop GUI running the MongoDB container](../images/Docker-GUI.png)
Once this `docker-compose.yml` file is created, all you have to do is create and bring the container up using:

`docker-compose up -d`

Using the `-d` flag will run the container in detached mode in the background. You can leave the container running if your development computer has enough resources, but you will have to restart the container with this command or by clicking on the play icon in the Desktop GUI whenever you restart your computer.

If you prefer, when not actively developing your Apostrophe project you can bring the container down from either the Desktop GUI by clicking on the stop icon or by using:

`docker-compose down`

Additionally, MongoDB can consume significant memory and CPU resources, which may exceed the default limits set in Docker Desktop, leading to slow performance or container crashes. Over time, unused volumes, containers, and networks can accumulate, consuming disk space and further degrading performance. To ensure a smooth development experience, it‚Äôs important to adjust Docker's resource allocations using the Docker Desktop settings and regularly clean up unused resources with commands like `docker system prune`.


![Screenshot of the Docker Desktop GUI volumes tab](../images/docker-volumes.png)

Unneeded volumes can be removed from The Desktop GUI "Volumes" tab. **Note that this will delete all data saved to that container**. This should only be done if you are either finished with local development of the project or following backup of the database with a command using:

`mongodump --host localhost --port 27017 --out /path/to/backup`

This backup can then be restored using:

`mongorestore --host localhost --port 27017 /path/to/backup`

## Troubleshooting Tips:

- Container Fails to Start: Check for port conflicts or permission issues, especially if you're on a non-Linux system.
- Slow Performance: Increase Docker's resource allocation in Docker Desktop settings or consider running MongoDB directly on the host if necessary.
- Data Loss: Always ensure you're using named volumes and back up your data before removing volumes or containers.

### Conclusion

Setting up MongoDB for local development using Docker offers a streamlined alternative to installing the community server or using a managed service like Atlas, potentially saving time and costs. While there are some drawbacks‚Äîsuch as challenges in sharing database contents between developers‚Äîthe ease of setup and consistency it brings to your development workflow can often outweigh these concerns. As you become more comfortable with Docker, you may find new ways to leverage its capabilities, further enhancing your development process.

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Migrating > Overview
DOC_PATH: guide/migration/overview.md
URL: https://apostrophecms.com/docs/guide/migration/overview
================================================================================
# Changes from Apostrophe 3 to Apostrophe 4

Apostrophe 4.x (A4) differs from Apostrophe 3 in just one major area: the admin UI has been updated to use Vue 3,
the current major supported version of the Vue frontend framework.

As a result, most projects require no changes at all to work with Apostrophe 4.x, beyond changing certain dependencies
in `package.json`. However projects that customize the admin UI with their own Vue code will often require
some minor changes.

For more information, see the [3 to 4 upgrading guide](/guide/migration/upgrading-3-to-4.md).

# Changes from Apostrophe 2 to Apostrophe 4

**While upgrading from 2.x to 3.x is possible, there is no benefit in not going directly to 4.x because 
differences between 3.x and 4.x are very minor, 3 will reach its end of life for security updates in 2025,
and only 4.x receives new features going forward.**

Apostrophe 4.x has many things to offer developers familiar with Apostrophe 2 (A2). It has a totally new UI, clearer module configuration, and many quality-of-life improvements, large and small. It has been re-engineered from the ground up to provide a best-in-class experience for organizations of all sizes.

There are also some breaking changes, including in the general directory structure, so be sure to review the [upgrading guide](/guide/migration/upgrading.md) before upgrading codebases.

## Features

### 100% RESTful API coverage

In the previous version, developers who wanted REST API access to their data needed to install the `apostrophe-headless` module. [This is now built into A4](/reference/api/README) and is the foundation of the user interface.

### Totally rebuilt content editing interface

The UI has been completely rebuilt with [Vue.js](https://vuejs.org/). As of apostrophe 4.x this is using Vue.js version 3.x. It is much faster, more accessible, and easier to configure. It will also stay out of your way, so you can build with React, vanilla JavaScript, a different Vue.js version, or any other framework without any issue.

### Clearer and easier module building

There were several things about building advanced modules in A2 that often tripped up developers. A4 helps avoid the confusion around where to put things by doing away with `beforeConstruct`, `construct`, and `afterConstruct`. [They are replaced by a single `init` function and special sections](/reference/module-api/module-overview.md#initialization-function) to do things like extend API routes, add template helper methods, and add columns to the piece manager UI. The `addFields` array also became a `fields` object with an `add` sub-property to prevent problems with common inheritance patterns.

### New Rich Text Editor

A4 uses the [tiptap](https://tiptap.dev/) rich text editor, a modern, open-source editor powered by [ProseMirror](https://prosemirror.net/) and built by √ºberdosis. Besides being a great editor, it is built with JavaScript, which should make it easier to customize for developers using a Node.js CMS.

### Async template components

[Async components](/guide/async-components.md) allow developers to write template code that uses data from custom database requests. In A2, the pattern to make those requests before rendering templates was unclear and fairly advanced. Async components should make this a clearer process and improve rendering performance.

## Other improvements

- Callback-driven code has been completely eliminated from the core of Apostrophe, and all of the JavaScript APIs return promises, so you can `await` them in async functions.
- A4 completely removes the jQuery, lodash, and Moment.js libraries that were pushed to browsers by default. There is now only [a small set of helper methods](/guide/front-end-helpers.md).
- In addition to the classic template macros, there are now [fragments](/guide/fragments.md). These are compatible with the new async components, unlike macros.
- [Content localization](../localization/dynamic.md), which was a feature of Apostrophe Workflow for A2, is now fully available in A4 core.

There are additional features planned for Apostrophe 4. Keep an eye on the [product roadmap](https://roadmap.apostrophecms.com/roadmap) for more on those.

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Migrating > Upgrade From Apostrophe 2
DOC_PATH: guide/migration/upgrading.md
URL: https://apostrophecms.com/docs/guide/migration/upgrading
================================================================================
# Migration from Apostrophe 2 to Apostrophe 4

While many foundational patterns from Apostrophe 2 (A2) were maintained in Apostrophe 3 and now in the latest versions of Apostrophe, there are significant breaking changes to both the database document structure and site-building APIs. This guide will summarize those and cover how to begin upgrading website and standalone module projects from A2 to the newest Apostrophe. Importantly, it will also introduce [tools for developers to automate most of the necessary migration work](#migration-tools-and-process).

## Breaking changes

The updates described below are the majority of significant breaking changes but are not completely comprehensive.

### Code syntax, APIs, and module configuration

#### Codebase structure and module naming

- The modules directory moved from `/lib/modules` to `/modules` since there was little need for the additional nesting.
- All core modules have been namespaced with `@apostrophecms`. For example, the `apostrophe-pages` module is now `@apostrophecms/page`. At project level, you can configure this module in `/modules/@apostrophecms/page/index.js`.

::: info
Project-specific modules should not use the `@apostrophecms` namespace to avoid future collisions.

- Official doc-type modules are now singular as well, e.g., `@apostrophecms/file`.
- Due to core module name changes, the `name` option is no longer necessary (or functional) in page and piece-type modules. Module names now exactly match the document `type` property (e.g., `@apostrophecms/user`, `@apostrophecms/image`).

#### Updated UI and module architecture

- Most any user interface customizations based on the A2 jQuery code will no longer work.
- [As noted on the migration overview page](/guide/migration/overview.md#other-notable-improvements), Apostrophe no longer provides jQuery, lodash, or Moment.js to browsers by default. If you need any of those libraries in the client you will need to provide them.
- Due to the module architecture changes, all modules in an A2 project would need to be refactored when migrating to a newer version. Most configurations and methods will be reusable, but they will need to be rearranged. See the [module reference](/reference/module-api/module-overview.md) for details. Here are some highlights:
  - Module field schemas now use an object structure on the `fields` property. It has `add`, `remove`, and `group` subproperties to replace A2's `addFields`, `removeFields`, and `arrangeFields`.
  - `columns` (for piece manager UI columns) is structured similarly to `fields` with `add`, `remove`, and `order` subproperties. This replaces A2's `addColumns` property.
  - `filters` (for piece manager filters) is structured similarly to `fields` with `add`, and `remove` subproperties. This replaces A2's `addFilters` property.
  - Many module settings that were top level properties in A2 (e.g., `label`, `alias`, `sort`) are now subproperties of `options`. These include all settings that are *not* covered in the [module properties overview reference](/reference/module-api/module-overview.md). See the [module options reference](/reference/module-api/module-options.md) for more on that.
  <!-- TODO: Update once options are all moved into individual module reference pages -->
  - The A2 `self.addHelper()` method used to add Nunjucks helper functions is replaced by the `helpers` section in module configuration.
  - The A2 `self.apiRoute()` method used to add a custom API route is replaced by the `apiRoutes` section in module configuration.
  - The A2 `self.renderRoute()` method used to add a custom template rendering route is replaced by the `renderRoutes` section in module configuration.
  - The A2 `self.route()` method used to add a custom Express route is replaced by the `routes` section in module configuration.
  - The A2 `self.on()` method that watched for Apostrophe server-side promise events is replaced by the `handlers` section in module configuration.
  - The A2 `self.addFilter()` method used to add MongoDB cursor filters is replaced by the `queries` section and its `builders` subsection in module configuration.
  - Custom `lib/cursor.js` files for modules are no longer loaded. Migrate this code to the new `queries` section as well.
  - The A2 `self.expressMiddleware` system for adding Express middleware functions is replaced by the `middleware` section in module configuration.
  - The A2 `self.addTask()` method for adding CLI tasks is replaced by the `tasks` section in module configuration.

#### Areas, singletons, and template macros

- Areas must be declared as fields in the [content field schema](/guide/content-schema.md). They will no longer work if simply added to template files without being registered.
- The area template tag format is now `{% area data.page, 'areaName' %}`. Note that this no longer includes the configuration of widgets since that is now done in module configuration.
- The new area template tag renders asynchronously, which the standard [Nunjucks macro](https://mozilla.github.io/nunjucks/templating.html#macro) doesn't not support. Macros containing area tags must be converted to ["fragments"](/guide/fragments.md), the comparable feature in newer versions of Apostrophe.
  - As a rule, we encourage developers to use fragments instead of macros in almost every case. See the fragments guide for information on exceptions.
- Area "singletons" are no longer a separate field type or template helper. They were always simply areas that only allowed one widget. With the other area changes, there is not much benefit to having that feature over adding the `max: 1` option to an area field.

#### Client-side assets

- A2 widget player formats are deprecated. The "lean" widget player structure can be more easily converted to the [new widget player](/guide/custom-widgets.md#client-side-javascript-for-widgets) due to a similar structure.
- The `pushAsset` method for delivering CSS and client-side JS is replaced by [placing files in the correct location](/guide/front-end-assets.md).

#### Other changes

- Every page type will need a corresponding module (in A2 this was only necessary if the page had custom fields or functionality). Page templates live in the page type module rather than in the base page module.
- In A2, relationships between two piece or page types were referred to as "joins." Now they are called "relationships." [The `relationship` field type](/reference/field-types/relationship.md) is fundamentally the same as the previous `joinByArray` and `joinByOne` fields (using a `max: 1` option to replicate the latter). [See the guide](/reference/field-types/relationship.md#using-a-relationship-in-templates) regarding for changes in template use.
- The `array` and `object` field types use [a new syntax for adding their field schemas](/reference/field-types/array.md#module-field-definition), matching the new module field schema syntax.
- The `tags` field from A2 no longer exists. In most cases, we recommend replacing that by adding a piece type for categorization. The core `@apostrophecms/image-tag` and `@apostrophecms/file-tag` modules are examples of this.
- Template helper methods need to be adjusted to use the singular form of their module aliases, e.g., `apos.attachments.url` to `apos.attachment.url`.

### Data Structure

The following changes apply to database documents in A2 databases' primary content collection, `aposDocs`, unless otherwise specified.

- Apostrophe core *doc type* names (the `type` property) change to reflect the comparable apostrophe module names (e.g., `apostrophe-image`, `@apostrophecms/image`).
- Apostrophe core *widget type* names (the `type` property) change to reflect the comparable apostrophe module names (e.g., `apostrophe-video` to `@apostrophecms/video`). This is equal to the widget module name without its `-widget` suffix.
- There are always at least two database documents for each published document: one representing the published document and another representing the draft, potentially with unpublished changes. Once changes are saved after initial publication, another for the "previous" state is added. The "previous" document is not required for initial operation, however.
  - The exception to this is when a module has the [`localized: false` option](/reference/module-api/module-options.md#localized). The `@apostrophecms/user` module is the only such case in Apostrophe core.
- Unique ID and document state properties evolved to support the document version system.
  - The `_id` property is now a combination of a unique string, a locale identifier (defaults to `en`), and the document mode (e.g., `ckokisysc00048d4l5zdo9l0c:en:published`).
  - A new property, `aposLocale` stores the full locale, e.g., `en:published`.
  - A new property `aposMode` stores the document mode, e.g., `published`.
  - A new property `aposDocId` stores the unique document ID (shared between each variation), e.g., `ckokisysc00048d4l5zdo9l0c`.
- `metaType` properties identify particular sections of document structure. These help Apostrophe property operate on similar content object structures.
  - All `aposDocs` documents have a top-level `metaType: 'doc'` property.
  - Area field objects within documents have a `metaType: 'area'` property.
  - Widget objects within areas have a `metaType: 'widget'` property.
  - Individual array field items include a `metaType: 'arrayItem'` property.
- A2 join field properties, now "relationships" in newer versions, have a new name structure.
- `singleton` fields are no longer supported. They are `area` fields in newer versions.
- The `trash` property is `archived` in newer versions.
- Attachment documents in the `aposAttachments` DB collection change the `trashDocIds` property to `archivedDocIds`.

## Migration tools and process

Migrating an Apostrophe 2 codebase and data should be done with care, but there are two official tools that can help speed the process along. Both tools are still somewhat early in development, so it is important to use them locally (not in production) and make sure to back up code and data before using them.

**The Apostrophe team is very interested in feedback on these upgrader tools.** With each of their limitations in mind, please provide any comments, bug reports, code contributions, or feature requests as issues on the respective Github repositories.

### Content Upgrader

While completely manual code migration is possible, the *Content* Upgrader tool is basically essential for data conversion. Writing custom data migrations would not be able to do many things differently from the official tool and there is very little to gain by doing so.

The Content Upgrader tool does not change anything in the original Apostrophe 2 database. Instead, it reads that original database and creates a *new database* using a name the developer provides. That new database will contain the original data, converted for use in the newest verrsions ofApostrophe.

Developers will install the Content Upgrader as a module **within the A2 project**. This allows it to access schemas and other important project information. **See the [Content Upgrader README](https://www.npmjs.com/package/@apostrophecms/content-upgrader) for full instructions.**

::: info
The Content Upgrader tool is currently published as an initial stable release. It is essentially feature-complete but may miss some edge cases. We encourage developers to begin trying it on A2 projects and [provide feedback](https://github.com/apostrophecms/content-upgrader/issues/new) as we prepare for a stable release.

#### Limitations

There are a few limitations in the Content Upgrader to understand before using it.

- Users and groups are not migrated. This is because the user roles of newer versions differ in design from the permissions groups of A2. Copying users directly could create security issues. Create new accounts in your updated project or arrive at your own migration strategy.
- A2 has a built-in `apostrophe-images` widget type that acts as a slideshow when multiple images are selected. The newer Apostrophe versions only has a built-in single-image `@apostrophecms/image` widget type. By default, `apostrophe-images` will be upgraded to `@apostrophecms/image`, with only the first image present in each. However, you can use the `mapWidgetTypes` option (see the README) to override this mapping during the upgrade.


### Code Upgrader

The *Code* Upgrader tool supports upgrading codebases for **full Apostrophe projects** (websites) and **installable modules**. It has two major roles in converting an A2 codebase to use the newer version of Apostrophe:

1. It will lint an Apostrophe codebase for A2 syntax and structure that must change. This is its `lint` command.
2. It will *make* many of those code changes for you. This is its `upgrade` command.

Additionally, there is a `reset` command that can undo all uncommitted changes. Always use a new git branch during this process as well to have an additional way to roll back changes.

One reason we recommend using this tool to execute changes on a full project is that it will make minimal code adjustments for newer version use. This is important because additional changes (such as field name changes), could unnecessarily break compatibility with the [upgraded database](#content-upgrader). After running the automatic code upgrade, take care with final code changes to avoid affecting data compatibility.

The Code Upgrader is installed globally in a Node environment (including developer environments) and run as a command line tool. **See the [Code Upgrader README](https://www.npmjs.com/package/@apostrophecms/code-upgrader) for full instructions.**

::: info
The Code Upgrader tool is currently published as an **alpha** release. It will lint most A2 features that need updating, but there are several features that it cannot automatically upgrade yet. The tool will never do 100% of the necessary code conversion, but we will continue adding feature support before it can be published as a full 1.0 release.

We encourage developers to begin trying it on A2 projects and [provide feedback](https://github.com/apostrophecms/code-upgrader/issues/new) as we prepare for a stable release.

#### Limitations

Just as with the content tool, the Code Upgrader has some limitations to understand. While database structure is very predictable, code styles and patterns are not. Some A2 APIs and syntax are intentionally not touched to avoid making incorrect assumptions.

- The tool is designed to operation on the majority of standard Apostrophe 2 codebases. Projects that generally follow patterns in official documentation and sample projects will have the best results. The tool will help on very custom projects (especially the linting mode), but more manual work will be always be needed to finish the work.
- [Widget player code](/guide/custom-widgets.md#client-side-javascript-for-widgets) (client-side JavaScript) is not changed. The original widget player syntax relies on jQuery, which the newer versions of Apostrophe do not include. A2 "lean" players may be supported in the future.
- [Areas](/reference/glossary.md#area) (and A2's "singletons") that are only defined in A2 template files, "anonymous areas," are not changed. In newer versions, all areas must be registered in a module's field schema, however, the complexity of area configuration (and limitations of template parsers) make them better converted manually.
- [As mentioned above](#limitations) the image widget only supports a single image in newer versions. As in the content tool, these are converted to the equivalent updated version, but full slideshow conversion will need to be done manually.
- As the tool is still in development, some features will eventually be supported in the automatic upgrade, but are not yet. We appreciate your patience during development.

In many of these limitation cases the **`lint`** command will still alert you to the outdated code so you can find it and make changes manually.

================================================================================
COLLECTION: guides
NAV_PATH: Getting Started > Migrating > Upgrade From Apostrophe 3
DOC_PATH: guide/migration/upgrading-3-to-4.md
URL: https://apostrophecms.com/docs/guide/migration/upgrading-3-to-4
================================================================================
# Migration from Apostrophe 3 to Apostrophe 4

## Introduction

Apostrophe‚Äôs admin UI is built on the Vue UI framework. Until the 4.x release of Apostrophe, it was built on Vue 2.x, which has reached its official end of life. That means there will be no more free upstream support for Vue 2.x from the Vue development team. So, we have migrated ApostropheCMS to the fully supported Vue 3.x release. This ensures ongoing support and also allows admin UI developers to follow new and improved practices when coding with Vue.

Of course, we recognize that our customers‚Äô code needs to be safe and secure and reliable in the meantime. Therefore we have committed to provide fixes or workarounds for any critical security issues with Vue 2.x until April 2025. However in practice Vue security issues have been very rare because security is primarily the responsibility of the server (Apostrophe) and not the client (Vue).

As part of releasing Vue 3 support, we updated the major version number of Apostrophe from 3.x to 4.x.
While the differences are minor for most projects, we updated the major version number to ensure we follow
[semantic versioning](https://semver.org/) best practices, avoiding any inconvenience for customers who
have written custom admin UI code that requires modification. However, **most projects will not require
any modification to work with 4.x** other than changing versions in `package.json`.

There are **no changes in Apostrophe 4.x** other than the use of Vue 3 for the admin interfaces.

We will support Apostrophe 3.x (which is based on Vue 2.x) until **April 2025.** But since the migration
to 4.x is straightforward and our new efforts will be focused there, 3.x support will increasingly be
a matter of security fixes only. Therefore it is recommended that all developers migrate to 4.x.

## How to upgrade your project

After upgrading Apostrophe will work exactly the same, except as explicitly noted below. You‚Äôll want to make these changes **together,** and follow them with a single `npm update` command.

- In `package.json`, change your dependency on `apostrophe` to `^4.0.0`.
- Make similar changes for the following modules, **if you use them.**
    - `@apostrophecms-pro/data-set`: change to `^2.0.0`.
    - `@apostrophecms-pro/document-versions`: change to `^2.0.0`.
    - `@apostrophecms-pro/doc-template-library`: change to `^2.0.0`.
    - `@apostrophecms-pro/palette`: change to `^4.0.0`.
    - `@apostrophecms-pro/signup`: change to `^2.0.0`.
    - `@apostrophecms-pro/advanced-permission`: change to `^3.0.0`. Note this is based on the `^2.0.0`
    series, so if you were used to the `^1.0.0` series review the [documentation](https://apostrophecms.com/extensions/advanced-permission)
    for more information about what will change with this upgrade.

- **Run the `npm update` command.** This is necessary to ensure other modules receive required minor
or patchlevel version updates.

## For those who have not customized our admin UI

If you have not created custom admin UI field types, overridden various admin UI Vue components, or **otherwise created any code in ui/apos subdirectories of your modules,** then **you are done.** Your project has been upgraded and will work exactly as before. As with any upgrade, we recommend QA in your staging environment before a production release.

Just to be clear‚Ä¶ *front end code in `ui/src` folders does not have to change at all.* And of course server side code is entirely unaffected by this change.

::: info
No custom admin UI code? You‚Äôre done! üéâ You can stop here and start testing the results.

## For those who have customized our admin UI

The changes to be made in `ui/apos` are surprisingly few in all. Most existing admin UI code can run without modification. Familiar Vue 2 features like single-file components, traditional component structure and mix-ins are still 100% supported by Vue 3.

But, often some smaller changes are necessary. Here are the most frequently encountered concerns:

### Vue components: stylesheets

::: info
In Apostrophe, admin UI components are found in `ui/apos/components` subdirectories. Check for such subdirectories in your own project-level code before continuing. If you don‚Äôt have any, you can move on.

**Deep selectors have changed**

In the `style` elements of your Vue components (look for `ui/apos/components` subdirectories in your own code), you will need to modernize any `v-deep` selectors:

```css
// OLD
v-deep .apos-button {...}

// NEW
:deep(.apos-button) {...}
```

*You do not need to touch your `ui/src/index.scss` or other stylesheets outside of `ui/apos` and its Vue components at all.*

### Vue components: JavaScript

::: info
In Apostrophe, admin UI components are found in `ui/apos/components` subdirectories. Check for such subdirectories in your own project-level code before continuing. If you don‚Äôt have any, you can move on.

#### `v-model` props and events have changed

The names of the props and events automatically used by the `v-model` feature have changed. If you have implemented the `v-model` pattern yourself, you will need to update your code:

```nunjucks
<!-- These are the props passed by Vue when using v-model.
  In some cases we may want to pass them manually 
  to have more power over what's happening -->

<!-- OLD -->
<AposSchema
  :value="docFields"
  @input="updateDocFields"
/>

<!-- NEW -->
<AposSchema
  :model-value="docFields"
  @update:model-value="updateDocFields"
/>
```

Note that in JavaScript code you would therefore access `this.modelValue`  instead of `this.value`.

::: warning
An exception: field input components like `AposInputRadio` still use the `input` event handler.

#### Life cycle events have changed

`beforeDestroy` becomes `beforeUnmount`  and `destroyed` becomes `unmounted`.

#### `Vue.set` has been removed and is not necessary

The global `Vue` methods `set` and `delete`, and the instance methods `$set` and `$delete`, no longer exist. They are no longer required with Vue 3's proxy-based change detection.

```javascript
// OLD
this.$set(this.personObject, 'bio', bio)

// NEW
this.personObject['bio'] = bio
```

### Vue apps

::: info
 In Apostrophe, admin UI ‚Äúapps‚Äù are found in `ui/apos/apps` subdirectories. Check for such subdirectories in your own project-level code before continuing. If you don‚Äôt have any, you can move on.

Most projects don‚Äôt involve custom Apostrophe Vue ‚Äúapps,‚Äù just custom and overridden Vue components. But, some projects do.

The syntax for instantiating Vue apps has changed in Vue 3. Here‚Äôs an example, taken from Apostrophe‚Äôs built-in ‚Äúbusy indicator‚Äù Vue app:

```javascript
// OLD
import Vue from 'Modules/@apostrophecms/ui/lib/vue';

export default function() {
  return new Vue({
    el: '#apos-busy',
    render: function (h) {
      return h('TheAposBusy');
    }
  });
};

// NEW
import createApp from 'Modules/@apostrophecms/ui/lib/vue';

export default function() {
  const component = apos.vueComponents.TheAposBusy;
  const el = document.querySelector('#apos-busy');
  if (!el) {
    return;
  }
  const app = createApp(component);
  app.mount(el);
};
```

Important things to note:

- As always, you should import Vue via our official wrapper as shown above.
- Although Vue 3 doesn‚Äôt natively support registering components globally by name, the `createApp` function, which is new in Vue 3, has been enhanced to automatically register components the same way we did in Vue 2.
- However, we still need a way to pass a ‚Äúroot‚Äù component when creating an app. In your project-level work, you have two options: you can `import` it in the usual way, or you can do what we‚Äôve done here, accessing it by name on the `apos.vueComponents` object, which contains all components discovered in the `ui/apos/components` subdirectories of any module.

### Notes on popular Vue libraries used in Apostrophe

Although you normally don‚Äôt need to worry about the internal choices we made in our own components, it is worth noting that we replaced certain obsolete packages with new ones that support Vue 3:

- `@apostrophecms/vue-color`  was replaced by `@ckpack/vue-color`
- `vuedraggable` was replaced by `sortablejs-vue3`
- `v-tooltip`  was removed in favor of an internal implementation using `@floating-ui/dom`  (`AposContextMenu.vue`  and the directive `v-apos-tooltip`  were updated, so they work exactly the same as before).
- `vue-material-design-icons` has been migrated to `@apostrophecms/vue-material-design-icons` and packaged for Vue 3, but otherwise left **exactly the same** so that your icon names will still work without modification.

### Additional resources

Thanks to the Vue team‚Äôs foresight in maintaining such a large degree of backwards compatibility, these notes cover everything most developers will have to do. However, depending on your implementation other changes could be needed. We recommend that you read the [Vue 3 official migration guide](https://v3-migration.vuejs.org/breaking-changes/). Note that we did not use Vue 3‚Äôs ‚Äúcompatibility mode‚Äù for this migration, as the changes to support Vue 3 fully turned out to be straightforward.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Module Configuration
DOC_PATH: guide/module-configuration-patterns.md
URL: https://apostrophecms.com/docs/guide/module-configuration-patterns
================================================================================
# Module Extension and Improvement

One core feature of ApostropheCMS is its module system that allows you to customize and enhance functionality without modifying core code. This approach keeps your project maintainable and upgrade-friendly while giving you the flexibility to tailor the CMS to your needs. You will see this information partially repeated in several areas of our documentation including in the [reference section](/reference/module-api/module-overview.html#extend) because we feel it is so important for developers to understand.

## Understanding Module Customization in ApostropheCMS

When working with ApostropheCMS, it's important to understand that customizations should be made through files in your project's `/modules` folder rather than by directly modifying files in the `node_modules` directory.

Modifying files in `node_modules` can create significant problems:
- Changes are lost when you run `npm install` or `npm update`
- Customizations won't carry over when deploying to different environments
- Your changes won't be tracked in version control

Instead, ApostropheCMS is designed to let you customize modules by creating corresponding files in your project's `/modules` folder. This way, your changes are:
- Preserved during updates
- Properly tracked in version control
- Correctly deployed across environments
- Applied consistently throughout your application

## The Three Types of Module Customization

ApostropheCMS provides three distinct ways to customize module behavior, each with its own purpose:

### 1. Module options

**Use for:** Adjusting existing behavior using options that have been specifically built into modules.

The module `options` property provides a way to set values for options that are already designed into the modules. You can only configure options that the module (or code you are adding to it) explicitly supports in this way, not create new ones. You can apply these configuration options in your project level module files or `app.js` when registering the module:

**For core ApostropheCMS modules:**
Create an `index.js` file with a path matching how the core module is organized in the `node_modules` folder.

<AposCodeBlock>

```javascript
export default {
  options: {
    session: {
      // If this still says `undefined`, set a real secret!
      secret: undefined
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/express/index.js
  </template>
</AposCodeBlock>

This example is from our [starter-kit-essentials](https://github.com/apostrophecms/starter-kit-essentials) repository and configures the options for the core `@apostrophecms/express` module.

**For project-specific modules:**
You can just configure the options within the modules main `index.js` file.
<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/piece-type',
  options: {
    // Configuration options
    label: 'Article',
    pluralLabel: 'Articles',
    sort: { publishedAt: -1 }
  }
}
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>


For both core and project-specific modules you can pass an `options` object when registering modules in your `app.js` file:

<AposCodeBlock>

```javascript
export default {
  modules: {
    '@apostrophecms/image': {
      options: {
        // Simple configuration settings
        sizes: '(min-width: 600px) 45vw, (min-width: 1140px) 530px'
      }
    }
  }
}
```
  <template v-slot:caption>
    app.js
  </template>
</AposCodeBlock>

### 2. Module Improvement

**Use for:** Adding or enhancing functionality of an existing module without changing its core purpose.

Module improvement lets you add new methods, event handlers, or other features to an existing module that was installed as a npm package. You do this by creating a file with the same path as the module you want to improve For core Apostrophe modules you place your improvement files inside an `@apostrophecms` folder like they are in the `node_modules` folder, just like setting the `options` configuration:

<AposCodeBlock>

```javascript
export default {
  // No "extend" needed - you're improving a specific module
  handlers(self) {
    return {
      beforeSave: {
        logSaving(req, piece) {
          console.log(`About to save ${piece.title}`);
        }
      }
    };
  },
  methods(self) {
    return {
      // Log piece information for debugging
      logPieceInfo(piece, label = 'Piece Info') {
        console.log(`--- ${label} ---`);
        console.log(`ID: ${piece._id}`);
        console.log(`Title: ${piece.title}`);
        console.log(`Type: ${piece.type}`);
        console.log(`Last Modified: ${piece.updatedAt}`);
      }
    };
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/piece-type/index.js
  </template>
</AposCodeBlock>

In this example we are adding a `handler(self)` and a `methods(self)` to the core `@apostrophecms/piece-type` module. This means that any other module in your project that uses `extend` to create a new piece type will have access to that handler and method.

### 3. Module Extension

**Use for:** Creating a new module that inherits behavior from an existing one.

Module extension allows you to create entirely new modules that utilize the base functionality of existing ones. You use the `extend` property to specify which module you're building upon:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Article',
    pluralLabel: 'Articles'
  },
  fields: {
    add: {
      subtitle: {
        type: 'string',
        label: 'Subtitle'
      },
      featuredImage: {
        type: 'relationship',
        withType: '@apostrophecms/image',
        label: 'Featured Image',
        max: 1
      }
    },
    group: {
      basics: {
        label: 'Basic Information',
        fields: ['title', 'subtitle', 'featuredImage']
      }
    }
  }
}
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

In this example we created a new type of piece, an article, that extends the core `@apostrophecms/piece-type` module. This means that new articles will be created and edited in the piece manager and can easily be displayed on a piece type page.


## How Module Customization Works Behind the Scenes

### Module Configuration

When you configure a module, Apostrophe applies those settings to the module definition before initializing it. Only options that have been programmed into the module will have an effect.

### Module Improvement

When you create a file at `modules/@apostrophecms/piece-type/index.js`, Apostrophe:

1. Loads the core module definition from `node_modules`
2. Merges your project-level improvements with the core module
3. Uses the enhanced module definition for all operations

Improvements affect both the base module and any modules that extend it.

### Module Extension

When you extend a module with `extend: '@apostrophecms/piece-type'`, Apostrophe:

1. Creates a new module type based on the parent module
2. Applies any improvements to the parent module first
3. Applies your extension-specific configuration
4. Initializes the new module type with the combined definition

This cascade ensures that improvements to base modules flow through to all modules that extend them.

## Customizing Third-Party Modules and Packages

The same customization patterns apply to all Apostrophe modules, including:
- Core modules bundled with ApostropheCMS
- Official packages from the Apostrophe team (like `@apostrophecms/blog`)
- Third-party modules from other developers
- Your own custom modules installed via npm

When you install any module through npm, you should **never modify the files in `node_modules`**. Instead, use project-level improvements and extensions just as you would with core modules.

### Example: Improving a Third-Party Module

Say you've installed a module called `organization-chart` (a hypothetical Apostrophe module for displaying org charts):

### Improving the Module

You might want to improve the base module to add functionality that will apply to all uses of it:

<AposCodeBlock>

```javascript
export default {
  // No "extend" property - this improves the original module
  methods(self) {
    return {
      // Add a new utility method to the original module
      sortEmployeesByDepartment(employees) {
        return employees.sort((a, b) => a.department.localeCompare(b.department));
      }
    }
  },
  handlers(self) {
    return {
      // Add an event handler to the original module
      beforeSave: {
        validateReportingStructure(req, piece) {
          // Custom validation logic
        }
      }
    }
  }
}
```
  <template v-slot:caption>
    modules/organization-chart/index.js
  </template>
</AposCodeBlock>

### Extending the Module

At the same time, you could extend the module to create specialized versions of it:

<AposCodeBlock>

```javascript
export default {
  extend: 'organization-chart',
  options: {
    label: 'Executive Team Chart',
    pluralLabel: 'Executive Team Charts'
  },
  fields: {
    add: {
      fiscalYear: {
        type: 'select',
        label: 'Fiscal Year',
        choices: [
          { label: '2023', value: '2023' },
          { label: '2024', value: '2024' },
          { label: '2025', value: '2025' }
        ]
      }
    }
  }
}
```
  <template v-slot:caption>
    modules/executive-team-chart/index.js
  </template>
</AposCodeBlock>

### How This Works Together

When Apostrophe initializes your project:

1. It applies your improvements to the `organization-chart` module first
2. Then it creates the new `executive-team-chart` module type that extends the (now improved) `organization-chart` module
3. The `executive-team-chart` module inherits all the functionality from the improved base module, plus gets its own specialized fields and behavior

This powerful pattern lets you:
1. Add global improvements that affect both the module and those that extend it
2. Create specialized versions of modules for specific purposes
3. Maintain clean separation of concerns in your code

It's particularly useful when you want to both enhance a module's core functionality and create specialized variants of it for different use cases in your project.

## The `improve` Property in npm Packages

While project-level module improvements are made by creating matching file paths in your `/modules` directory, npm packages that aim to improve core ApostropheCMS modules use a different approach: the `improve` property. Much like the `extend` property, the specific module being improved is passed as the value.

<AposCodeBlock>

```javascript
module.exports = {
  improve: '@apostrophecms/rich-text-widget',
  options: {
    typoConfig: {}
  },
  extendMethods(self) {
    return {
      // We need to extend this method so that our configuration data is available
      getBrowserData(_super, req) {
        const initialData = _super(req);
        const finalData = {
          ...initialData,
          aposTypoConfig: self.options.typoConfig
        }
        return finalData;
      }
    }
  }
};
```
  <template v-slot:caption>
    rich-text-example-extensions/modules/@apostrophecms/typography/index.js
  </template>
</AposCodeBlock>

This example is from the [rich-text-example-extensions](https://github.com/apostrophecms/rich-text-example-extensions) repository that can be installed into a project using `npm install @apostrophecms/rich-text-example-extensions`. It uses the `improve` property to target the core `@apostrophecms/rich-text-widget` module and add additional functionality.

> [!IMPORTANT]
> The `improve` property should never be used in a project-level module, only in modules installed as packages in the `node_modules` folder.

## Conclusion

Understanding the difference between configuration options, improvement, and extension in ApostropheCMS will help you customize the CMS effectively while maintaining a clean, maintainable codebase.

To summarize:
- **Configuration** adjusts existing behavior using predefined options
- **Improvement** enhances existing modules with new capabilities
- **Extension** creates new module types based on existing ones

These patterns apply to all modules, whether they're core modules, official packages, third-party modules, or your own custom modules installed via npm.

By choosing the right approach for each customization need and always making changes at the project level rather than in `node_modules`, you'll build robust ApostropheCMS projects that remain maintainable as your needs evolve and as the platform is updated.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Code Organization > Modules
DOC_PATH: guide/modules.md
URL: https://apostrophecms.com/docs/guide/modules
================================================================================
# Code organization with modules

Apostrophe code is organized in a system of modules. Modules are the building blocks we use to build Apostrophe projects ‚Äî as well as the CMS itself.

Each module defines a specific set of functionality, from configuring blog post fields to governing internationalization. Common Apostrophe project modules will define custom content types, page types, or editable widget types.

All modules use [the same API](/reference/module-api/module-overview). That shared foundation means that all have access to powerful features, such as custom command line tasks and API routes. It's the same API the core team uses to build the CMS, so it is well tested and designed to be as intuitive as possible.

To find both official and community-supported Apostrophe modules to install, see [the Extensions and Integrations index](https://apostrophecms.com/extensions).

## Setting up a module

Modules are organized in a folder at the root of a project named `modules`. Each module has a dedicated directory with an `index.js` file that contains its configurations. For example, you would define a blog post module in the file:

```
modules/blog-post/index.js
```

ApostropheCMS supports both ECMAScript Modules (ESM) and CommonJS (CJS) formats. While we recommend using ESM for all new projects due to its alignment with modern JavaScript standards, CJS remains supported for legacy projects.

However, it‚Äôs important to note that at the project-level, you must fully commit to either ESM or CJS‚Äîmixing the two within the same project is not compatible. That said, ApostropheCMS supports npm packages in both ESM and CJS formats, so you can freely use a combination of package formats in your dependencies.

As we continue to evolve ApostropheCMS, ESM may become mandatory in the future. We encourage developers to transition to ESM to stay ahead of this shift and take full advantage of modern JavaScript features.

### Using CommonJS

If you‚Äôre working with a legacy project or prefer CommonJS, the module configuration is assigned to `module.exports`. This is a familiar pattern if you‚Äôve worked with Node.js before.

```javascript
// modules/blog-post/index.js
module.exports = {
  // ...
};
```

To enable this blog post module, configure it in your main application file (`app.js`) within the `modules` object:

```javascript
// app.js
require('apostrophe')({
  modules: {
    'blog-post': {}
  }
});
```

### Using ESM

For newer projects, we recommend using ECMAScript Modules. The module configuration is exported using `export default`. This approach takes advantage of the latest JavaScript module syntax.

```javascript
// modules/blog-post/index.js
export default {
  // ...
};
```

To enable this module in your main application file (`app.mjs`), you‚Äôll use an `import` statement:

```javascript
// app.mjs
import apostrophe from 'apostrophe';

apostrophe({
  modules: {
    'blog-post': {}
  }
});
```

The module API supports many different configuration options. See the [module API reference](/reference/module-api/module-overview.md) for more detail.

::: info
Module names may not include periods (`.`).

- Bad: `blog.post` ‚ùå
- Good: `blog-post` ‚úÖ

## Module inheritance

As we stressed in [`Module Configuration'](/guide/module-configuration-patterns.html), inheritance is the glue of the module system. Every module extends another module, inheriting functionality and structure. This means that your blog post module, which extends the ["piece type"](/reference/glossary.md#piece) module, comes with a huge set of features you never have to write.

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-type'
  };
  ```
  <template v-slot:caption>
    modules/blog-post/index.js
  </template>

</AposCodeBlock>

::: tip
Since this is a piece type, you could add this file from your project root with starting code using the CLI with the command:

```bash
apos add piece blog-post
```

Even if a module does not include an `extend` setting, it will extend `@apostrophecms/module`, which provides useful features such as template rendering and API routes support.

Additionally, the inheritance system allows us to customize a core piece type module (e.g., `@apostrophecms/piece-type`) in a project and see those changes in all modules that extend it. That includes every module that extends it in Apostrophe core as well.

## Configuring core and installed modules

Configuring a core or installed module is as simple as creating an `index.js` file for the module in your project. For example, we might want to log the title of every piece when it is published. We would then create the file:

```
modules/@apostrophecms/piece-type/index.js
```

Then add the event handler:

<AposCodeBlock>

  ```javascript
  module.exports = {
    handlers(self) {
      return {
        afterPublish: {
          logPublished (req, data) {
            console.log(`Published ${data.published.title}`);
          }
        }
      };
    }
  };
  ```
  <template v-slot:caption>
    modules/@apostrophecms/piece-type/index.js
  </template>

</AposCodeBlock>

Since every piece type extends that module, they all get the benefits of changes to it. And in the project code we only need to include our changes. All the rest of the module's code is untouched.

The rest of the documentation will include many specific, practical examples of these ideas. For now, the main takeaways are:
  - The module API supports a consistent code structure regardless of the module's functionality
  - It is easy to extend another module to use built-in features
  - Core and installed modules can also be configured in a project without disrupting inheritance

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Code Organization > Nesting Modules
DOC_PATH: guide/nested-module-subdirs.md
URL: https://apostrophecms.com/docs/guide/nested-module-subdirs
================================================================================
# Nested module folders

When projects have dozens of modules, the `modules/` folder can begin to appear cluttered. It can be difficult to locate a particular module in such a long list. Similarly, since every module must at least be activated in `app.js`, that file can begin to feel cluttered as well. In this situation, developers often wish for a way to group their modules into subdirectories, as well as a way to break up `app.js` into multiple files for readability. Apostrophe offers the `nestedModuleSubdirs` option as a solution to both problems.

When the top-level `nestedModuleSubdirs` option is set to `true`, Apostrophe will:

* Recognize modules when nested in subdirectories within `modules/`. This reduces clutter in the `modules/` folder.
* Load any `modules.js` files discovered in parent directories within `modules/`, and merge them with the `modules` section of `app.js`. This reduces clutter in `app.js`.

We can set the `nestedModuleSubdirs` option to `true` in `app.js`, like this:

<AposCodeBlock>

```javascript
require('apostrophe')({
  shortName: 'my-project',
  nestedModuleSubdirs: true
  // etc., you may have additional options here as always
  modules: {
    // You can still enable all modules here, or move some or all to modules.js
    // files in subdirectories, as seen below
  }
});
```
  <template v-slot:caption>
    app.js
  </template>
</AposCodeBlock>

Now you can nest modules in subdirectories, like the example `modules/products` folder explored below. Start with a `modules.js` file in the parent `modules/products` folder. Here you can activate all of the modules that relate to products, making `app.js` shorter:

<AposCodeBlock>

```javascript
module.exports = {
  // This code merges with the `modules` section of `app.js`
  'product': {},
  'product-page': {},
  'product-widget': {}
};
```
  <template v-slot:caption>
    modules/products/modules.js
  </template>
</AposCodeBlock>

::: info
You do not have to use `modules.js` files if you don't want to. You can still activate your modules in `app.js` if you prefer. It usually makes sense to reduce clutter in both places: the `modules/` folder and `app.js`. But, it's up to you. This feature is entirely for your convenience.

Now we'll implement those modules in their own sub-subdirectories:

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Products'
  }
};
```
  <template v-slot:caption>
    modules/products/product/index.js
  </template>
</AposCodeBlock>

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    label: 'Products Page'
  }
};
```
  <template v-slot:caption>
    modules/products/product-page/index.js
  </template>
</AposCodeBlock>

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Products'
  },
  fields: {
    add: {
      _products: {
        label: 'Products',
        type: 'relationship',
        withType: 'product'
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/products/product-widget/index.js
  </template>
</AposCodeBlock>

The resulting directory tree looks like this:

```
/app.js
/modules
/modules/products
/modules/products/module.js (activates the three modules below)
/modules/products/product (index.js for the product piece type lives here)
/modules/products/product-page-type (index.js, views/show.html, etc.)
/modules/products/product-widget (index.js, views/widget.html, etc.)
```

::: warning
It is important to understand that **the names of the subdirectories do not matter.** The The subdirectories are purely there for your convenience in organizing your code and they are **not part of the name of the modules within them.** The names of the actual
module folders within them must still match the full name of each module.

By following through with this approach you can make `app.js` much shorter and better organize your project's files for easier maintenance.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Code Organization > Front End > CSS and JS
DOC_PATH: guide/front-end-assets.md
URL: https://apostrophecms.com/docs/guide/front-end-assets
================================================================================
# Adding front end CSS and JavaScript

ApostropheCMS approaches CSS and client-side JavaScript by trying to taking care of as much of the hard parts as possible. To that end, the developers main job is to **put their SCSS and client-side JavaScript into `ui/src/index.scss` and `ui/src/index.js` files in the relevant module**. Apostrophe will then:
  - Compile [SCSS](https://sass-lang.com/guide) from `*.scss` files to CSS
  - Optionally use Babel to automatically compile modern JavaScript into an Internet Explorer 11-compatible form
  - Interpret all `import` statements and deliver the code to browsers in one CSS and one JavaScript file, either:
    - with the editing UI if the browser is logged in, or
    - without the editing UI if logged out

## Placing client-side code

SCSS and JavaScript files need to be placed in **any module's `ui/src/index.scss` and `ui/src/index.js` files**, or files imported from them. You can put client-side code in a single module directory (e.g., using `import` statements) or spread it across many modules.

For example, if we had a global SCSS file, `site.scss`, we might create an `asset` module for this purpose and place the SCSS file at:

```
modules/asset/ui/src/index.scss
```

We would also need to activate the module in `app.js` like any other.

We could instead add code for an individual widget type as shown in the [custom widget guide](/guide/custom-widgets.md#client-side-javascript-for-widgets). That example's JavaScript code was placed at:

```
modules/collapse-widget/ui/src/index.js
```

::: tip
If you have your own build process using something like webpack or Gulp, you will want to [push the output of your process to a `ui/public` folder instead](#using-your-own-build-process).

In this case, the `assets` module may not have any additional code and even may not have an `index.js` file (though it certainly could). As long as it is instantiated in `apps.js`, the client-side assets will be found.

Client side code will be recompiled **when the app starts up** or if **the build task runs**. Tools like [nodemon](https://www.npmjs.com/package/nodemon) are helpful to watch for code changes and restart the app for automatic recompiling. The CLI command to run the build task manually is `node app @apostrophecms/asset:build`.

## Executing your JavaScript code in the right order

If you spread the client-side code across modules, it will be imported in the order they are instantiated in `app.js`. For example, let's say you have JavaScript files in `modules/sing-widget/ui/src/index.js` and `modules/dance-widget/ui/src/index.js`.

The `sing-widget` sings:

```javascript
export default () => {
  // `modules/sing-widget/ui/src/index.js
  console.log('üßë‚Äçüé§üé∂');
}
```

And the `dance-widget` dances:

```javascript
export default () => {
  // `modules/dance-widget/ui/src/index.js
  console.log('üï∫üèªüíÉüèΩ');
}
```

If your module's configuration in `app.js` includes this:

```javascript
// app.js
'sing-widget': {},
'dance-widget': {},
```

The output will **sing** before it **dances**. If the modules are instantiated in the opposite order:

```javascript
// app.js
'dance-widget': {},
'sing-widget': {},
```

the output will **dance** before it **sings**.

::: info Why do I have to export a function?
A funny thing about JavaScript `import` statements: they don't guarantee any order in which the files are loaded. To fix that, Apostrophe requires you to export a function from each `ui/src/index.js` file so that it can call them in the order the modules are initialized.

## Ordering the SCSS files

Rules found in or imported by `ui/src/index.scss` files are compiled in the order the modules are activated in `app.js`.

::: info The starter-kit-essentials boilerplate
The [Apostrophe starter-kit-essentials boilerplate](https://github.com/apostrophecms/starter-kit-essentials/) takes advantage of `ui/src` in exactly the same way. The `asset` module contains `ui/src/index.js` and `ui/src/index.scss` files, which Apostrophe automatically discovers.

## Supporting Internet Explorer 11

Internet Explorer 11 is [going away soon](https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/#:~:text=With%20Microsoft%20Edge%20capable%20of,certain%20versions%20of%20Windows%2010.), but for now at least some projects still require support for it.

By default, Apostrophe does *not* guarantee that code written in modern JavaScript in `ui/src/index.js` files will run in Internet Explorer 11. However, you can turn on support by setting the `es5: true` option of the `@apostrophecms/asset` module:

```js
// modules/@apostrophecms/asset/index.js
module.exports = {
  options: {
    es5: true
  }
};
```

This configures Apostrophe to compile two JavaScript bundles: one for Internet Explorer 11 users, and one for everyone else. The Internet Explorer 11 bundle contains code compiled with `babel` in order to add support for missing features, as well as polyfills for missing functions.

That makes the bundle larger, but Apostrophe serves a separate, small and fast bundle to non-IE11 users, so there is **no performance penalty** for them.

::: info Internet Explorer 11 limitations
Apostrophe uses babel's `@babel/preset-env` module to provide as much support as possible for JavaScript language features, including promises, `async/await` and more. However, Apostrophe does not provide polyfills for all browser API features, and some, such as `Observable`, cannot be implemented for Internet Explorer 11. Apostrophe also does not attempt to fix the limitations of CSS in Internet Explorer 11. And the most important limitation is that **Apostrophe's editing interface is not available in Internet Explorer 11.** You should test your sites thoroughly in all browsers you intend to support.

## Using your own build process

Apostrophe's built-in `ui/src` feature is very handy, and sufficient for most sites. And if it isn't quite powerful enough, you can [extend it to meet your needs](webpack.md). In most cases that is the best way forward.

However, if after reading that guide you still wish to create your own build process,then you'll want to take a different path. This is where `ui/public` comes in.

The basic idea is that your build process should produce just one output `.js` file, and possibly a `.css` file too. Then you can feed those into Apostrophe by creating a generic module, like `asset`, and configuring your own build process to write its output to `modules/asset/ui/public/index.js` and `modules/asset/ui/public/index.css`.

### The `ui/public` folder

`ui/public` is similar to `ui/src`, with one important difference: Apostrophe imports the code exactly "as-is." Similar like `ui/src`, a `ui/public` folder can exist in any number of modules. However unlike `ui/src` its contents are concatenated into the asset bundle that Apostrophe creates, with no compilation or interpretation of any kind. This makes it perfect for the output of your own build process.

Here's how it works in a typical project with its own build process:

- The project's JavaScript and styles are in a `src` folder at the root of the project, which always contains at least `index.js` and often `index.scss` as starting points, assuming that SCSS files are part of your build process.
- The `dev` npm script in `package.json` runs your build process. If you're using webpack, that script might compile `src/index.js` and `src/index.scss` according to the rules in `webpack.config.js`.
- At the end of the build, the bundled assets are written to `modules/asset/ui/public/sites.js`.
- Any `.js` files Apostrophe finds in the `ui/public` folder of any module are automatically included in the asset bundle served to the visitor.
- Whenever code changes are made, `nodemon` automatically restarts this cycle and refreshes the browser after a successful restart.

But you don't have to use SCSS, webpack or any other specifics mentioned here, except for pushing the output into a `ui/public` folder so that Apostrophe can find it. You can follow whatever process works best for you or your organization.

### What about other static assets for my module?

If you have a need for static asset files like images and would like to ship them with individual modules, see the advanced topic [static module assets](static-module-assets.md).

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Code Organization > Front End > Front End Tips
DOC_PATH: guide/front-end-tips.md
URL: https://apostrophecms.com/docs/guide/front-end-tips
================================================================================
<!-- # Front end best practices -->
<!-- ‚òùÔ∏è Broader title once other examples are added. -->

# Client-side JavaScript tips

## Register JS to keep up with in-context editing events

Since Apostrophe features in-context editing, the main content area that editors manage **frequently refreshes following changes**. That is necessary to make sure editors are working with the most accurate state of the page. It also means that we need to reapply any event listeners we attach to that part of the DOM after it refreshes.

::: info
**What section are we talking about?** If you inspect an Apostrophe page's markup you will see a `div` tag with the `data-apos-refreshable` data attribute. That's the short answer. Anything inside that `div` will refresh following in-context changes, editor modal submissions, and other data changes. There is not much outside of this section: mostly Apostrophe UI, the `head` tag, and generated `script` tags. So any event listeners (or other DOM interactions) on the `body` tag or in the `head` probably only need to be done once. Any others need to be reapplied.

Apostrophe has a utility method to make this easy. [`apos.util.onReady()`](front-end-helpers.md#onready-fn) is in the browser and takes a function as its argument. Every time the page content refreshes the function is run. It's like a [widget player](/guide/custom-widgets.md#client-side-javascript-for-widgets) for the whole page. As such, it is not necessary (and might cause trouble) within a widget player, since the player already does this job.

::: warning
No matter [what module the JS file is in](/guide/front-end-assets.md#placing-client-side-code), the code will run on each page. It's always best to use conditionals to prevent code from running where it is not needed. Look for a relevant DOM element, for example, and only execute the full code when that is present.

```javascript
// modules/assets/ui/src/index.js
export default () = {
  if (document.querySelector('[data-party-toggle]')) {
    apos.util.onReady(() => {
      const partyToggle = document.querySelector('[data-party-toggle]');

      partyToggle.addEventListener('click', engagePartyMode);

      function engagePartyMode () {
        // Party.
      }
    });
  }
}
```

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Code Organization > Front End > Front End Helpers
DOC_PATH: guide/front-end-helpers.md
URL: https://apostrophecms.com/docs/guide/front-end-helpers
================================================================================
# Front end helper methods

Apostrophe provides a small library of front-end utility methods to support implementing client-side JavaScript. These can be useful in widget players, for example. [General utility methods](#general-utility-methods) area available on `apos.util` and [HTTP request methods](#http-request-methods) are available on `apos.http`.

## General utility methods

These are all available in the browser on `apos.util`, e.g., `apos.util.addClass(el, 'is-active')`. They include wrappers for common browser APIs, classic DOM traversal methods, and Apostrophe-specific utilities. They are also compatible with all modern browsers as well as Internet Explorer 11.

| Method | What is it? |
| -------- | ----------- |
| [`addClass`](#addclass-el-classname) | Add a class to a DOM element, if missing. |
| [`assign`](#assign-target-src1-src2) | Assigns properties from one or more source objects to a target object. |
| [`attachmentUrl`](#attachmenturl-fileobj-options) | Get the file URL for an Apostrophe attachment object. |
| [`closest`](#closest-el-selector) | Returns the closest ancestor element that matches the selector. |
| [`emit`](#emit-el-name-data) | Emit a custom browser event on a DOM element. |
| [`getCookie`](#getcookie-name) | Get the value of a browser cookie. |
| [`onReady`](#onready-fn) | Runs the function passed in when Apostrophe refreshes page content during editing.
| [`removeClass`](#removeclass-el-classname) | Remove a class from a DOM element, if present. |
| [`sameSite`](#samesite-uri) | Returns `true` if a URI argument matches the same website as the current page. |

### `addClass(el, className)`

Add a class to a DOM element, if missing. Often used with [`removeClass`](#removeclass-el-classname). Supports browsers without the matching native method.

| Argument | What is it? |
| -------- | ----------- |
| `el` | a DOM element |
| `className` | a string to be added to the `class` attribute |

```javascript
const myElement = document.querySelector('[data-my-element]');

apos.util.addClass(myElement, 'is-active');
```

### `assign(target, src1, src2, ...)`

Assigns properties from one or more source objects to a target object. Uses [`Object.assign`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) when available. Supports browsers without the matching native method.

| Argument | What is it? |
| -------- | ----------- |
| `target` | an object on which to add source object properties |
| `src1`, `src2`, etc. | one or more source objects whose properties should copy to the target object |

```javascript
const options = {
  name: 'balloon',
  color: 'blue'
};

apos.util.assign(options, {
  color: 'red',
  language: 'French'
});

console.log(options)
// {
//   name: 'balloon',
//   color: 'red',
//   language: 'French'
// }
```

### `attachmentUrl(fileObj, options)`

Get the file URL for an Apostrophe attachment object. Optionally pass an options object to get a specific version of the file. File (non-image) attachment objects include a single `_url` property already, so this is primarily used for retrieving specific versions of an image.

| Argument | What is it? |
| -------- | ----------- |
| `fileObj` | an attachment object, such as from an attachment field value or using a template helper method to parse an [image widget](/guide/core-widgets.md#image-widget) value |
| `options` | image options to apply for the resulting URL |

| Options | What is it? |
| -------- | ----------- |
| `size` | an image size name to retrieve, such as one of the [standard image file variations](/guide/core-widgets.md#specifying-the-fallback-size) |

<!-- TODO: Add this line back when the cropping UI is available. -->
<!-- | `crop` | an object of image cropping coordinates with `left`, `top` and `width` properties (usually populated from the cropping UI and included on the image object) | -->

```javascript
// Getting an image attachment object after stashing the stringified object
// on a `data-image` attribute in the template
const imageObj = document.querySelector('[data-thumbnail]').dataset.image;

const smallImage = apos.util.attachmentUrl(imageObj, {
  size: 'one-third'
});
```

### `closest(el, selector)`

Returns the closest ancestor element that matches the selector. The element itself is considered the closest possible match. Supports browsers without the matching native method.

| Argument | What is it? |
| -------- | ----------- |
| `el` | a DOM element |
| `selector` | a string to use as a CSS selector to match |

```javascript
const menuToggle = document.querySelector('[data-toggle]');

const menu = apos.util.closest(myElement, '[data-menu]');
```

### `emit(el, name, data)`

Emit a custom browser event on a DOM element. Optionally include a `data` object to include on the event. For event listeners, use the standard browser [`addEventListener` method](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener).

| Argument | What is it? |
| -------- | ----------- |
| `el` | a DOM element |
| `name` | a string to use as the event name |
| `data` | (optional) an object containing data to include on the event object |

```javascript
const myElement = document.querySelector('[data-my-element]');

apos.util.emit(myElement, 'openChat', {
  url: window.location
});
```

### `getCookie(name)`

Get the value of a browser cookie.

| Argument | What is it? |
| -------- | ----------- |
| `name` | The name of a browser cookie |

```javascript
apos.util.getCookie('cookiename');
```

### `onReady(fn)`

Runs the function passed in when the page loads as well as when Apostrophe refreshes page content during editing. When logged out it will run the function on initial page load. This is not necessary in [widget players](/guide/custom-widgets.md#client-side-javascript-for-widgets).

::: info
This method was previously named `onReadyAndRefresh`. The name was changed, though the previous name will still work through the 3.x major version.

| Argument | What is it? |
| -------- | ----------- |
| `fn` | a function that should run when page content is ready |

```javascript
const loadNewsletterForm = function () {
  // Code that loads a sign-up form...
}

apos.util.onReady(loadNewsletterForm);
```

### `removeClass(el, className)`

Remove a class from a DOM element, if present. Often used with [`addClass`](#addclass-el-classname). Supports browsers without the matching native method.

| Argument | What is it? |
| -------- | ----------- |
| `el` | a DOM element |
| `className` | a string to be added to the `class` attribute |

```javascript
const myElement = document.querySelector('[data-my-element]');

apos.util.removeClass(myElement, 'is-hidden');
```

### `sameSite(uri)`

Returns `true` if the URI pass in matches the same website (same host and port) as the current page. This is used in some HTTP utility methods.

| Argument | What is it? |
| -------- | ----------- |
| `uri` | a valid URI |

```javascript
const targetUrl = 'https://some-website.rocks/api/gems'
const siteMatches = apos.util.sameSite(targetUrl);
```

::: info
There is also a `runPlayers` method on `apos.util`. That is run for us using `apos.util.onReady` and runs all registered widget players. It is unlikely that it will need to be run in project-level code.

## HTTP request methods

These are all available in the browser on `apos.http`, e.g., `apos.http.get('/api/v1/article')`. They include utility methods to make requests with each HTTP method (`GET`, `POST`, `PATCH`, `PUT`, and `DELETE`) as well as other helpers for making HTTP requests.

| Method | What is it? |
| -------- | ----------- |
| [`get`](#get-url-options-callback) | Send a `GET` request. |
| [`post`](#post-url-options-callback) | Send a `POST` request. |
| [`patch`](#patch-url-options-callback) | Send a `PATCH` request. |
| [`put`](#put-url-options-callback) | Send a `PUT` request. |
| [`delete`](#delete-url-options-callback) | Send a `DELETE` request. |
| [`remote`](#remotemet-hod-url-options-callback) | The HTTP request method that powers other request methods. |
| [`parseQuery`](#parsequery-query) | Parses a URL query string, returning an object of parameters. |
| [`addQueryToUrl`](#addquerytourl-url-data) | Returns a URL with data object properties added as a query string. |

### `get(url, options, callback)`

Send a `GET` request. The response will be returned via a Promise unless a callback is included. Query string data may be in `options.qs`. You do NOT have to pass a callback unless you must support IE11 and do not otherwise have Promise support.

| Argument | What is it? |
| -------- | ----------- |
| `url` | The path to a resource or service |
| `options` | Request options. See [`apos.http.remote`](#remote-method-url-options-callback) for details. Required. |
| `callback` | An optional callback function, required when not using Promises. Receives `error` and `result` arguments. |

```javascript
async function logArticles() {
  let articles;

  try {
    articles = await apos.http.get('/api/v1/article', {});
    console.info(articles);
  } catch (err) {
    console.error(err);
  }
}

logArticles();
```

### `post(url, options, callback)`

Send a `POST` request. The response will be returned via a Promise unless a callback is included. `options.body` should be an object containing properties to be passed as `POST` body data. You do NOT have to pass a callback unless you must support IE11 and do not otherwise have Promise support.

See [the `get` method](#get-url-options-callback) for argument details and a related example.

### `patch(url, options, callback)`

Send a `PATCH` request. The response will be returned via a Promise unless a callback is included. `PATCH` body data should be in `options.body`. You do NOT have to pass a callback unless you must support IE11 and do not otherwise have Promise support.

See [the `get` method](#get-url-options-callback) for argument details and a related example.

### `put(url, options, callback)`

Send a `PUT` request. The response will be returned via a Promise unless a callback is included. `PUT` body data should be in `options.body`. You do NOT have to pass a callback unless you must support IE11 and do not otherwise have Promise support.

See [the `get` method](#get-url-options-callback) for argument details and a related example.

### `delete(url, options, callback)`

Send a `DELETE` request. The response will be returned via a Promise unless a callback is included. You do NOT have to pass a callback unless you must support IE11 and do not otherwise have Promise support.

See [the `get` method](#get-url-options-callback) for argument details and a related example.

### `remote(method, url, options, callback)`

Send an HTTP request with a specific method to the given URL, returning the response body. The response will be returned via a Promise unless a callback is included. You do NOT have to pass a callback unless you must support IE11 and do not otherwise have Promise support.

::: info
**This method is used to power the individual HTTP request methods. We recommend using those instead.** They will produce the same result as using `remote` and including the proper HTTP method name.

| Argument | What is it? |
| -------- | ----------- |
| `method` | An HTTP method name: `GET`, `POST`, `PUT`, `PATCH`, or `DELETE`  |
| `url` | The path to a resource or service  |
| `options` | Request options. See below. |
| `callback` | An optional callback function receiving when not using Promises. Receives `error` and `result` arguments. |

| Options | What is it? |
| ------- | ----------- |
| `qs` | An object of query string parameters set to values. |
| `body` | The request body. If an object or array it is sent as JSON. Otherwise sent as-is, unless the `send` option is set to `'json'`. |
| `send` | Set to `'json'` to *always* send the request body as JSON, even if a [`FormData` object](https://www.npmjs.com/package/form-data) or non-object. This is not necessary when the body is a normal object. |
| `parse` | Set to `'json'` to *always* parse the response as JSON. Otherwise the response body is parsed as JSON only if the `Content-Type` is `application/json`. |
| `headers` | An object containing HTTP header names and values. |
| `draft` | If `true`, always add `aposMode=draft` to the query string, creating one if needed. |
| `csrf` | Set to `false` to prevent sending the `X-XSRF-TOKEN` header when talking to the same site. |
| `fullResponse` | If `true`, return an object with `status`, `headers` and `body` properties, rather than returning the body directly. The individual `headers` are canonicalized to lowercase names. If there are duplicate headers after canonicalizing only the last value is returned. If a header appears multiple times an array is returned for it. |
| `downloadProgress` | Optional. A function accepting `received` and `total` arguments. It may never be called. If called, `received` will be the bytes sent so far and `total` will be the total bytes to be received. If the total is unknown, it will be `null` |
| `uploadProgress` | Optional. A function accepting `sent` and `total` arguments. It may never be called. If it is called, `sent` will be the bytes sent so far and `total` will be the total bytes to be sent. If the total is unknown, it will be `null`. |

If the status code is greater than 400 an error is thrown. The error object will be similar to a `fullResponse` object, with a `status` property.

If the URL is site-relative (starts with `/`) it will be requested from the Apostrophe site itself.

::: tip
Just before the `XMLHttpRequest` is sent, this method emits an event matching the HTTP method. For example, `apos-before-post` for `POST` requests, `apos-before-get` for `GET` requests, etc. The event object has `uri`, `data` and `request` properties. `request` is the `XMLHttpRequest` object.

You can use this to set custom headers on all requests, for example.

### `parseQuery(query)`

Returns a data object from parsing a URL query string (e.g., `?theme=light&aposRefresh=1`). The argument should only include the query string part of a URL. The leading question mark (`?`) is allowed but not required. A parameter with no value will be set to `null`.

| Argument | What is it? |
| -------- | ----------- |
| `query` | A url query string |

```javascript
const simpleParams = apos.http.parseQuery('?refresh=true&number=7');
const nestedParams = apos.http.parseQuery('?product%5Bprice%5D=50&product%5Bname%5D=Cheese')
```

::: info
`apos.http.parseQuery()` supports query parameter objects and arrays (when escaped), as well as bracket nesting.

### `addQueryToUrl(url, data)`

Returns a URL with data object properties added as a query string. This supports data object values as objects and arrays. If `data` is an empty object no query string is added. **If the URL already includes a query string it is discarded and replaced.**

| Argument | What is it? |
| -------- | ----------- |
| `url` | A url |
| `data` | An object with data to convert to a query string |

```javascript
const updatedUrl = apos.http.addQueryToUrl(location.href, {
  theme: 'dark',
  'search-complete': 1
});
```

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Code Organization > Front End > Static Assets
DOC_PATH: guide/static-module-assets.md
URL: https://apostrophecms.com/docs/guide/static-module-assets
================================================================================
# Using static module assets

While developers can place static files in the top-level `/public` folder of the project, which allows a file like `/public/images/bg.png` to be accessed via the URL `https://example.com/images/bg.png`, this isn't a good solution for some situations. One issue is that the URL does not change with each new deployment, so if `bg.png` has been changed a stale version may be served by the browser's cache.

Another issue is that those who configure Apostrophe to copy CSS and JS assets to Amazon S3 and other CDNs will discover that code like `url("/images/bg.png")` no longer works, because the static asset files are not on the same host with the CSS code. This can be worked around with absolute URLs, but this gives up some of the benefit of using a CDN.

Apostrophe offers a solution to this problem: each module folder can have its own `public` subdirectory (e.g., `/modules/article/public`). Any static assets in a module's public subdirectory are *copied to the same release location* where the CSS and JS bundles are deployed, regardless of whether that is on the server's hard drive, in S3, or some third location.

::: info
The `public` folder of each module solves a different problem from [`ui/public`](/guide/front-end-assets.md#the-ui-public-folder). While `ui/public` is for JavaScript and CSS files that should be appended as-is to Apostrophe's JavaScript and CSS bundles, usually to accommodate a custom webpack build, `public` is for files that should be **available separately.** A common example is a `.png` file to be used as a background image in CSS.

## Automatic asset path correction in stylesheets

Files we place in the `public` subdirectory of any module are always deployed such that we can write URLs like this in our CSS or SCSS files:

`/modules/custom-module/images/bg.png`

Apostrophe will automatically fix these "asset paths" so they refer to the final URL of the asset, *no matter what our production environment looks like.* In addition, in production deployments, the final URL will always contain a "release identifier" so that any static assets in the browser cache from a previous release are not reused.

::: warning
If you are configuring an Apostrophe core module or other module installed via npm, and you choose to add a `public` subdirectory for that module at project level, you will need to prefix the module name with `my-` when creating asset URLs to those assets.

Note that the `my-` prefix goes in the module name part, not the organization name part. For example, if you have a `modules/@apostrophecms/asset/public/example.svg` file, you can access that via CSS or via the methods given below as `/modules/@apostrophecms/my-asset/example.svg`.

This distinguishes your `public` folder from any assets that might be provided by the original npm module.

It's usually simpler to just put your public assets in a module specific to your project, rather than a project-level configuration of a core one.

## Asset paths in Nunjucks templates

In Nunjucks templates we can convert asset paths to URs by calling the `apos.asset.url` helper function. Again, the rendered template will include the complete asset URL:

``` nunjucks
{{ apos.asset.url('/modules/custom-module/images/bg.png') }}
```

## Asset paths in front end JavaScript

Finally, we can obtain the URL corresponding to an asset path in front end JavaScript using `apos.util.assetUrl`:

```javascript
apos.util.assetUrl('/modules/custom-module/images/bg.png')
```

## What about `extend` and `improve`?

Sometimes modules extend or improve other modules, inheriting or contributing functionality. If both a base class module `a` and a module `b` that extends it contain `public` folders, all files with unique file names will be available via paths starting with `/modules/b`. If files provided by `a` and `b` have the same name, the version in module `b` will take precedence in `/modules/b`. However the base class version is still available in `/modules/a`. The same logic applies when `improve` is used.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Schemas > Content Fields
DOC_PATH: guide/content-schema.md
URL: https://apostrophecms.com/docs/guide/content-schema
================================================================================
# Content field schemas

The content **field schema** is another key concept in Apostrophe. The "schema" simply refers to the fields for a particular content type. In addition to setting fields for the user interface, it supports data validation.

Our blog post module's schema might look something like this:

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-type',
    // üëá The field schema
    fields: {
      add: {
        authorName: {
          label: 'Author name',
          type: 'string'
        },
        body: {
          label: 'Blog post body',
          // The `area` field type supports dynamic content widgets. It is
          // covered in the "Areas and widgets" guide section.
          type: 'area',
          options: {
            widgets: {
              '@apostrophecms/rich-text': {}
            }
          }
        }
      },
      group: {
        blogFields: {
          label: 'Blog fields',
          fields: [ 'authorName', 'body' ]
        }
      }
    }
  };
  ```
  <template v-slot:caption>
  modules/blog-post/index.js
  </template>

</AposCodeBlock>
Content schemas are configured in the `fields` setting. In this case, `fields` has two subsections: `add`, where fields are added to the schema, and `group`, which organizes the fields for the user interface.

Each property in the `add` object is a field you are including in the schema. Each property in `group` is a section of the interface, set to an array of fields to include in that section.

See the reference documentation on [the `fields` setting](/reference/module-api/module-overview.md#fields) and [individual field types](/reference/field-types/index.md) for more information.

## Using existing field groups

Fields that a piece type inherits will likely already be in field groups. This includes the default fields `title`, `slug`, and `visibility`. You can add new fields into these groups and rearrange them if needed. There are a few things to keep in mind as you do.

### It's fairly simple to see what the existing groups are

 Working with inherited fields and field groups can be difficult when you don't know what they are. You can make it easier by logging them in your terminal from the module's [initialization function](/reference/module-api/module-overview.md#initialization-function).

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-type',
    init (self) {
      console.log(self.fieldsGroups);

      // Output:
      // {
      //   basics: { label: 'Basics', fields: [ 'title' ] },
      //   utility: { fields: [ 'slug', 'visibility' ] }
      // }
    }
  };
  ```
  <template v-slot:caption>
    modules/product/index.js
  </template>

</AposCodeBlock>
The `init` function runs once on start up and has access to the module as an argument. By the time it runs, the field groups have been compiled into an object named `fieldsGroups`. If you haven't added any fields yet you can log this to see what you are working with.

::: info
You would see an `archived` field in the log output with this addition. The interface does not show that as a normal field, but it is registered as one to support editing via the REST API.

### Reusing an inherited group's name will ungroup its original fields

For example, `title` is in the default "Basics" group. If you add a `basics` group in your field configuration and do not include `title` in its `fields` array, it will no longer be in any group. Fields that are not part of any group will appear in an "Ungrouped" tab in the interface.

As in the example above, you could include `title` with the "Basics" group along with new fields.

<AposCodeBlock>

``` js
module.exports = {
  // ...
  fields: {
    add: {
      // ...
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [ 'title', 'price', 'description', 'image' ]
      }
    }
  }
};
```
<template v-slot:caption>
  modules/product/index.js
</template>

</AposCodeBlock>

### You don't need a `basics` group

There is nothing special about "Basics." It is a default group name, but if you place all of the fields from that group (or any inherited group) in a new one the group will no longer appear in the UI.

`utility` _is_ a special group. It places fields in the right column of the content editor interface. By default, it includes "meta" fields, such as the slug and visibility fields. You are allowed to add fields to that group and move existing fields.

![The utility field group](/images/fields-utility-highlight.jpg)

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Schemas > Conditional Fields
DOC_PATH: guide/conditional-fields.md
URL: https://apostrophecms.com/docs/guide/conditional-fields
================================================================================
# Displaying conditional fields

When defining a field schema, fields can be made conditional based on the values of other fields using the `if` setting. These conditional fields remain hidden until the specified `if` conditions are satisfied.

## Simple conditions

Simple conditions are passed as an object with keys *matching the names of other fields in the same schema*. The condition values must match the sibling field values *exactly* to pass. When matching values from a `checkboxes` field, the condition is considered met if *any* of the checkbox values selected by the user match any of the values specified in the `if` condition.

::: info
Because strict equivalence is required for simple conditions, fields used in conditions must have values that are strings, numbers, or booleans. This can include simple `string`, `boolean`, or `integer` fields, but also `checkboxes`, `select`, or even `date` or `time` since they are returned as strings.

In the following case, if the `seenMovie` field is set to `true`, the rating field will be displayed.

```javascript
// A field schema's `add` configuration
add: {
  // üëá This boolean field must be set to `true` in the editor interface
  seenMovie: {
    label: 'Have you seen this movie?',
    type: 'boolean'
  },
  rating: {
    label: 'Rate the movie from 1-5',
    type: 'integer',
    min: 1,
    max: 5,
    // üëá Here is our simple condition definition
    if: {
      seenMovie: true
    }
  }
}
```

## MongoDB-style comparison operators

For more flexible conditions, you can use [MongoDB-style comparison operators](https://www.mongodb.com/docs/manual/reference/operator/query-comparison/) instead of exact value matching. This allows for range checks, existence checks, and matching against multiple values.

```javascript
// A field schema's `add` configuration
add: {
  priority: {
    label: 'Task Priority',
    type: 'select',
    choices: [
      { label: 'Low', value: 'low' },
      { label: 'Medium', value: 'medium' },
      { label: 'High', value: 'high' },
      { label: 'Critical', value: 'critical' }
    ]
  },
  estimatedHours: {
    label: 'Estimated Hours',
    type: 'integer'
  },
  assignee: {
  type: 'string',
  label: 'Assignee',
},
  escalationNotes: {
    label: 'Escalation Notes',
    type: 'string',
    textarea: true,
    // üëá Show this field for high/critical priority tasks with 20+ hours
    // where someone has been assigned
    if: {
      priority: { $in: ['high', 'critical'] },
      estimatedHours: { $gte: 20 },
      'assignee.length': { $gt: 0 }
    }
  }
}
```
> [!NOTE]
> For the `assignee` field we are checking that the string length is greater than `0` characters.
> We can't use `$exists: true` because an empty string is truthy.

### Supported comparison operators

| Operator | Description | Example |
| -------- | ----------- | ------- |
| `$eq` | Equal to (same as simple condition) | `{ status: { $eq: 'active' } }` |
| `$ne` | Not equal to | `{ status: { $ne: 'archived' } }` |
| `$gt` | Greater than | `{ score: { $gt: 80 } }` |
| `$gte` | Greater than or equal to | `{ age: { $gte: 18 } }` |
| `$lt` | Less than | `{ price: { $lt: 100 } }` |
| `$lte` | Less than or equal to | `{ discount: { $lte: 50 } }` |
| `$in` | Value is in array | `{ category: { $in: ['news', 'blog'] } }` |
| `$nin` | Value is not in array | `{ status: { $nin: ['draft', 'archived'] } }` |
| `$exists` | Field exists (not null/undefined) | `{ author: { $exists: true } }` |

> [!NOTE]
> The `$eq` operator differs slightly from MongoDB's implementation when working with arrays:
> - When comparing arrays, ApostropheCMS matches if all condition values exist in the document array (order doesn't matter)
> - When the document field is an array but the condition isn't, ApostropheCMS matches if the condition value exists anywhere in the array
>
> MongoDB's `$eq` requires exact array matches including order and length.

### Combining multiple operators

You can combine multiple operators on the same field for range checks and complex validation:

```javascript
// Show field only for users aged 18-65 with a valid email
if: {
  age: {
    $gte: 18,
    $lte: 65
  },
  email: {
    $ne: ''  // Not empty string (implies existence for practical purposes)
  },
  status: {
    $in: ['active', 'verified'],
    $ne: 'suspended'
  }
}
```

::: info Negation without `$not`
While there's no `$not` operator, you can achieve negation using other operators:
- Use `$ne` instead of `$not: 'value'`
- Use `$nin` instead of `$not: { $in: ['a', 'b'] }`
- Use `$exists: false` instead of `$not: { $exists: true }`

> [!INFO]
> When using `$exists`, a value of `true` checks that the field has a value (not null or undefined), while `false` checks that the field is null or undefined. Again, an empty string will evaluate as `true`, so use either `$ne` or check the length.

## Nested Conditional Fields

You can also create a hierarchy of conditional fields where child field visibility depends on a parent field. While the display of this parent field, in turn, is influenced by the value of another field in the schema. The child fields will remain hidden until both the parent field conditional display criteria is satisfied and the value of the parent field fulfills the child field conditional.

## Accessing parent schema fields

When working with nested schemas (like `array` or `object` fields), conditional fields can access values from parent schema fields using the `following` property with the same `<` prefix syntax used for dynamic choices.

> [!IMPORTANT]
> If you need to use a parent schema field for conditional display of a `string` field, and you do not want the value of that followed field to be used for the string value you need to pass any `following` fields into a `followingIgnore` property. If you do want to set a value from one of the `following` fields, leave that field out of the array passed to the `followingIgnore` property.

### Parent field access syntax reference

  - `<fieldName` - access parent level field
  - `<<fieldName` - access grandparent level field
  - `<<<fieldName` - access great-grandparent level field
  - `<arrayField.length` - access array length property
  - `<arrayField.0.property` - access specific array element by index
  - `<arrayField.property` - access property across all array elements (flattened search)
  - `<objectField.nestedProperty` - access nested object properties
  - `<arrayField.nestedObject.deepProperty` - access deeply nested properties

```javascript
// Example with nested object field
add: {
  projectType: {
    label: 'Project Type',
    type: 'select',
    choices: [
      { label: 'Internal', value: 'internal' },
      { label: 'Client', value: 'client' }
    ]
  },
  projectDetails: {
    label: 'Project Details',
    type: 'object',
    fields: {
      add: {
        clientBudget: {
          label: 'Client Budget',
          type: 'integer',
          following: [ '<projectType' ],
          // üëá Access parent field value
          if: {
            '<projectType': 'client'
          }
        },
        internalCostCenter: {
          label: 'Cost Center',
          type: 'string',
          following: [ '<projectType' ],
          // üëá Don't use the `following` field to set the field value
          followingIgnore: [ '<projectType' ],
          if: {
            '<projectType': 'internal'
          }
        }
      }
    }
  }
}
```

### Advanced parent field access with dot notation

You can use dot notation to access nested properties, array elements, and special properties like `length`:

```javascript
add: {
  tasks: {
    label: 'Tasks',
    type: 'array',
    fields: {
      add: {
        title: {
          label: 'Task Title',
          type: 'string'
        },
        priority: {
          label: 'Priority',
          type: 'select',
          choices: [
            { label: 'Low', value: 'low' },
            { label: 'High', value: 'high' }
          ]
        }
      }
    }
  },
  projectSettings: {
    label: 'Project Settings',
    type: 'object',
    fields: {
      add: {
        // Show only when there are tasks
        taskSummary: {
          label: 'Task Summary',
          type: 'string',
          following: [ '<tasks' ],
          followingIgnore: [ '<tasks' ],
          if: {
            '<tasks.length': { $gt: 0 }
          }
        },
        // Show only when there are 3+ tasks
        bulkActions: {
          label: 'Bulk Actions',
          type: 'checkboxes',
          following: [ '<tasks' ],
          choices: [
            { label: 'Mark all complete', value: 'complete' },
            { label: 'Delete all', value: 'delete' }
          ],
          if: {
            '<tasks.length': { $gte: 3 }
          }
        },
        // Show only when the first task is high priority
        urgentNotice: {
          label: 'Urgent Notice',
          type: 'string',
          following: [ '<tasks' ],
          followingIgnore: [ '<tasks' ],
          if: {
            '<tasks.0.priority': 'high'
          }
        },
        // Show when any task has high priority
        highPrioritySettings: {
          label: 'High Priority Settings',
          type: 'checkboxes',
          choices: [
            {
              label: 'Send email notifications',
              value: 'emailNotifications'
            },
            {
              label: 'Escalate to team lead',
              value: 'escalateToLead'
            },
            {
              label: 'Flag for immediate review',
              value: 'immediateReview'
            },
          ],
          following: [ '<tasks' ],
          if: {
            '<tasks.priority': 'high'  // Automatically searches all array elements
          }
        }
      }
    }
  }
}
```

## Complex conditions

In addition to simple field names and comparison operators, the conditional object can take the name of a method as a key. The sibling field value will be compared using strict equivalence to the value returned from the method. You cannot use MongoDB-like conditionals (like `$eq`, `$gt`, etc.) to test the returned values, only strict equivalence is supported. Like simple conditional fields, the returned value should be a string, number, boolean, or any [primitive value](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).

This conditional method can either be defined in the `methods` section of the same module as the conditional field, or another module by prefixing the method with the name of defining module followed by a colon. In either case, the method name must have parentheses appended to the end.

::: info
The property here is a string, not the actual method, so you can't pass arguments back to the method within the parentheses.

The method will receive values of `(req, {docId})`, where the `docId` is `null` if the document is being created for the first time. Otherwise, the `docId` will contain the `_id` for a piece/page, or if the method is being called from a widget, the `_id` of the document where the widget is being added. The call is a server-side, asynchronous method, just like that supported for dynamic selection choices. It only occurs when the editor modal is first opened. This is unlike simple conditional fields which continuously poll other schema fields in the same module. Any changes that occur while the editor is open will not alter the original value returned from the call until the modal is closed. Additionally, the returned value is cached on the first call, so if multiple fields depend on the same method, that method will only be called once.

<AposCodeBlock>

``` javascript
module.exports = {
  fields: {
    add: {
      selectSponsors: {
        label: 'Select a project sponsor',
        type: 'select',
        // populate choices dynamically
        choices: 'sponsorNames',
        if: {
          // `()` are mandatory, method defined in the `article` module
          'isSponsored()': true
        }
      },
      grantName: {
        label: 'Select a grant',
        type: 'select',
        choices: 'grantNames',
        if: {
          // method defined in `modules/grant/index.js`
          'grant:multipleFundingSources()': 'multiple'
        }
      }
    }
    // remainder of fields omitted for brevity
  },
  methods(self) {
    return {
      async isSponsored(req, { docId }) {
        // code to check sponsorship, potentially to outside API
        const response = await fetch(url, {options});
        const grantData = await response.json();
        if (grantData.sponsored === true) {
          // show the field
          return true;
        };
        // don't show the field
        return false;
      }
    };
  }
};

```

<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

## Multiple required conditions (AND logic)

**The `if` setting may contain more than one condition.** When there is more than one, **all conditions must be met** before the field will be active (AND logic). These conditions can be a mix of simple comparisons, MongoDB-style operators, comparisons to other schema fields within the same modal, and calls to a method.

In the next example, `seenMovie` must be `true` *and* `votingOpen()` must be `true` for the rating field to appear.

```javascript
// A field schema's `add` configuration
add: {
  seenMovie: {
    label: 'Have you seen this movie?',
    type: 'boolean'
  },
  rating: {
    label: 'Rate the movie from 1-5',
    type: 'integer',
    min: 1,
    max: 5,
    // üëá Two conditions that both must be met (AND logic)
    if: {
      seenMovie: true,
      'votingStillOpen()': true
    }
  }
}
```

::: info AND vs OR Logic
By default, multiple conditions use AND logic - all must be true. For OR logic (any condition can be true), use the `$or` operator described below.

## Conditional field requirement

In addition to conditionally displaying a field, you can also conditionally mark a field as `required: true` based on the value of another field using the `requiredIf` setting. Like `if`, this property takes an object with keys *matching the names of other fields in the same schema*. The condition values must match the sibling field values *exactly* to pass, use MongoDB-style comparison operators, or dot notation.

Also like the `if` setting, the `requiredIf` can take complex conditionals with a mix of comparisons to other schema fields within the same modal, and calls to a method. All conditions must be met before the field will be active.

You can have both an `if` and `requiredIf` with different conditions on the same field. If the conditions for the `if` are not met, the `requiredIf` will be ignored.

> [!IMPORTANT]
> At this time, `requiredIf` does not support `following` parent schema fields. If this functionality is needed, create a hidden sibling field that takes its value from the parent field and then set the `requiredIf` based on the value of that "cloned" field.

```javascript
// Example using MongoDB-style operators in requiredIf
add: {
  customerType: {
    label: 'Customer Type',
    type: 'select',
    choices: [
      { label: 'Individual', value: 'individual' },
      { label: 'Business', value: 'business' }
    ]
  },
  annualRevenue: {
    label: 'Annual Revenue',
    type: 'integer'
  },
  taxId: {
    label: 'Tax ID Number',
    type: 'string',
    requiredIf: {
      customerType: 'business',
      annualRevenue: { $gte: 50000 }
    }
  }
}
```

## Special conditional operators

| Conditional operator | Value type | Description |
| -------------------- | ---------- | ----------- |
| [`$or`](#or) | Array | The `$or` condition passes if any of the array conditions pass |
| [`$and`](#and) | Array | The `$and` condition passes if all of the array conditions pass |

### `$or`

Condition rules may be independent of one another. Add separate condition rules in an array of objects using the key `$or` to show the field if any of the condition groups pass. A mixture of simple equivalence, MongoDB-style operators, and method calls can be used.

In this example, the rating field will display if *either* `seenMovie` or `uninformedOpinion` is true, if `contributorLevel` is 'intermediate' or 'expert', or if a call to the `featuredMovie()` method returns `true`.

```javascript
// A field schema's `add` configuration
add: {
  seenMovie: {
    label: 'Have you seen this movie?',
    type: 'boolean'
  },
  uninformedOpinion: {
    label: 'Do you have an uninformed opinion about the movie?',
    type: 'boolean'
  },
  contributorLevel: {
    label: 'How many movies have you previously rated in total?',
    type: 'select',
    choices: [
      {
        label: '<100',
        value: 'beginner'
      },
      {
        label: '100-500',
        value: 'novice'
      },
      {
        label: '501-1000',
        value: 'intermediate'
      },
      {
        label: '>1000',
        value: 'expert'
      }
    ]
  },
  rating: {
    label: 'Rate the movie from 1-5',
    type: 'integer',
    min: 1,
    max: 5,
    // üëá Including multiple independent conditions with MongoDB-style operators
    if: {
      $or: [
        { seenMovie: true },
        { uninformedOpinion: true },
        { contributorLevel: { $in: ['intermediate', 'expert'] } },
        { 'featuredMovie()': true }
      ]
    }
  }
}
```

### `$and`

While conditions at the same level are implicitly combined with `$and` logic, you can use explicit `$and` for more complex nested logic or when combining with `$or`. The `$and` operator takes an array of condition objects, all of which must be true.

```javascript
// Example: Show field only for admin users in specific departments 
// OR managers with sufficient experience
add: {
  userRole: {
    label: 'User Role',
    type: 'select',
    choices: [
      { label: 'User', value: 'user' },
      { label: 'Manager', value: 'manager' },
      { label: 'Admin', value: 'admin' }
    ]
  },
  department: {
    label: 'Department',
    type: 'select',
    choices: [
      { label: 'HR', value: 'hr' },
      { label: 'Finance', value: 'finance' },
      { label: 'Engineering', value: 'engineering' }
    ]
  },
  yearsExperience: {
    label: 'Years of Experience',
    type: 'integer'
  },
  confidentialField: {
    label: 'Confidential Information',
    type: 'string',
    if: {
      $or: [
        {
          // Explicit $and for clarity in complex conditions
          $and: [
            { userRole: 'admin' },
            { department: { $in: ['hr', 'finance'] } }
          ]
        },
        {
          $and: [
            { userRole: 'manager' },
            { yearsExperience: { $gte: 5 } }
          ]
        }
      ]
    }
  }
}
```

::: tip
In most cases, you don't need explicit `$and` since multiple conditions at the same level use AND logic by default. Use explicit `$and` when you need to create complex nested logic with `$or`.

The exact same structure can be used to regulate whether a field is required, substituting `requiredIf` in place of `if` in the code above.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Schemas > Content Relationships
DOC_PATH: guide/relationships.md
URL: https://apostrophecms.com/docs/guide/relationships
================================================================================
# Connecting content with relationships

Creating and displaying content is great, but the power of a CMS really shines when you start connecting pieces of content to one another. In Apostrophe we do that with **relationship fields**.

::: info
If you have experience with Apostrophe 2, this may already sound familiar. It is an updated version of the A2 "join" field types.

There are many use cases for relationships, but one common use is categorization. You may have a blog with dozens of articles covering several topics. If you make a piece type for "Topics" and select a topic on each article, you can then do things such as filtering the articles by topic. Let's take a look at how this works.

## The anatomy of a relationship field

We will start with a basic blog article piece type with only an area field for the article text.

<AposCodeBlock>

``` js
module.exports = {
  extend: '@apostrophecms/piece-type',
  fields: {
    add: {
      body: {
        label: 'Article text',
        type: 'area',
        options: {
          max: 1,
          widgets: {
            '@apostrophecms/rich-text': {}
          }
        }
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [ 'title', 'body' ]
      }
    }
  }
};
```
<template v-slot:caption>
  modules/article/index.js
</template>

</AposCodeBlock>

``` nunjucks
{# modules/article-page/views/show.html #}
{% extends "layout.html" %}

{% block main %}
  <h1>{{ data.piece.title }}</h1>
  <section>
    {% area data.piece, 'body' %}
  </section>
{% endblock %}
```

::: info
Refer to the [pieces guide](/guide/pieces.md) for more information on adding piece types.

Then we can add a "Topics" piece type. Since it is only used for categorization, it doesn't need any special fields.

<AposCodeBlock>

  ``` js
  module.exports = {
    extend: '@apostrophecms/piece-type'
  };
  ```
  <template v-slot:caption>
    modules/topic/index.js
  </template>

</AposCodeBlock>

Now that we have the two piece types, the next step is to add a relationship field to connect them. The important question is: where should we put the relationship field?

Relationships establish **directional connections**. That means that the connection is added on one end, then it can only be *edited* or *removed* from that same end. In the case of articles and topics, we will put the field on the *article* piece type. That way editors can select a topic when adding articles and they never have to edit the topic at all.

The article piece type's relationship field would look like:

<AposCodeBlock>

  ``` js
  module.exports = {
    extend: '@apostrophecms/piece-type',
    fields: {
      add: {
        // ...
        _topics: {
          type: 'relationship',
          label: 'Blog post topic',
          withType: 'topic',
          builders: {
            project: {
              title: 1,
              _url: 1
            }
          }
        }
      },
      group: {
        basics: {
          label: 'Basics',
          fields: [ 'title', 'body', '_topics' ]
        }
      }
  };
  ```
  <template v-slot:caption>
    modules/article/index.js
  </template>

</AposCodeBlock>

Like with all fields, we identify the field type, `type: 'relationship'`, and give it a display label. The other two properties are new.

| New properties | What is it? |
| -------------- | ----------- |
| **`withType`** | This identifies the Apostrophe doc type that can connect on the field. If connecting to pages, use `@apostrophecms/any-page-type`. |
| **`builders`** | Field query builders, specifically using the `project` filter. This limits the data that is fetched from the connected doc. It is optional, but recommended for improved performance. [See the relationship field reference for detail.](/reference/field-types/relationship.md#filtering-related-document-properties) |

::: info
**Why does the field name start with an underscore?** You may have noticed that the field name is `_topics`, *not* simply `topics`. Field names that begin with an underscore indicate that a *reference* will be saved to the database document instead of the actual data being referenced.

In the case of a relationship field, the `_id` of the connected doc is saved. Since that connected doc may change, the actual data will be fetched when the relationship is used so it is always up to date.

`_id` is another example of a document property that begins with an underscore. Pieces' `_url` is as well. This pattern generally indicates that a property should not be updated directly when a document is saved using APIs. `_id` is a permanent unique identifier and others are populated by Apostrophe when the document is loaded.

## Creating relationships in the interface

Once a relationship field is added to the schema, the editor will now include a relationship field. They can type in the name of a topic or use the "Browse" button to view the full list of topics to choose.

![The topics relationship field](/images/relationship-autocomplete.png)

![The chooser interface for the topics relationship field](/images/relationship-chooser.png)

## Limiting the number of relationships

You can configure a minimum and/or maximum number of doc relationships on a relationship field using the `min` and `max` settings.

Setting `max: 1` on a relationship field will only allow one such connection.

```javascript
_topics: {
  type: 'relationship',
  label: 'Blog post topic',
  withType: 'topic',
  max: 1,
  builders: {
    project: {
      title: 1,
      _url: 1
    }
  }
}
```

Or setting `min: 2` and `max: 5` will require at least two topics on the article and no more than five. These settings can be used to guide editors to choose the right number of relationship, whatever that may be.

```javascript
_topics: {
  type: 'relationship',
  label: 'Blog post topic',
  withType: 'topic',
  min: 2,
  max: 5,
  builders: {
    project: {
      title: 1,
      _url: 1
    }
  }
}
```

See the full table of [relationship field settings](/reference/field-types/relationship.md#settings) in the reference section.

## Using a relationship in templates

Relationship fields can be referenced in templates like any other field as a property on the context object. If there is any, the field data will be an array of objects.

A blog article show page template may include this code snippet:

``` nunjucks
{# modules/article-page/views/show.html #}
<p>Topics:</p>
<ul>
  {% for topic in data.piece._topics %}
    <li>{{ topic.title }}</li>
  {% endfor %}
</ul>
```

Since the data is fetched in an array, we use the `{% for %}` tag to loop it. **If there is a maximum of one connected doc**, you could reference it directly using the array index:

``` nunjucks
{# modules/article-page/views/show.html #}
{% if data.piece._topics.length > 0 %}
  <p>Topic: {{ data.piece._topics[0] }}</p>
{% endif %}
```

::: warning
Even if the relationship has `min: 1` set, requiring one selection, never assume that the relationship is populated in templates. If the selected item is archived at some point the field will become empty.

## Reverse relationships

Relationships are directional, but you can still read the relationship from the opposite direction using a `reverseRelationship` field. A `reverseRelationship` field must reflect an existing `relationship` field. **It has no user interface or property in database documents.** It is simply a signal for Apostrophe to populate data when fetching a document.

In the example above of articles and topics, you might want to give each topic their own page showing every article using that topic. To do that, add a `relationshipReverse` field to the topic piece type:

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  fields: {
    add: {
      _articles: {
        type: 'relationshipReverse',
        withType: 'article',
        reverseOf: '_topics'
      }
    }
  }
};
```
<template v-slot:caption>
modules/topic/index.js
</template>

</AposCodeBlock>

::: tip
You don't need to use a fields `group` setting here since the `relationshipReverse` field has no user interface. There is no `label` for the same reason.

This field is identifying the connected doc type with the `withType` setting, then the matching `relationship` field on that doc type with the `reverseOf` setting. See [more about `relationshipReverse` configuration](/reference/field-types/relationship-reverse.md) in the field type reference page.

With this field in place, you could display connected articles in a topics show page the same way you displayed article topics above.

``` nunjucks
{# modules/topic-page/views/show.html #}
<p>Articles:</p>
<ul>
  {% for article in data.piece._articles %}
    <li>{{ article.title }}</li>
  {% endfor %}
</ul>
```


## Providing context with `fields`

In some cases, it is useful to add additional information to individual relationships. This would be information that is only relevant to the relationship and not to each individual part.

::: info
This will work for the majority of relationships. However, for relationships with `@apostrophecms/image` pieces you can not add additional fields.

For example, we might be working on a website that displays teams within a company and the people on each team. We would use a relationship field on each `team` piece to connect to multiple `person` pieces. With that we should list all the team members on each `team` show page.

If people have *unique job titles within different teams* we could store the job title directly on the relationship itself. Someone might be a "Support engineer" on the Support Team and a "QA engineer" within the Product Team. To do this, we add a standard field schema to the relationship field.

<AposCodeBlock>

  ``` js
  module.exports = {
    extend: '@apostrophecms/piece-type',
    fields: {
      add: {
        // ...
        _people: {
          type: 'relationship',
          label: 'Team members',
          withType: 'person',
          // üëá Our relationship fields
          fields: {
            add: {
              teamTitle: {
                type: 'string',
                label: 'Team title'
              },
              teamRole: {
                type: 'string',
                label: 'Team role'
              }
            },
            group: {
              positions: {
                label: 'Position',
                fields: [ 'teamTitle', 'teamRole' ]
              }
            }
          }
        }
      },
      group: {
        basics: {
          label: 'Basics',
          fields: [ 'title', '_people' ]
        }
      }
      // ...
  };
  ```
  <template v-slot:caption>
    modules/team/index.js
  </template>

</AposCodeBlock>

In the example above, we add a `fields` property to the relationship field, just like the `fields` property on the module itself. Just like the primary schema, we use an `add` subproperty with field configurations inside it. We are also adding a `group` to give a label to the tab within the "Edit Relationship" modal.

Once this is added, editors can select an "Edit Relationship" option from the context menu of each relationship.

![The relationship field now with a menu button and "edit relationship" option](/images/relationship-fields.png)

![The editor interface for the relationship's "team role" field](/images/relationship-editor.png)

### Accessing the fields of a relationship

Once a relationship with fields has been populated, we can access it, for instance from a template, using the `_fields` property of each related document:

```nunjucks
<h3>Members of Team {{ data.piece.title }}</h3>
<ul>
{% for person in data.piece._people %}
  <li><a href="{{ person._url }}">{{ person.title }} ({{ person._fields.teamRole }})</a></li>
{% endfor %}
```

Notice that within each element of the `data.piece._people` array, we can access `person._fields.teamRole`.
This information is not about the person or the team in general ‚Äî it is specific to the relationship between the two.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Schemas > Images and Media
DOC_PATH: guide/media.md
URL: https://apostrophecms.com/docs/guide/media
================================================================================
# Working with images and media files

There are a few ways to configure a field schema to allow editors to select images or other media files.

1. [An image widget](#the-image-widget-option)
2. [An attachment field](#the-attachment-field-option)
3. [A relationship field](#the-relationship-field-option)

In addition to covering the main ways to allow editors to choose files for their content, we'll also look at how to use the data from each approach in templates. We'll focus on how developers would get the file URL plus critical image information for generating markup.

## The image widget option

The core [image widget](/guide/core-widgets.md#image-widget) is a good way to allow editors to select an image. If we want to use the provided image widget template to render it as HTML, it's definitely the right choice. Once the editor selects an image, the full image is displayed in the editor interface.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  fields: {
    add: {
      photo: {
        label: 'Photo',
        type: 'area',
        options: {
          max: 1,
          widgets: {
            '@apostrophecms/image': {}
          }
        }
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

![an image widget in an area field](/images/media-image-widget.png)

### Using an image widget in templates

If presenting an image using the image widget and its template, the process is not different from rendering any other area in a template. Use the `area` template tag, including the context reference and the area field name.

<AposCodeBlock>

``` nunjucks
{% area data.piece, 'photo' %}
```
  <template v-slot:caption>
    modules/article-page/views/show.html
  </template>
</AposCodeBlock>

Done. The core image widget is designed to render a responsive image with alt text (if it was entered for the image). When that is all that's needed this is a great option.

## The attachment field option

The [attachment field](/reference/field-types/attachment.md) is the direct route for uploading any type of file (e.g., image, PDF) to the file system. It is a fairly simple field that does not do much more than upload the file.

Importantly, a file uploaded through an attachment field *will not appear in either the media library* or the non-image files library. If the image or file is meant to be reused, this will not be best. However if the file should only be associated with one particular page or piece it can work well. Uploading resumes associated with job applicants is one such example.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  fields: {
    add: {
      fileUpload: {
        label: 'File upload',
        type: 'attachment',
        fileGroup: 'office'
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

![an attachment field](/images/media-attachment.png)

### Using attachment field values in templates

Getting file information from an attachment field value is simpler than the other options since you have immediate access to the attachment object. If the field on a piece type is called `fileUpload`, the attachment object is `data.piece.fileUpload` in a show page template.

Apostrophe generates multiple sizes of each uploaded image as discussed [regarding the image widget](/guide/core-widgets.md#image-widget). There is a helper method available in templates to retrieve the url: `apos.attachment.url()`. This method will take into account any custom media hosting settings for the website.

For non-image attachments, simply pass the attachment object into the method.

<AposCodeBlock>

``` nunjucks
{% set fileUrl = apos.attachment.url(data.piece.fileUpload) %}

<a href="{{ fileUrl }}">Download</a>
```
  <template v-slot:caption>
    modules/article-page/views/show.html
  </template>
</AposCodeBlock>


For image attachments, doing the same thing will return the URL for the `full` image size by default (1140px √ó 1140px maximum size). You can pass an options object as a second argument with its `size` property set to another image size to get a different URL back.

<AposCodeBlock>

``` nunjucks
{% set imgUrl = apos.attachment.url(data.piece.photoUpload, {
  size: 'one-third'
}) %}

<img src="{{ imgUrl }}" alt="" />
```
  <template v-slot:caption>
    modules/article-page/views/show.html
  </template>
</AposCodeBlock>


[Responsive images](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) are very important for cross-device support these days. Getting each image size to populate the `srcset` attribute for an image would get repetitive very quickly even using the `apos.attachment.url()` method. For that, there is a dedicated `apos.image.srcset()` method. Pass in the attachment object as an argument and it will return a `srcset` value with all sizes included.

<AposCodeBlock>

``` nunjucks
{% set srcset = apos.image.srcset(data.piece.photoUpload) %}

<img srcset="{{ srcset }}" src="{{ apos.attachment.url(data.piece.photoUpload) }}" alt="" />
```
  <template v-slot:caption>
    modules/article-page/views/show.html
  </template>
</AposCodeBlock>

Notice that in the examples above **the alt text is not included when using an attachment field**. If inserting images with the attachment field we would need to provide alt text with another field. The other two options will usually be better for images since they support metadata such as the alt text.

## The relationship field option

If the image or file should be reusable and in the image or file library, but we *aren't using the image widget template* and don't care about showing the full image in the editor interface, choosing a file with the relationship field is a great option. It uses less code abstraction than an area with an image widget and subsequently has a clearer data structure when retrieved from the database.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  fields: {
    add: {
      _image: {
        label: 'Image',
        type: 'relationship',
        // Use `@apostrophecms/file` for non-image files
        withType: '@apostrophecms/image',
        max: 1
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

### Using a file or image relationship field value in templates

Much of the same steps from [using attachment field values](#the-attachment-field-option) also apply to rendering media relationship fields. There is first an additional step of getting the attachment object. Relationship field values include information in addition to the attachment data, but there are some helper methods to quickly get to that usable data.

Since relationship fields can accept multiple values (e.g., connecting multiple files to a single piece), the `apos.attachment.all()` and `apos.image.all()` methods will return an array of all attachments or all *image* attachments, respectively. This is helpful for looping over several files.

<AposCodeBlock>

``` nunjucks
{% set filesObject = apos.attachment.all(data.piece._files) %}

{% for file in filesObject %}
  <a src="{{ apos.attachment.url(file) }}">Download file</a>
{% endfor %}
```
  <template v-slot:caption>
    modules/article-page/views/show.html
  </template>
</AposCodeBlock>


When the relationship field has the `max: 1` limit, or when we only want the first connected file, we instead use `apos.attachment.first()` or `apos.image.first()`. These return the first (or only) attachment object from the field passed in.

<AposCodeBlock>

``` nunjucks
{% set imageObject = apos.attachment.first(data.piece._image) %}

<img src="{{ apos.attachment.url(imageObject) }}" alt="{{ imageObject._alt }}" />
```
  <template v-slot:caption>
    modules/article-page/views/show.html
  </template>
</AposCodeBlock>

As mentioned above, once we have the attachment object, all of the helper methods from [the attachment field option](#the-attachment-field-option) examples can help finish the job. Additionally, since an image from a relationship field may have alt text, that can be found on the image attachment object `_alt` property as shown above.

When working with images, additional helpers are available. As an example, see the markup below, taken from the built-in `@apostrophecms/image-widget` module. You can use this markup in your own widgets and templates:

<AposCodeBlock>

``` nunjucks
{% set attachment = apos.image.first(data.widget._image) %}

{% if attachment %}
  <img
    {# Modern browsers, best when used with a "sizes" attribute #}
    srcset="{{ apos.image.srcset(attachment) }}"
    {# Legacy browsers #}
    src="{{ apos.attachment.url(attachment, { size: data.options.size or 'full' }) }}"
    {# image.first attaches this property of the image piece for you #}
    alt="{{ attachment._alt or '' }}"
    {# Effective width and height (takes cropping into account) #}
    width="{{ apos.attachment.getWidth(attachment) }}"
    height="{{ apos.attachment.getHeight(attachment) }}"
    {# Responsive design: make sure an editor-chosen focal point remains visible #}
    {% if apos.attachment.hasFocalPoint(attachment) %}
      style="object-position: {{ apos.attachment.focalPointToObjectPosition(attachment) }}"
    {%- endif -%}
  />
{% endif %}
```
  <template v-slot:caption>
    modules/article-page/views/show.html
  </template>
</AposCodeBlock>

::: tip TLDR;
It would be reasonable to be saying, "simply tell me which option to use!" It does depend on the case and how each developer and their clients prefer to work. That said, there are some clear cases where one option is best:

- **The file should only be associated with a single page or piece:** use an attachment field.
- **The file should be added to the file library or media library**: use a relationship field *or* an area with the image widget.
- **An image will be displayed using the image widget template from Apostrophe core**: use an area field with the image widget.
- **The editors definitely want a full-size view of the image in the content editor UI**: use an area field with the image widget.
- **The cropping and focal point features are needed:** use a relationship field (see above example markup) *or* an area with the image widget (more automatic).

If none of those cases apply, personal preference will come into play. For what it's worth, **the core Apostrophe team generally prefers using relationship fields to select images or files** when possible. Put simply, once familiar with the helper methods, using the individual file properties in templates provides ultimate control over presentation to match the context.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Pages and Pieces > Pages
DOC_PATH: guide/pages.md
URL: https://apostrophecms.com/docs/guide/pages
================================================================================
# Pages and page types

Every page in an Apostrophe website is assigned a **"page type"**. The page type tells Apostrophe **what template to use** to render the page and **what configuration to apply**. Configurations will often at least include the field schema for the page type.

## Creating a page type

Apostrophe core only includes a "Home page" type with some basic default content options. You will likely need your own page types, which you create by adding modules that extend `@apostrophecms/page-type` and instantiating them in `app.js`. You can read more about using `extend` in our [section on module configuration](/guide/module-configuration-patterns.md).

<AposCodeBlock>

  ```js
  module.exports = {
    extend: '@apostrophecms/page-type'
  };
  ```
  <template v-slot:caption>
    modules/default-page/index.js
  </template>

</AposCodeBlock>

<AposCodeBlock>

```js
require('apostrophe')({
  shortName: 'my-website',
  modules: {
    'default-page': {}
  }
});
```
<template v-slot:caption>
  app.js
</template>

</AposCodeBlock>

<!-- TODO: Replace area field link to a guide page when available. -->
If we add a string field for the subtitle and an [area field](/reference/field-types/area.md) for rich text and images, the Default page type would look like:

<AposCodeBlock>

  ```js
  module.exports = {
    extend: '@apostrophecms/page-type',
    fields: {
      add: {
        subtitle: {
          type: 'string'
        },
        main: {
          type: 'area',
          options: {
            widgets: {
              '@apostrophecms/rich-text': {},
              '@apostrophecms/image': {}
            }
          }
        }
      },
      group: {
        basics: {
          fields: ['title', 'subtitle', 'main']
        }
      }
    }
  };
  ```
  <template v-slot:caption>
    modules/default-page/index.js
  </template>

</AposCodeBlock>

See the [field schema](/guide/content-schema.md) page for more on configuring fields.

::: tip
We can add functionality to the default home page type by adding a configuration file for it at `modules/@apostrophecms/home-page/index.js`. Add new fields to it as in the example above and this core page type will be ready for additional content possibilities. Or it will be once we update its page template... See below.

## Page template essentials

Each page type requires a template. The only exception to that rule is if a page type extends another page type that already has a template.

Page templates are added in a `views` directory for the page type as `page.html`. The template for the previous example's default page would be `modules/default-page/views/page.html`. A very simple page template for the Default page might look like this:
<!-- TODO: Consider adding a file tree component when available. -->

``` nunjucks
{# modules/default-page/views/page.html #}
{% extends "layout.html" %}

{% block main %}
  <header>
    <h1>{{ data.page.title }}</h1>
    {% if data.page.subtitle %}
      <p>{{ data.page.subtitle }}</p>
    {% endif %}
  </header>
  {% area data.page, 'main' %}
{% endblock %}
```

There are a number of things at work here.

### The template is extending a `layout.html` template

``` nunjucks
{% extends "layout.html" %}
```

`layout.html` is a base level template [used in official Apostrophe essentials starter kit](https://github.com/apostrophecms/starter-kit-essentials/blob/main/views/layout.html) and placed in `views/layout.html`. It is used to add markup for things that belong on every page, such as the website navigation and footer. It extends the `outerLayout.html` template from Apostrophe core, but provides a layer to customize the page wrapper while not overwriting `outerLayout.html`.

The layout template might look something like this:

``` nunjucks
{% extends data.outerLayout %}

{% block beforeMain %}
<div>
  <header>
    {# Page header code: logo, navigation, etc. #}
  </header>
  <main>
{% endblock %}

{% block main %}
  {# Page body content. Pages templates normally override this. #}
{% endblock %}

{% block afterMain %}
  </main>
  <footer>
    {# Page header code: contact information, secondary navigation, etc. #}
  </footer>
</div>
{% endblock %}
```

### We are inserting page template markup in a template block

``` nunjucks
{% block main %}
{% endblock %}
```

Apostrophe uses the Nunjucks template language, which has a [block system](https://mozilla.github.io/nunjucks/templating.html#block) for injecting markup into lower-level templates. The block system involves placing a `block` tag in the root-level template file, then using those blocks in higher-level templates to insert markup. Since we used the `main` block here it will overwrite the layout template's `main` block.

### Page data is on `data.page`

``` nunjucks
{{ data.page.title }}
```

Templates have access to a `data` object containing information about the Apostrophe application and current context data. In page templates, `data.page` contains data for the active page. For our Default page, that includes the title, subtitle, "main" area, and lots of other information.

Naming specific properties in the double brackets syntax, `{{}}`, prints them in the template.

``` nunjucks
{% if data.page.subtitle %}
  <p>{{ data.page.subtitle }}</p>
{% endif %}
```

Nunjucks offers additional tags, including the [`{% if %}` conditional tag](https://mozilla.github.io/nunjucks/templating.html#if), to help work with data in templates.

::: tip
If you want to know what is available in a template object, you can log it in your terminal using the template method `apos.log()`. This looks like:

``` nunjucks
{{ apos.log(data.page) }}
```

### The widget area is added using the `area` tag

``` nunjucks
{% area data.page, 'main' %}
```

This is a special tag in Apostrophe used to let editors add and manage content widgets to the page. After the `area` tag name, we pass the tag the field's context, which is our page, followed by the field name. We [configured it in the `index.js` file](#creating-a-page-type) to use two widget types. While editing the page, the user will have access to a menu to add widgets of those types.

![A page with the area menu opened](/images/page-area.jpg)

We'll explore areas more in [the areas guide](/guide/areas-and-widgets.md).

::: tip
To overwrite the home page type template, create a template file for it at  `modules/@apostrophecms/home-page/views/page.html` and add template markup.

## Activating page types

 There is one more step to make a page type available to use: You'll need to add it to the core page module's `type` option. This configures the "Type" field for pages.

![A page editing modal with the type field highlighted](/images/page-type-select.jpg)

This is a core module option, but you can add your own configuration by giving it an `index.js` file in your project: `modules/@apostrophecms/page/index.js`. You'll then configure it's `types` option with all page types you want to allow.

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    types: [
      // üëá Adding our new page type
      {
        name: 'default-page',
        label: 'Default page'
      },
      // üëá Optionally including the core "Home page" type
      {
        name: '@apostrophecms/home-page',
        label: 'Home page'
      }
    ]
  }
}
```
<template v-slot:caption>
  modules/@apostrophecms/page/index.js
</template>

</AposCodeBlock>

Each type needs a `name` matching the module's name and a label for editors. See the reference section for [other core page module options](/reference/module-api/module-options.md#options-for-the-core-page-module).

## Connecting pages with page tree navigation

<!-- TODO: Link to a guide on building manual navigation widgets or through
     the global doc when available. -->
There are many ways to build navigation with Apostrophe. One is to base site navigation on the page tree. The **"page tree"** refers to the parent-child relationship between pages. For example, the home page is the parent of all top-level pages, which may have subpages of their own.

Pages can be organized into a page tree hierarchy while adding them or through the page manager interface.

![A modal interface with pages organized in order and nested under one another](/images/new-page-tree.png)

Apostrophe templates have data available to add navigation based on the page tree. This includes:

| Data object | What is it? |
| ------ | ------ |
| `data.home` | Home page data. It is similar to the data on `data.page`, but always references the home page. |
| `data.home._children` | Page data for pages one level below the home page in the page tree. |
| `data.page._ancestors` | Page data for the ancestors of the active page, starting with the home page. |
| `data.page._children` | Page data for pages one level *below* the active page. |

By default, one level of children are available on each ancestor, as well as on the home page and `data.page`.

With that available data, we could construct navigation for the website header using the Nunjucks `{% for %}` loop tag. The `layout.html` `beforeMain` block could look like:

``` nunjucks
{# views/layout.html #}
{% block beforeMain %}
<div>
  <header>
    {# üëá Adding our navigation wrapper. #}
    <nav>
      <ul>
        {# üëá Referencing `data.home._children` and looping over them. #}
        {% for page in data.home._children %}
          <li>
            <a href="{{ page._url }}">{{ page.title }}</a>
          </li>
        {% endfor %}
      </ul>
    </nav>
  </header>
  <main>
{% endblock %}
```

This is looping over the home page's child pages, printing their URLs and titles into links. This is simply one way to add navigation using the page data in templates.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Pages and Pieces > Pieces
DOC_PATH: guide/pieces.md
URL: https://apostrophecms.com/docs/guide/pieces
================================================================================
# Pieces

"Piece types" are classifications for standalone, structured content. Individual entries created with a piece type are known as "pieces". Products, events, and authors are all common examples of piece types. The piece type defines how pieces are structured, how end users interact with them, and how they might interact with other content.

Use cases for pieces include:
- Articles in a blog
- Authors to associate with multiple articles
- Individual products in a store

Unlike Apostrophe ["pages"](/guide/pages.md), pieces do not always have a dedicated web page. In the "articles" and "authors" example, there would be a web page for each article, but there may not be a page for each author.

## Creating a piece type

You can create a new piece type by adding a module that [extends](/guide/module-configuration-patterns.html) the `@apostrophecms/piece-type` module. After instantiating in `app.js`, a piece type that had no other configuration would have the default fields **title**, **slug**, and **visibility**.

::: tip
Generate the starter code for a piece type using the [official CLI](/guide/development-setup.md#installing-the-apostrophe-cli) with the command:

```bash
apos add piece product
```

<AposCodeBlock>

  ``` js
  module.exports = {
    extend: '@apostrophecms/piece-type',
  };
  ```
  <template v-slot:caption>
    modules/product/index.js
  </template>

</AposCodeBlock>

<AposCodeBlock>

  ``` js
  require('apostrophe')({
    shortName: 'my-store',
    modules: {
      product: {}
    }
  });
  ```
  <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

A more realistic product piece might also include [fields](/reference/field-types/index.md) for the product price, description, and photo, as well as explicit labels for the UI.

<AposCodeBlock>

  ``` js
  module.exports = {
    extend: '@apostrophecms/piece-type',
    options: {
      label: 'Product',
      pluralLabel: 'Products'
    },
    fields: {
      add: {
        price: {
          type: 'float',
          label: 'Price',
          required: true
        },
        description: {
          type: 'string',
          label: 'Description',
          textarea: true,
          required: true
        },
        image: {
          label: 'Product photo',
          type: 'area',
          options: {
            max: 1,
            widgets: {
              '@apostrophecms/image': {}
            }
          }
        }
      },
      group: {
        basics: {
          label: 'Basics',
          fields: [ 'title', 'price', 'description', 'image' ]
          // üëÜ 'title' is included here because it is in the default `basics`
          // group for all piece types. Since we are replacing that group, we
          // include it ourselves.
        }
      }
    }
  };
  ```
  <template v-slot:caption>
    modules/product/index.js
  </template>

</AposCodeBlock>

::: tip
There is a full REST API for pieces that you can use in headless contexts, custom interfaces, and more. For more information, see [the REST API section](/reference/api/pieces.md).

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Pages and Pieces > Piece Pages
DOC_PATH: guide/piece-pages.md
URL: https://apostrophecms.com/docs/guide/piece-pages
================================================================================
# Piece index and show pages

**Index pages** list pieces of a particular type. Once one is created, each individual piece automatically has its own web page, known in Apostrophe as a **show page**. If you're familiar with blogs, you know this model all too well.

This feature set is powered by the `@apostrophecms/piece-page-type` module (because you're creating a *page type* that displays *pieces*, get it?).

Index pages support all features from [pages](/guide/pages.md), then add on some special features. In short, those are:

- Two template files: one for index pages and one for show pages
- Additional piece data available in templates

## Creating a piece page type

There are two critical steps to adding a new module for a piece page type:

1. [Extend](/guide/module-configuration-patterns.html) `@apostrophecms/piece-page-type`
2. Specify what piece type should be shown on the page

Extending the right module is simple enough. These modules use the property:

```javascript
extend: '@apostrophecms/piece-page-type',
```

Identifying the piece type can be done two ways: **using a module naming convention** or **using the `pieceModuleName` setting**. We can look at both options using a blog as our example.

### Matching a piece type using naming

In this example, the piece type is `article`, since "articles" are the individual entries that make up a blog. If you name the piece page type `article-page`, Apostrophe will automatically know that the two modules go together. (In case you missed the trick there, the piece page name is: piece type + `-page`.)

The piece page module then looks like:

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-page-type',
    options: {
      label: 'Blog page'
    }
  };
  ```
  <template v-slot:caption>
    modules/article-page/index.js
  </template>

</AposCodeBlock>

One benefit of this approach is that the codebase folders for the piece type and piece page type will be next to one another alphabetically. This tends to be the choice of the Apostrophe core team.

![Screenshot of code directories "article" and "article-page"](/images/piece-page-modules.png)

### Specifying the piece type with `pieceModuleName`

This method allows you to name the module whatever you want since you are specifically identifying a piece type. Set the [`pieceModuleName` option](/reference/module-api/module-options.md#piecemodulename) to the piece type name and Apostrophe makes the right connection.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    label: 'Blog page',
    pieceModuleName: 'article'
  }
};
```
<template v-slot:caption>
  modules/blog-page/index.js
</template>

</AposCodeBlock>

Either method works well and you may find both options useful depending on the situation.

### Add template files and instantiate

Piece page types use two templates, both added in the module's `views` directory (e.g., `modules/article-page/views/`).

::: tip
When using the [official CLI](/guide/development-setup.md#installing-the-apostrophe-cli) to create a piece page type, include the `--page` option when creating the piece type. It will not only generate the piece type for you, but also the piece page code including blank template files.

```bash
apos add piece article --page
```

| Template file name | What is it? |
| ------------------ | ----------- |
| `index.html` | Template for listing pieces (the **"index page**) |
| `show.html` | Template to display an individual piece (a **"show page"**) |

We'll review each template's features next.

Once those template files exist, you would **add this to the `app.js` configuration** [like any other module](/guide/modules.html#setting-up-a-module). Additionally, in order for your pages to show up in the page selection dropdown, you also need to add your module to the `module/@apostrophecms/page/index.js` file. As with other pages, you add an object with the name of the module and a label into the `types` option array.

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    types: [
      // üëá Adding our new page type
      {
        name: 'article-page',
        label: 'Article page'
      },
      // üëá Optionally including the core "Home page" type
      {
        name: '@apostrophecms/home-page',
        label: 'Home page'
      }
    ]
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>

</AposCodeBlock>

::: warning üõë Hold up. ‚úã

You've reviewed the [page type guide](/guide/pages.md), right? The sections below will highlight the special features of index and show page templates. For general page template syntax, see that page type guide.

## The index page template

Index page templates look very similar to other page templates.

``` nunjucks
{# modules/article-page/views/index.html #}

{% extends "layout.html" %}
{% import '@apostrophecms/pager:macros.html' as pager with context %}

{% block main %}
  <h1>{{ data.page.title }}</h1>

  {% for article in data.pieces %}
    <article>
      <h2>
        <a href="{{ article._url }}">{{ article.title }}</a>
      </h2>
    </article>
  {% endfor %}

  {{ pager.render({
    page: data.currentPage,
    total: data.totalPages,
    class: 'blog-pager'
  }, data.url) }}
{% endblock %}
```

### `data.pieces` and other unique `data` properties

The first new thing here is the `import` statement, but we'll get back to that. Let's talk about the **loop over `data.pieces`**.

``` nunjucks
{% for article in data.pieces %}
  <article>
    <h2>
      <a href="{{ article._url }}">{{ article.title }}</a>
    </h2>
  </article>
{% endfor %}
```

Index page templates have access to `data.pieces`, which is an array of piece docs. Since it's an array, we use the [Nunjucks `for` tag](https://mozilla.github.io/nunjucks/templating.html#for) to loop over the pieces.

The `data` object properties unique to index pages are:

| Property | What is it? |
| -------- | ----------- |
| `pieces` | An array of piece docs for the current set of results |
| `currentPage` | A number representing what page of results is shown, starting with `1` |
| `totalPages` | The total number of results pages there are |
| `totalPieces` | The total number of pieces across all result pages |

### Pagination

``` nunjucks
{% import '@apostrophecms/pager:macros.html' as pager with context %}

{{ pager.render({
  page: data.currentPage,
  total: data.totalPages,
  class: 'blog-pager'
}, data.url) }}
```

By default, index pages will include up to *ten* pieces on `data.pieces` at a time. **You can change the number of pieces in each page of results** by setting [the `perPage` option](/reference/module-api/module-options.md#perpage-1) on the module. The data passed to templates will update, so you don't need to make any other adjustments.

Apostrophe's pager macro adds basic, unstyled pagination to view more. The pager macro is a special template using the [Nunjucks macro](https://mozilla.github.io/nunjucks/templating.html#macro) feature. This particular macro accepts two arguments:

1. an object with the `currentPage` and `totalPages` values, described above, as well as an optional CSS class for the pager wrapper
```javascript
{
  page: data.currentPage,
  total: data.totalPages,
  class: 'my-pager-class' // Optional
}
```
2. the page URL, `data.url`

## The show page template

Show pages are the web pages for individual pieces, rendered from `show.html` templates. Instead of `data.page`, the template uses `data.piece` to access the piece data.

Assuming our `article` piece type example has a single `body` area, it could look like this:

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-type',
    options: {
      label: 'Article'
      // Additionally add a `pluralLabel` option if needed.
    },
    fields: {
      add: {
        body: {
          label: 'Article text',
          type: 'area',
          options: {
            max: 1,
            widgets: {
              '@apostrophecms/rich-text': {}
            }
          }
        }
      },
      group: {
        basics: {
          label: 'Basics',
          fields: [ 'title', 'body' ]
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/article/index.js
  </template>

</AposCodeBlock>

``` nunjucks
{# modules/article-page/views/show.html #}
{% extends "layout.html" %}

{% block main %}
  <h1>{{ data.piece.title }}</h1>
  <section>
    {% area data.piece, 'body' %}
  </section>
{% endblock %}
```

There are some other special data available in show page templates:

| Property | What is it? |
| -------- | ----------- |
| `piece` | The document object for the featured piece. In a blog, this would be a single article. |
| `page` | In show page templates, `data.page` refers to the index page |
| `previous` | If using the [`previous: true` option](/reference/module-api/module-options.md#previous), `data.previous` is the previous piece based on the [sort](/reference/module-api/module-options.md#sort) |
| `next` | If using the [`next: true` option](/reference/module-api/module-options.md#next), `data.next` is the next piece based on the [sort](/reference/module-api/module-options.md#sort) |

## Index and show page URL basics

Index page URLs, like other page URLs, generally are constructed from the base domain/URL (the home page URL) plus their slug. Page slugs include forward slashes and, by default, the path of their parent page, if they have one.

If the home page URL was `https://example.rocks` and the "Articles" index page had the slug `/articles`, the "Articles" page URL would be **`https://example.rocks/articles`**.

Show pages are extensions of their index page. To that end, their URLs are the index page url plus the piece slug. Piece slugs do not have slashes or look like a URL path on their own since pieces can be used in many ways.

Consider an article "How to write JavaScript." Apostrophe would generate the slug `how-to-write-javascript` based on the title. With the index page url `https://example.rocks/articles` and that slug, the show page URL would be **`https://example.rocks/articles/how-to-write-javascript`**.

The structure of index and show page URLs is one of the most clear ways to understand how show pages depend on index pages. Even if this does not seem terribly complex, it is important to understand that relationship.

::: info
You may create multiple index pages of a particular type. If you do, the related piece show pages can be accessed at URLs based on any of the index pages. For example, if you create one articles index page with the slug `/articles` and another with `/news`, both of these URLs will go to the same article:

- `https://example.rocks/articles/how-to-write-javascript`
- `https://example.rocks/news/how-to-write-javascript`

This can be used to create index pages that are filtered to list different pieces (e.g., articles on different topics).

Even if any of the index page URL paths can be used to reach a particular show page, the piece will have a primary `_url` property when requested (e.g., in a `GET` API request). That primary URL is generated using the index page identified using the `chooseParentPage` method on `@apostrophecms/piece-page-type` (and modules that extend it). By default it simply returns the first index page created, but you can override that method to choose a matching index page another way.

<!-- TODO: Link to the piece page module reference page `chooseParentPage` method when available. -->

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Areas and Widgets > Areas
DOC_PATH: guide/areas-and-widgets.md
URL: https://apostrophecms.com/docs/guide/areas-and-widgets
================================================================================
# Areas and widgets

**Areas** are core to Apostrophe's in-context editing experience. They are special fields where editors can add one or more content widgets. A **widget** is a section of structured content, such as a block of rich text, an image slideshow, or a grid of featured products. Together, these two features let editors add custom and advanced content to a website, move it around, and edit it &ndash; all within a model that maintains the content design. Areas can be configured for editors to add content through a basic menu or through an expanded preview menu.

## Basic area configuration

Like other fields, area fields are configured as part of the [field schema](/guide/content-schema.md) for a page or piece type. The following example shows a landing page type with one area field named `main`. Every area requires a `widgets` option to configure the allowed widget types. This example includes four core widget types.

<AposCodeBlock>

``` js
export default {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Landing Page'
  },
  fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/layout': {},
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {},
            '@apostrophecms/video': {}
          }
        }
      }
    },
    group: {
      mainArea: {
        label: 'Main page content',
        fields: ['main']
      }
    }
  }
};
```

<template v-slot:caption>
  modules/landing-page/index.js
</template>

</AposCodeBlock>


![The landing page main area with the menu open, showing available widgets](../images/new-area-in-context.png)

### Leave `-widget` out of area configuration

If you dig into the Apostrophe code, or read the guide to custom widget types, you may already know that widget module names end with `-widget`, such as `@apostrophecms/rich-text-widget`. This suffix is left off when configuring areas. The area knows these are widgets already and it does not seem necessary to require developers to write it over and over.

### Limiting the number of widgets in an area

To limit the number of widgets allowed in a specific area, include a `max` option.

```javascript
main: {
  type: 'area',
  options: {
    widgets: {
      '@apostrophecms/layout': {},
      '@apostrophecms/rich-text': {},
      '@apostrophecms/image': {},
      '@apostrophecms/video': {}
    },
    max: 3
  }
}
```

This can be especially useful when you want to allow only one widget of a particular type in an area. This can be a good way to add a special page introduction that should only include a single rich text area.

```javascript
introduction: {
  type: 'area',
  options: {
    widgets: {
      '@apostrophecms/rich-text': {}
    },
    max: 1
  }
}
```

## Adding default widgets to areas

To solve the "blank page" problem and help editors get started with content creation, you can configure areas to include default widgets when a new document is created. This is particularly useful when combined with the [layout widget](#layout-widget) to provide editors with a pre-structured content framework.

The `def` feature is designed for **simple, straightforward default layouts** that work well for all new documents of a particular type. For more sophisticated needs‚Äîsuch as offering editors a library of pre-designed sections they can choose from, or when different pages need different starting layouts‚Äîconsider using the [Section Template Library extension](https://apostrophecms.com/extensions/section-template-library) instead.

### Basic default widgets

The `def` field accepts an array of widget type names that will be automatically added to the area when a new document is created:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Landing Page'
  },
  fields: {
    add: {
      content: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {},
            '@apostrophecms/video': {},
            '@apostrophecms/layout': {}
          }
        },
        def: [
          '@apostrophecms/image',
          '@apostrophecms/rich-text',
          '@apostrophecms/rich-text',
          '@apostrophecms/video'
        ]
      }
    },
    group: {
      content: {
        label: 'Page content',
        fields: ['content']
      }
    }
  }
};
```

<template v-slot:caption>
  modules/landing-page/index.js
</template>

</AposCodeBlock>

In this example, when an editor creates a new landing page, the `content` area will automatically include four widgets: an image widget, two rich text widgets, and a video widget, in that order. Each widget will be instantiated with its default properties.

> [!TIP]
> To learn more about adding default widgets into layout widgets on your page check out the [Core Widgets documentation](/guide/core-widgets.html#creating-default-layouts-with-pre-populated-content).

### Widget compatibility notes

Not all widgets may work smoothly as defaults. When choosing widgets to include in a `def` configuration:

- **Best choices**: Widgets that work well with empty or default content (e.g., `@apostrophecms/rich-text`, `@apostrophecms/image`, `@apostrophecms/video`)
- **Consider carefully**: Widgets that require specific configuration or selections to function properly
- **Test thoroughly**: Always test your default widget configuration to ensure it provides a good editing experience

## Expanded widget preview menu configuration
 To enhance the editor experience, an expanded widget menu can be added instead of the basic menu. This context menu expands from the left side and provides a visual indicator for each widget in the area and support for organizing widgets into groups. These visual indicators can be preview images or icons.

 Adding an `area` using the expanded menu requires a [field schema](/guide/content-schema.md) slightly different from a basic area. The following example shows a landing page type with one area field named `main`.

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Landing Page'
  },
  fields: {
    add: {
      main: {
        type: 'area',
        options: {
      üëâüèª  expanded: true,
      üëâüèª  groups: {
            layout: {
              label: 'Layout',
              widgets: {
                '@apostrophecms/layout': {}
              },
          üëâüèª  columns: 2
            },
            basic: {
              label: 'Basic',
              widgets: {
                '@apostrophecms/rich-text': {},
                '@apostrophecms/image': {},
                'topic': {},
                '@apostrophecms/video': {}
              },
          üëâüèª  columns: 2
            },
            specialty: {
              label: 'Specialty',
              widgets: {
                'hero': {},
                'review': {},
                '@apostrophecms/html': {}
              },
          üëâüèª  columns: 3
            }
          }
        }
      }
    },
    group: {
      mainArea: {
        label: 'Main page content',
        fields: ['main']
      }
    }
  }
};
```

<template v-slot:caption>
  modules/landing-page/index.js
</template>

</AposCodeBlock>

![Editing an area with the expanded widget preview open.](../images/new-widget-preview-menu.png)

 For the expanded widget preview menu, there are three settings to configure. The first option is `expanded` and takes a boolean to activate the expanded preview. This is required to activate the menu.
 
 Second, widgets are added in a `groups` option that organizes the added widgets into specific regions of the menu. Each grouping of widgets is organized in a named object. In the example code, there are two such `groups` added within the area. The first is named `basic`, and the second is named `layout`. Each has a `label` key that provides the name displayed for the widget group. Each individual group has a `widgets` key that contains the names and options for all of the widgets to be included in that group. Like with the basic configuration, the widget names do not need the '-widget' suffix.
 
 Finally, each group has a `columns` key that takes an integer from 1-4. This determines how many widgets will be displayed per line. The default value is 3.

An `area` configured in this way can still take a `max` option to limit the number of widgets to be added.

### Widget preview options

#### `previewImage`: the simplest way to use an image

The `previewImage` option takes the extension, without prefixing, of the image to be used. For example, `'png'` or `'gif'`. The actual image should be added into the `/public` folder of the widget and named `preview.<extension>`, where `extension` matches the string passed to the option. If a file by this name exists in the `public/` subdirectory of the module's project-level configuration, that will automatically be used in preference to a version found in the core module, but still we recommend setting `previewImage` to match your file extension in case the extension of the original ever changes.

The displayed dimensions of the `previewImage` depend on the number of columns being used for the row in which it will be displayed. For two columns, the displayed dimensions are about 240 x 120, or 2:1. For three columns, the dimensions are about 160 x 90, or 16:9. For four columns, the dimensions are approximately 120 x 66, or approximately 16:9. Choosing an image with a ratio of 16:9, with the center of the image well placed should work with all column sizes.

::: info
The extension should always be lower case.

#### `previewUrl`: when you need a custom image URL

The `previewUrl` option accepts a complete URL to the image being used. This option supports Apostrophe asset paths, making it easier to serve
images kept in a particular module. If you do not wish to use the default filename, or wish to serve the image from a different location, this option gives you the flexibility to achieve that.

**For example:** if you wish to serve the file `special-preview.jpg` from
your project-level `modules/@apostrophecms/image-widget/public` folder,
you can do that with the following configuration:

<AposCodeBlock>

```javascript
export default {
  options: {
    // The "my-" prefix tells Apostrophe to use the project-level
    // folder, not the one in the core apostrophe module
    previewUrl: '/modules/@apostrophecms/my-image-widget/special-preview.jpg',
  }
}
```
<template v-slot:caption>
  modules/@apostrophecms/image-widget/index.js
</template>

</AposCodeBlock>

::: info
Note the `my-` prefix in `@apostrophecms/my-image-widget`. Without this
prefix, Apostrophe would look for the file in the core Apostrophe npm
module, and would not find it.

#### `previewIcon`: when you prefer an icon to an image

The final option is `previewIcon`. This option takes any icon that has already been [registered](https://github.com/apostrophecms/apostrophe/blob/main/modules/@apostrophecms/asset/lib/globalIcons.js). Alternatively, additional Material Design Icons or icons from your own Vue files can be registered using the [`icons`](/reference/module-api/module-options.md#icon) property within the module. If it is present, the `icon` option will be used if no `previewIcon` option is set.

## Adding placeholder content to widgets

The rich text, image, and video widgets all display placeholder content by default. Additionally, these modules do not show an initial editing modal. This placeholder content will not be displayed in either the draft preview or the live page if published. This default behavior can be turned off by setting the `placeholder` option of the relevant module to `false`. This will eliminate the display of placeholder content and open the editing modal when the widget is selected.

Custom placeholder content can be added to the image and video widgets through the `placeholderImage` and `placeholderUrl` options.

For the image widget, the `placeholderImage` option takes **just the file extension,** like `jpg` (note no `.`). You must also copy a matching file in the `public` folder of the module, e.g. copy that image to `/modules/@apostrophecms/image-widget/public/placeholder.jpg` (the name must be `placeholder` and the extension must match `placeholderImage`).

`placeholderImage` is the easiest way, but for those who prefer to change the filename or specify a complete URL to the placeholder image, see also the [placeholderUrl option](core-widgets.md#specifying-a-custom-url-to-a-placeholder-image).

For the video widget, the `placeholderUrl` option takes the URL of a video on a site that the video widget already supports, like YouTube.

::: info
For legacy reasons, `placeholderUrl` is also supported for image widgets, however we do not recommend its use because it is challenging to determine the correct asset URL. Use `placeholderImage` and let Apostrophe figure it out for you.

The custom placeholder content for the rich text widget is passed as a string to the `placeholderText` option in the `/modules/@apostrophecms/rich-text-widget/index.js` file. This can be either a simple string or a namespaced i18n string.

Both the image and video widgets have a `placeholderClass` option that takes a string and adds that class to the content wrapper.

## Real-time content editing with the `preview` option

ApostropheCMS offers a real-time preview feature that allows editors to see their changes immediately as they edit widget content. This can be configured either globally for all widgets or individually for specific widget types.

### Global preview configuration

To enable real-time preview for all widgets in your project, configure the `@apostrophecms/widget-type` module in your project:

<AposCodeBlock>

```javascript
export default {
  options: {
    preview: true
  }
};
```

<template v-slot:caption>
  modules/@apostrophecms/widget-type/index.js
</template>

</AposCodeBlock>

### Individual widget preview configuration

You can also enable or disable the preview feature for specific widget types:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Hero Widget',
    preview: true
  }
};
```

<template v-slot:caption>
  modules/hero-widget/index.js
</template>

</AposCodeBlock>

When the preview option is enabled:

- Widgets will update in real time as edits are made
- Editors can immediately see the impact of their changes in context
- Previews will only update when all required fields and validation errors have been dealt with
- The editing modal will intelligently position itself to avoid overlapping the widget, typically to the left or right

This feature enhances the in-context editing experience by providing immediate visual feedback to editors as they work with content.

## Adding areas to templates

Areas have a special template tag to add them in template markup. It requires passing two arguments: the area's context and the area name.

``` nunjucks
{% area context, 'name' %}
```

The **context** refers to the data object that the area field belongs to. This could be a page, a piece, or a widget. In the landing page example above, the `main` area belongs to a landing page. In that case, the context would be that page's data object in the template: `data.page`.

``` nunjucks
{% area data.page, 'main' %}
```

The template tag knows to use the area data on `data.page.main`, check for the widgets allowed in that area, and render the area using the correct widget templates.

### Passing context options

Most widget options must be included in the area field configuration. For example, you can configure the rich text widget to use particular formatting controls. The server uses these options to properly validate user input.

```javascript
main: {
  type: 'area',
  options: {
    widgets: {
      '@apostrophecms/rich-text': {
        toolbar: [
          'bold',
          'italic',
          'strike',
          'link'
        ]
      }
    }
  }
}
```

::: info
Learn more about rich text options in [the section on core widgets](/guide/core-widgets.md).

In other situations, you may need to **pass the widget *template* options that only apply to a specific context**. One example of this is the [`sizes` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#sizes) for the core image widget's `img` tag. Since that attribute tells browsers which file versions to use in a responsive image, it may be different when the image is a small thumbnail as opposed to when it is a larger featured photo.

These can be added in an object after the area tag arguments using the `with` keyword.

<AposCodeBlock>

``` nunjucks
{% area data.page, 'main' with {
  '@apostrophecms/image': {
    sizes: '(min-width: 600px) 45vw, (min-width: 1140px) 530px'
  }
} %}
```

<template v-slot:caption>
  modules/landing-page/views/page.html
</template>

</AposCodeBlock>

The object following `with` should include keys matching widget type names, without the `-widget` suffix (e.g., the `@apostrophecms/image`). The context template will pass those options into the proper widget template as `data.contextOptions`. In the example above, the core image widget template, *and only that template*, would be able to use the data as:

``` nunjucks
{{ data.contextOptions.sizes }}
```

Any context options for widget types not allowed in the area are ignored.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Areas and Widgets > Core Widgets
DOC_PATH: guide/core-widgets.md
URL: https://apostrophecms.com/docs/guide/core-widgets
================================================================================
# Core widgets

Apostrophe comes with some content widgets you can use in areas right away. See below for their descriptions and options.

| Common name/label | Widget reference | What is it? |
| ------ | ------ | ------ |
| [Layout](#layout-widget) | `@apostrophecms/layout-widget` | Create responsive grid-based layouts with configurable columns |
| [Rich text](#rich-text-widget) | `@apostrophecms/rich-text` | A space to enter text and allow formatting (e.g., bolding, links) |
| [Image](#image-widget) | `@apostrophecms/image` | A single image supporting alt text and responsive behavior |
| [Video](#video-widget) | `@apostrophecms/video` | Embed a video from most video hosts by entering its URL |
| [File](#file-widget) | `@apostrophecms/file` | Display a downloadable file link |
| [Raw HTML](#html-widget) | `@apostrophecms/html` | Allow entering HTML directly (see security notes below) |

## Layout widget

![The layout widget after first addition to the page](../images/basic-layout-selection.png)

The layout widget provides a powerful CSS grid-based layout system for creating responsive column-based designs. Editors can add the layout widget to a page and then directly add, remove, and resize columns in-context without leaving the page. This provides precise control over column positioning, spanning, and responsive behavior across different screen sizes.

<AposCodeBlock>

``` js
fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/layout': {}
          }
        }
      }
// remainder of fields
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>
</AposCodeBlock>

### How it works

The layout widget creates a CSS grid container with a configurable number of grid columns (default 12). By default, two layout-column widgets (`@apostrophecms/layout-column-widget`) are added when the layout widget is first placed on a page. Editors can then add or remove columns in-context. Each column has its own area for widget addition and can:
- Span multiple grid columns
- Be positioned precisely on the grid
- Adjust its visibility at different breakpoints (desktop, tablet, mobile)
- Apply custom alignment (horizontal and vertical)

### Editor experience

The layout widget provides a specialized editing interface that separates layout management from content editing. This two-mode approach gives editors precise control over their grid structure while keeping content editing straightforward.

#### Editing modes

When a layout widget is selected on the page, the breadcrumb area at the top displays two mode-switching buttons:

- **Edit Content** (left button) - Add and edit widgets within existing columns
- **Edit Columns** (right button) - Modify the grid structure by adding, removing, resizing, and repositioning columns

Toggle between these modes depending on whether you need to work with content or adjust the layout structure.

#### Edit Content mode

![Layout widget with the "Edit content" button selected and widget menu open](../images/layout-content-editing.png)

In Edit Content mode, the interface behaves like a standard Apostrophe area with a few key differences:

- Each column displays its standard widget controls (add, edit, move, etc.)
- You can add any configured widget type to each column's content area
- The grid structure remains locked - you cannot resize or reposition columns
- This mode is ideal for editors who need to work with content without accidentally modifying the layout

**Common tasks in Edit Content mode:**
- Adding rich text, images, videos, or custom widgets to columns
- Editing existing widget content
- Reordering widgets within a column
- Removing widgets from columns

#### Edit Columns mode

![The layout widget with the "Edit columns" button selected](../images/layout-column-editing.png)

Edit Columns mode unlocks the full power of the layout system, allowing you to manipulate the grid structure itself. Each column displays a set of controls and supports multiple interaction methods.

##### Column controls

Each column displays three icons in its upper-left corner:

1. **Move handle** (drag icon) - Click and drag to reposition the column on the grid
2. **Settings** (cog icon) - Opens the Column Settings dialog
3. **Delete** (trash icon) - Removes the column from the layout

##### Resizing columns

![Resizing columns in the layout widget using the side handles](../images/layout-column-resize.png)

Columns can be resized horizontally using the drag handles that appear on the left and right edges of each column on hover:

1. **Hover over a column edge** - Resize handles appear at hover location
2. **Click and hold a handle** - The underlying grid structure becomes visible, showing column tracks and gaps
3. **Drag horizontally** - The column edge will snap to the nearest grid column line
4. **Release** - The column resizes to span the new width

**Resizing behavior:**
- Columns respect the configured `minSpan` setting (default: 2 columns)
- Columns cannot resize beyond the grid boundaries
- Columns can only be resized to the edge of adjacent columns
- The grid visualization disappears when you release the handle

**Visual feedback during resize:**
- Semi-transparent grid column indicators appear
- Gap indicators show the spacing between grid tracks
- The resizing column is highlighted
- Invalid resize positions are prevented automatically

##### Adding new columns

![When there is enough space, a plus will apper in the layout widget to allow addition of another column](../images/layout-add-column.png)

The layout widget intelligently detects when there's space available for a new column:

1. **Create space** - Resize existing columns or remove columns to create available space
2. **Watch for the plus icon** - When the available space equals or exceeds the `minSpan` setting, a plus icon (‚ûï) appears in the available space
3. **Click the plus icon** - A new column is added at the `defaultSpan` width
4. **Position the column** - Use the move handle to reposition if needed

**Column addition requirements:**
- Available space must be at least `minSpan` columns wide (default: 2 columns)
- New columns are created at `defaultSpan` width (default: 6 columns)
- Maximum number of columns is limited by the grid's total `columns` setting

##### Repositioning columns

![You can drag-and-drop the layout columns by directly interacting with the column or the drag icon](../images/layout-column-drag.png)

There are two methods for moving columns:

**Method 1: Body drag**

1. Click and hold anywhere on the column (except the move handle)
2. Drag the column over another column until it visually shifts
3. Release to exchange positions

**Method 2: Icon drag (drag via move handle)**

1. Click and hold the **move icon** in the upper-left corner
2. Drag the column to a new position
3. The grid visualization appears showing column tracks
4. Release to place the column

*Smart positioning behavior:*

When you drag over another column, the system intelligently decides whether to **nudge** or **swap**:

- **If there's enough grid space**: Adjacent columns are "nudged" over to make room for your column at the new position
- **If there isn't enough space**: Columns swap positions instead

> [!TIP]
> The swapping will occur when there is more than 40% overlap between the columns. This means that sometimes there will be more room to nudge the existing column, but the columns will swap anyway. If you want a column to nudge more than one or two grid columns, it is better to drag them separately.

This smart behavior means you don't have to worry about whether there's room - the layout automatically adapts:
- Dragging left or right with available space ‚Üí neighbors shift to accommodate
- Dragging when grid is tight ‚Üí clean position swap
- The grid visualization helps you see available space while dragging

##### Column Settings dialog

![The column settings dialog contains toggles and dropdowns for visibility and content orientation](../images/layout-column-settings.png)

When in Edit Columns mode, click the settings icon (cog) on any column to open the Column Settings dialog, which provides options for:

**Responsive visibility controls**

- **Show on Tablet** - Toggle to show or hide this column at tablet viewport widths (configurable, default: 1024px and below)
- **Show on Mobile** - Toggle to show or hide this column at mobile viewport widths (configurable, default: 600px and below)

*Responsive behavior notes:*
- Columns are automatically visible at desktop widths
- Tablet and mobile visibility are independent settings
- Hidden columns still exist in the content but are not rendered
- Use these settings to create responsive layouts that adapt to smaller screens

**Content alignment controls**

- **Horizontal Alignment (justify)** - Controls how content aligns horizontally within the column. Options: `start`, `end`, `center`, `stretch`. Default: `stretch` (or the widget's `defaultCellHorizontalAlignment` setting)
- **Vertical Alignment (align)** - Controls how content aligns vertically within the column. Options: `start`, `end`, `center`, `stretch`. Default: `stretch` (or the widget's `defaultCellVerticalAlignment` setting)

*Alignment behavior notes:*
- These settings apply to the column's content area, not the column itself
- `stretch` (default) makes content fill the available space
- Alignment is applied via CSS Grid's `justify-self` and `align-self` properties
- Changes preview in real-time as you adjust settings

##### Deleting columns

![The layout widget with the "Edit columns" button selected and the configuration icons displayed](../images/layout-column-editing.png)

To remove a column from the layout:

1. Click the trash icon in the upper-left corner of the column
2. Confirm the deletion if prompted
3. The column and all its content are removed
4. Adjacent columns are left untouched

> [!IMPORTANT]
> **Deleting a column also deletes all widgets within that column**. This action can be undone using **Ctrl/Cmd + Z**.

#### Keyboard shortcuts

While in Edit Columns mode, several keyboard shortcuts enhance your workflow:

- **Escape** - Close the Column Settings dialog
- **Ctrl/Cmd + Z** - Undo the last column operation (resize, move, add, delete)

### Basic configuration

The layout widget comes with sensible defaults but can be customized through various options:

<AposCodeBlock>

``` js
export default {
  modules: {
    '@apostrophecms/layout-widget': {
      options: {
        columns: 12,          // Total number of grid columns
        minSpan: 2,           // Minimum columns a cell can span
        defaultSpan: 6,       // Default span when adding new columns
        gap: '1.5rem',        // Gap between grid items
        mobile: {
          breakpoint: 600     // Mobile breakpoint in pixels
        },
        tablet: {
          breakpoint: 1024    // Tablet breakpoint in pixels
        },
        defaultCellHorizontalAlignment: null,  // Default horizontal alignment
        defaultCellVerticalAlignment: null     // Default vertical alignment
      }
    }
  }
};
```
<template v-slot:caption>
  app.js
</template>
</AposCodeBlock>

### Configuration options

| Option | Type | Default | Description |
| ------ | ---- | ------- | ----------- |
| `columns` | `Integer` | `12` | Total number of CSS grid columns in the grid template (minimum 2). This does not control how many layout-column widgets are added to the page. |
| `minSpan` | `Integer` | `2` | Minimum number of columns a cell can span |
| `defaultSpan` | `Integer` | `6` | Default number of columns for new cells |
| `gap` | `String` | `'1.5rem'` | CSS gap value between grid items |
| `mobile.breakpoint` | `Integer` | `600` | Mobile breakpoint in pixels |
| `tablet.breakpoint` | `Integer` | `1024` | Tablet breakpoint in pixels |
| `defaultCellHorizontalAlignment` | `String` | `null` | Default horizontal alignment (`'start'`, `'end'`, `'center'`, `'stretch'`) |
| `defaultCellVerticalAlignment` | `String` | `null` | Default vertical alignment (`'start'`, `'end'`, `'center'`, `'stretch'`) |
| `injectStyles` | `Boolean` | `true` | Automatically inject layout styles |
| `minifyStyles` | `Boolean` | `true` | Minify injected CSS |

> [!NOTE]
> The `columns` option defines the CSS grid template columns for layout calculations, not the number of layout-column widgets on the page. When a layout widget is first added, two layout-column widgets are created by default. Editors can add or remove columns in-context as needed. The `minSpan` option controls the minimum number of grid columns each layout-column widget can span.

### Configuring allowed widgets in columns

By default, layout columns contain the core rich text, image, and video widgets. You can customize this by extending the `@apostrophecms/layout-column-widget`:

<AposCodeBlock>

``` js
export default {
  fields: {
    add: {
      content: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {},
            '@apostrophecms/video': {},
            'custom-content': {}
          }
        }
      }
    }
  }
};
```
<template v-slot:caption>
  modules/@apostrophecms/layout-column-widget/index.js
</template>
</AposCodeBlock>


### Creating default layouts with pre-populated content

The layout widget works with the `def` field to create simple default page structures. This helps solve the "blank page" problem by providing editors with a starting layout containing pre-populated widgets.

>[!NOTE]
> The `def` feature is designed for **simple, consistent default layouts** that work well for all new documents of a particular type. For more sophisticated scenarios‚Äîsuch as offering editors a library of pre-designed sections to choose from‚Äîconsider using the [Section Template Library extension](https://apostrophecms.com/extensions/section-template-library), which provides a more powerful and flexible approach to reusable layouts.

#### Basic default layout structure

Default content for layout columns is configured in the layout column widget itself, not at the page level. This allows you to define what widgets appear inside each column when a layout is added:

<AposCodeBlock>

``` js
export default {
  extend: '@apostrophecms/layout-column-widget',
  fields: {
    add: {
      content: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {},
            '@apostrophecms/video': {}
          }
        },
        def: [
          ['@apostrophecms/image', '@apostrophecms/rich-text'],
          ['@apostrophecms/image']
        ]
      }
    }
  }
};
```

<template v-slot:caption>
  modules/@apostrophecms/layout-column-widget/index.js
</template>

</AposCodeBlock>

With this configuration, whenever a layout widget is added to a page, it will automatically create two columns (the default) with pre-populated content:
- **First column**: An image widget followed by a rich text widget
- **Second column**: A single image widget

#### Adding layout widgets by default to pages

You can also configure pages to start with a layout widget (or multiple widgets) by using `def` at the page level:

<AposCodeBlock>

``` js
export default {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Landing Page'
  },
  fields: {
    add: {
      content: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/layout': {},
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {}
          }
        },
        def: [
          '@apostrophecms/layout'
        ]
      }
    },
    group: {
      content: {
        label: 'Page content',
        fields: ['content']
      }
    }
  }
};
```

<template v-slot:caption>
  modules/landing-page/index.js
</template>

</AposCodeBlock>

This creates a new landing page with a layout widget already added. The layout widget will use the default column configuration from your `@apostrophecms/layout-column-widget` setup.

#### Creating complex default page structures

You can create more sophisticated default page layouts by combining different widgets in the page-level `def`:

<AposCodeBlock>

``` js
content: {
  type: 'area',
  options: {
    widgets: {
      '@apostrophecms/layout': {},
      '@apostrophecms/rich-text': {},
      '@apostrophecms/image': {}
    }
  },
  def: [
    '@apostrophecms/image',
    '@apostrophecms/layout',
    '@apostrophecms/rich-text',
    '@apostrophecms/layout'
  ]
}
```

<template v-slot:caption>
  modules/landing-page/index.js
</template>

</AposCodeBlock>

This creates a page with:
1. An image widget at the top
2. A layout widget (with its configured default columns)
3. A rich text widget
4. Another layout widget (with its configured default columns)

#### Using different layout widgets with different defaults

For even more control, you can create multiple layout widget types, each extending the base layout widget with different column configurations:

<AposCodeBlock>

``` js
// First layout widget type with specific defaults
export default {
  extend: '@apostrophecms/layout-widget',
  options: {
    label: 'Hero Layout',
    columns: 9,
    minSpan: 1,
    defaultSpan: 3
  }
};
```

<template v-slot:caption>
  modules/hero-layout-widget/index.js
</template>

</AposCodeBlock>

This will create a layout with 3 areas, each spanning 3 CSS grid columns.

<AposCodeBlock>

``` js
// Configure its column widget with specific defaults
export default {
  extend: '@apostrophecms/layout-column-widget',
  fields: {
    add: {
      content: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {}
          }
        },
        def: [
          ['@apostrophecms/image', '@apostrophecms/rich-text', '@apostrophecms/rich-text']
        ]
      }
    }
  }
};
```

<template v-slot:caption>
  modules/hero-layout-column-widget/index.js
</template>

</AposCodeBlock>

Then use different layout widget types on your page:

<AposCodeBlock>

``` js
content: {
  type: 'area',
  options: {
    widgets: {
      'hero-layout': {},
      '@apostrophecms/layout': {},
      '@apostrophecms/rich-text': {}
    }
  },
  def: [
    'hero-layout',
    '@apostrophecms/rich-text',
    '@apostrophecms/layout'
  ]
}
```

<template v-slot:caption>
  modules/landing-page/index.js
</template>
</AposCodeBlock>

This creates a page with three sections: a hero layout with specific column content, a rich text widget, and a standard layout widget with its own default column configuration.

#### How default layouts work

Understanding where to configure `def` is key:

1. **Layout column widget level** (`@apostrophecms/layout-column-widget/index.js`):
   - Configure `def` on the `content` area field
   - Defines what widgets appear inside columns when any layout widget is added
   - Uses nested arrays where each array represents one column
   - Column content can be a string (single widget) or an array (multiple widgets)

2. **Page/piece level** (e.g., `landing-page/index.js`):
   - Configure `def` on the page's area field
   - Defines which widgets appear when a new page/piece is created
   - Can include layout widgets, which will then use their configured column defaults
   - Can mix different widget types in sequence

>[!IMPORTANT]
> The number of columns created is determined by the layout widget's default configuration, typically 2 columns. If you provide more arrays in the column widget's `def` than the default number of columns, the extra arrays will be ignored.

>[!TIP]
> When configuring `def` in a layout column widget, make sure the widgets you include are also listed in the `options.widgets` configuration. Otherwise, editors won't be able to add additional widgets of those types later.

### Best practices for nested layouts

> [!IMPORTANT]
> **We do not recommend infinite nesting of layout widgets**. While it's technically possible to add layout widgets inside column content areas, this can lead to complex, difficult-to-maintain content structures and potential performance issues.

#### Recommended approach: Extend for nested layouts with controlled depth

Instead of allowing infinite nesting, the recommended pattern is to create a nested layout widget that uses custom column widgets which only allow content widgets (not additional layout widgets). This gives editors one level of nesting while preventing complexity:

First, create a custom column widget that only accepts content widgets:

<AposCodeBlock>

``` js
export default {
  extend: '@apostrophecms/layout-column-widget',
  options: {
    label: 'Nested Layout Column'
  },
  fields: {
      add: {
        content: {
          type: 'area',
          options: {
            widgets: {
              '@apostrophecms/rich-text': {},
              '@apostrophecms/image': {},
              '@apostrophecms/video': {},
              'custom-content': {}
            }
          }
        }
      }
    };
  }
};
```
<template v-slot:caption>
  modules/nested-layout-column-widget/index.js
</template>
</AposCodeBlock>

Then create a nested layout widget that uses these custom columns:

<AposCodeBlock>

``` js
export default {
  extend: '@apostrophecms/layout-widget',
  options: {
    label: 'Nested Layout',
    icon: 'view-grid-icon',
    columns: 6,
    minSpan: 1,
    defaultSpan: 2
  },
  fields: {
    add: {
      columns: {
        type: 'area',
        options: {
          widgets: {
            'nested-layout-column': {}
          }
        }
      }
    }
  }
};
```
<template v-slot:caption>
  modules/nested-layout-widget/index.js
</template>
</AposCodeBlock>

Finally, add this new `nested-layout-widget` to any areas, with or without the base `@apostrophecms/layout-widget` and other content widgets.

This pattern allows editors to use the main layout widget (12 columns) and place a nested layout widget (6 columns) inside it, but the nested layout's columns can only contain content widgets, preventing infinite nesting.

### Creating custom column widgets

You can also create custom column widgets that extend the base column widget with different content options or restrictions:

<AposCodeBlock>

``` js
export default {
  extend: '@apostrophecms/layout-column-widget',
  options: {
    label: 'Specialized Content Column'
  },
  fields: {
    add: {
      content: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {
              toolbar: [ 'bold', 'italic', 'link' ]
            }
          }
        }
      }
    }
  }
};
```
<template v-slot:caption>
  modules/specialized-content-column-widget/index.js
</template>
</AposCodeBlock>

Then configure your layout widget to use the custom column widget:

<AposCodeBlock>

``` js
export default {
  extend: '@apostrophecms/layout-widget',
  options: {
    label: 'Custom Layout'
  },
  fields: {
    add: {
      columns: {
        type: 'area',
        options: {
          widgets: {
            'nested-column': {},
            'specialized-content-column': {}
          }
        }
      }
    }
  }
};
```
<template v-slot:caption>
  modules/custom-layout-widget/index.js
</template>
</AposCodeBlock>

### Troubleshooting: content stretches, overlaps, or vanishes inside Layout

If a widget or custom component behaves strangely **only after** you place it in a Layout column (stretches to full height, overlaps content below, or disappears at some breakpoints), the cause is almost always legacy CSS inside that component, not the grid itself. CSS Grid‚Äôs default for items is `justify-self: stretch` and `align-self: stretch`. That‚Äôs normal ‚Äî and usually harmless ‚Äî unless a child has old percentage-height or positioning tricks.

#### Fast diagnosis

1. **Toggle alignment for just that cell**
   In **Edit Columns ‚Üí Column Settings**, set **Horizontal** and **Vertical** alignment to **start**. If the bug vanishes, your child had rules that don‚Äôt tolerate stretching. (You can keep ‚Äústart‚Äù for this one column or fix the child CSS.)

2. **Remove legacy percentage heights**
   In DevTools, look for `height: 100%`, or `min-height` with percentages on the component or its immediate wrappers. Delete them temporarily. If the bug disappears, replace those with modern equivalents (see below).

3. **Check positioning & overflow**
   Look for `position: absolute` without a positioned ancestor, `overflow: visible` paired with large negative margins, or `width: 100vw`. Any of these can jump outside a column and overlap neighbors.

### Common legacy patterns ‚Üí modern fixes

| Legacy pattern                                            | Why it breaks in grid                                                                                                | Safer modern replacement                                                                                                                                               |
| --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `height: XX%` on cards, iframes, wrappers | Percent heights need a *definite* parent height; grid columns are auto-height by default ‚Üí weird stretching/overflow | Remove it. Prefer `height: auto`. If you need aspect locking, use `aspect-ratio` (e.g. `aspect-ratio: 16/9`) or intrinsic sizing with `max-width: 100%; height: auto;` |
| ‚ÄúEqual height‚Äù hacks (from pre-grid times)                | Conflicts with grid‚Äôs track sizing & `stretch`                                                                       | Let the grid do its job. If you truly need equal heights, use consistent content or an explicit `min-height` in `px`/`rem`‚Äînot `%`                                     |
| `position: absolute` children                             | Without `position: relative` on the column content wrapper, they escape and overlap                                  | Add a positioned container: `.your-card { position: relative; } .your-card__badge { position: absolute; ‚Ä¶ }`                                                           |
| Full-viewport widths (`width: 100vw`)                     | Ignores grid gutters and column width ‚Üí overflow                                                                     | Use `width: 100%` within columns; the grid defines the width                                                                                                           |
| Sticky headers in a column                                | `align-self: stretch` makes sticky math weird; parent overflow can disable stickiness                                | Set `align-self: start` for the column‚Äôs content; ensure no `overflow` on the sticky ancestor                                                                          |
| Big negative margins                                      | Can visually overrun grid gaps/rows                                                                                  | Prefer padding on the parent, or use smaller translations with `transform`                                                                                             |

#### Quick CSS safety net (scoped)

If lots of legacy components are in play, add a minimal reset **scoped to your project‚Äôs card/components**, not to Apostrophe‚Äôs core classes:

```css
/* Example: scope to your design system cards */
.card, .tile, .widget-root {
  height: auto;
  min-height: 0;
  max-width: 100%;
  box-sizing: border-box;
}

.card img, .card video, .card iframe {
  max-width: 100%;
  height: auto;
}
```

> Tip: If just one column needs ‚Äúnon-stretch‚Äù behavior by default, open the column‚Äôs **Settings** and set **Horizontal/Vertical** alignment to **start** for that column only.

#### Project-level mitigation (defaults)

If you know many legacy widgets won‚Äôt like stretching, set Layout‚Äôs defaults to ‚Äústart‚Äù alignment project-wide:

```js
// app.js (or your module config)
export default {
  modules: {
    '@apostrophecms/layout-widget': {
      options: {
        // existing options‚Ä¶
        defaultCellHorizontalAlignment: 'start',
        defaultCellVerticalAlignment: 'start'
      }
    }
  }
};
```

This flips the default from `stretch` to `start`, while editors can still choose `stretch` per column when appropriate.

## Rich text widget

The rich text widget provides a space for entering and editing formatted text. Editors can update its content directly in-context.

<iframe width="560" height="315" src="https://www.youtube.com/embed/LmVOzjKW13s?si=P3NxaJTFqwUBxK5I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

There are many text formatting features that you can configure for rich text widgets. These editor options are configured in three widget options: [`toolbar`](#configuring-the-toolbar), [`styles`](#configuring-text-styles), and [`color`](#configuring-the-color-picker). Add these to the widget configuration object when adding an area field.

<AposCodeBlock>

``` js
fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {
              // üëá Toolbar configuration
              toolbar: ['styles', 'bold', 'italic', 'color'],
              // üëá Styles configuration
              styles: [
                {
                  tag: 'p',
                  label: 'Paragraph (P)'
                },
                {
                  tag: 'h2',
                  label: 'Heading 2 (H2)'
                }
              ],
              color: {
                presetColors: [ '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff']
              }
            }
          }
        }
      }
// remainder of fields
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>
</AposCodeBlock>

### Configuring the toolbar

To add formatting tools to the rich text toolbar, add their names to the `toolbar` array. The available formatting options include:

| Tool name | What is it? |
| --------- | ----------- |
| `'styles'` | A list of text styles, allowing different HTML tags and CSS classes (see ["Configuring text styles"](#configuring-text-styles) below) |
| `'color'` | Change text color (see ["Configuring the color picker"](#configuring-the-color-picker) below) |
| `'bold'` | Bold text |
| `'italic'` | Italicize text |
| `'strike'` | Strikethrough text |
| `'superscript'` | Superscript text |
| `'subscript'` | Subscript text |
| `'underline'` | Underline text |
| `'link'` | Add a link |
| `'anchor'` | Add an anchor id |
| `'horizontalRule'` | Add a visual horizontal rule |
| `'bulletList'` | Bulleted list |
| `'orderedList'` | Numbered list |
| `'blockquote'` | Block quote |
| `'codeBlock'` | Code block |
| `'alignLeft'` | Text Align Left |
| `'alignCenter'` | Text Align Center |
| `'alignRight'` | Text Align Right |
| `'alignJustify'` | Text Align Justify |
| `'importTable'` | Import a CSV file to be added as a table |
| `'image'` | Insert and edit images |
| `'undo'` | Undo the last change |
| `'redo'` | Redo the last undone change |
| `'\|'` | Add a visual separator to the toolbar (not a formatting action) |

<!-- TODO: Add a link to the how-to on adding your own tools when available. -->

### Configuring the insert menu

Note that the toolbar appears only when text is already selected. Some features, like
`table`, `importTable`, `image`, and `horizontalRule` should be available all the time because they insert entirely
new content unrelated to existing text.

To accommodate this, you can enable the "insert menu" as well:

``` js
// modules/@apostrophecms/home-page/index.js
// In area field configuration options
widgets: {
  '@apostrophecms/rich-text': {
    //  Toolbar configuration
    toolbar: ['styles', 'bold', 'italic', 'importTable', 'image'],
    // üëá Insert menu configuration
    insert: ['table', 'importTable', 'image', 'horizontalRule']
}
```

When you do so, the user receives a hint to press the `/` key at the start of any
line to open the insert menu.

Note that in this example, the table and image insert menu options appear on the toolbar as well.
This is because there are useful features included for editing *existing* tables and
images, not just inserting new ones.

### Configuring text styles

When you add the `'styles'` formatting tool, you can configure an array of text styles. These must include an HTML tag and a label for the menu interface. They may also include a CSS class.

A single style including class might look like:

```javascript
{
  label: 'Centered heading',
  tag: 'h2',
  class: 'centered'
}
```

You can use the same tag in several styles with various CSS classes.

> [!IMPORTANT]
> If you want the content manager to be able to remove a class, you will also have to add the same tag without a class to the style array.

::: info
Including a class with a style will not automatically apply any styles. You still need to [write your own CSS](/guide/front-end-assets.md) for the class.

Some tags will wrap the selected text, rather than converting the entire block to be enclosed in a specific tag. For example, selecting just a few words within a paragraph and applying a style using the span tag will surround the selected text with span tags configured with the configured class attribute(s).

In addition to the `span` tag, several other tags can wrap selected text without converting the entire block. These include `b`, `strong`, `code`, `mark`, `em`, `i`, `a`, `s`, `del`, `u`, `sup`, and `sub`. While the majority of these have dedicated toolbar buttons, you can also add them to the style menu if you want to apply a class when inserting them into the page.

Any of these wrapping-style tags added to the `styles` array will appear in a new `Apply styles` dropdown menu, separate from the dropdown for non-wrapping tags.

Adding to the toolbar styles:

``` js
{
  styles: [
    {
      tag: 'span',
      label: 'Highlight: Seafoam',
      class: 'highlight-seafoam'
    }
  ]
}
```
Adding to the stylesheet:

```css
.highlight-seafoam { color: #2e8b57; }
```

![Screenshot showing the addition of seafoam highlighting to text in the Rich Text Editor](../images/rich-text-style-dropdown.png)

### Configuring the color picker
If you choose to add the `color` button to the toolbar you can optionally pass in a `color` configuration object.

The `color` configuration is an extension of the color schema field and as such follows the same options API. [See the configuration here](/reference/field-types/color.html#options).

### Configuring the table editor
By default tables in rich text are configured with resizable (draggable) column widths, minimum cell widths, and other helpers.

```javascript
tableOptions: {
  resizable: true,
  handleWidth: 10,
  cellMinWidth: 100,
  lastColumnResizable: false,
  class: 'apos-rich-text-table'
}
```

::: info
To override the defaults you must provide a new configuration object **at the `@apostrophecms/rich-text-widget`** module level. These options **do not** merge.

#### Table editor options
| Property | Type | Default | What it does|
| --- | --- | --- | ------- |
| `resizable` | `Boolean` | `true` | Column widths are resizable (draggable) |
| `handleWidth` | `Integer` | `10` | The width of the resizable drag handle (in pixels) |
| `cellMinWidth` | `Integer` | `100` | The minimum width of a cell (in pixels) |
| `lastColumnResizable` | `Boolean` | `false` | Whether the last column of the table can be resized from the right side |
| `class` | `String` | `apos-rich-text-table` | Class applied to table element |

#### Custom table options example

<AposCodeBlock>

  ```js
  import apostrophe from 'apostrophe';

  apostrophe({
    modules: {
      '@apostrophecms/rich-text-widget': {
        options: {
          tableOptions: {
            resizable: false,
            class: 'my-table-class'
          }
        }
      }
    }
  });

  ```
  <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

### Default rich text configuration

```javascript
{
  toolbar: [
    'styles',
    '|',
    'bold',
    'italic',
    'strike',
    'underline',
    'subscript',
    'superscript',
    'blockquote',
    '|',
    'alignLeft',
    'alignCenter',
    'alignRight',
    'image',
    'horizontalRule',
    'link',
    'anchor',
    'bulletList',
    'orderedList',
    'color'
  ],
  styles: [
    // you may also use a `class` property with these
    {
      tag: 'p',
      label: 'apostrophe:richTextParagraph'
    },
    {
      tag: 'h1',
      label: 'apostrophe:richTextH1'
    },
    {
      tag: 'h2',
      label: 'apostrophe:richTextH2'
    },
    {
      tag: 'h3',
      label: 'apostrophe:richTextH3'
    },
    {
      tag: 'h4',
      label: 'apostrophe:richTextH4'
    },
    {
      tag: 'h5',
      label: 'apostrophe:richTextH5'
    },
    {
      tag: 'h6',
      label: 'apostrophe:richTextH6'
    }
  ],
  insert: [
    'image',
    'table',
    'importTable'
  ]
}
```

If you prefer, you can configure only one of the two sections (`toolbar` or `styles`), and keep the default configuration for the other.

**You can also set your own default** rich text options. Avoid adding the same options repeatedly by configuring these options on the `@apostrophecms/rich-text-widget` module.

<AposCodeBlock>

  ```javascript
  export default {
    options: {
      defaultOptions: {
        toolbar: [
          // Your default formatting tools
        ],
        styles: [
          // Your own default styles
        ],
        color: {
          // Your own default color picker options
        },
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/rich-text-widget/index.js
  </template>

</AposCodeBlock>

### Using Markdown in the Rich Text Widget
The rich text widget has limited support for using [Markdown syntax](https://www.markdownguide.org/cheat-sheet/). Heading styles can be selected by adding the same number of octothorpe ('#') as the heading level, followed by a space, and then the heading text. This will only work if you have that heading added into your `styles` dropdown. If you do not have a particular heading added to your `styles`, the next heading lower will be substituted. For example, if you have the `h2` tag added but not the `h1`, using `# My Title` will result in your title having `h2` tags. For the default rich text widget settings, headings `## H2`, `### H3`, and `#### H4` are defined.

Several other Markdown shortcuts are enabled by default, including double tilde (`~~ strikethrough~~`) for strikethrough and double asterisk (`**bold**`). See the table below for the entire list.


| Element | Syntax | Enabling |
| --- | --- | --- |
| `h1` | `# heading 1` | Must be defined in 'styles' |
| `h2` | `## heading 2` | Must be defined in 'styles' |
| `h3` | `## heading 3` | Must be defined in 'styles' |
| `h4` | `## heading 4` | Must be defined in 'styles' |
| `h5` | `## heading 5` | Must be defined in 'styles' |
| `h6` | `## heading 6` | Must be defined in 'styles' |
| `strong` | `**bold**` or `__bold__` | Default |
| `em` | `*italics*` or `_italics_`| Default |
| `blockquote` | `> blockquote` | Default |
| `ol` | `1. list item` | Default |
| `ul` | `* list item` | Default |
| `code` | \`code\` (single backticks)| Default |
| `s` | `~~strikethrough~~` | Default |
| `mark` | `==highlight==` | Default |
| `hr` | `---` | Default |

::: info
Spaces in the syntax between the symbol and any text in the table are required, e.g., `## heading`. Equally, a lack of space between symbols and any text is also required for proper formatting, e.g., `**bold**`.
### Configuring the `image` toolbar and insert menu option

If you choose to enable the `image` toolbar option, which allows images to
appear inline in text, you will usually want to also add it to the `insert` option so
that the user can easily insert a brand-new image without selecting text first.

In addition, you will likely want to configure the `imageStyles` option
of the `@apostrophecms/rich-text-widget` module, in order to specify CSS classes
the user is allowed to select for the image:

<AposCodeBlock>

  ```javascript
  export default {
    options: {
      imageStyles: [
        {
          value: 'image-float-left',
          label: 'Float Left'
        },
        {
          value: 'image-float-right',
          label: 'Float Right'
        },
        {
          value: 'image-float-center',
          label: 'Center'
        }
      ]
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/rich-text-widget/index.js
  </template>

</AposCodeBlock>

Apostrophe will apply the specified classes to a `figure` element that will contain an `img` element and a `figcaption` element. You can also choose to add a link to your image. Like text links, by default images can be linked to URLs or internal pages. See the [next section](#allowing-links-to-specific-piece-types) for expanding that capability to linking with specific piece-type show pages.
Note that writing CSS styles for those classes to suit your needs is up to you. `image-float-left` does not ship with Apostrophe,
it is just an example.

Inline images can be handy, especially for floating, but image widgets and custom widgets are generally more
flexible.

### Allowing links to specific piece-types

By default, the rich text widget allows you to add links to URLs or internal pages. The `linkWithType` option allows you to add links to any `piece-type` show page. Simply pass an array with the name of each desired `piece-type`. If you want to maintain linking to internal pages, also add `@apostrophecms/any-page-type` to your array. Note that you don't need to change this setting if you just want to link to the main index page for a piece type.

<AposCodeBlock>

``` javascript
export default {
  options: {
    linkWithType: [ '@apostrophecms/any-page-type', 'article' ]
  }
};
```

<template v-slot:caption>
  modules/@apostrophecms/rich-text-widget/index.js
</template>
</AposCodeBlock>

### Adding placeholder content

By default, the rich text widget displays placeholder content. To block this behavior, set the `placeholder` option to a value of `false`. To change the content, pass either a simple string or a string containing a namespaced i18n key, to the `placeholderText` option.

<AposCodeBlock>

``` js
export default {
  options: {
    placeholderText: 'myNamespace:placeholder'
  }
};

```

<template v-slot:caption>
modules/@apostrophecms/rich-text-widget/index.js
</template>
</AposCodeBlock>

<AposCodeBlock>

``` json
{
  "placeholder": "Add text here..."
}

```

<template v-slot:caption>
modules/@apostrophecms/rich-text-widget/i18n/myNamespace/en.json
</template>
</AposCodeBlock>


## Image widget

The image widget displays a single image with full caption and linking support. Images are wrapped in semantic figure elements, allowing you to add optional captions beneath each image. The widget also supports adding links to external URLs, internal pages, or any piece-type show page (using the [`linkWithType` option](#allowing-image-links-to-specific-piece-types)). Apostrophe automatically generates responsive image variants to optimize loading across different screen sizes.

<!-- TODO: Link to info about uploading media regarding multiple image versions, instead of explaining here, when available. -->

<AposCodeBlock>

``` js
fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/image': {}
          }
        }
      }
// remainder of fields
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>
</AposCodeBlock>

### Styling
By default, image widgets output a `figure` element with an optional `figcaption` when a caption is added. An inline style of `margin: 0` is applied to the `figure` by default to reduce unwanted spacing. If you prefer to handle all styling in your own CSS, you can disable the default inline styles by setting `inlineStyles: false` and adding your own `className` in the widget configuration, either in a project level module or per-area:

<AposCodeBlock>

``` js
export default {
  options: {
    inlineStyles: false,
    className: 'image-class'
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/image-widget/index.js
  </template>
</AposCodeBlock>

The `className` string will be appended with `__wrapper` on the `figure` element and `__caption` on the `figcaption` element.

### Specifying a minimum size

You can specify a minimum size for any image widget:

<AposCodeBlock>

``` js
// In area field configuration options
widgets: {
  '@apostrophecms/image': {
    minSize: [ 1000, 600 ]
  }
}
```
<template v-slot:caption>
  modules/@apostrophecms/home-page/index.js
</template>

</AposCodeBlock>

This widget won't allow the editor to select any image under 1000 pixels wide, or under 600 pixels tall. In addition, editors won't be able to crop the image smaller than that after selecting it for that particular widget.

### Specifying an aspect ratio

You can specify an aspect ratio for any image widget:

<AposCodeBlock>

``` js
// In area field configuration options
widgets: {
  '@apostrophecms/image': {
    aspectRatio: [ 3, 2 ]
  }
}
```
<template v-slot:caption>
  modules/@apostrophecms/home-page/index.js
</template>

</AposCodeBlock>

In some designs, especially slideshow experiences involving multiple images, allowing images with different aspect ratios just doesn't look good. For these cases, you can set an appropriate aspect ratio.

When you set an aspect ratio, editors can still select differently shaped images. However, if they save that selection without manually cropping it, the image is automatically cropped to match the ratio you set. If the editor does choose to manually crop it, the cropping interface ensures the aspect ratio you chose remains in effect.

### Taking advantage of the "focal point" feature

A fixed ratio for all devices doesn't work for all designs. If your responsive design features custom CSS with different ratios at different breakpoints, consider encouraging editors to use the focal point feature as an alternative to setting `minSize`. The image widget emits CSS that biases the browser toward ensuring that the editor's chosen focal point remains visible, regardless of device.

### Customizing responsive image sizes {#srcset}

<!-- TODO: link to attachment module srcset method when reference is available. -->
The image widget's default `srcset` attribute for responsive behavior assumes the image is roughly the same width as the viewport. This will help reduce download times even if the display size is smaller, but you can make responsive loading more accurate by providing [the `sizes` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#sizes) value.

This configuration is applied as a template option. In the template's `area` tag, include a `sizes` [context option](/guide/areas-and-widgets.md#passing-context-options) for the image widget. The option value should be the actual HTML attribute value.

``` nunjucks
{% area data.page, 'main' with {
  '@apostrophecms/image': {
    sizes: '(min-width: 600px) 45vw, (min-width: 1140px) 530px'
  }
} %}
```

See below for the image variant sizes that Apostrophe generates by default.

### Specifying the fallback size

Most browsers will use the responsive `srcset` attribute to find the right image file to display. Older browsers may need the static `src` attribute value. By default Apostrophe uses the `full` image variant, no larger than 1140px
by 1140px, for the `src` value.

You can change this in the area field widget options, using another image size name.

<AposCodeBlock>

``` js
// In area field configuration options
widgets: {
  '@apostrophecms/image': {
    size: 'one-half'
  }
}
```
<template v-slot:caption>
  modules/@apostrophecms/home-page/index.js
</template>

</AposCodeBlock>

The sizes available by default are:

| Name | Maximum width | Maximum height |
| ------ | ------ | ------ |
| `max` | 1600px | 1600px |
| `full` | 1140px | 1140px |
| `two-thirds` | 760px | 760px |
| `one-half` | 570px | 700px |
| `one-third` | 380px | 700px |
| `one-sixth` | 190px | 350px |

The final image size name is `original`, which delivers the original image file. This should be used carefully since it could be very large and slow to download.

You can also elect to change the default size for all image widgets by passing a named size to the `size` option in a project-level image widget configuration. This size will be overridden by a `size` set in the area widget configuration.

<AposCodeBlock>

``` js
export default {
  options: {
    size: 'one-half'
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/image-widget/index.js
</template>
</AposCodeBlock>

### Adding a `loading` attribute
You can elect to add a `loading` attribute to your image markup by passing the `loadingType` option to either the project-level image widget configuration or within the area widget configuration. This [attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#loading) can take values of `lazy` or `eager` to alter when the image is loaded onto the page. As with the `size` option, setting this option in the area widget configuration will override the value added to project-level options.

<AposCodeBlock>

``` javascript
export default {
  options: {
    loadingType: 'lazy'
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/image-widget/index.js
  </template>
</AposCodeBlock>

### Adding a placeholder image

The image widget displays a placeholder image by default. To block this behavior, set the `placeholder` option to a value of `false`.

Alternatively, the placeholder image can be changed for your project. For the image widget, the `placeholderImage` option takes **just the file extension,** like `png` (note no `.`). You must also copy a matching file to the `public` subdirectory of your project-level configuration of the module, e.g. copy that image to `/modules/@apostrophecms/image-widget/public/placeholder.png` (the name must be `placeholder` and the extension must match `placeholderImage`).

<AposCodeBlock>

``` js
export default {
  options: {
    // for a file named 'placeholder.png' in the module's project-level public folder
    placeholderImage: 'png'
  }
};
```

<template v-slot:caption>
/modules/@apostrophecms/image-widget/index.js
</template>
</AposCodeBlock>

### Specifying a custom URL to a placeholder image

While `placeholderImage` is usually the straightforward choice, sometimes more customization is desired. The `placeholderUrl` option supports Apostrophe asset paths as well as full URLs, making it easier to serve images kept in a particular module. If you do not wish to use the default filename, or wish to serve the image from a different location, this option gives you the flexibility to achieve that.

**For example:** if you wish to serve the file `special-placeholder.jpg` from your project-level `modules/@apostrophecms/image-widget/public` folder,
you can do that with the following configuration:

<AposCodeBlock>

``` js
export default {
  options: {
    // The "my-" prefix tells Apostrophe to use the project-level
    // folder, not the one in the core apostrophe module
    placeholderUrl: '/modules/@apostrophecms/my-image-widget/special-placeholder.jpg'
  }
}
```
<template v-slot:caption>
  modules/@apostrophecms/image-widget/index.js
</template>
</AposCodeBlock>

::: info
Note the `my-` prefix in `@apostrophecms/my-image-widget`. Without this
prefix, Apostrophe would look for the file in the core Apostrophe npm
module, and would not find it.

### Allowing image links to specific piece-types

By default, the image widget allows you to add links to URLs or internal pages. The `linkWithType` option allows you to add links to any `piece-type` show page. Simply pass an array with the name of each desired `piece-type`. If you want to maintain linking to internal pages, also add `@apostrophecms/any-page-type` to your array. Note that you don't need to change this setting if you just want to link to the main index page for a piece type.

<AposCodeBlock>

``` javascript
export default {
  options: {
    linkWithType: [ '@apostrophecms/any-page-type', 'article' ]
  }
};
```

<template v-slot:caption>
  modules/@apostrophecms/image-widget/index.js
</template>
</AposCodeBlock>

## Video widget

The core video widget accepts a video URL and fetches the embed code to display it. Most major video hosts are supported by default.

<!-- TODO: Link to the `allowList` option on the oembed module once module references are available. -->

<AposCodeBlock>

``` js
fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/video': {}
          }
        }
      }
// remainder of fields
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>
</AposCodeBlock>

### Adding a placeholder video

By default, the video widget displays a placeholder video. To block this behavior, set the `placeholder` option to a value of `false`. The default video can be changed by adding a hosted video URL string as the value of the `placeholderUrl` option. The video URL must be compatible with the video widget, e.g., a YouTube video page URL, Vimeo video page URL, etc.

<AposCodeBlock>

``` js
export default {
  options: {
    placeholderUrl: 'https://vimeo.com/375468729'
  }
};

```

<template v-slot:caption>
/modules/@apostrophecms/video-widget/index.js
</template>
</AposCodeBlock>

## File widget

The file widget allows content editors to select and display a downloadable file from the media library. When editors add this widget to a page, they can choose any file that has been uploaded to the `@apostrophecms/file` piece type, or upload and create a new file piece.

<AposCodeBlock>

``` js
fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/file': {}
          }
        }
      }
// remainder of fields
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>
</AposCodeBlock>

The widget uses a relationship field to connect to files in the media library. By default, it requires exactly one file to be selected before the widget can be saved.

### Customizing the file relationship

The file widget's relationship field can be configured using standard relationship field options. For example, you might want to allow multiple files or make the file selection optional:

<AposCodeBlock>

``` javascript
export default {
  fields: {
    add: {
      _file: {
        type: 'relationship',
        label: 'apostrophe:file',
        max: 3,
        required: true,
        withType: '@apostrophecms/file'
      }
    }
  }
};

```

<template v-slot:caption>
  modules/@apostrophecms/file-widget/index.js
</template>
</AposCodeBlock>

You can also modify other relationship field properties like `required`, though removing the requirement may result in an empty widget if no file is selected.


## HTML widget

**Or: How to get access to the editing interface when embedded HTML breaks it.**

The HTML widget allows content editors to embed raw HTML directly into a template. This can be helpful if they may need to add third-party features (e.g., sign-up forms). This can also be very dangerous since there are no limits to what they can add. Bad JavaScript in embedded HTML can break the user interface, making it impossible to remove the bad code.

<AposCodeBlock>

``` js
fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/html': {}
          }
        }
      }
// remainder of fields
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>
</AposCodeBlock>

>[!IMPORTANT]
> **Think carefully before providing this widget option to editors and make them aware of the risks.**

There is a safety mechanism in case things do go wrong. If embedded HTML breaks the Apostrophe interface, append the query parameter `safemode=1` to the end of the URL. The HTML widget will not render its contents and editors will be able to edit it to remove or fix the embed.

```
https://example.net/broken-page?safemode=1
```

To do that, access the page with `?safemode=1` at the end of the URL. Then you will be able to edit the widget and remove the offending content.


## Enabling real-time preview for widgets

The `preview` option allows widgets to update in real time as edits are made, giving editors immediate visual feedback. When enabled, the editing modal will intelligently position itself to avoid overlapping the widget.

### Global preview configuration

You can enable this feature globally for all widgets in your project:

<AposCodeBlock>

```javascript
export default {
  modules: {
    '@apostrophecms/widget-type': {
      options: {
        preview: true
      }
    }
  }
};
```
<template v-slot:caption>
  app.js
</template>
</AposCodeBlock>

### Widget-specific configuration

You can enable or disable this feature for individual widget types:

<AposCodeBlock>

```javascript
export default {
  modules: {
    '@apostrophecms/rich-text-widget': {
      options: {
        preview: true
      }
    }
  }
};
```
<template v-slot:caption>
  app.js
</template>
</AposCodeBlock>

When the preview option is enabled:
- Widgets update in real time as edits are made
- Previews will only update when all required fields and validation errors have been dealt with
- The editing modal will position itself to avoid overlapping the widget

## Setting a CSS class on core widgets

There are two options to set classes on core widgets. You can add a `className` option to **either the widget module or the widget options in an area field**. That value will be added to the outer-most HTML element in core widget templates. If both are set, the `className` property on the area configuration will be used.

Configuring on the module widget level:

<AposCodeBlock>

``` js
import apostrophe from 'apostrophe';

apostrophe ({
  root: import.meta,
  modules: {
    '@apostrophecms/video-widget': {
      options: {
        className: 'project-video-class'
      }
    }
  }
};
```
<template v-slot:caption>
  app.js
</template>

</AposCodeBlock>

Configuring on the area field widget options:

<AposCodeBlock>

``` js
export default {
  fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/video': {
              className: 'area-video-class'
            }
          }
        }
      }
    },
    // ...
  }
};
```
<template v-slot:caption>
modules/@apostrophecms/home-page/index.js
</template>

</AposCodeBlock>

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Areas and Widgets > Custom Widgets
DOC_PATH: guide/custom-widgets.md
URL: https://apostrophecms.com/docs/guide/custom-widgets
================================================================================
# Custom widgets

Creating new widget options in addition to the [core widgets](/guide/core-widgets.md) is crucial to getting the most from Apostrophe. Doing so allows developers to build the content *structure* a design requires while giving editors flexibility in how content will evolve over time.

## Creating a widget type

Adding a new widget type involves creating a new module that extends the `@apostrophecms/widget-type` module. It also requires a template to render the editor input. The module configuration file will include a [field schema](/guide/content-schema.md) with the appropriate fields.

We will use the example of a two column **"layout widget."** It is a fairly common and relatively simple use case that allows editors to visually align content in a row. This version of a layout widget consists of two areas next to one another. Each will allow either rich text and image widgets nested inside.

First create the module configuration file, extend the core widget type module, and add a widget label for editors. If you do not add a label, Apostrophe will attempt to generate one for the UI based on the module's name.

**The module's name must end in `-widget`.** It is a convention that supports core business logic around widgets and can help keep project code organized. This two-column widget is named `two-column-widget`.

::: tip
Generate the starter code using the [official CLI](/guide/development-setup.md#installing-the-apostrophe-cli) with the command:

```bash
apos add widget two-column
```

<AposCodeBlock>

``` js
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Two column'
  },
  // üëá The widget type's field schema
  fields: {
    add: {
      // üëá The first column area
      columnOne: {
        type: 'area',
        label: 'Column One',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {}
          }
        }
      },
      // üëá The second column area
      columnTwo: {
        type: 'area',
        label: 'Column Two',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {}
          }
        }
      }
    }
  }
};

```
<template v-slot:caption>
modules/two-column-widget/index.js
</template>

</AposCodeBlock>

You can then add this module to the `app.js` file to instantiate it.

<AposCodeBlock>

``` js
require('apostrophe')({
  shortName: 'my-website',
  modules: {
    'two-column-widget': {}
  }
});
```
<template v-slot:caption>
app.js
</template>

</AposCodeBlock>

In this example, we only have a limited number of schema fields, so we haven't added a `group` property. Much like with pieces or pages, the `group` property will allow you to organize your schema fields into groups. Like the other document types, the widget `group` property takes a named object for each tab, consisting of a label for the tab and `fields` property with an array of schema field names.

```js
fields: {
  add: {
    subtitle: {
      label: 'Subtitle',
      type: 'string'
    },
    author: {
    label: 'Author',
      type: 'string'
    },
    _article: {
      label: 'Article',
      type: 'relationship',
      withType: 'Article',
      builders: {
        project: {
          title: 1,
          _url: 1
        }
      }
    }
  },
  group: {
    content: {
      lable: 'Content',
      fields: [ '_article' ]
    },
    metadata: {
      label: 'Metadata',
      fields: [ 'subtitle', 'author' ]
    }
  }
}
```

Unlike the other document types, not adding a `group` property will not add an `ungrouped` tab. Instead, no tabs will be displayed. However, if you only add part of the fields to a group object, the ungrouped fields will be displayed on an `ungrouped` tab. If the number of tabs exceeds the width of the widget edit modal, additional tabs will be found in a context menu to the right of the displayed tabs and can be selected from there.

### Adding schema field placeholder content

Much like the core widgets, you can add placeholder content for many of the fields in your custom widgets. Within the widget options add `placeholder: true`. Then within individual fields add a `placeholder` property with a value appropriate to the type of schema field.

<AposCodeBlock>

``` js
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Custom Widget',
    icon: 'text-subject',
    placeholder: true,
    placeholderClass: 'my-custom-widget-placeholder'
  },
  fields: {
    add: {
      email: {
        type: 'email',
        placeholder: 'bob@email.com'
      },
      float: {
        type: 'float',
        placeholder: 0.05
      },
      integer: {
        type: 'integer',
        placeholder: 2
      },
      string: {
        type: 'string',
        placeholder: 'widget-with-placeholder placeholder'
      },
      url: {
        type: 'url',
        placeholder: 'https://example.com'
      }
    }
  }
};

```

<template v-slot:caption>
/modules/my-custom-widget/index.js
</template>
</AposCodeBlock>

This placeholder content will be present on the page when the widget is added. This content will never appear in the page preview. It will *only* appear on-page until you click Edit for that widget and save some real content. This data will also show up in the fields within the editor modal. The `placeholder` option can also be used to fill the editor modal fields with suggested content without also adding it to the page by setting it to `false`, but still adding placeholder content to each field.

::: info
If you set `placeholder: true` in the options and have either a `date` or `time` schema field, it will be populated with the current date/time on the page - not in the editor modal. Like the other fields, this content will not appear on the live page or in preview until you edit the widget and add actual content. It isn't possible to pass placeholder content into either of these fields.

The `placeholderClass` option can be used to add a class to the wrapper around the rendered display of the widget until it is edited for the first time.

### Disabling the initial editor modal
Even when placeholder content is not needed, for some types of custom widgets, it may be useful to disable the automatic opening of the editor modal when it is first added to the page. This is similar to the behavior when adding placeholder content. The content is added to the page, but the Editor has to open the modal manually. For example, a widget to display a variable number of products set by default to five items. The Editor would only open the modal if they wanted to change this amount. The `initialModal` option is set to `true` by default, so to prevent initial modal opening, set the value to `false`.

::: info
Adding `placeholder: true` in the options for a widget automatically sets `initialModal` to `false`. This can **not** be overridden by passing a `true` value.

# Server-Side Widget Validation

ApostropheCMS supports server-side validation for widgets with user-friendly error notifications. This feature allows you to enforce content rules and display helpful messages to editors when validation fails. This is only needed if you want to add custom validation in addition to the validation that ApostropheCMS already performs on schema field input and when a field is marked as `required`.

## Implementing Server-Side Validation

To add server-side validation to a widget, extend the `sanitize` method in your widget module:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  // other configuration...
  extendMethods(self) {
    return {
      async sanitize(_super, req, input, ...rest) {
        // First call the original sanitize method
        const sanitized = await _super(req, input, ...rest);

        // Add your validation logic
        if (sanitized.title?.toLowerCase().includes('invalid term')) {
          throw self.apos.error('invalid', 'Validation failed', {
            detail: 'This title contains terms that are not permitted. Please revise it.'
          });
        }
        
        return sanitized;
      }
    };
  }
};
```
  <template v-slot:caption>
    modules/my-widget/index.js
  </template>
</AposCodeBlock>

When throwing validation errors, use this format:

```javascript
throw self.apos.error('invalid', 'Technical error message', {
  detail: 'User-friendly message for the UI'
});
```

The `detail` property contains the message that will be displayed to the user. If omitted, the error message itself will be shown.

## How Validation Works

Server-side validation offers key benefits:

- Validation occurs on the server when the user clicks "Save"
- If validation fails, the save operation is interrupted
- An error notification appears with the user-friendly message
- The user is returned to the widget editor to correct the issue
- Invalid content is prevented from being saved to the database

During live preview, validation behaves differently:
- Preview pauses until the issue is fixed, without showing error messages
- Preview resumes automatically when the content becomes valid

This approach allows you to implement complex validation rules that can access the database or enforce business logic that cannot be handled client-side.

## Widget templates

Before using the new widget type, it needs a template file, `widget.html`, in the module's `views` directory. A simple template for the two column widget might look like:

<AposCodeBlock>

``` nunjucks
<section class="two-col">
  <div class="two-col__column">
    {% area data.widget, 'columnOne' %}
  </div>
  <div class="two-col__column">
    {% area data.widget, 'columnTwo' %}
  </div>
</section>
```
<template v-slot:caption>
modules/two-column-widget/views/widget.html
</template>
</AposCodeBlock>

**Widget field values are available on `data.widget` in templates.** [Context options](/guide/areas-and-widgets.md#passing-context-options) passed in are available on `data.contextOptions`.

::: info
Here are some two-column styles for people following along.

<AposCodeBlock>

```css
.two-col {
  display: flex;
  flex-flow: row wrap;
  width: 100%;
}

.two-col__column {
  display: flex;
  flex-direction: column;
  flex: 1;
}
```
<template v-slot:caption>
modules/two-column-widget/ui/src/index.scss
</template>
</AposCodeBlock>


## Client-side JavaScript for widgets

When adding client-side JavaScript for widget interaction, add a widget "player" to contain that code. The player will run only when the widget is used. It will also run when the editable area of the page is refreshed during editing.

We can use the example of a basic collapsible section widget, `collapse-widget` (also known as an "accordion" or "disclosure" widget). It will hide detail text until a user clicks the header/button.

::: tip
When using the [official CLI](/guide/development-setup.md#installing-the-apostrophe-cli) to create a widget type, include widget player starter code with the `--player` option.

```bash
apos add widget collapse --player
```

::: details Example collapsible widget code
**Module configuration**

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Collapsible section'
  },
  fields: {
    add: {
      heading: {
        type: 'string',
        required: true
      },
      detail: {
        type: 'string',
        required: true,
        textarea: true
      }
    }
  }
};
```
<template v-slot:caption>
modules/collapse-widget/index.js
</template>
</AposCodeBlock>

**Module template**
<AposCodeBlock>

``` nunjucks
<section data-collapser class="collapser">
  <h2>
    <button data-collapser-button aria-expanded="false">
      {{ data.widget.heading }}
    </button>
  </h2>
  <div hidden data-collapser-detail>
    {# `nlbr` and `safe` are core Nunjucks tag filters #}
    {{ data.widget.detail | nlbr | safe }}
  </div>
</section>
```
<template v-slot:caption>
modules/collapse-widget/views/widget.html
</template>
</AposCodeBlock>

**Module styles** (see [front end assets guide](/guide/front-end-assets.md))

```css
.collapser__detail {
  display: none;

  &.is-active {
    display: block;
  }
}
```

Widget player code can be added in any module's `ui/src/index.js` file, or a file imported by it. In this example it would be in `modules/collapse-widget/ui/src/index.js`.

The player code is added to an object of widget players, `apos.util.widgetPlayers` using the widget's name, excluding the `-widget` suffix. It is an object with two properties:

| Property | Description |
| -------- | ----------- |
| `selector` | A string selector for the player to find the widget as you would use in [`document.querySelector`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector). |
| `player` | A function that takes the matching widget DOM element as an argument. |

<AposCodeBlock>

```javascript
export default () => {
  apos.util.widgetPlayers.collapser = {
    selector: '[data-collapser]',
    player: function (el) {
      // ...
    }
  };
};
```
<template v-slot:caption>
modules/collapse-widget/ui/src/index.js
</template>
</AposCodeBlock>

With some code to manage showing and hiding the detail, it would look like:
<AposCodeBlock>

```javascript
export default () => {
  apos.util.widgetPlayers.accordion = {
    selector: '[data-collapser]',
    player: function (el) {
      // Find our button
      const btn = el.querySelector('[data-collapser-button]');
      // Find our hidden text
      const target = el.querySelector('[data-collapser-detail]');

      btn.onclick = () => {
        const expanded = btn.getAttribute('aria-expanded') === 'true';
        // Update the button's aria attribute
        btn.setAttribute('aria-expanded', !expanded);
        // Update the `hidden` attribute on the detail
        target.hidden = expanded;
      };
    }
  };
};
```
<template v-slot:caption>
modules/collapse-widget/ui/src/index.js
</template>
</AposCodeBlock>

[Credit goes to Heydon Pickering](https://inclusive-components.design/collapsible-sections/) for the accessible collapsible example.

### Using widget data in players

Widget players do not have direct access to any *widget data*. If we want to use widget data in the player, we need to pass it in.

Template files on the other hand, *do* have access to widget data (they are rendered on the server). One good way to use data in a widget player is to insert it as a data attribute value in the template. The player can then look for that data attribute.

For example, we could change our collapse widget to include a `color` field value:

<AposCodeBlock>

``` nunjucks
<section data-collapser data-color="{{ data.widget.color }}" class="collapser">
  {# The rest of the code is the same... #}
</section>
```
<template v-slot:caption>
modules/collapse-widget/views/widget.html
</template>
</AposCodeBlock>

We've added the `data-color` attribute to the widget wrapper with our color data. Then in the player code we could get the value with the wrapper element's `dataset` property.

<AposCodeBlock>

```javascript
export default () => {
  apos.util.widgetPlayers.accordion = {
    selector: '[data-collapser]',
    player: function (el) {
      const color = el.dataset.color || 'purple'
      // The rest of the code is the same...
    }
  };
};
```
<template v-slot:caption>
modules/collapse-widget/views/widget.html
</template>
</AposCodeBlock>

The player *does* have access to the widget's wrapping element, so we use `el.dataset.color` to access the color data we stored on `data-color`.

::: tip
We can pass a string, number, or boolean value with a data attribute using the method shown above. If the value we need to use in the widget player is an array or object, it will need to become a properly escaped string first. Use the `jsonAttribute` template filter to do this.

``` nunjucks
<div data-config="{{ data.piece.someObjectOrArray | jsonAttribute }}"></div>
```

The value will be converted to a JSON string and escaped. The original value can be retrieved in the player with `JSON.parse`.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Templating > Working with Templates
DOC_PATH: guide/templating.md
URL: https://apostrophecms.com/docs/guide/templating
================================================================================
# Working with templates

Templates are where code and content turn into web pages people can actually see and use. Apostrophe templates use the Nunjucks templating language and generally look like normal HTML markup with special tags and variables sprinkled throughout to render data.

Template files go in `views` directories, either as module subdirectories or at the project root.

![Screenshot of a file directory highlighting a default-page module views directory and the global views directory](/images/templating-views-dirs.jpg)

The root `views` directory will usually contain [a layout template](/guide/layout-template.md) and often [fragment templates](/guide/fragments.md). Templates in modules' `views` directories will usually be used only for their respective modules. [Widget](/guide/custom-widgets.md#widget-templates), [page](/guide/pages.md#page-template-essentials), and [piece page](/guide/piece-pages.md#the-index-page-template) templates are the main examples of that.

## How templates work together

To paraphrase [John Donne](https://en.wikipedia.org/wiki/John_Donne), no template is an island. Templates will always be used as a system. We do this with the **`extends`**, **`include`**, and **[`import`](/guide/fragments.md)** tags.

### Extending templates

When you use the `{% extends %}` tag in a template, it will inherit all of the markup and template blocks of the template it is extending. Any template blocks used in the *extending* template will replace matching blocks in the *extended* template.

For example, the layout template will often be structured like this:

``` nunjucks
{# views/layout.html #}
{% extends data.outerLayout %}

{% block beforeMain %}
  {# Page header markup and the main content area opening tag... #}
{% endblock %}

{% block main %}{% endblock %}

{% block afterMain %}
  {# The main content area closing tag and page footer... #}
{% endblock %}
```

Individual page type templates will extend that layout:

<AposCodeBlock>

``` nunjucks
{% extends "layout.html" %}{# üëà Our template extension #}

{% block main %}
  {% area data.page, 'mainContent' %}
{% endblock %}
```
<template v-slot:caption>
modules/default-page/views/page.html
</template>
</AposCodeBlock>

`page.html` *inherits* all of the markup and template blocks of `layout.html`. When it uses the `main` block, that *replaces* only the matching block from `layout.html`.

::: info
You may have noticed that the layout template above also extends another template. `data.outerLayout` is a core, base level template. See the [layout template](/guide/layout-template.md) guide for more on that.

#### The `super()` tag

**You can also *add to* template block content, rather than completely replace it.** To do this, include a `super()` render tag at the beginning of a block. `super()` will render as the contents of the inherited block.

For example, this may be in your layout file:

<AposCodeBlock>

``` nunjucks
{% block main %}
<h1>{{ data.piece.title or data.page.title }}</h1>
{% endblock main %}
```
<template v-slot:caption>
modules/default-page/views/page.html
</template>
</AposCodeBlock>

In my home page template I could extend the layout template and use `super()` to include that `h1` tag before new content markup:

<AposCodeBlock>

``` nunjucks
{% block main %}
  {{ super() }} {# üëà That will render the <h1> tag above #}
  <div>
    {# ... additional home page content #}
  </div>
{% endblock %}
```
<template v-slot:caption>
modules/@apostrophecms/home-page/views/page.html
</template>
</AposCodeBlock>

See another example [in the Nunjucks documentation](https://mozilla.github.io/nunjucks/templating.html#template-inheritance).

### Including templates

The `{% include %}` template tag pulls one template *into* another template. This can be useful to break large template files into pieces. For example, you might write your site footer in a template file: `views/footer.html`. The layout template could include that like so:

<AposCodeBlock>

``` nunjucks
{% block afterMain %}
  </main> {# Closing tag for the main block #}
  {% include "footer.html" %}
{% endblock %}
```
<template v-slot:caption>
views/layout.html
</template>
</AposCodeBlock>

That footer template would render as part of the layout template.

See more about including templates [in the Nunjucks documentation](https://mozilla.github.io/nunjucks/templating.html#include).

### Referencing templates across modules

The `include` and `extends` tags in the examples above name "global templates," which are in the root `views` directory. As such, we can simply reference by file name: e.g., `{% extends "layout.html" %}` or `{% include "footer.html" %}`. You could do the same thing if both templates were in the *same* module directory (both in our `modules/default-page/views` directory).

In some cases, **we will need to extend or include a template file that belongs to a separate module**. In that case, we need to provide additional information so Apostrophe can find that template.

For example, we may have a default page type that includes a sidebar we want to use in other page types:

<AposCodeBlock>

``` nunjucks
{% extends "layout.html" %}

{% block main %}
  {# üëá Sidebar that we'll reuse. #}
  <aside>
    {# Sidebar content... #}
  <aside />
  {# üëá Content area that we'll replace. #}
  {% block content %}
    {% area data.page, 'main' %}
  {% endblock %}
{% endblock %}
```
<template v-slot:caption>
modules/default-page/views/page.html
</template>
</AposCodeBlock>

Let's extend it in a contact page type to reuse that sidebar. We will only replace the `content` block. To do this, the `{% extend %}` tag must include the name of the default page module:

``` nunjucks
{% extends "default-page:page.html" %}

{% block content %}
  <h1>Contact info</h1>
  {# Contact information... #}
{% endblock %}
```

`{% extends "default-page:page.html" %}` tells Apostrophe that we are using the `page.html` template file that belongs to the `default-page` module. The same pattern applies when using the `include` tag.

::: tip
The Nunjucks templating language includes many tags and tools you can use in Apostrophe templates. These include:

- Adding conditional checks
- Looping over arrays
- Declaring variables
- Comparison and math operators

See the official [Nunjucks templating documentation](https://mozilla.github.io/nunjucks/templating.html) to see what is available.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Templating > Layout Templates
DOC_PATH: guide/layout-template.md
URL: https://apostrophecms.com/docs/guide/layout-template
================================================================================
# Layout templates

A layout template is common in most Apostrophe apps. As the name suggests, it **contains the markup that surrounds page content and is mostly consistent across the website**. Website navigation and footers are both usually in the layout template, whether directly as markup or included from template partials.

**Let's look at a simple layout template file at `views/layout.html`.**

<AposCodeBlock>

``` nunjucks
{% extends data.outerLayout %}{# üëà Extending outerLayout.html from core #}

{# üëá Inserting markup into a lower level template block #}
{% block beforeMain %}
<div>{# Open page wrapper #}
  <header>
    <img src="/images/logo.png" alt="Organization logo">
    <nav>{# Website navigation #}</nav>
    {% if not data.user %}<a href="/login">Login</a>{% endif %}
  </header>
  <main>{# Open main tag #}
{% endblock %}

{% block afterMain %}
  </main>{# Close main tag #}
  <footer class="bp-footer">
    <p>
      ¬© Apostrophe Technology, Inc.
    </p>
  </footer>
</div>{# Close page wrapper #}
{% endblock %}
```
<template v-slot:caption>
views/layout.html
</template>
</AposCodeBlock>

You might notice is that this does not have essential web page elements such as a `head` or `body` tag. That is because the first thing this template does is extend another template:

``` nunjucks
{% extends data.outerLayout %}
```

`data.outerLayout` is a reference to a lower level layout template from Apostrophe core that includes those critical HTML elements, markup required by Apostrophe, and the template block structure that project-level templates use. **The lowest-level templates in any project should extend this.** ([See that file on Github](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/template/views/outerLayoutBase.html) if you're interested.)

This layout template then includes two template blocks, **`beforeMain` and `afterMain`**, containing markup that wraps most page content.

``` nunjucks
{% block beforeMain %}
  {# Page opening markup... #}
{% endblock %}

{% block afterMain %}
  {# Page ending markup... #}
{% endblock %}
```

These two are before and after the `main` block in the base layout template linked above. By using them in `views/layout.html`, they override the matching blocks in the extended template. They are great places to put the site navigation, site footer, and other markup that should always wrap the main content of the page.

The most important templates blocks from that core layout template are:

| Template block name | What is it? |
| ------------------- | ----------- |
| `startHead` | A block at the beginning of the `head` tag for inserting metadata tags. |
| `title` | The contents of the `title` tag. This defaults to using the title of the page or piece (for [show pages](/guide/piece-pages.md#the-show-page-template)). |
| `extraHead` | A block at the end of the `head` tag for inserting metadata tags. |
| `bodyClass` | A block in the `body` tag's `class` attribute for adding a class for when that template is used. |
| `beforeMain` | A block before the `main` content block. Usually used for the website header. |
| `main` | The primary block for page content. Most page template markup goes inside `main`. |
| `afterMain` | A block after the `main` content block. Usually used for the website footer. |
| `extraBody` | A block at the end of the `body` tag. |

The layout template and any page, index page, or show page template could use these blocks to overwrite them or add to them ([using the `super()` tag](/guide/templating.md#the-super-tag)).

::: info NOTES
The `beforeMain`, `main`, and `afterMain` blocks are inside the section that Apostrophe refreshes regularly during content editing. Any `script` tags inside those blocks will run an indeterminate number of times during editing. Be especially careful when using event handlers. As a reminder, any widget-related JavaScript belongs in a [widget player](/guide/custom-widgets.md#client-side-javascript-for-widgets).

`layout.html` is a naming convention in Apostrophe, but is not a required file name. You can name it anything you like. Just remember to  extend `data.outerLayout` and update page templates to extend it by its new name.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Templating > Template Data
DOC_PATH: guide/template-data.md
URL: https://apostrophecms.com/docs/guide/template-data
================================================================================
# Template data

All Apostrophe template files have access to a `data` object. It contains content data as well as additional information such as the page's URL and the active user. Some properties differ depending on the template type (e.g., `data.widget` is only available in widget templates).

The table below lists the data properties available from Apostrophe core as well as the template types where they are available.

::: info
**Template type indicators:**
- <AposTag text="All pages"/>: The property is present in all page templates, including piece index pages and show pages.
- <AposTag text="Show pages" :tagStyle="0"/>: The property is present in piece show page templates and not in other normal page templates.
- <AposTag text="Widgets" :tagStyle="1"/>: The property is present in widget templates.
| Property | Description | Templates where present |
|----------|-------------|----------------|
| `absoluteUrl` | The complete URL currently displayed, including base URL (with prefix, if set) and query parameters. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `aposBodyDataAttributes` | A string of JSON that Apostrophe applies to the `body` tag as data attributes. Used by the UI app. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `baseUrl` | The site's configured `baseUrl` value. Typically the website's domain. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `baseUrlWithPrefix` | The `baseUrl` value, plus the site's `prefix` value, if set. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `bestPage` | Usually the same as `data.page`. If no page is found for the URL (e.g., a 404 page) it will be the data object for the page that best matches the slug, going back to the home page. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `contextOptions` | An object of [context options](/guide/areas-and-widgets.md#passing-context-options), if passed in.| <AposTag text="Widgets" :tagStyle="1"/> |
| `edit` | An alias of `data.bestPage._edit`, indicating whether the active user has editing permissions for the `data.bestPage` document. | <AposTag text="All pages"/>|
| `global` | The data object for the global doc. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `home` | The data object for the home page. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `locale` | The active locale.| <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `localizations` | An array of active locales including information about the active page in each.| <AposTag text="All pages"/> |
| `manager` | In widget templates, the widget module manager object. | <AposTag text="Widgets" :tagStyle="1"/> |
| `next` | If [`next: true` is set on the piece page type](/reference/module-api/module-options.md#next), the data object for the next piece in sort order. | <AposTag text="Show pages" :tagStyle="0"/> |
| `options` | | <AposTag text="Widgets" :tagStyle="1"/> |
| `outerLayout` | A reference path to the outer layout template. Used in [layout templates](/guide/layout-template.md). | <AposTag text="All pages"/> |
| `page` | A data object for the active page *or* the index page in show page templates. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `piece` | The piece data object in a show page template. | <AposTag text="Show pages" :tagStyle="0"/> |
| `previous` | If [`previous: true` is set on the piece page type](/reference/module-api/module-options.md#previous), the data object for the previous piece in sort order. | <AposTag text="Show pages" :tagStyle="0"/> |
| `query` | An object of query parameters from the request URL. | <AposTag text="All pages"/> |
| `scene` | A string indicating the active "scene," or general user context. Either `'public'` or `'apos'`. | <AposTag text="All pages"/> |
| `slug` | The active page's slug. | <AposTag text="All pages"/> |
| `url` | The active page's full relative URL, including query parameters. | <AposTag text="All pages"/> |
| `user` | When a user is logged in, a data object for the active user. `null` if logged out. | <AposTag text="All pages"/> <AposTag text="Widgets" :tagStyle="1"/> |
| `widget` | The widget data object in a widget template. | <AposTag text="Widgets" :tagStyle="1"/> |
<!-- TODO: Update `locale` with a link to localization info when available. -->

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Templating > Template Filters
DOC_PATH: guide/template-filters.md
URL: https://apostrophecms.com/docs/guide/template-filters
================================================================================
# Template filters

## Nunjucks supplied filters

The Nunjucks templating language comes with several [built-in filters](https://mozilla.github.io/nunjucks/templating.html#filters). These filters apply functions to template data before outputting content to the page. They are called with a pipe operator `|` and can take arguments.

<AposCodeBlock>

``` nunjucks
<h1>{{ data.page.headline | replace("foo", "bar" ) | upper }}</h1>
```
</AposCodeBlock>

In this example, a hypothetical page headline will be retrieved from the page data and then piped to the 'replace' filter, along with two arguments. This filter will scan the incoming data and replace any instances of ‚Äòfoo‚Äô with 'bar'. The output of this filter will then pass the result to the upper function, which will return the input as an uppercase string before being output to the page.

::: info

The order of filters can be significant, as they are applied sequentially to the input data.


## Apostrophe supplied filters

Several custom filters and filter sets (multiple, sequential filters) are used in Apostrophe templating. Rather than remembering each filter and the correct order, apostrophe exposes them automatically to the templates. In addition, Apostrophe also adds multiple "helper functions" which do not use the `| foo` filter syntax. The most common of these are described in the [alphabetical filter reference](/guide/template-filters.html#alphabetical-apostrophe-filter-reference).

## Custom template filters

If you have special template needs you can also construct custom filters for use in Nunjucks templates. They can be added by passing the filter name and function to the template module `addFilter(name, function)` method. Multiple filters can be added by passing an object to this same method, where each key is the name of the filter and the value is the function.

By way of example, we'll create a link where the URL is included as part of the label, but without the protocol.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Link to a Page'
  },
  fields: {
    add: {
      url: {
        type: 'url',
        label: 'URL',
        required: true
      },
      label: {
        type: 'string',
        label: 'Label',
        required: true
      }
    },
    group: {
      links: {
        label: 'Links',
        fields: [ 'url', 'label' ]
      }
    }
  },
  init(self) {
    self.apos.template.addFilter({
      stripHttp: self.stripHttp
    });
  },
  methods(self) {
    return {
      stripHttp(s) {
        return s.replace(/^(https?:|)\/\//, '');
      }
    };
  }
};
```
<template v-slot:caption>
  lib/modules/link-widgets/index.js
</template>
</AposCodeBlock>

Within the `methods`, we create a function `stripHttp()` that takes a string from the template. It performs a RegExp replace to strip the protocol before returning the string.

In `init()`, we pass our function to the template module using `self.apos.template.addFilter({})`. This method takes the name of the filter that will be used in the template as property - in this case `stripHttp` - and our new function as a value.

To use this new filter you would simply pipe your data to the filter from within the template.

<AposCodeBlock>

  ``` nunjucks
  <section data-link-widget>
    <a href="{{ data.widget.url }}">{{ data.widget.label }}: {{ data.widget.url | stripHttp }}</a>
  </section>
  ```
  <template v-slot:caption>
    lib/modules/link-widgets/views/widget.html
  </template>
</AposCodeBlock>

## Alphabetical Apostrophe filter reference

### `| build(url, path, data...)`

This filter can add path and query string parameters to the passed URL. This is very useful for adding filters to the current URL, respecting other filters already present, without complicated logic.
The method in the `url` module requires that the URL be passed in as the first argument. However, when using this as a filter in Nunjucks, the data before the pipe will be sent as the first argument. This parameter accepts a URL that can include query parameters and anchor tags.

The `path` parameter accepts an array but is optional. If present, it allows the addition of additional path elements to the URL. The array strings are not added directly to the URL but are substituted with values from the `data` object. So, with a `path` array of `['one', 'two']` and a `data` object of `{ one: 'first', two: 'second'}` the URL `https://example.com` would be modified to `https://example.com/first/second`. The path elements will be added in the order they appear in the `path` array.

The `data` parameter can accept multiple, comma-separated objects. The objects will be considered sequentially, so if duplicate keys are passed, the value will be assigned from the last passed object. As outlined for `path`, these objects can be key:value pairs that add new path elements. If the key does not match any element in the `path` array, it will be added to the URL as a query parameter. Continuing with the example URL from above, passing a `data` object of `{ id: 1010 }` would result in a filtered URL of `https://example.com?id=1010`. If the query parameter already exists in the URL, the value will be changed to the value in the `data` object. Passing values of `null`, `undefined`, or an empty string will remove the query parameter.

If the `data` object contains a key that matches a string in the `path` array and has an invalid path value, e.g. `null`, or is not slug safe, all path processing will stop. Any additional `data` key:value pairs will be added as query parameters even if they match a `path` array value.

Since passing a parameter of the same name as an existing query parameter will replace the value, building an array property for a query requires MongoDB-style operators. If an array doesn‚Äôt already exist, the `$addToSet` operator will create it and add a value. Otherwise, it will simply add the value.

`{ colors: { $addToSet: ‚Äòblue‚Äô } }`

To remove values from an existing array use the `$pull` operator:

`{ colors: { $pull: ‚Äòblue‚Äô } }`

### `| clonePermanent`

Given JavaScript data, this filter recursively strips out any properties whose names begin with a `_`, except `_id`. This is used to avoid pushing large related documents into the DOM, keeping markup size down. This filter is usually followed by either the `json` or `jsonAttribute` filters.

### `| css`

Converts a string from other formats, such as underscore or camelCase to a kebab-case CSS identifier. For instance, `fooBar` becomes `foo-bar`.

### `| date(format)`

Turns a JavaScript Date object into a string, as specified by `format`. For formatting options, see the documentation of the `dayjs` npm module.

### `| json`

Turns JavaScript data into a JSON string, **correctly escaped for safe use inside a** `script` **tag in the middle of an HTML document.** Note that it is **not** safe to use the Nunjucks `dump` filter in this way. This filter is not for attributes; see `jsonAttribute`.

### `| jsonAttribute(options)`

Given JavaScript data, this filter escapes it correctly to be the value of a `data-` attribute of an element in the page. It does not add the `"` quote characters around the attribute itself, but it does escape any `"` characters in the JSON string.

`options` may be omitted. If `options.single` is truthy, single-quotes are escaped instead, and you must use `'` (single quotes) to quote the attribute. This saves space and is more readable in "view page source."

**If this filter is applied to anything other than an object or array**, the value is converted to a string and output literally, without quotes. This is done for compatibility with jQuery's `data` method, which only parses JSON when it sees `{}` or `[]` syntax, and otherwise returns the value directly as a string. If you don't like this, only pass objects to this filter.

### `| merge(object2, object3...)`

When applied to an object, this filter "merges in" the properties of any additional objects given to it as arguments. Note that this is not a recursive merge. If two objects contain the same property, the last object wins.

### `| nlbr`

Converts newlines found in a string into `<br />` tags. The incoming string is escaped from any HTML markup. After converting the newlines into breaks, the string is passed through the `|safe` filter before returning it.

### `| nlp`

Breaks a string into `<p>...</p>` elements, based on newlines. Like the `| nlbr` filter, the incoming string is escaped and passed back as safe.

### `| query`

Turns an object into a query string. This filter uses the stringify method of the npm (‚Äòqs‚Äô package)[https://www.npmjs.com/package/qs]. See also `build`.

### `| safe`

The `| safe` filter marks any passed value as safe for direct output on the page. This filter is built into Nunjucks but merits special mention. Data passed from Apostrophe into templates is automatically escaped. Thus, there is no need for the `| escape` (aliased as `| e`) filter. However, if you want to bypass this behavior, you must pass any data through the `| safe` filter. This should be used with caution as this could allow the Editor to pass HTML breaking code onto the page.

### `| striptags`

Strips HTML tags from a string, leaving only the content inside the tags.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Templating > Template Fragments
DOC_PATH: guide/fragments.md
URL: https://apostrophecms.com/docs/guide/fragments
================================================================================
# Template fragments

We will often find that template code is reused across multiple files or that it simply gets overly complicated for a single file. **Template fragments** help solve this by splitting template code into smaller, managable pieces that can be used in other templates.

::: info
If you are already familiar with the [Nunjucks macro](https://mozilla.github.io/nunjucks/templating.html#macro) feature, fragments are very similar. Fragments are a new feature specific to Apostrophe to support asynchronous template tags, such as the [area](/guide/areas-and-widgets.md#adding-areas-to-templates) tag and [async components](/guide/async-components.md). If the code does *not* use either async components or areas, macros are also fine to use.

The only macros feature currently unavailable or unreplaced for fragments is passing the template context using `with context`. This is planned for fragments as well.

## Using fragments

We define fragments by putting template markup between `{% fragment %}` and `{% endfragment %}` tags. The opening tag should also include a name for the fragment.

``` nunjucks
{% fragment heading() %}
  <h2>This is a heading fragment</h2>
{% endfragment %}
```

To use the fragment in a template, reference it by name using the `{% render %}` tag:

``` nunjucks
{% render heading() %}
{# Renders: `<h2>This is a heading fragment</h2>` #}
```

We can also pass arguments to fragments, allowing us to reuse them across templates with different data.

``` nunjucks
{% fragment heading(adjective) %}
  <h2>This is a {{ adjective }} fragment</h2>
{% endfragment %}

{# üëá Passing in a string argument #}
{% render heading('cool') %}
```

Fragment arguments can be any data or template variables understood by Apostrophe templates (e.g., strings, objects, arrays, etc.). It can often be useful to pass a [doc object](/reference/glossary.md#doc) to a macro to render its areas, especially when docs are referenced in [relationships](/guide/relationships.md).

``` nunjucks
{% fragment authorCredit(author) %}
  <div>
    <p>By {{ author.title }}</p>
    {% area author, 'photo' %}
  </div>
{% endfragment %}

{# üëá Passing in a piece object from a relationship field #}
{% render authorCredit(data.piece._author) %}
```

<!-- ::: tip
Fragments also support keyword arguments, another [feature of Nunjucks macros](https://mozilla.github.io/nunjucks/templating.html#keyword-arguments). They can be used to establish default argument values as well as to skip positional arguments.

``` nunjucks
{% fragment listNumbers(first, second, third=3, fourth=4) %}
  <p>{{ first }} {{ second }} {{ third }} {{ fourth }}</p>
{% endfragment %}

{% render listNumbers(1, 2) %}
{# Renders: `<p>1 2 3 4</p> #}

{% render listNumbers(1, third=9) %}
{# Renders: `<p>1  9 4</p> #}
```
::: -->

::: warning
It is possible to pass the entire `data` object into a fragment as an argument. That is usually excessive, however. It's generally a better idea to be more specific with what you pass into a fragment.

## Importing fragments across files

The examples above simply render the fragments by name since they were defined in the same file. That can be useful sometimes, but it is more common to define fragments in different files from where they are used. This works very similarly to how template files are [extended or included](/guide/templating.md#referencing-templates-across-modules) across files. In this case, we use the `{% import %}` tag.

### Importing within the same module or the root `views` directory

As when we `include` or `extend` another template file, when that file is in the project root `views` directory or from the same module as where we're working, we only need to name the file or relative file path.

For example, you might have an article [index page](/guide/piece-pages.md) that lists a series of linked article titles with rich text teasers. The index page template itself would be at the path `modules/article-page/views/index.html`. You could separate the markup for each article in the listing into a fragment file, `modules/article-page/views/item-fragment.html`.

<AposCodeBlock>

``` nunjucks
{# üëá Accepting an argument with the article data object #}
{% fragment teaser(article) %}
  <section>
    <h2>{{ article.title }}</h2>
    {% area article, 'teaser' %}
    <a href="{{ article._url }}">Read more</a>
  </section>
{% endfragment %}
```
<template v-slot:caption>
modules/article-page/views/item-fragment.html
</template>
</AposCodeBlock>

Since the fragment and page template are both in the `article-page` module, we can import it with only the file name using the `{% import %}` template tag.

<AposCodeBlock>

``` nunjucks
{% import 'item-fragment.html' as articleFragment %}

{% for article in data.pieces %}
  {# üëá Rendering a heading and teaser for each article in the loop #}
  {% render articleFragment.teaser(article) %}
{% endfor %}
```
<template v-slot:caption>
modules/article-page/views/index.html
</template>
</AposCodeBlock>

::: info
Unlike importing and extending templates, when importing, the fragment is a property of the imported file, e.g, `articleFragment.teaser()`. This allow us to define multiple fragments in a single file, then import the one file and use any inside it.

<AposCodeBlock>

``` nunjucks
{% import 'fragments.html' as articleFragments %}

<h1>{{ data.piece.title }}</h1>
{# Maybe one fragment in the file has author credit markup: #}
{% render articleFragments.author(data.piece._author) %}
{# And another handles the article topic tags: #}
{% render articleFragments.topicTags(data.piece.tags) %}
```
<template v-slot:caption>
modules/article-page/views/show.html
</template>
</AposCodeBlock>


Similarly, **when fragment files are in the root-level `views` directory** or a sub-directory of it, we can import the fragment with only the relative file path from that `views` directory.

The global fragment file:

<AposCodeBlock>

``` nunjucks
{% fragment heading(title) %}
  <h2 class="fancy">{{ title }}</h2>
{% endfragment %}
```
<template v-slot:caption>
views/fragments/utilities.html
</template>
</AposCodeBlock>

Importing the fragment into any page or widget template would look exactly as if the fragment was in the same module.

``` nunjucks
{# In any page or widget template file #}
{% import 'fragments/utilities.html' as utilities %}

{% render utilities.heading('Organization history') %}
{# Renders: `<h2 class="fancy">Organization history</h2>` #}
```

### Importing from a different module

To import template fragments from one module into templates of another module, include the fragment file's module name in the `import` tag. This is what it might look like to import the article teaser fragment from above into a `press-page` index page template:

<AposCodeBlock>

``` nunjucks
{# üëá Importing our fragment from the `article-page` module #}
{% import 'article-page:item-fragment.html' as importedFragment %}

{% for article in data.pieces %}
  {% render importedFragment.teaser(article) %}
{% endfor %}
```
<template v-slot:caption>
modules/press-page/views/index.html
</template>
</AposCodeBlock>

In this case, the file name is prefixed with `article-page:`, indicating the source module for the template fragment.

## Inserting markup with `rendercall`

In addition to passing arguments, it is possible to pass markup directly from a template into a fragment it is using. The fragment must first include `rendercaller()`. This will be the location where the calling template will insert markup.

<AposCodeBlock>

``` nunjucks
{% fragment highlighter %}
  <aside class="highlight">
    {# üëáThe inserted markup will slot in here, inside the `aside` tags. #}
    {{ rendercaller() }}
  </aside>
{% endfragment %}
```
<template v-slot:caption>
/views/fragments/utilities.html
</template>
</AposCodeBlock>

When using the fragment, a template would use `{% rendercall %}` instead of `{% render %}`.

<AposCodeBlock>

``` nunjucks
{% import 'fragments/utilities.html' as utilities %}

{% rendercall utilities.highlighter() %}
  Fun fact: {{ data.page.funFact }}
{% endrendercall %}
```
<template v-slot:caption>
modules/default-page/views/page.html
</template>
</AposCodeBlock>

This might render something like:

```html
<aside class="highlight">
  Fun fact: The first ever ice cream sundae was served in Two Rivers, Wisconsin in 1881.
</aside>
```

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Templating > Async Components
DOC_PATH: guide/async-components.md
URL: https://apostrophecms.com/docs/guide/async-components
================================================================================
# Async components

Writing template files is how we turn data into HTML to display in browsers (or any number of other interfaces). When the data we are using comes directly from [standard document or widget fields](/reference/field-types/index.md), normal templates already have it ready to use. But what if the data we want to display needs to be freshly queried from the database or fetched from a third-party source?

**Async components** offer a great way to use data from asynchronous requests in templates. They also make it easy to *reuse* that template code. For developers familiar with the previous major version of Apostrophe, this replaces some clunkier and less clear ways to use async data in templates.

## Using async components in templates

In the template, an async component looks like this:

``` nunjucks
{% component 'product:newest' with { max: 3 } %}
```

- The `{% component %}` tag indicates that we are working with an async component.
- `'product:newest'` tells the template two things:
  1. The component is defined in the `product` module.
  2. Its name is `newest`, which is used as the component function name as well as its template partial filename.
- `with { max: 3 }` is an options object that will be passed to the component function. It's not required, but can allow for varied use in different contexts.

With that one line, the template rendering will know to find the component definition, execute the component function asynchronously, and render the appropriate template partial. That's a lot of benefit for one line of template code.

Let's see how we define these components.

## Defining async components

There are two parts to creating an async component. First, we need to write a component function in a module. Second, we add a template that uses the data returned by the function.

Async component functions are defined in a module's `components` customization function. Add a `components` function to a module that takes `self` (representing the module itself) as an argument. It must return an object containing the individual component functions.

<AposCodeBlock>

``` js
module.exports = {
  extend: '@apostrophecms/piece-type',
  components(self) {
    return {
      // Async component functions here...
    };
  }
};
```
  <template v-slot:caption>
    modules/product/index.js
  </template>
</AposCodeBlock>


Each component function takes two arguments:

| Argument | Description |
| ------- | ------- |
| `req` | The request object from the originating template context. |
| `data` | Data passed into the component where the component is used. (`{ max: 3 }` in the example above) |

**The function should return an object** that will be passed into its template as `data`. This best practice makes using the returned data consistent with other template data and thus clearer in the template partial.

For example, this component function in a `product` module requests products from the database in reverse chronological order and limits the number of products using `data.max`, if available. We then pass that to the template on the `products` property of our new data object.

<AposCodeBlock>

``` js
module.exports = {
  extend: '@apostrophecms/piece-type',
  components(self) {
    return {
      async newest(req, data) {
        // Using the `find` method with query builders
        const products = await self.find(req).sort({
          createdAt: -1
        }).limit(data.max || 5).toArray();

        return {
          products
        };
      }
    };
  }
};
```
  <template v-slot:caption>
    modules/product/index.js
  </template>
</AposCodeBlock>

The database request is asynchronous (as you can tell since it is an `async` function and uses `await` while making the request). This is the kind of thing that would otherwise cause trouble for a template.

Since the name of the component function is `newest`, our template partial for it will be in the `product` module as `newest.html`.

<AposCodeBlock>

``` nunjucks
<h2>Newest products</h2>
<ul>
  {% for product in data.products %}
    <li><a href="{{ product._url }}">{{ product.title }}</li>
  {% endfor %}
</ul>
```
  <template v-slot:caption>
    modules/product/views/newest.html
  </template>
</AposCodeBlock>

`data.products` in this template is the information we returned in the component function. From there, this is a normal template. The resulting markup is rendered along with the original template that used the `{% component %}` tag.

::: info
Async components have many uses. One of the most common is to support reuse in different contexts. For instance, the home page may always use the `newest` component at a fixed point in the page template. A products widget might also use it to show the newest products anywhere editors want to show the information.

Inside Apostrophe, async components are used to implement the `{% area %}` tag.

::: warning
Standard Nunjucks template macros cannot run asyncronous code, including async components. The Apostrophe template [fragment](fragments.md) feature *can* run async code and is a general purpose replacement for macros in ApostropheCMS.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Templating > Custom Nunjucks Tags
DOC_PATH: reference/template-tags.md
URL: https://apostrophecms.com/docs/reference/template-tags
================================================================================
# Template tags

Apostrophe template tags add additional functionality to templates, such as inserting widget areas, async components, and template fragments. The tags described below are specific to Apostrophe, though they use the standard Nunjucks syntax: `{% tagName %}`. See standard tags in the [Nunjucks reference](https://mozilla.github.io/nunjucks/templating.html#tags).

If a template tag takes multiple arguments they will be comma-separated. Additional context data may be included after a `with` keyword. See `area` below for examples of both.

| Tag name | Description | Self-closing |
| -------- | ----------- | ------------ |
| [`area`](#area) | Insert a [widget area](/guide/areas-and-widgets.md) | Yes |
| [`component`](#component) | Insert an [async component](/guide/async-components.md) | Yes |
| [`fragment`](#fragment) | Declare a [template fragment](/guide/fragments.md) | No |
| [`render`](#render) | Insert a basic template fragment | Yes |
| [`rendercall`](#rendercall) | Insert a template fragment that includes a `rendercaller` slot | No |
| [`widget`](#widget) | Used in the core area template to render individual widgets | Yes |


## `area`

The `area` tag inserts an area field into the template. The area field [must already be configured](/guide/areas-and-widgets.md#basic-area-configuration) in the page.

### Usage

``` nunjucks
{% area context, areaName with contextOptions %}
```

**Example:**
``` nunjucks
{# Without context options (most typical) #}
{% area data.page, 'sidebar' %}

{# Including context options #}
{% area data.page, 'main' with {
  '@apostrophecms/image': {
    sizes: '(min-width: 600px) 45vw, (min-width: 1140px) 530px'
  }
} %}
```

### Arguments

#### `context`

The area's document context, either a page (`data.page`), piece (`data.piece`), widget (`data.widget`), `array` field or `object` field. The area field must be defined in the field schema for that context. See the [template data](/guide/template-data.md) section for more on each `data` property.

#### `areaName`

The name (a string) of the area field as defined in the field schema.

#### `contextOptions` (optional)

The context options object is added after area tag arguments following the `with` keyword. It is an object with keys matching the names of widget types allowed in that particular area field. Each key is assigned a value that will be passed into the widget template as `data.contextOptions`. See the [image widget guide](/guide/core-widgets.md#image-widget) for an example.

Context options are optional for all core and official Apostrophe widget types.

::: info
Context options are not the best place for most widget configuration. That should be done in the [area field configuration](/reference/field-types/area.md#widgets). Context options are used to supplement that with options that only apply to the specific template context. Context options cannot change which widgets are permitted in an area.

## `component`

The `component` tag inserts an asynchronous component into the template. See the [async components guide](/guide/async-components.md) for more on using this feature.

### Usage

``` nunjucks
{% component 'module:componentName' with data %}
```

**Example:**
``` nunjucks
{% component 'product:newest' with { max: 3 } %}
```

### Arguments

#### `module:componentName`

The primary argument is a combination of the name of a module and the name of an async component from that module, separated by a colon. All async components belong to a specific module, though multiple modules may have components with the same name.

#### `data` (optional)

The data argument, following the `with` keyword, is available in the async component template as `data`. It can be any data type, however it is a best practice to use an object with subproperties.

## `fragment`

Template fragments let us reuse template markup across a codebase, whether standard synchronous or [async code](/guide/async-components.md). The `fragment` tag *declares* a template fragment that will be inserted elsewhere with [`render`](#render) or [`rendercall`](#rendercall). See the [template fragments guide](/guide/fragments.md) for more on using this feature.

This tag must be closed with an `endfragment` tag.

### Usage

``` nunjucks
{% fragment name(parameters) %}
  {# Fragment markup #}
{% endfragment %}
```

**Examples:**
``` nunjucks
{% fragment button(text, action, options = {}) %}
  <button class="o-button {{ options.class }}" data-action="{{ action }}">
    {{ text }}
  </button>
{% endfragment %}
```

``` nunjucks
{% fragment card(data = {}) %}
  <section class="o-card">
    <h2>{{ data.heading }}</h2>
    <div>
      {# `rendercaller` connects to the `rendercall` tag below. #}
      {{ rendercaller() }}
    </div>
  </section>
{% endfragment %}
```

### Arguments

#### `name(parameters)`

The fragment name used to reference it in `render` and `rendercall` tags. It should be written like a function with parentheses. The parentheses may include parameter names if needed. Parameters should be separated by commas and may optionally include a default value assignment.

## `render`

The `render` tag is used to insert a [fragment](/guide/fragments.md) in a template.

### Usage

``` nunjucks
{% render name(arguments) %}
```

**Example:**
``` nunjucks
{% render button('Click me', 'send', { class: 'is-blue' }) %}
```

### Arguments

#### `name(arguments)`

The name of the fragment to render. It may include a source reference [if the fragment was imported](/guide/fragments.md#importing-fragments-across-files) (e.g., `source.button()`). The parentheses following the name may take arguments to pass into the fragment.

## `rendercall`

Similar to `render`, `rendercall` tag is used to insert a fragment in a template. `rendercall` is used when [injecting markup into a fragment as well](/guide/fragments.md#inserting-markup-with-rendercall). The markup inside this tag is added in a fragment where it has a `rendercaller()` call.

This tag must be closed with an `endrendercall` tag.

### Usage

``` nunjucks
{% rendercall name(arguments) %}
{% endrendercall %}
```

**Example:**
``` nunjucks
{% rendercall card({ heading: 'Featured image' }) %}
  {% area data.widget, 'photo' %}
{% endrendercall %}

```

### Arguments

#### `name(arguments)`

The name of the fragment to render. It may include a source reference [if the fragment was imported](/guide/fragments.md#importing-fragments-across-files) (e.g., `source.card()`). The parentheses following the name may take arguments to pass into the fragment.

## widget

The `widget` template tag will usually not be used in Apostrophe project templates. It is used in the core area template file to render individual widgets.

``` nunjucks
{% widget widgetObject, widgetOptions with contextOptions %}
```

**Example:**
``` nunjucks
{# Example from modules/@apostrophecms/area/views/area.html in apostrophe core #}
{% widget item, widgetOptions with data._with %}
```

### Arguments

#### `widgetObject`

An individual widget object from area field data. Eventually passed into a widget template as `data.widget`.

#### `widgetOptions`

Widget options object as defined in the area configuration. Eventually passed into a widget template as `data.options`.

#### `contextOptions`

Area context options for the widget type as [defined in the template using the area](/guide/areas-and-widgets.md#passing-context-options). Eventually passed into a widget template as `data.contextOptions`.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Headless
DOC_PATH: guide/headless-cms.md
URL: https://apostrophecms.com/docs/guide/headless-cms
================================================================================
# Using Apostrophe as a headless CMS

Apostrophe is fully featured as a traditional CMS. It is also immediately ready for use as a headless CMS. There are many scenarios where Apostrophe works well in a decoupled architecture, including:

- We may want to use Apostrophe to serve webpages normally, but also use the website data in another context, such as a mobile app.
- We may want to go fully headless with a front end like Gatsby or Gridsome while also allowing editors to use Apostrophe's in-context editing.
- We may have an app that handles features such as e-commerce but need a CMS to create and pipe content into the app.

Regardless of the reason or the layers involved there are some common concepts to understand.

## Accessing data using the REST APIs

Before going further, keep in mind that there is an [API route reference section](/reference/api/README) that will include much of the following information in a more direct format. One section there that will not be fully covered in this guide will be the [authentication APIs](/reference/api/authentication.md). There are a few options for authentication discussed there.

One of the more common use cases for a headless CMS is to simply get data from the CMS for a public website built with React, Vue.js or some other framework. Since the certain data is publicly available in the front-end application, we can simply make that data publicly available directly through the REST API using [a `publicApiProjection` option](/reference/api/authentication.md#allowing-public-access) on the doc type. This will only apply to `GET` requests.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  options: {
    publicApiProjection: {
      title: 1,
      slug: 1,
      _url: 1,
      _author: 1,
      main: 1,
      thumbnail: 1
    }
  }
};
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

We would add a `publicApiProjection` object for each piece type or page type that the front end app accesses. Since the REST APIs for Apostrophe content are immediately ready there is no other configuration needed inside Apostrophe for a basic one-way data flow.

## Getting piece data from the REST API

Requesting and using [piece](/guide/pieces.md) data should seem familiar to developers who have used a headless data source before. It is returned from the API request as an array of objects, each of which is an individual piece. Those results are paginated to send a limited number from any single request.

REST API routes are automatically constructed using the application's base URL, an API prefix (`/api/v1/`), the name of a content type module, and possibly a document ID. If using an API key for authentication, that would be added at the end in a query parameter as normal. For example, making a request for an *`article`* piece type from a website at `https://example.rocks` would use a URL like:

```
https://example.rocks/api/v1/article
```

When using Apostrophe as a headless CMS, we will most frequently be making `GET` requests from the Apostrophe app (see the [pieces API reference](/reference/api/pieces.md) for more on other request types). There are two main types of `GET` requests we should think about: a "get all" request and a "get one" request.

### Get all the pieces!

To make a **"get all"** request, hit the URL as described above. Using the Node.js `node-fetch` utility, such a request in a front end application might look like:

```javascript
async function getArticles() {
  const response = await fetch('http://example.rocks/api/v1/article', {
    method: 'GET'
  });

  return response.results;
}

try {
  const articles = await getArticles();
  // Do something with the articles!
} catch (error) {
  // Handle the error
}
```

Assuming the request goes through well, it will return an object with three properties:

- `results`: an array of piece objects, limited to 10 pieces by default
- `pages`: the total number of possible "pages" of results for this request
- `currentPage`: the page number for that request (`1` for this first request)

With that information we can make additional requests for more pages of results until we have as much data as we need.

### Get one piece

The **"get one"** type of request works similarly. Following the standard REST pattern, we add a document ID to the end of the previous request route URL to get only one result back. Each "get all" result object will include an `_id` property. Let's say that one `_id` was `j8e6n7n5y309:en:published`. We would make the request to:

```
GET https://example.rocks/api/v1/article/j8e6n7n5y309:en:published
```

The response to that successful request will be [a single piece object](/reference/api/pieces.md#piece-document-response-example).

## Getting page data from the REST API

Page REST API requests look very similar to piece requests. They follow the same REST API pattern:

```
# The home page and first-level children
GET https://example.rocks/api/v1/@apostrophecms/page

# A single page with document _id `903y5n76e8j:en:published`
GET https://example.rocks/api/v1/@apostrophecms/page/903y5n76e8j:en:published
```

The module name used for these requests is always `@apostrophecms/page`, the module that manages pages in Apostrophe. The response for a "get one" request is also similar to a single piece `GET` request. It is a single page object with the page data properties immediate at the top level.

The response for page "get all" requests work differently by default. This is because it reflects that pages have a hierarchical structure. The home page is the "parent" of the top-level pages, which then have additional "child" pages, and so on. As such, the response to a "get all" route as written above looks something like this:

``` json
{
    "_id": "ckhdscx5900054z9k88uqs16w",
    "title": "Home Page",
    "slug": "/",
    // ... additional properties
    "_url": "http://localhost:3000/",
    "_ancestors": [],
    // Child pages üëá
    "_children": [
        {
            "_id": "ckhfen8ls0005mq9k8p9izkjt",
            "title": "Blog",
            "slug": "/blog",
            // ... additional properties
            "_url": "http://localhost:3000/blog",
            "_children": []
        },
        {
            "_id": "ckhurshqd00088v9k6pfnqpjz",
            "title": "About us",
            "slug": "/about-us",
            // ... additional properties
            "_url": "http://localhost:3000/about-us",
            "_children": []
        }
    ]
}
```

The home page object is returned with a `_children` array with the first-level pages.

**We can get all pages**, with limited data on child pages, by adding the `?all=1` query parameter.

```
GET https://example.rocks/api/v1/@apostrophecms/page?all=1
```

**We can request this data as a flat array** by adding the `?flat=1` query parameter.

```
GET https://example.rocks/api/v1/@apostrophecms/page?all=1&flat=1
```

## Getting rendered HTML in responses

Using an object of JSON-like data from a REST API is common with a headless CMS. Traditionally the application's "head" (such as a single page Vue.js, React, Angular or native application) would use that structured data to display product, event, or similar content information. It is less common for a headless CMS to deliver page content that is tied to particular HTML markup and layout. More often, landing page text and images might be coded directly into the app code or otherwise not be from the same data source.

Apostrophe supports both approaches. The in-context editing features and [widget areas](/guide/areas-and-widgets.md) give editors more control over content, but in its default form areas are data objects mainly useful in an editing context and for native apps. When areas are rendered as HTML from widget template files they are fully realized and easier to use in contexts that utilize HTML.

### "Just give me the HTML:" `?render-areas=1` parameter

**If you just want the HTML for each area, include the `?render-areas=1` query parameter in your API request.** This will return the page document as JSON. Each area field in the response will have a `_rendered` property with a string of HTML, in place of the `items` array of widget objects. This is useful if we just want to insert the rendered area HTML into an existing template system or utilize an iOS `WKWebView` or Android `WebView`.

```
GET https://example.rocks/api/v1/@apostrophecms/page/_ID-OF-A-PAGE-GOES-HERE?render-areas=1
```

### "I want both:" `?render-areas=inline` parameter

If you prefer to maintain access to the data properties of each individual widget *in addition* to rendered HTML, try:

```
GET https://example.rocks/api/v1/@apostrophecms/page/_ID-OF-A-PAGE-GOES-HERE?render-areas=inline
```

A `_rendered` property containing HTML will be added to each individual widget in each area's `items` array, *in addition to* all of the usual properties provided by the API.

### "I just want the whole page:" fetching the page URL directly

If we wanted to get the full page as HTML rendered using the page templates, we could make a `GET` request to the page URL (basically what browsers do). This is only good if we are not trying to insert it into the midst of a larger HTML document.

```
GET https://example.rocks/about-us
```

### "I want the *content* of the page:" leveraging the `aposRefresh=1` parameter

 More likely we would only want the unique page content (without the `head` tag and outer wrapper elements), which we can get by adding the `aposRefresh=1` query parameter. It will include only the HTML markup for the page template. This is great for using Apostrophe page templates inside an external page wrapper (e.g., `head` tag, site header, and site footer).

```
GET https://example.rocks/about-us?aposRefresh=1
```

This technique is quite effective. It can be extended by passing additional custom query parameters and checking `data.query.parameterName` inside page and layout templates to decide how to further adjust the response.

## Headless integrations

As official platform-specific plugins are made available they will be added here. These are meant to make it even easier to use Apostrophe REST APIs with certain popular front end systems.

### Astro plugin

[Astro](https://astro.build/) is a powerful framework for content-driven websites. The [apostrophe-astro](https://apostrophecms.com/extensions/astro-integration)
plugin provides a bridge that allows Astro to act as an "external front end" for Apostrophe. Note that Astro allows sites to be built with any mix of React, Vue, SvelteJS and other frontend frameworks which is highly effective when combined with Apostrophe as a back end.

### Gatsby source plugin

[Gatsby](https://gatsbyjs.com/) is a static site generator using React. The [Apostrophe source plugin](https://www.npmjs.com/package/gatsby-source-apostrophe) bridges the gap between the REST APIs and the GraphQL query language that Gatsby uses.

::: info
Direct GraphQL support is on the product roadmap for Apostrophe. If you are interested in that feature, [please indicate that on the product roadmap card](https://roadmap.apostrophecms.com/roadmap?id=86628443-cf29-49ca-a6a5-8ef899b37fe2) so we can properly prioritize it.

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Users and Roles
DOC_PATH: guide/users.md
URL: https://apostrophecms.com/docs/guide/users
================================================================================
# Users and user roles

A **"user"** in Apostrophe is an account (usually for a human or benevolent robot) that can be used to log into the application. Beyond that, users get specific sets of permissions based on the **role** they are assigned.

## Adding new users

If you want to do anything with your Apostrophe website, you will need users. There are two main ways to add them: using the command line task or through the user interface.

### Adding users with the CLI task

The CLI task for adding users is primarily useful to add the very first admin user. The command is:

```bash
node app @apostrophecms/user:add my-user admin
```

The two final arguments passed to the task are, in order, the new username (`my-user`) and the [user role](#user-roles) (`admin`).

### Adding users through the UI

Once you have that first user, you have the option to add new ones through the user interface. The first and most important thing to know is that **only admin users can create and manage other users.** The admin user created with the CLI command above will have this ability.

Open the users manager interface by clicking the "Users" button in the admin menu.

![The admin menu at the top of the browser window with the Users button highlighted](/images/users-admin-bar.png)

When the manager opens, click the "New User" button to open a fresh content editor modal. Populate the required fields, including the user's "Display Name," [role](#user-roles), username, and password. By default, if a site is configured for [multiple locales](/reference/modules/i18n.html), and a user is viewing the site in a particular locale, then the user interface will also be displayed in that locale whenever possible. However, if the `adminLocales` option of the i18n module is set to an array of locales, then it becomes possible to 'lock' the admin UI to a particular language on a per-user basis. Users can change this setting themselves if the Personal Settings module is configured. If the [`defaultAdminLocale` option](/reference/modules/i18n.html) of the i18n module is configured, the admin UI language will default to that language.

![A user editor modal with values filled in for our user, "Sam Wilson"](/images/users-editor.png)

## User roles

Users are assigned one of four **user roles**. Each role is assigned a set of permissions that cover typical content editing, review, and administration duties.

| User role | What can they do? |
| --------- | ----------------- |
| **Guest** | Guest users can log into the website and view content with visibility set to "Login required." They cannot edit any content or view unpublished content. |
| **Contributor** | Contributors may create and edit content, including the global doc. They cannot upload files (i.e., images, PDFs) or take any action on users. |
| **Editor** | Editors have all the permissions of contributors. They can also *publish* content and upload files. They cannot take any action on users. |
| **Admin** | Administrators have permissions to create, edit, archive, and publish any content. They are the only role that may create, update, or archive users. At the time of writing, an admin account is needed to reset passwords through the user interface. |

::: info
We can also change passwords through the command line task below. The `username` argument will be the username of the account you are updating.

``` bash
node app @apostrophecms/user:change-password username
```

You can [read more about permissions and content workflows](/guide/permissions-and-workflow.md) to see how these roles work together in practice.

## Logging into an Apostrophe website

Users can log into Apostrophe websites at the `/login` URL path for the website. If the website base URL (homepage) is `https://example.rocks`, the login page will be `https://example.rocks/login`.

![The Apostrophe login page with username and password fields](/images/users-login.png)

::: tip
Sometimes certain content should never be fully public. You may have subscribers who get special access or information that only employees should see. The "Guest" role can be used for that.

Require login access to view specific pages or pieces using the visibility field, labeled **"Who can view this?"** This field is found in the "Permissions" editor tab by default.

![A page editor interface showing the permission tab and "who can view this" field](/images/users-visibility.png)

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Permissions and Workflow
DOC_PATH: guide/permissions-and-workflow.md
URL: https://apostrophecms.com/docs/guide/permissions-and-workflow
================================================================================
# Permissions and Workflow

The permission system available through the core `@apostrophecms/permission` module manages content workflows, user access, and site administration. It allows you to:

- **Create safe content workflows** where drafts can be reviewed before going live
- **Delegate content creation** without worrying about accidental changes to critical pages
- **Control file uploads** to maintain site security and organization
- **Manage user access** to sensitive or premium content
- **Scale your editorial team** with clear roles and responsibilities

## The four default user roles

Apostrophe provides four user roles that cover most organizational needs:

| **Ability**                     | **Guest** | **Contributor** | **Editor** | **Administrator** |
|---------------------------------|-----------|------------------|------------|--------------------|
| View "Login Required" Content   | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Create Content                  | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ |
| Edit Content                    | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ |
| Publish Content                 | ‚ùå | ‚ùå | ‚úÖ | ‚úÖ |
| Upload Images and Files         | ‚ùå | ‚ùå | ‚úÖ | ‚úÖ |
| Manage Users                    | ‚ùå | ‚ùå | ‚ùå | ‚úÖ |

### Guest
Guest users can log in to view content marked as "Login required" but cannot make any changes to the website. Use this role for:
- Newsletter subscribers who get early access to articles
- Community members viewing member-only resources
- External stakeholders who need to review content without editing rights

### Contributors
Contributors can create and edit content but cannot publish it live or upload files. This role is ideal for:
- Freelance writers submitting articles for review
- Team members creating draft content
- Junior staff learning the content management system

### Editors
Editors have all contributor permissions plus the ability to publish content and upload files. Perfect for:
- Senior editorial staff who review and approve content
- Content managers overseeing publication schedules
- Marketing teams managing campaigns and assets

### Administrators
Admins can do everything, including user management. Essential for:
- Website administrators
- IT staff managing user accounts
- Senior managers with full oversight needs

## Content Workflow

Let's walk through a typical content workflow to see how permissions create a smooth editorial process.

| **Step** | **Contributor Workflow** | **Editor Workflow** |
|----------|--------------------------|---------------------|
| **1. Create** | Logs in and creates a draft post.                                                 | Logs in and creates a post.                            |
| **2. Edit** | Can format text, link pages, and revise drafts - **cannot upload files or images**. | Can format, revise, and add media.                     |
| **3. Save** | Saves as a draft ‚Äî **cannot publish**.                                              | Saves and can publish immediately.                     |
| **4. Submit** | Submits for editor review.                                                        | Skips review ‚Äî manages and publishes their own work.   |
| **5. Publish** | Not allowed.                                                                     | Publishes instantly ‚Äî full control.                    |
| **6. Revisions**| Can continue editing; changes remain drafts until republished by an Editor.     | Can edit live content and push updates directly.       |


### Step 1: Contributor Creates Content

A freelance writer with the **Contributor** role logs into the website and creates a new blog post.

As a contributor, the writer **can**:
<div style="
  display: grid;
  grid-template-columns: 70% 30%;
  gap: 1rem;
  align-items: start;
"
>
  <ul>
    <li>Write and format the article</li>
    <li>Add internal links to other pages</li>
    <li>Save work as a draft</li>
    <li>Edit content multiple times</li>
    <li>Submit the draft for review (using the "Submit" button instead of "Publish")</li>
  </ul>
  <img src="../images/submit-button.png" alt="The submit button for a user with an contributor role" style="width: 100%; height: auto;">
</div>


However, contributors **cannot**:
- Publish the article (it remains in draft status)
- Upload images or files

The article remains editable by the original author even after submission, allowing them to make revisions, corrections, or improvements while the editor reviews their work through their own submission management interface. Any changes made during this review period will be included when the editor eventually publishes the piece. Contributors can also elect to take the content out of the submission flow and resubmit at a later point.

### Step 2: Editor Reviews and Enhances


<div style="
  display: grid;
  grid-template-columns: 25% 75%;
  gap: 1rem;
  align-items: center;
"
>
  <img src="../images/inbox.png" alt="The inbox icon of the admin-bar showing one unread message" style="width: 100%; height: auto;">
  <p>The content editor with the <strong>Editor</strong> role receives a notification about the new draft article.</p>
</div>

The editor can open their submitted drafts inbox to review the content. The inbox provides information about when the content was submitted and author details. Articles are clearly marked to indicate whether they are new submissions or revisions to previously published content.
![The modal displaying information about articles currently in submission](../images/submission-management.png)

From the submitted drafts interface, editors can:
- Edit the content for style and accuracy
- Upload and add images to enhance the article
- Preview how the article will look when published
- Publish the submission immediately
- Share a preview link for others to review the draft
- Dismiss the submission if it's not ready for publication

### Step 3: Publication

<div style="
  display: grid;
  grid-template-columns: 70% 30%;
  gap: 1rem;
  align-items: start;
"
>
  <p>After reviewing the work and adding appropriate images, the Editor publishes the article.</p>
  <img src="../images/publish-button.png" alt="The publish button for a user with an editor role" style="width: 100%; height: auto;">
</div>

The article is now live on the website. If changes are needed later:
- The original Contributor can continue to edit the published article (but changes remain as drafts until an editor publishes them)
- The Editor can make immediate changes and publish them

## Advanced Permissions Extension

While the four standard roles handle most situations, some organizations need more granular control. For complex hierarchies, departmental workflows, or custom permission requirements, Apostrophe offers an Advanced Permissions extension that provides:

- **Custom user groups** for departments or teams with specific permission sets
- **Content-based permissions** (e.g., "can only edit blog posts")
- **Per-document permissions**, allowing you to grant specific users or groups access to individual pieces of content rather than all content of that type

The Advanced Permissions extension enables more targeted workflows - for example, a freelance writer could be given permission to edit only their assigned articles, or a department editor could manage only content in their section.

The Advanced Permissions extension integrates seamlessly with Apostrophe's core permission system while adding enterprise-level control. For detailed implementation guidance, see the [Advanced Permissions documentation](https://apostrophecms.com/extensions/advanced-permission).

================================================================================
COLLECTION: guides
NAV_PATH: Essentials > Site Settings
DOC_PATH: guide/global.md
URL: https://apostrophecms.com/docs/guide/global
================================================================================
# Global settings

Editable content or settings used across your app can be managed through the **global doc**. You can use this for many things, including configuring:

- company information or navigation in the website footer
- a special ID for a third-party service, such as Google Analytics
- social media account URLs

The global doc is a special [piece](/guide/pieces.md): it is created automatically and there can only be one. It is configured through the `@apostrophecms/global` piece type module.

To demonstrate, we may want to display an organizational Github URL in the website footer and a "Contact" page. We can add that to the global doc as we would on any other piece type.

<AposCodeBlock>

```javascript
module.exports = {
  fields: {
    add: {
      githubUrl: {
        type: 'url',
        label: 'Github organization url'
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: ['githubUrl']
      }
    }
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/global/index.js
</template>
</AposCodeBlock>

Once the global doc is configured with fields, it will be added to the admin bar for editing.

**Templates always have direct access to the global doc as `data.global`.** The Github URL field could be used in a template as a property of that doc:

``` nunjucks
{% extends data.outerLayout %}

{% block afterMain %}
  <footer>
    {% if data.global.githubUrl %}
      <a href="{{ data.global.githubUrl }}">Our Github organization</a>
    {% endif %}
  </footer>
{% endblock %}
```

::: warning
Since the global doc is available in every template it can be tempting to add all kinds of data to it. This can eventually lead to performance problems since **the whole global doc is fetched for templates on every page request**. If it contains a lot of [content areas](/guide/areas-and-widgets.md) and has [relationships](/guide/relationships.md) with other docs, that one request can get very large.

A basic guideline is that things should only be added to the global doc if they are used in *at least* 50% of pages.

================================================================================
COLLECTION: guides
NAV_PATH: Scaling Up > Localization > Overview
DOC_PATH: guide/localization/overview.md
URL: https://apostrophecms.com/docs/guide/localization/overview
================================================================================
# Localization in Apostrophe

For Apostrophe, "localization," often abbreviated as **l10n**, is the process of adapting the Apostrophe user interface and Apostrophe website content for different "locales," or groups of people (usually based on language and country). This can include text translation, date formats, content variation, and much more.

Localizing Apostrophe websites is done in two contexts:

- **Static content**: localizing "hard-coded" text and other information. This primarily involves strings in template files and the Apostrophe user interface components. This will usually involve a developer, though translation will likely be done by other people. [See the related guide for more on this.](static.md)
- **Dynamic content**: translating and generally customizing content controlled through the user interface. Depending on the website needs, this may mean direct translation between locales, but may also mean major content changes for the different groups of people. This work is usually done by content editors and translators. [See the related guide for more on this.](dynamic.md)

::: info What about "internationalization"?
The term "internationalization," often abbreviated **i18n** comes up when discussing this as well. And for good reason. See [the localization section of the glossary](/reference/glossary.md#localization-terms) for a quick overview of how we use these terms. Put simply, we use "internationalization" to refer to the system that supports the localization processes. That's why the core Apostrophe module is `@apostrophecms/i18n`.

## Configuring locales

The first step in localizing content, whether static or dynamic, is to define locales. These are most often different languages, countries, or combinations of the two. In some cases it may also be appropriate to establish locales for people based on topical interests, professional categories, or cultural identities.


We configure locales through the `@apostrophecms/i18n` module. In a project codebase, we can add a `modules/@apostrophecms/i18n/index.js` file. The locales will go in its `locales` option object.

<AposCodeBlock>

  ```javascript
    module.exports = {
      options: {
        locales: {}
      }
    }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/i18n/index.js
  </template>
</AposCodeBlock>

**Each locale needs a short identifier**, which is typically a two-letter country code, language code, or one of each with a dash separating them. This will be the object key for each locale. For example, if we had a USA-based business working across North America we might have locales for US/general English speakers (`en`) and Spanish speakers (`es`), residents of Mexico using Spanish (`es-MX`), Canadian French speakers (`fr-CA`), and Canadian English speakers (`en-CA`). The `label` property is used in the user interface.

::: info
- Locale names (e.g., `'en'`, `'fr-CA'`) must begin with an alphabetic (non-numeric) character.
- The best practice for locale names is to use a two-character language code (`'en'`) or the language code with two character country code, capitalized (`'en-GB'`). This will improve compatibility with i18n features as they are added to Apostrophe.

Additionally, we need to tell Apostrophe how to identify which one to use. This is done based on the URL used to access the website, either by the URL **hostname**, the URL path **prefix**, or a combination of the two.

<AposCodeBlock>

  ```javascript
    module.exports = {
      options: {
        locales: {
          en: {
            label: 'English'
          },
          es: {
            label: 'Spanish',
            prefix: '/es'
          },
          'es-MX': {
            label: 'Spanish (Mexico)',
            hostname: 'example.mx'
          },
          'fr-CA': {
            label: 'French (Canada)',
            hostname: 'example.ca',
            prefix: '/fr'
          },
          'en-CA': {
            label: 'English (Canada)',
            hostname: 'example.ca',
            prefix: '/en'
          }
        }
      }
    }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/i18n/index.js
  </template>
</AposCodeBlock>

::: info
If `hostname` is used for any locale:
- a `baseUrl` must be set on the application, defining the default hostname, OR
- a `hostname` setting must be used on all locales

For this example, we'll assume we have `baseUrl: 'example.com'` set on the application.

So how does Apostrophe choose the best locale to use? In many cases it is clear. If there is conflict, however, the best locale uses the following prioritization:
1. The locale has both `hostname` and `prefix` settings and the URL matches *both* settings.
2. The URL matches the locale's configured `hostname` and the locale has no `prefix`
3. The URL matches the locale's configured `prefix` and the locale has no `hostname`.
4. The locale is the default locale (when no other locale matches).

## The default locale

The default locale is the locale used when no others match the URL better. It is typically the locale used by your website's primary audience. **If no locales are configured, Apostrophe will use `en` as the default locale name.**

The default locale can be changed in one of the following ways:
- Configuring locales! The first one configured will be the default.
- Using [the `defaultLocale` option](/reference/modules/i18n.md) on the `@apostrophecms/i18n` module to name another locale

The best practice when configuring locales is to explicitly set the `defaultLocale` option if it should not be `en`.

::: warning
It is important to configure locales, especially the default locale, before content entry begins. This is especially the case if your locales will not include `en`. If content entry begins on the default `en` locale and we later configure locales that do not include `en`, that original content will disappear (until the `en` locale is restored).

With locales configured, the next step is to proceed with actual content localization. See the following guides on [static](static.md) and [dynamic](dynamic.md) localization.

================================================================================
COLLECTION: guides
NAV_PATH: Scaling Up > Localization > Static i10n
DOC_PATH: guide/localization/static.md
URL: https://apostrophecms.com/docs/guide/localization/static
================================================================================
# Static string localization

This section covers localization of strings throughout template files and Apostrophe user interface. These strings are hard-coded, not editable by logged-in users, and thus are not stored in the database. Instead, this localization is stored in JSON files associated with the various locales.

::: info
Localizing static strings is only possible if the Apostrophe app has configured locales. If you are looking for information on configuring locales, see the [localization landing page](overview.md#configuring-locales). There is also a [glossary section](/reference/glossary.md#localization-terms) of related terms.

## Localizing strings

There are often good reasons to hard-code text in templates even if we operate in multiple languages. For example, if our website has a blog with related articles featured at the bottom of each post using a relationship field. The heading "Related articles" belongs in the show page template. We don't want to make content editors translate that each time and we want to avoid creating any custom global fields for a text string that is not likely to change.

That section of our show page template might look like this:

<AposCodeBlock>

  ``` nunjucks
    {# More article template stuff above ‚§¥ #}
    <section>
      <h2>Related articles</h2> {# üëà We need to localize this. #}
      <ul>
        {% for post in data.piece._related %}
          <li><a href="{{ post._url }}">{{ post.title }}</a></li>
        {% endfor %}
      </ul>
    </section>
  ```
  <template v-slot:caption>
    /modules/article-page/views/show.html
  </template>
</AposCodeBlock>

Localizing that string is as easy as wrapping it in a template helper: `__t()`. Make sure the string passed to the helper is in quotes and any matching quotes in the string are escaped (e.g., `__t('Gritty\'s friends')`).

<AposCodeBlock>

  ``` nunjucks
    {# More article template stuff above ‚§¥ #}
    <section>
      <h2>{{ __t('Related articles') }}</h2> {# üéâ It's localized! #}
      <ul>
        {% for post in data.piece._related %}
          <li><a href="{{ post._url }}">{{ post.title }}</a></li>
        {% endfor %}
      </ul>
    </section>
  ```
  <template v-slot:caption>
    /modules/article-page/views/show.html
  </template>
</AposCodeBlock>

In that example, we passed the actual text to the localization helper. This has the benefit that it will be automatically used for the default locale and any other locales that don't translate it.

Our other option is to use a **localization key that is different from the original text**. Taking our example, that heading tag might instead look like:

``` nunjucks
<h2>{{ __t('relatedArticles') }}</h2>
```

This method is better if your team prefers to maintain all hard-coded strings in the same way across locales (treating the default locale the same as others). Using the original text as the key, as in our previous example, might be better so that translators can see the original text alongside their translations in the JSON files. It mostly depends how you prefer to work. The important thing is to be consistent.

### Registering text outside of templates

Two other places you may want to register strings are in **API routes** and in Vue.js **user interface components**.

To register strings in **custom API routes**, use the `req.t()` method on the request object.

<AposCodeBlock>

  ```javascript
  module.exports = {
    // ...
    apiRoutes(self) {
      return {
        get: {
          // GET /api/v1/product/newest
          async newest(req) {
            const product = await self.find(req).sort({ createdAt: -1 }).toObject();
            if (!product) {
              // üëá Sends a localized version of the error with req.t()
              throw self.apos.error('notfound', req.t('No products were found.'));
            }

            return { product };
          }
        }
      };
    }
  };
  ```
  <template v-slot:caption>
    /modules/product/index.js
  </template>
</AposCodeBlock>

::: tip
There is currently no browser method available to register strings in project client-side JS. A good alternative is to create an API route that returns localized strings then use the response from that route in client-side JS.

### Localizing with string interpolation

Consider the following string: "*Contact the London office*." Maybe we have offices in multiple countries and use this heading on each office's page. In this case we don't know the *exact* string to translate since the city will change. The variable part, the city, is also in the middle (for some languages, at least) so we could not even translate the rest very easily. In cases like this we use **string interpolation**.

String interpolation is a process of generating a text string that is partly dynamic. In the previous paragraph's example, the city name is dynamic, or variable, since it is reused for each office.

Regardless of whether we are localizing text in templates, server-side code, or UI Vue files, interpolation works essentially the same way. The string or localization key is still the first argument in the localization function. **Then an object is passed as a second argument to the l10n function, containing interpolation properties that match keys in curly braces.**

Template example:

<AposCodeBlock>

  ``` nunjucks
    {{ __t('Contact the {{ city }} office', {
      city: data.piece.city
    }) }}
  ```
  <template v-slot:caption>
    /modules/office-page/views/show.html
  </template>
</AposCodeBlock>

The arguments would look essentially identical in server-side or a UI file, using the respective l10n functions (`req.t()` and `this.$t()`, respectively). This also works if the first argument was a localization key that had that string assigned as its value.

<AposCodeBlock>

  ``` json
    {
      "contactOffice": "Contact the {{ city }} office"
    }
  ```
  <template v-slot:caption>
    /modules/office-page/i18n/en.json
  </template>
</AposCodeBlock>

<AposCodeBlock>

  ``` nunjucks
    {{ __t('contactOffice', {
      city: data.piece.city
    }) }}
  ```
  <template v-slot:caption>
    /modules/office-page/views/show.html
  </template>
</AposCodeBlock>

See the [i18next documentation](https://www.i18next.com/translation-function/interpolation) for more available options.

## Adding and using localization files

Now that there are strings to localize, we need to add JSON files for locales with the strings and their translations. For the purposes of our example we will assume we have two locales: `'en'` (English) and `'es'` (Spanish). Each locale should get its own JSON file using the locale name, in a `i18n` subdirectory of a module that has internationalization active.

Like all modules, we would need to activate this module in `app.js`, even if we don't need an `index.js` file. Our JSON files would be:

- `modules/localization/i18n/en.json`
- `modules/localization/i18n/es.json`

::: tip
These files can be spread across modules if you like. For example you might want to localize strings from a particular module's template files in that module directory. Like with many things, this depends how you and your team like to work.

It's important to note that **if the same key is used in multiple template files they will be rendered to the same string**. It does not matter if each template has a localization JSON file with that key registered.

Each JSON file will include key/value pairs with the localization key and a string that should replace the localization key.

If the only localization key we registered in our project was `relatedArticles` from above, our files would look like:

<AposCodeBlock>

  ``` json
  {
    "relatedArticles": "Related articles"
  }
  ```
  <template v-slot:caption>
    /modules/localization/i18n/en.json
  </template>
</AposCodeBlock>

<AposCodeBlock>

  ``` json
  {
    "relatedArticles": "Art√≠culos relacionados"
  }
  ```
  <template v-slot:caption>
    /modules/localization/i18n/es.json
  </template>
</AposCodeBlock>

When rendering the show page template, Apostrophe will look in these files, find the registered key and replace it with the correct string based on the active locale.

::: warning
The primary module to avoid using to store l10n strings for project-level text is `@apostrophecms/i18n`, the actual internationalization module. This is used by Apostrophe core for the user interface and it uses a namespace to keep its l10n keys separate from project-level localization.

## Using namespaces

A l10n **namespace** is a prefix on localization keys that makes it harder to accidentally override. In project-level l10n namespacing is *not really necessary* since there are not additional layers of work that might override translation there.

Namespacing can be useful if you are building your own modules with hard-coded strings that you intend to publish. When that module is installed in a project later it would be less likely that the project will change them accidentally.

To use a l10n namespace, first choose a namespace name. Let's say it's `ourTeam`. Create an `i18n/ourTeam` subdirectory inside your module, and populate it with `.json` files.

::: warning
Although you can set the `i18n.ns` option of the module instead to define the namespace for `.json` files placed directly in `i18n/`, we do not recommend this legacy approach because it can break localization of text inherited from another module. Use namespace subdirectories instead.

<AposCodeBlock>

  ``` json
  {
    "relatedArticles": "Related articles"
  }
  ```
  <template v-slot:caption>
    /modules/localization/i18n/ourTeam/en.json
  </template>
</AposCodeBlock>

**You do not need to include the namespace name in the contents of the l10n JSON files themselves.** Apostrophe will know the namespace already based on the directory name.

Then when you use the localization keys in template files (or elsewhere), start each key with the namespace:

``` nunjucks
<h2>__t('ourTeam:relatedArticles')</h2>
```

Apostrophe will then treat keys with the namespace differently from the same key without the namespace (`ourTeam:relatedArticles` vs. `relatedArticles`). If someone uses the version *without* the namespace it will not overwrite the version *with* the namespace.

::: warning
Avoid using namespaces that begin with `apos`. The core team uses namespaces that begin with that for official modules, e.g., `aposForm` and `aposSeo`. Using that prefix is not technically forbidden, but it could result in conflicts with official modules. Using the `apostrophe` namespace should definitely be avoided since it is used in Apostrophe core.

As a reminder, namespacing is primarily necessary for *installable modules* and not for project-level localization.

## Localizing the Apostrophe user interface

### Core UI localization

The Apostrophe user interface contains many registered strings, currently localized to English and a few other languages. We will be working to provide more localization files, but if you are interested in adding l10n files to your project for the UI, you are welcome to do that.

To localize Apostrophe's existing user interface strings, we need to create JSON files for the `apostrophe` namespace, which contains all of the phrases for the core UI of Apostrophe. To do that, add JSON files for the locales to a project-level `modules/@apostrophecms/i18n/i18n/apostrophe` directory. The name of the subdirectory determines the namespace. You can also do this in any other module as long as you use an `i18n/apostrophe` subdirectory within that module, keeping these localizations separate from your project-level strings.

Note that separately installed npm modules may use other namespaces, which you can see in their source code. You can create subdirectories for these as well, again keeping these localizations separate from your project-level strings.

In each JSON file, copy the contents of [the Apostrophe core l10n file](https://github.com/apostrophecms/apostrophe/blob/main/modules/@apostrophecms/i18n/i18n/en.json) to get all the keys. You can then start translating each string.

Of course, this can be a lot of work and would likely involve tracking down where strings are used for testing purposes. If you are interested in being part of translating the UI for a language that isn't supported yet, please contact us in [Discord](http://chat.apostrophecms.com) or at [help@apostrophecms.com](mailto:help@apostrophecms.com) so we can coordinate efforts and let the whole community benefit.

### Localizing schema field labels

An important part of the admin UI that often needs localization is the field labels in your schemas. These labels appear throughout the admin interface and should be presented in the editor's preferred language. You can localize these labels using namespaced keys in your schema fields:

<AposCodeBlock>

```javascript
module.exports = {
  fields: {
    add: {
      location: {
        type: 'string',
        label: 'venueStrings:location'
      },
      capacity: {
        type: 'integer',
        label: 'venueStrings:capacity'
      }
    },
    group: {
      basics: {
        label: 'venueStrings:basicInfo',
        fields: [ 'location', 'capacity' ]
      }
    }
  },
  // Configure the namespace for browser use since these labels 
  // appear in the admin UI
  i18n: {
    venueStrings: {
      browser: true  // Makes translations available in the admin UI
    }
  }
};
```
<template v-slot:caption>
/modules/venue/index.js
</template>
</AposCodeBlock>

Then add your translations to the corresponding namespace directory:

<AposCodeBlock>

```json
{
  "location": "Venue Location",
  "capacity": "Maximum Capacity",
  "basicInfo": "Basic Information"
}
```
<template v-slot:caption>
/modules/venue/i18n/venueStrings/en.json
</template>
</AposCodeBlock>

<AposCodeBlock>

```json
{
  "location": "Ubicaci√≥n del lugar",
  "capacity": "Capacidad m√°xima",
  "basicInfo": "Informaci√≥n b√°sica"
}
```
<template v-slot:caption>
/modules/venue/i18n/venueStrings/es.json
</template>
</AposCodeBlock>

Since these labels will appear in the admin UI, we need to tell Apostrophe to make sure they are available to the browser, not just on the server side. To accomplish this, they need to be configured in your module's top-level `i18n` property. This property is separate from your schema configuration and contains options for each namespace used in your module. Currently, the only available option is `browser: true`, which tells Apostrophe to include these translations in the browser-side admin UI bundle. Without this setting, the translations would only be available server-side, which works for public-facing content (like Nunjucks templates) but not for the admin UI where the labels need to be available in the browser. Each namespace that needs to be available in the admin UI must be configured with `browser: true`.

### Localizing custom UI modules

If you are [writing your own extensions to the Apostrophe user interface](../custom-ui.md), you will want to localize strings there just as you would in any module, with the following additions:

* You should use a custom namespace for your strings, to avoid any confusion with our official `apostrophe` namespace.
* You'll need to set `browser: true` for your namespace, as shown below. Doing this in any module will ensure strings for this namespace make it to the browser for the admin UI.
* You'll need to register the text strings in your custom Vue admin UI components.

Here is an example module `index.js` file that sets the `browser: true` flag for a namespace:

<AposCodeBlock>

```javascript
module.exports = {
  // Note this is at top level, not under options
  i18n: {
    venueStrings: {
      browser: true
    }
  }
};
```
<template v-slot:caption>
/modules/venue/index.js
</template>
</AposCodeBlock>

Once that file is in place we can populate the `/modules/venue/i18n/venueStrings` folder with JSON files as described earlier.

To access our phrases in our custom admin UI Vue components, we invoke `this.$t()` when writing Vue methods, or just `$t()` when in the template block. In all other respects invoking `$t()` works the same way as `__t()`, discussed earlier.

::: info
As a reminder, the Vue.js components of the user interface are not connected to any Vue app you may be running for your website visitors. The registration method will not be automatically available outside the UI components.

## Debugging localization

There are two environment variables developers can use to debug during localization.

### `APOS_DEBUG_I18N`

Starting Apostrophe with the `APOS_DEBUG_I18N=1` environment variable will trigger the `i18next` debugging mode. This provides information about the i18n settings that may help resolve issues.

### `APOS_SHOW_I18N`

Using the `APOS_SHOW_I18N=1` environment variable adds emoji indicators to localized strings. For example, the localized string "Images" would be displayed as "üåç Images." These help identify that text in a web page (or logged errors) have been passed through localization. Different emojis indicate additional information.

| Emoji indicator | Meaning |
|-----|----|
| üåç | The string used a localization key and is registered with a value. |
| üï≥Ô∏è | The displayed string is identical to the string passed into localization. It also *does not* seem to be using a l10n namespace.
| ‚ùå | The displayed string is identical to the string passed into localization. It also *does* seem to be using a l10n namespace. Look for a module using the string's namespace (the part before `:`).

For üï≥Ô∏è and ‚ùå indicators those are likely either localization keys that have not yet been registered with values (e.g., not translated) or they are not localization keys at all. Those do not necessarily indicate a problem, but simply are meant to give developers more information if a problem occurs.

================================================================================
COLLECTION: guides
NAV_PATH: Scaling Up > Localization > Dynamic i10n
DOC_PATH: guide/localization/dynamic.md
URL: https://apostrophecms.com/docs/guide/localization/dynamic
================================================================================
# Dynamic content localization

Dynamic content localization (or simply "content localization") refers to the process of translating and customizing Apostrophe site content for different locales. In most cases this is primarily a matter of translation, but it can be much more than that depending on the website.

While [static localization](static.md) involves rendering strings of text depending on the locale, content localization involves using entirely *different database documents* based on the locale. That may seem like technical trivia, but it can be helpful when thinking about the content creation process.

<!-- TODO: Update when the l10n API reference is available. -->
Content l10n also is generally done completely through the user interface. There is an API for localization which will be covered in reference material, but for now we'll focus on:
- the content editor's experience of localization
- developer tools to give visitors and editors navigation between locales ([skip to this](#template-data-for-l10n))

::: info
Localizing content is only possible if the Apostrophe app has configured locales. If you are looking for information on configuring locales, see the [localization landing page](overview.md#configuring-locales). There is also a [glossary section](/reference/glossary.md#localization-terms) of related terms.

## Localizing editable content

Before going into specifics of the user interface, it is worth establishing some of the important concepts and patterns used in Apostrophe's content localization.

Localizing means that **we make a clone of the content for a new locale, then make changes specific to the new locale.** As mentioned earlier, this will often involve translation, switching out photos, adding information, and other content changes. Once the page or piece has a new locale version, website visitors using the new locale will be able to see that document.

> [!TIP]
> **Handling Accents in Slugs**
>By default, Apostrophe preserves accents and diacritical marks when generating slugs from page or piece titles. For example, a page titled "√Ä propos de l'√©quipe" will have the slug `√†-propos-de-l-√©quipe` with accents preserved.
>
>If you prefer to strip accents from slugs for URL compatibility or SEO consistency, you can enable the `stripAccentsFromSlugs` option in the `@apostrophecms/i18n` module.
>
>With this option enabled, slugs will automatically have accents removed during generation (e.g., "√Ä propos de l'√©quipe" becomes `a-propos-de-l-equipe`). If you enable this on an existing site with localized content, you can use the `strip-accents-from-slugs` task to update existing slugs. See the [i18n module reference](/reference/modules/i18n.md#strip-accents-from-slugs) for details.

**Each page or piece in Apostrophe is initially created for only one locale.** Sometimes we don't go any further. It may not be necessary to localize a page about Canadian office holidays into Mandarin, for example. If the page or piece should be available in more locales, *then* we localize it. The only exceptions are [parked pages](/reference/module-api/module-options.md#park) and piece types with the `replicate: true` option.

There are multiple ways to localize a page or piece document depending on your needs. The primary workflow is to use the context menu to re-localize the document. This will allow you to localize documents that are associated through relationships with the page at the same time. This also allows for the use of the automatic translation of existing content using the [`@apostrophecms-pro/automatic-translation` extension](https://apostrophecms.com/extensions/automatic-translation).

As covered below, from within the editor manager you also have the option to use the inline locale switcher located to the left of the user preferences menu. This will create a new document in the selected locale that is linked to the original document, but will not migrate any content.

Let's take a look at the context menu localization using a new page in the Apostrophe demo as an example. In this example we will have three locales configured:

<AposCodeBlock>

  ```javascript
    module.exports = {
      options: {
        locales: {
          en: {
            label: 'English'
            // The default locale since there is no prefix requirement.
          },
          fr: {
            label: 'French',
            prefix: '/fr'
          },
          es: {
            label: 'Spanish',
            prefix: '/es'
          }
        }
      }
    }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/i18n/index.js
  </template>
</AposCodeBlock>

### Creating localized content using the context menu

![The edit menu for this page opened and including a localize option](../../images/l10n/edit-mode-menu.png)

After creating a new page, we want to add any content and widgets that will also be used in other locales. For example, we might want to add a hero widget to the page since all pages would need that content. Once the page is localized you can then edit the content to fit the new locale. For example, the hero image in the English and French locales might differ. But, adding the content to your original page before localizing means that the pages in other locales will share a more unified look. Plus, it reduces the effort of building the page multiple times, once for each locale. Any content addition following the original localization action will not be included across locales automatically. The page can be re-localized, but this will overwrite any edits that have been made in the new locale for that document.

Once we have a page that is ready for localization, we can select "Localize..." from the context menu. For pages, this context menu is present when editing pages and in the page tree. For pieces, this context menu is present both when editing a piece and within the piece manager.

Once the localization item is selected we will be led through a few steps in the "wizard modal" to localize the page.

1. **Choose whether to only localize this page, this page and any related documents, or only related documents.** "Related documents" may include new images you uploaded for this page, pieces that you connected to this page through a widget, or other such [relationships](/guide/relationships.md).
2. **Select the locales that should get clones of this page.**
3. **Confirm whether to localize only new related docs or all related docs** (overriding existing versions) with checkboxes to fine tune this selection.

![The localization wizard modal with options for what docs to localize](../../images/l10n/step1.png)

![The localization wizard modal letting us choose locales](../../images/l10n/step2.png)

![The localization wizard modal confirming settings](../../images/l10n/step3.png)

If you have the automatic-translations extension installed, this screen will also have a checkbox indicating that you want the content translated as it is added to the new locale. Once confirmed, the page now exists in all three locales. We can see this by the updated indicators in the locale chooser. These pages will exist in these new locales as drafts and need to be published to become visible.

![The Apostrophe locale chooser showing the page in all locales](../../images/l10n/locale-chooser-updated.png)

We can then switch to another locale, make edits specific to that locale, and publish.

![The original page in the French locale, translated](../../images/l10n/fr-localized-page.png)

### Using the inline locale switcher
![The page editor modal with a new "Locale: english" indicator at the top](../../images/l10n/locale-picker.gif)

The inline locale switcher located to the left of the user preferences menu can allow you to easily edit the version of the document that has been localized to another locale without having to switch to that locale. It can also create a new, blank version of the document in another locale. If we haven't localized a document to another locale, selecting that locale from the inline switcher will create a new document of that type without **any** added content. However, if you were to examine the database, you would see that your original document and the newly created one share the same ID, minus the locale. In some cases, this may be the preferred workflow to create a set of pages across multiple locales that are going to differ greatly in content or be populated programmatically.

![The confirmation dialog for switching locales with unsaved changes](../../images/l10n/inline-confirmation.png) If a document has any changes that are unsaved when we try to switch locales using the inline switcher, we will be prompted to either discard any unsaved changes and switch locales immediately or save changes as a draft document and localize. Clicking on the close button in the upper right will completely cancel the operation and return you to the editing modal of the page in the current locale.

Once in the document in the new locale, you can edit it as you normally would. When you are finished with editing there will be the usual choices. If you elect to not preview the document and just save as a draft or publish, you will be returned to the original locale where you started the editing operation. So if you are editing a page in the Spanish locale, switch to the French locale using the inline switcher, and then choose to publish any edits made to that document without previewing, you will be returned to the Spanish locale. If you elect to preview the document, you will be switched to the new locale.

#### Nested content
As outlined, localizing a document that has relationships from the context menu allows for the localization of those related documents to the new locale. After that, if you switch to editing in another locale using the inline switcher and then edit one of the documents connected through the relationship field, you will still see the inline switcher indicating the new locale you are editing in. However, the inline switcher will be disabled. If you want to edit these documents in a different locale you will have to edit the original document, not through the relationship.

## Template data for l10n

The Apostrophe user interface has a locale chooser for editors, but visitors to the website won't have access to that. We typically need to provide a way for visitors to switch to a version of the page they are on, but in a different locale. There are two properties on the `data` object in templates to help with this.

### `data.locale`

`data.locale` is simple. It will render as the locale code for the active locale. So if you're in the English (`'en'`) locale, it will return `'en'`.

### `data.localizations`

This property provides much more information. It will be an array of objects that include information about the current page context (or piece, when on a show page) in all the active locales. It will include special properties that can help build a locale switcher for visitors:

| Locale property | Description |
| ------- | ------- |
| `locale` | The locale code (e.g., `'en'`, `'es'`) |
| `label` | The configured label for the locale (e.g., "English", "Spanish") |
| `available` | A boolean value indicating whether the page has been added to this locale |
| `current` | A boolean value indicating whether this is the currently displayed locale |
| `_url` | An API route that will return the page's URL in the locale (if it exists there) |

The `_url` property is an API route, and not the actual URL, to avoid making too many requests. If a website had 20 locales configured then Apostrophe would need to make 20 requests to get the actual page URL in each one. The API route is predictable and redirects to the actual URL when hit.

Here is an example of `data.localizations` for the page from the screenshots above.

```javascript
[
  {
    _id: 'cksqi1ye1000mof3rdgtmvn0y:en:draft',
    title: 'Localized page üá¨üáß',
    slug: '/localized-page',
    type: 'default-page',
    visibility: 'public',
    aposLocale: 'en:draft',
    aposMode: 'draft',
    available: true,
    _url: '/api/v1/@apostrophecms/page/cksqi1ye1000mof3rdgtmvn0y:es:draft/locale/en',
    locale: 'en',
    label: 'English',
    homePageUrl: 'http://localhost:3000/'
  },
  {
    _id: 'cksqi1ye1000mof3rdgtmvn0y:fr:draft',
    title: 'Page localis√©e üá´üá∑',
    slug: '/localized-page',
    type: 'default-page',
    visibility: 'public',
    aposLocale: 'fr:draft',
    aposMode: 'draft',
    available: true,
    _url: '/api/v1/@apostrophecms/page/cksqi1ye1000mof3rdgtmvn0y:es:draft/locale/fr',
    locale: 'fr',
    label: 'French',
    homePageUrl: 'http://localhost:3000/fr/'
  },
  {
    _id: 'cksqi1ye1000mof3rdgtmvn0y:es:draft',
    title: 'P√°gina localizada üá™üá∏',
    slug: '/localized-page',
    type: 'default-page',
    visibility: 'public',
    aposLocale: 'es:draft',
    aposMode: 'draft',
    available: true,
    _url: '/api/v1/@apostrophecms/page/cksqi1ye1000mof3rdgtmvn0y:es:draft/locale/es',
    current: true,
    locale: 'es',
    label: 'Spanish',
    homePageUrl: 'http://localhost:3000/es/'
  }
]
```

### Sample locale switcher template

Here is an example of using the `data.localizations` array to generate a locale switcher for a page.

``` nunjucks
<div class="locales">
  {# A button to open the list of locales (nothing special here) #}
  <button class="locales__toggler" data-locales-toggle aria-expanded="false">
    Toggle locales üåê
  </button>
  <ul class="locales__list" data-locales hidden>
    {# List of locales, looping over data.localizations #}
    {% for localization in data.localizations %}
      <li class="locales__item">
        {#
          Linking the locale name only when it exists in the locale and it's
          not the current locale
        #}
        {% if localization._url and not localization.current %}
          <a href="{{ localization._url or localization.homePageUrl }}">
        {% endif %}
        {# Using both the label and the locale code #}
        {{ localization.label }} ({{ localization.locale }})
        {% if localization._url and not localization.current %}
          </a>
        {% endif %}
      </li>
    {% endfor %}
  </ul>
</div>
```

================================================================================
COLLECTION: guides
NAV_PATH: Scaling Up > Caching
DOC_PATH: guide/caching.md
URL: https://apostrophecms.com/docs/guide/caching
================================================================================
# Caching

## Express Cache on Demand

Apostrophe uses [express-cache-on-demand](https://www.npmjs.com/package/express-cache-on-demand) to cache content under high load. This feature allows for similar and concurrent requests to compute the result only once. If multiple visitors request the same information at the same time, we load the content once and send it to both visitors. This works for regular page requests, and also for REST API GET requests when no user or session are involved.

Enabled by default, this feature can be disabled by setting `enableCacheOnDemand` to `false` in the options of the [`@apostrophecms/express` module](/reference/modules/express.html#options).

## Specifying a Cache Lifetime

While cache-on-demand is enabled by default, Apostrophe also supports sending cache headers to retain pages and REST API GET request responses for a specified amount of time. Since this means a user could see outdated content, up to the specified cache lifetime, it is not enabled by default.

Just as with `express-cache-on-demand`, Apostrophe always sends `Cache-Control: no-store` in the case of a logged-in user or a user with a populated `req.session`.

To enable the feature for ordinary page responses, set the `cache` option of the `@apostrophecms/page` module:

<AposCodeBlock>

```javascript
options: {
  cache: {
    page: {
      maxAge: 6000
    }
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

To also enable it for GET REST API responses for pages, set the `api` subproperty as well:

<AposCodeBlock>

```javascript
options: {
  cache: {
    page: {
      // Specified in seconds
      maxAge: 6000
    },
    api: {
      // Specified in seconds
      maxAge: 3000
    }
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

To enable it for GET REST API responses for a particular piece type, you can set the `cache` option for that module. Here the example is a project-level module named `article`:

<AposCodeBlock>

```javascript
extend: '@apostrophecms/piece-type',
options: {
  cache: {
    api: {
      // Specified in seconds
      maxAge: 3000
    }
  }
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

You can also enable it for all piece types by enabling it for `@apostrophecms/piece-type`:

<AposCodeBlock>

```javascript
options: {
  cache: {
    api: {
      // Specified in seconds
      maxAge: 3000
    }
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/piece-type/index.js
</template>
</AposCodeBlock>

Since custom piece types extend this module, configuring it at project level configures all of them with a new default. It is still possible to override the `cache` option in the individual modules.

## Advanced Cache Invalidation

The purpose of this feature is to generate `ETag` headers that allow the browser to check whether a page or piece has changed, reducing the amount of work done on the server. The actual caching is not performed in ApostropheCMS itself. To gain the full benefit of this strategy, you must implement a cache at the CDN level via a service such as CloudFlare, or do so in your reverse proxy server, e.g. `nginx`. Otherwise caching will only take place in individual web browsers.

- The cache of ordinary page responses is automatically invalidated when corresponding pages are modified
- The cache of `getOne` REST API page and piece responses, as well as `show` and `index` piece pages responses is automatically invalidated when corresponding documents are modified
- Editing a related document or a reverse related one will also trigger a cache invalidation

To enable the feature for ordinary page responses, set the `etags` option of the `@apostrophecms/page` module:

<AposCodeBlock>

```javascript
options: {
  cache: {
    page: {
      // Specified in seconds
      maxAge: 6000,
      etags: true
    }
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

To also enable it for GET REST API responses for pages, set it in the `api` subproperty as well:

<AposCodeBlock>

```javascript
options: {
  cache: {
    page: {
      // Specified in seconds
      maxAge: 6000,
      etags: true
    },
    api: {
      // Specified in seconds
      maxAge: 3000,
      etags: true
    }
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

To enable it for GET REST API responses for a particular piece type, you can set the `etags` option for that module:

<AposCodeBlock>

```javascript
extend: '@apostrophecms/piece-type',
options: {
  cache: {
    api: {
      // Specified in seconds
      maxAge: 3000,
      etags: true
    }
  }
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

You can also enable it for all piece types by enabling it for `@apostrophecms/piece-type`:

<AposCodeBlock>

```javascript
options: {
  cache: {
    api: {
      // Specified in seconds
      maxAge: 3000,
      etags: true
    }
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/piece-type/index.js
</template>
</AposCodeBlock>

Please note that even with the advanced cache invalidation system there will always be situations where caching allows a website visitor to see old content. Page content might differ based on an async component that fetches modified documents, or API calls to a third party service, or even the time of day.  
For this reason `maxAge` should always be set to a reasonable value to ensure the served content is never too old. Content is never cached for logged-in users.

================================================================================
COLLECTION: guides
NAV_PATH: Scaling Up > Logging
DOC_PATH: guide/logging.md
URL: https://apostrophecms.com/docs/guide/logging
================================================================================
# Logging in Apostrophe

Logging is a fundamental aspect of any web application, especially those that require user authentication. It serves as a vital tool for monitoring system behavior, troubleshooting issues, and maintaining security. By recording various events and transactions within the system, logs provide insights into user interactions, system performance, and potential errors. 

Unlike traditional unstructured logs, structured logs provide a consistent and machine-readable format, making it easier to analyze and monitor user activities and system performance. This is particularly important for Apostrophe projects with login features, as it facilitates tracking of authentication attempts, quicker detection of suspicious activities, and helps ensures the security and integrity of user data. By employing structured logging, developers and system administrators can quickly identify and respond to potential issues, enhancing both the user experience and the overall stability of the website.

## Log notifications

Apostrophe has multiple methods for logging simple messages available through the [`@apostrophecms/util` module](/reference/modules/util.html#logging-utilities). These include `log(msg)`, `warnDev(msg)`, and `warnDevOnce(name, msg)`. The latter two of these methods allow you to log a warning only when `process.env.NODE_ENV` is not `production`. The `warnDevOnce()` allows the error to be named, and will only log a warning once per unique name when the site isn't in production, even if the conditions for emitting the warning occur multiple times. These can be called from any module using `self.apos.util.<method name>`, for example, `self.apos.util.log('My log message')`. By default, these methods are wrappers for the `console.log()` and `console.warn()` methods, and like those methods, you can use substitution strings within the message being passed. There are also four additional legacy methods for `info(msg)`, `debug(msg)`, `warn(msg)`, and `error(msg)`, but these have been deprecated in favor of the methods exposed by the `@apostrophecms/module` module.

All Apostrophe modules provide four methods that can provide more detailed logging information than the methods provided by the `util` module. The `logInfo()`, `logDebug()`, `logWarn()`, and `logError()` methods are available on `self`. All of these methods require an `eventType` argument. This argument provides a name for the notification being logged. For example, the `@apostrophe/login` module emits an `eventType` of `incorrect-username` if there is a login attempt with an unknown user name: 

``` javascript
self.logInfo('incorrect-username', {
  username,
  ip,
  attempts: attempts + 1,
  requestId
});
```

In addition to the required `eventType`, these methods can take three optional arguments. Following the `eventType` they can each take an optional message string. This message string will be included, along with the module name that is emitting the notification. As a last argument, each can optionally take an object containing any number of key:value properties. These will be deconstructed in the final log notification.

For example:

``` javascript
self.logError('event-type', 'notification message', { key: 'value' });
```
Will log:
``` sh
'current-module-name: event-type: notification message'
{
  type: 'event-type',
  severity: 'error',
  module: 'current-module-name',
  key: 'value'
}
```

By default, in production, this will format as a single line to ease parsing with common tools. In development, for better readability, it will log as multiple lines as shown here. See the section on custom loggers below.

Finally, you can further enrich your logs by passing the optional `req` object as the first argument. This will add the `originalUrl`, `path`, `method`, `ip`, `query`, and `requestId` from this object.

``` javascript
self.logError( req, 'event-type', 'notification message', { key: 'value' });
```

## The `@apostrophecms/log` module

Apostrophe provides structured logging through the [`@apostrophecms/log` module](/reference/modules/log.html). This module adds several options, including the `logger` option that lets you specify a function or object with at least `info`, `debug`, `warn` and `error` methods. This allows you to pass notifications to 3rd-party logging packages, such as `pino`, `winston`, and `bunyan`, to name three popular packages. It can take other functions, including a `destroy()` function, which will be awaited just prior to project shut-down. If the logger option is not set, then notifications are sent to standard error via `console.error` (warn, error) or to standard output via `console.log` (info, log, debug).

The module includes an option called `messageAs`, which allows you to customize how messages are handled. By default, the logger receives the message string and the object as separate arguments. However, if you set the `messageAs` option to a string, the module will instead insert the message string into the object, using that specific property name as the key. This feature is designed to support certain logging packages that require this specific format. For instance, the `pino` logging package expects the log object to have a `"msg": "message string"` property. 

Lastly, the `filter` option in the module gives you control over which notifications are logged. By default, in `production`, only notifications with a severity of `warn` or `error` will be logged, otherwise, notifications of all severity will be logged. The `filter` option accepts an object containing named sub-objects, where each name refers to a specific module or is a wildcard symbol '*', which matches any module. Inside these sub-objects, you can define criteria based on severity levels (such as `debug`, `info`, `warn`, and `error`) and the names of specific event types to determine which notifications will be emitted.

- The `severity` key allows you to specify the severity levels you want to include, by taking an array of strings representing those levels.
- The `events` key lets you list the specific event types you want to include, by taking an array of strings representing those types.
- If you want to emit all notifications, even in production, you can simply set `'*': true` within the `filter` object.

Note that these filters will not impact log notifications that are emitted by the `@apostrophecms/util` methods such as `self.apos.util.info('message')`.

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    logger: 'pino',
    messageAs: 'msg',
    filter: {
      // By module name, or *. We can specify any mix of severity levels and specific event types,
      // and entries are kept if *either* criterion is met
      '*': {
        severity: [ 'warn', 'error' ]
      },
      '@apostrophecms/login': {
        events: [ 'incorrect-user', 'incorrect-password', 'complete' ]
      }
    }
  }
};
```

<template v-slot:caption>
modules/@apostrophecms/log/index.js
</template>
</AposCodeBlock>

So in this example, Apostrophe would log warning and error notifications from **all** modules, including the `@apostrophecms/login` module, and even though they have a severity of `info`, it would additionally log the `incorrect-user`, `incorrect-password` and `complete` event types from that module.

These filters can also be passed through an environment variable, `APOS_FILTER_LOGS`. For example, the filters passed through this `index.js` example would be:

``` sh
export APOS_FILTER_LOGS='*:severity:warn,error;@apostrophecms/login:events:incorrect-user,incorrect-password,complete'
```

Values passed through the environmental variables will trump any filter values assigned at project level.

## Login attempt logging
The `@apostrophecms/login` module has four `self.logInfo()` calls that are made based on the success or failure of a login attempt. The `incorrect-username` event is logged if an attempt is made to login with a user name that is not in the database. The `incorrect-password` event is logged if an attempt to login is made with a correct user name, but an incorrect password for that user. The `correct-password` event is logged if both the user name and password are correct. Because of additional login options, like time-based one-time passwords, this does not indicate that login was successful. Finally, the `complete` event is logged once login is successful. All of these events also add several pieces of information into the log object. The `username` from `req.body.username`, `ip` from `req.ip`, and number of login attempts as `attempts`.

Example output when using Pino as configured below:

``` sh
[09:54:51.333] INFO (82299): @apostrophecms/login: correct-password
    module: "@apostrophecms/login"
    type: "correct-password"
    severity: "info"
    username: "admin"
    ip: "::1"
    attempts: 0
    requestId: "cll3sl5sd000gi3lsch2j1t5v"
[09:54:51.336] INFO (82299): @apostrophecms/login: complete
    module: "@apostrophecms/login"
    type: "complete"
    severity: "info"
    url: "/api/v1/@apostrophecms/login/login"
    path: "/api/v1/@apostrophecms/login/login"
    method: "POST"
    ip: "::1"
    query: {}
    requestId: "cll3sl5sd000gi3lsch2j1t5v"
    username: "admin"
    attempts: 0
```
::: info
The `ip` here `::1` because the project is being run on `localhost:3000`

## Popular package set-up

### Pino
This is a simple set-up for [`Pino`](https://github.com/pinojs/pino), please consult the documentation for your specific needs.
Installing:

```sh
npm install pino
```
And optionally:

```sh
npm i pino-pretty
```

<AposCodeBlock>

``` javascript
const { pino } = require('pino');

module.exports = {
  options: {
    logger: pino({
      transport: {
        targets: [
          {
            // output to stdout and stderr
            level: 'debug',
            // if optional pino-pretty package installed
            target: 'pino-pretty',
            options: {}
          },
          {
            // sends error notifications to the error.log file
            level: 'error',
            target: 'pino/file',
            options: {
              destination: './error.log',
              // create the destination file if it does not exist
              mkdir: true
            }
          },
          {
            // sends all notifications to the combined.log file
            level: 'debug',
            target: 'pino/file',
            options: {
              destination: './combined.log',
              mkdir: true
            }
          }
        ]
      }
    }),
    messageAs: 'msg'
  }
};

```

<template v-slot:caption>
/modules/@apostrophecms/log/index.js
</template>
</AposCodeBlock>

### Winston

This is a simple set-up for [`Winston`](https://github.com/winstonjs/winston), please consult the documentation for your specific needs.
Installing:

```sh
npm install winston
```

<AposCodeBlock>

``` javascript
const { createLogger, format, transports } = require('winston');
module.exports = {
  options: {
    logger: createLogger({
      level: 'info',
      format: format.combine(
        format.timestamp(),
        format.json()
      ),
      transports: [
        // logs everything to the console
        new transports.Console({
          level: 'verbose',
          format: format.combine(
            format.colorize(),
            format.simple()
          )
        }),
        // logs errors only to error.log
        new transports.File({
          filename: 'error.log',
          level: 'error'
        }),
        // logs info and above to combined.log
        new transports.File({
          filename: 'combined.log'
        })
      ]
    }),
    messageAs: 'message'
};

```

<template v-slot:caption>
/modules/@apostrophecms/log/index.js
</template>
</AposCodeBlock>

### Bunyan

This is a simple set-up for [`Bunyan`](https://github.com/trentm/node-bunyan), please consult the documentation for your specific needs.
Installing:

```sh
npm install bunyan
```

<AposCodeBlock>

``` javascript
const { createLogger } = require('bunyan');
module.exports = {
  options: {
    logger: createLogger({
      name: 'apostrophe',
      streams: [
        {
          // log TRACE and above to stdout
          level: 'trace',
          stream: process.stdout
        },
        {
          // log INFO and above to a file
          level: 'info',
          path: './combined.log'
        },
        {
          // log ERROR and above to a file
          level: 'error',
          path: './error.log'
        }
      ]
    }),
    messageAs: 'msg'
  }
};

```

<template v-slot:caption>
modules/@apostrophecms/log/index.js
</template>
</AposCodeBlock>

================================================================================
COLLECTION: guides
NAV_PATH: Scaling Up > Profiling
DOC_PATH: cookbook/opentelemetry.md
URL: https://apostrophecms.com/docs/cookbook/opentelemetry
================================================================================
# Profiling ApostropheCMS with OpenTelemetry

Sometimes developers need insight into performance issues with their websites. [OpenTelemetry](https://opentelemetry.io/) is a widely adopted, open source solution for collecting performance "traces" that provide insight into where the time is going when a website responds to a request.

Here's the good news: ApostropheCMS has built-in support for OpenTelemetry tracing. So all we need to do is install the OpenTelemetry SDK in our Apostrophe-powered website project and set up a compatible "backend" in which to view the reports. [Jaeger](https://www.jaegertracing.io) is one of the simplest and best backends available.

Here is a quick guide to enabling OpenTelemetry tracing for ApostropheCMS with the [Jaeger backend](https://www.jaegertracing.io/docs/2.8/getting-started/). By the end of this guide, we'll be able to see not just how long requests take, but how much of the time in each request is spent on MongoDB queries, template rendering, Apostrophe events and more. This can be a helpful starting point for optimizing project code.

## 1. Install the required dependencies

Install the required dependencies in your ApostropheCMS project:

```sh
npm install @opentelemetry/sdk-node \
  @opentelemetry/auto-instrumentations-node \
  @opentelemetry/semantic-conventions \
  @opentelemetry/exporter-trace-otlp-http \
  @opentelemetry/resources
```

**Also make sure `apostrophe` is updated to at least version 3.18.0, preferably the newest 4.x release available.**

## 2. Install Jaeger

The easiest way to install and run Jaeger in our development environment is via Docker image. Here are the most basic steps to take, but if you prefer you may follow the [Jaeger Getting Started Guide](https://www.jaegertracing.io/docs/2.8/getting-started/).

::: warning
First ensure you have [Docker installed](https://docs.docker.com/get-docker/).

```sh
docker --version
```

Now we can install and launch Jaeger in the background with a single command:

```sh
docker run -d --name jaeger \
  -p 16686:16686 \
  -p 4317:4317 \
  -p 4318:4318 \
  -p 5778:5778 \
  -p 9411:9411 \
  cr.jaegertracing.io/jaegertracing/jaeger:2.8.0
```

Jaeger will keep running in the background. We can stop it later with:

```sh
docker stop jaeger && docker rm jaeger
```

Now we can open <span v-pre>`http://localhost:16686`</span> in the browser to ensure Jaeger is working properly.

## 3. Configure OpenTelemetry

There are various ways to configure and integrate OpenTelemetry in a project. We think this is the cleanest way.

Create a `telemetry.js` file in the project root:

<AposCodeBlock>

``` js
import { NodeSDK } from '@opentelemetry/sdk-node';
import { resourceFromAttributes } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } from '@opentelemetry/semantic-conventions';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import pkg from './package.json' with { type: 'json' };

// 1. Add the application metadata (resource)
const resource = resourceFromAttributes({
  [ATTR_SERVICE_NAME]: pkg.name,
  [ATTR_SERVICE_VERSION]: pkg.version
});

// 2. Initialize the OTLP exporter with correct endpoint
const traceExporter = new OTLPTraceExporter({
  url: 'http://localhost:4318/v1/traces',
  headers: {},
});

// 3. Initialize the SDK
const sdk = new NodeSDK({
  resource,
  traceExporter,
  instrumentations: [getNodeAutoInstrumentations()]
});

// 4. The shutdown handler
const shutdown = async () => {
  await sdk
    .shutdown()
    .then(
      () => console.log('OpenTelemetry stopped'),
      (err) => console.log('Error shutting down OpenTelemetry', err)
    );
};

export default {
  sdk,
  shutdown
};
```
<template v-slot:caption>
telemetry.js
</template>
</AposCodeBlock>

Now we'll need to refactor `app.js` a little bit to connect OpenTelemetry with Apostrophe:

<AposCodeBlock>

``` js
// The Apostrophe bootstrap
import apostrophe from 'apostrophe';
import telemetry from './telemetry.js';
import { trace } from '@opentelemetry/api';

const { sdk, shutdown } = telemetry;

// Move Apostrophe configuration to a variable, rather than directly
// invoking the apostrophe function

const config = {
  shortName: 'myApp',
  // Provide our shutdown handler
  beforeExit: process.env.APOS_OPENTELEMETRY ? shutdown : null,
  modules: {
    // ... Our regular module configuration comes here
  }
};

// Invoke based on APOS_OPENTELEMETRY environment variable
if (process.env.APOS_OPENTELEMETRY) {
  // Start the sdk
  sdk.start();
  console.log('opentelemetry started');
  // bootstrap apostrophe
  apostrophe(config);
} else {
  apostrophe(config);
}
```
<template v-slot:caption>
app.js
</template>
</AposCodeBlock>

The important bits of this change are:

1. Capture the apostrophe configuration in a variable
2. Provide a `shutdown` handler for `telemetry.js` as the value of the Apostrophe `beforeExit` configuration option 
3. Start Apostrophe after OpenTelemetry has been started

## 4. Start the application

Be sure that the Jaeger backend is running (step 2) and open http://localhost:16686 in the browser. 

Start the app:

```sh
APOS_OPENTELEMETRY=1 node app
```

After Apostrophe is fully started, refresh the Jaeger UI and you should see some data shown (give it some time).

Open http://localhost:3000 and go check the Jaeger UI for `GET` operations (again, give it some time and refresh).

You can trace command line tasks as well:

```sh
APOS_OPENTELEMETRY=1 node app @namespace/module:taskName
```

## Bonus - Developer's Quality of Life

You may optimize your development experience with a few CLI and npm scripts.

Create the file `jaeger` in your project root and make it executable:

```sh
chmod +x jaeger
```

Add contents to it:

```bash
#!/usr/bin/env bash

set -e

_ACTION="$1"
if [[ -z "$1" ]]; then
  _ACTION='help'
fi

# Start
function _start {
  docker run --rm --name jaeger \
  -p 16686:16686 \
  -p 4317:4317 \
  -p 4318:4318 \
  -p 5778:5778 \
  -p 9411:9411 \
  cr.jaegertracing.io/jaegertracing/jaeger:2.8.0
}

# Stop
function _stop {
  docker stop jaeger
  docker rm jaeger
}

function _help()
{
  echo
  echo 'USAGE: '
  echo './scripts/jaeger COMMAND'
  echo
  echo 'COMMANDS:'
  echo '  start'
  echo '      Start Jaeger in Docker container'
  echo '  stop'
  echo '      Stop Jaeger container and cleanup'
  echo '  help'
  echo '      Show help'
  return 1
}

if [[ $_ACTION = 'start' ]]; then
  echo "Start Jaeger"
  _start
  echo "Jaeger is running at http://localhost:16686"
elif [[ $_ACTION = 'stop' ]]; then
  echo "Shut down Jaeger"
  _stop
else
  _help
fi
```

Open your `package.json` and add the following scripts at the end of the `scripts` section:

``` json
  "scripts": {
    "start:telemetry": "APOS_OPENTELEMETRY=1 node app",
    "jaeger:start": "./jaeger start",
    "jaeger:stop": "./jaeger stop"
  },
```

Now you can start it:

```sh
npm run jaeger:start
npm run start:telemetry
```

and stop it:

```sh
npm run jaeger:stop
```

## Bonus - trace your own application

You can use the tracing API of the OpenTelemetry to trace your own code. Apostrophe exposes `self.apos.telemetry`. It contains the OpenTelemtry API, some useful helpers and the tracer used internally by the Apostrophe core. You could use it or you could add application level OpenTelemetry API dependency and trace your code as you see fit.

A common scenario using an Apostrophe helper:
``` js
// Somewhere in your application code or module.
const telemetry = self.apos.telemetry;
// Create an OpenTelemetry span, that is "connected" (child) to
// the current active context
const span = telemetry.startSpan('yourSpanName');
span.setAttribute('some', 'attribute');

// Do some work...

// Create a child span of the span above
const child = telemetry.startSpan('yourChildSpanName', span);
child.setAttribute('another', 'attribute');
child.addEvent('some event');

// Do some wore work ...

// End the child span with appropriate status code
child.setStatus({ code: telemetry.api.SpanStatusCode.OK });
child.end();

// End the parent span with appropriate status code
span.setStatus({ code: telemetry.api.SpanStatusCode.OK });
span.end();
```

You can inspect [the telemetry namespace exports here](https://github.com/apostrophecms/apostrophe/blob/main/lib/opentelemetry.js).

An example of [an internal implementation is available here](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/module/lib/events.js#L29).

================================================================================
COLLECTION: guides
NAV_PATH: Scaling Up > Sending Email
DOC_PATH: guide/sending-email.md
URL: https://apostrophecms.com/docs/guide/sending-email
================================================================================
# Sending email from your Apostrophe project

Any module in Apostrophe can send email by calling its own [`self.email()`](/reference/modules/module.html#featured-methods) method and the popular [nodemailer](https://nodemailer.com/) package. However, prior to sending an email using this method, either the `nodemailer` option of the `@apostrophecms/email` module needs to be configured, or another Nodemailer transport needs to be defined as `self.transport` in that same module. The `nodemailer` option will pass any values to the [`createTransport` method](https://nodemailer.com/about/) of the nodemailer app.

Due to the difficulty of ensuring that emails are delivered reliably, we recommend that you utilize a delivery provider. However, if your server is set up with both [DKIM](https://dkim.org/) and [SPF](https://en.wikipedia.org/wiki/Sender_Policy_Framework) ([DMARC](https://en.wikipedia.org/wiki/DMARC)) configured correctly, you can easily use the `sendmail` server app.

## Configuring to use `sendmail`

If your server has `sendmail` installed, `nodemailer` can use the service to send emails by setting the `sendmail` property to `true`. Both the `newline` and `path` properties may also need to be configured. By default, `newline` is set to `unix`(\<LF\> only), but it also accepts `windows`(\<LF\> and \<CR\>). The `path` property defaults to `usr/bin/sendmail`. If this isn't how your server is configured, then the correct path needs to be passed in.

### Example

<AposCodeBlock>

```js
module.exports = {
  options: {
    nodemailer: {
      // enables the usage of `sendmail`
      sendmail: true,
      // changes the path to the `sendmail` app
      path: 'user/sbin/sendmail'
    }
  }
};

```
<template v-slot:caption>
/modules/@apostrophecms/email
</template>

</AposCodeBlock>

## Configuring using generic SMTP

Using a 3rd-party email delivery provider like Gmail, or Mailgun will probably better guarantee delivery without the email being either bounced or sent to spam. Most providers use SMTP. In fact, the `sendmail` server application uses SMTP. It just performs most of the configuration for you automatically. To configure sending through other providers, you typically need to supply three different parameters to the `nodemailer` option through an object - the 'host', 'port', and 'auth' parameters. Depending on the host there are a number of other options that could be passed as outlined in the [`nodemailer` documentation](https://nodemailer.com/smtp/).

### Example

<AposCodeBlock>

```js
module.exports = {
  options: {
    nodemailer: {
      service: 'gmail',
      host: "smtp.gmail.com.com",
      auth: {
        // substitute in your actual Gmail credentials
        user: "username@gmail.com",
        pass: "password"
      }
    }
  }
};

```
<template v-slot:caption>
/modules/@apostrophecms/email
</template>

</AposCodeBlock>

::: info
When using Gmail as the SMTP email relay, you need to make sure that the "from" address of your email matches the user name added to the nodemailer configuration. You will likely also have to allow [less secure apps](https://myaccount.google.com/lesssecureapps) and [disable Captcha]( https://accounts.google.com/DisplayUnlockCaptcha) from your Google account dashboard.

## Using specific service APIs

The `nodemailer` app has four built-in transports - `sendmail`, `SES` - for sending by AWS SES, and the `stream` and `jsonTransport` transports - which are used for testing or passing data to another nodemailer extension for processing as detailed in the [nodemailer documentation](https://nodemailer.com/transports/stream/). You can create your own custom transport using the `nodemailer` [transport API documentation](https://nodemailer.com/plugins/create/#transports), or use one of the many transport plugins that are available. These can either be found on the provider's site or by [searching NPM](https://www.npmjs.com/search?q=nodemailer%20transport). Each transporter will have slightly different parameters configured through an object that is then passed along with the specific transport.

### Example for Mailgun

<AposCodeBlock>

```js
const mg = require('nodemailer-mailgun-transport');

const auth = {
  auth: {
    // key supplied with your Mailgun account
    api_key: 'key-1234123412341234',
    //one of your domains listed at your https://app.mailgun.com/app/sending/domains
    domain: 'sandbox.domain.com'
  }
};

module.exports = {
  options: {
    nodemailer: mg(auth)
  }
};

```
<template v-slot:caption>
/modules/@apostrophecms/email
</template>

</AposCodeBlock>

## Sending email from a module
Once the `@apostrophecms/email` module is configured, email can be sent from any module using the `self.email(req, template, data, options)` method.

The first parameter passed to this method is the `req`.

The next parameter, `template`, takes the name of a Nunjucks template that will make up the body of the email. This template should be located in the `views` template of the module. The method will pass this HTML template, as well as an automatically generated plain text version, to the `nodemailer` transport object.

The `data` parameter takes an object that will be passed to the Nunjucks template for populating any customized fields. It can be accessed through `data.property` within the template.

The final parameter, `options`, should be an object that contains the information for the email header. This is typically `from`, `to`, and `subject`.  The `from` parameter can alternatively be given a default by setting the `{ email: { from: 'some@address.com' } }` option in the module that is calling `self.email`, or by setting the `from: 'some@address.com'` option (not nested in a parent option) on the `@apostrophecms/email` module itself.  The `from` address used will then be (1) the `from` property given in the final parameter to `sendEmail`, or (2) the `from` subproperty of the `email` option configured on the module sending the email, or (3) the `from` option configured on the `@apostrophecms/email` module, in that order.

### Example usage setting `from` in `sendEmail`

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    lable: 'article',
    pluralLabel: 'articles'
  },
  // additional module code
  handlers(self) {
    return {
      'afterSave': {
        async sendEmail(req, piece) {
          const options = {
            from: 'admin@mysite.com',
            to: 'editors@mysite.com',
            subject: 'New Article added'
          };
          try {
            await self.email(req, 'email.html', { piece }, options);
          } catch (err) {
            self.apos.util.error('email notification error: ', err);
          }
        }
      }
    }
  }
};
```

<template v-slot:caption>
/modules/article/index.js
</template>

</AposCodeBlock>


<AposCodeBlock>

``` nunjucks
<h1>A new article has been added to the site</h1>
<p>Here is the blurb</p>
{{ data.piece.title }}
{% area data.piece, 'blurb' %}
```

<template v-slot:caption>
  /modules/article/views/email.html
</template>

</AposCodeBlock>

In this example, we are creating a custom piece type that implements an article. The `afterSave` server event property is being added to the `handlers()` function. This event is emitted any time this custom module saves a new article and runs the function that is being passed in as a value. This function, in turn, sends out an email to the site editors. The data coming from the piece is passed into the `email.html` template through the `data` argument to add the title and blurb for the editors to review.

### Example usage setting `from` in the module configuration

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    // Allow password reset, requires that the `@apostrophecms/email` module
    // is configured
    passwordReset: true,
    // Limit validity of reset token to 12 hours, 48 is the default
    passwordResetHours: 12,
    // Set specific `from` address for password reset
    // This will override a default password set in the `@apostrophecms/email`
    // module configuration
    email: {
      from: '"Password Assistance" <password.assistance@mysite.com>'
    }
  },
}
```
<template v-slot:caption>
  modules/@apostrophecms/login
</template>

</AposCodeBlock>

In this example, we are setting a unique `from` address for the e-mail that is sent to users when they want to reset their login password. This address will override any address set in the `@apostrophecms/email` options. Note, that if you pass a `from` property in the `options` object of `sendEmail()` it will **not* be overridden by this module option. 

## Debugging email delivery without sending

The `self.email()` method returns `info`. This can be used to determine if message handoff to the mailing service has been completed successfully. Note: this does not mean that message delivery will complete successfully. The email could still be rejected en route or by the receiving server.

The returned data can also be used along with the `stream` transporter to ensure that the header and body of the email have been correctly constructed without sending the email.

### Stream example

<AposCodeBlock>

```js
module.exports = {
  options: {
    nodemailer: {
      // enables the usage of the `stream` transport
      streamTransport: true
    }
  }
};
```

<template v-slot:caption>
/modules/@apostrophecms/email
</template>
</AposCodeBlock>

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    lable: 'article',
    pluralLabel: 'articles'
  },
  // additional module code
  handlers(self) {
    return {
      'afterSave': {
        async sendEmail(req, piece) {
          const options = {
            from: 'admin@mysite.com',
            to: 'editors@mysite.com',
            subject: 'New Article added'
          };
          try {
            const info = await self.email(req, 'email.html', { piece }, options);
          }
          console.log(info.envelope);
          console.log(info.messageId);
          info.message.pipe(process.stdout);
        }
      }
    }
  }
};
```

<template v-slot:caption>
/modules/article/index.js
</template>

</AposCodeBlock>

## Triggering email from a route

In addition to using `handlers()` to trigger email delivery, you can use `apiRoutes()`. This can be triggered by any selected HTTP request, like submission of FormData through POST, or retrieval of a specified payload with GET. All of the same arguments passed when invoking the `email()` method from a module need to be supplied when using the method in a route.

### Example usage

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    lable: 'contact'
  },
  // additional module code
  apiRoutes(self) {
    return {
      post: {
        async subscribe(req) {
          if (!req.body.email || !req.body.name) {
            throw self.apos.error('invalid');
          }
          const email = self.apos.launder.string(req.body.email);
          const options = {
            from: email,
            to: 'admin@mysite.com',
            subject: 'A new user has subscribed'
          };
          const data = {
            name: self.apos.launder.string(req.body.name)
          };
          try {
            await self.email(req, 'email.html', data, options);
          }
        }
      }
    };
  }
};

```

<template v-slot:caption>
/modules/article/index.js
</template>

</AposCodeBlock>

So, what is going on with this code? First, we are passing our `apiRoutes()` a `post` object. This contains the functions that should be used with a `POST` HTTP request. Each expected route should get a separate function. In this case, we are passing the `subscribe` function. This will monitor for a POST request to `https://www.mysite.com/api/v1/subscribe`. We could give the property a name prefixed with a slash to monitor that exact route - `https://www.mysite.com/subscribe`. See the [reference documentation](../reference/module-api/module-overview.html#naming-routes) for more details.

In the next block of code, we test to ensure that the information needed to construct the `options` and `data` arguments exists in the submission. If it does exist, the values for both those parameters are created with sanitization using `self.apos.launder.string()`. Finally, this information and the email template are passed to the `self.email()` method in a try block. If passing the email to the handler fails, the exception will be caught automatically, logged, and reported as a 500 error. Note that even if the `self.email()` method doesn't throw an error it does not mean that message delivery will be completed successfully. The email could still be rejected en route or by the receiving server.

================================================================================
COLLECTION: guides
NAV_PATH: Scaling Up > Writing Migrations
DOC_PATH: guide/writing-migrations.md
URL: https://apostrophecms.com/docs/guide/writing-migrations
================================================================================
# Writing Migrations

Migrations in ApostropheCMS allow you to make targeted changes to your database, ensuring that your data stays in sync with the evolving structure of your code. If your goal is to ensure a newly-added field in the schema will be present in the database for existing documents with its default value (as specified by def, or the fallback def of the field type such as the empty string for string fields), then you do not need to write a migration. As of version 4.8.0, this is automatic. However, if you need to transform the existing content of the database in another way, such as renaming or removing a property or transforming a number to a string, then migrations are the right tool for you. In this guide, we will walk through how to write migrations to add or remove properties from existing pieces and widgets.

## Adding migrations

In ApostropheCMS, migrations are added using the [`add(name, fn)` method](/reference/modules/migration.md#add-name-fn) of the `@apostrophecms/migration` module. One common place to add these is within the `init(self)` initialization function of your module. Each migration requires a unique name and is only run **once**. ApostropheCMS tracks which migrations have already been executed, ensuring they won‚Äôt run again across restarts or deployments.

While the migration function can be added as an anonymous function as the second argument to the `add()`method, they can also be defined in the `methods(self)` customization function of the module. This can provide for a cleaner `init(self)` function, but is a matter of preference.

Example adding the migration to `init(self)`:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/piece-type',
  async init(self) {
    self.migration.add('add-copyright-notice', async () => {
      return self.apos.migration.eachDoc({
        type: 'article'
      }, async (doc) => {
        if (doc.copyright === undefined) {
          await self.apos.doc.db.updateOne({
            _id: doc._id
          }, {
            $set: { copyright: '¬©2024 ApostropheCMS. All rights reserved.' }
          });
        }
      });
    });
  }
};
```
<template v-slot:caption>
  /modules/product/index.js
</template>

</AposCodeBlock>

Example using `methods(self)`:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/piece-type',
  async init(self) {
    self.apos.migration.add('add-copyright-notice', self.addCopyrightNotice);
  }
  methods(self) {
    return {
      async addCopyrightNotice() {
        await self.apos.migration.eachDoc({
          type: 'article'
        }, async (doc) => {
          if (doc.copyright === undefined) {
            await self.apos.doc.db.updateOne({
              _id: doc._id
            }, {
              $set: { copyright: '¬©2024 ApostropheCMS. All rights reserved.' }
            });
          }
        });
      };
    }
  }
};
```
<template v-slot:caption>
  /modules/product/index.js
</template>

</AposCodeBlock>

For both of these examples we are looping through all documents to find the `article` piece types. Then we are using the document `_id` and the Apostrophe database helper method `updateOne` to run the MongoDB operation `$set` that will either create or update the value of the `copyright` field for that piece. We will go through additional examples in detail below.

### Running Migrations in Production

Although migrations currently do run automatically in both development and production, it is best practice to run the `@apostrophecms/migration:migrate` task in production before launching the newest version of the application to serve requests. At a future time, an option to disable Apostrophe's check for needed migrations on ordinary invocations in production may be offered as an optimization.

```bash
node app @apostrophecms/migration:migrate
```

## Adding or Modifying a Property in Existing Documents

When a property of all instances of a document type needs to be changed, transformed or added in a way more complicated than setting `def` at the time it is first added to the code, you can use the [`eachDoc`](/reference/modules/migration.md#async-eachdoc-criteria-limit-iterator) helper provided by the migration module. This method efficiently queries documents in your collection and allows you to update them with only the necessary changes. The `eachDoc` helper takes three parameters.

The first is the `criteria` object. This object is in the same format as a [MongoDB `find` operation query](https://www.mongodb.com/docs/v4.4/reference/method/db.collection.find/). It takes any properties that will be in your document, for example `type`, which will find documents of that type. You need to pass at least one `criteria` property.

The second is `limit` and is optional. It allows you to pass an integer that specifies how many documents to process in parallel. If no integer is passed as the second argument it is 1 by default.

The third criteria is the `iterator` function that should be performed on every document found. It receives the document as an argument. You can use most MongoDB methods here, but typically it uses the [`updateOne` method](https://www.mongodb.com/docs/drivers/csharp/current/usage-examples/updateOne/) to modify the document being passed to the iterator.

Here is an example migration that adds a `featured` boolean property to all `article` pieces, defaulting to `false`:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/piece-type',
   async init(self) {
    self.apos.migration.add('change-featured-flag', self.changeFeaturedFlag);
  }
  methods(self) {
    return {
      async changeFeaturedFlag(self) {
        await self.apos.migration.eachDoc({
          type: 'article'
        }, async (doc) => {
          if (doc.featured === undefined) {
            await self.apos.doc.db.updateOne({
              _id: doc._id
            }, {
              $set: { featured: false }
            });
          }
        });
      }
    }
  }
};
```
<template v-slot:caption>
  /modules/article/index.js
</template>

</AposCodeBlock>

In this example:

- The `eachDoc` method iterates over all documents, finding those with the `type` of `article`.
- For each found document, we check if the `featured` property is missing.
- We use the shorthand `self.apos.doc.db` to access the `aposDocs` collection of our database.
- The [`updateOne`](https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/modify/) helper operation allows us to modify the document by passing in the document `_id`.
- Finally, we use the [`$set` operator](https://www.mongodb.com/docs/manual/reference/operator/update/set/) to add the `featured` property without modifying any other fields.

::: info
Note: In this example we are checking if the `featured` property is missing before using `$set`. This will prevent overwriting any existing values in the database. This might not be the behavior you intend. You might want all `featured` schema fields to have a value of false as a default. In this case, just skip the check and the `$set` operation will either create the featured field or change the value to `false` if it already exists.

## Removing a Property from Existing Documents

If you need to remove a property, you can use `$unset`. Note that this is going to remove that data from the database and it can't be recovered. You can opt to simply remove the field from the document schema until you are certain the information it contains can be deleted. Here‚Äôs an example that removes a `temporaryNote` property from all `default` page types:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/page-type',
  init(self) {
    self.apos.migration.add('remove-note', self.removeNote);
  },
  methods(self) {
    return {
      async removeNote(self) {
        await self.apos.migration.eachDoc({
          type: 'default-page'
        }, async (doc) => {
          if (doc.temporaryNote !== undefined) {
            await self.apos.doc.db.updateOne({
              _id: doc._id
            }, {
              $unset: { temporaryNote: '' }
            });
          }
        });
      }
    }
  }
};
```
<template v-slot:caption>
  /modules/article/index.js
</template>

</AposCodeBlock>

- In this example, [`$unset`](https://www.mongodb.com/docs/manual/reference/operator/update/unset/) is used to remove the `temporaryNote` property from the document. Note that the value of the property in `$unset` doesn't matter, you could also elect to pass `null`.
- The rest of this example is essentially like the `$set` example above.

## Adding a Missing Property to Existing Widgets

Similar to updating pieces and pages, you can use the `eachWidget` helper to add or remove properties from any widget. This is useful when updating the schema of a widget across all pages or pieces. This works whether the widget is within a top-level `area` or has been nested in an `object` field, `array` field, or even in an `area` of another widget.

Here is an example migration that adds an `alignment` property to all `image` widgets, defaulting to `center`:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophe/widget-type',
  init(self) {
    self.apos.migration.add('align-images', self.alignImages);
  }
  methods(self) {
    return {
      async alignImages(self) {
        await self.apos.migration.eachWidget({},
          async (doc, widget, dotPath) => {
          if (widget.type !== '@apostrophecms/image') {
            return;
          }
          if (widget.alignment === undefined) {
            await self.apos.doc.db.updateOne({
              _id: doc._id,
            }, {
              $set: {
                [`${dotPath}.alignment`]: 'center'
              }
            });
          }
        });
      }
    }
  }
};
```
<template v-slot:caption>
</template>
</AposCodeBlock>

- The `eachWidget` method iterates over **every** widget in **every** area in **every** document. For this reason, you should check the `widget.type` to make sure you are only altering the desired widgets.
- In our `criteria` argument we are passing an empty object, indicating that every document should be checked. You can narrow this focus if you only want the widgets on a certain document type changed. For example, passing `type: 'product'` would only change widgets that are in a product piece-type.
- In the iterator, we first confirm that the widget is an image widget by checking the `widget.type`. If it is an image, we then check if the `alignment` property is present. If the `alignment` property is missing, we use `$set` to add it.

The `iterator` in an `eachWidget` method gets three arguments. In addition to the document, `doc`, where the widget is found, it also receives the `widget` object that will be modified and the `dotPath`. The `dotPath` argument represents the location of the current widget within the document's structure, using a "dot notation" format. It allows you to trace exactly where the widget is nested within its parent area, such as `main.content.0`, where `main` is the area, `content` is the widget array, and `0` is the first widget in that array. This simplifies the process of pointing the MongoDB operation at the correct widget within a document.

## Removing a Property from Existing Widgets

Here‚Äôs how you can remove a property from widgets using `$unset`. Again, this is an irreversible operation, so you may want to simply remove a schema field. In this case, we are removing the `border` property from all `video` widgets:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophe/widget-type',
  init(self) {
    self.apos.migration.add('remove-vid-border', self.removeVidBorder);
  }
  methods(self) {
    return {
      async removeVidBorder(self) {
        await self.apos.migration.eachWidget({},
          async (doc, widget, dotpath) => {
            if (widget.type !== '@apostrophecms/video') {
              return;
            }
            if (widget.border !== undefined) {
              await self.apos.doc.db.updateOne({
                _id: doc._id
              }, {
                $unset: { `${dotPath}.border`: '' }
              });
            }
        });
      }
    }
  }
};
```
<template v-slot:caption>
</template>
</AposCodeBlock>

- The `eachWidget` method iterates over all document returning each widget found.
- We check that the widget is the type we want to alter, else we return early.
- We use `$unset` to remove the `border` property from the widget if it exists.

## Additional Migrations
While the examples above use `eachDoc` and `eachWidget` to iterate over and modify documents, you're welcome to use any MongoDB APIs you're familiar with to perform migrations. For instance, if your migration needs are simple and easily expressed through MongoDB's query capabilities, methods like `updateMany` can be more efficient than iterating over every document individually.

For example, the first migration using `eachDoc` could easily be performed by an `updateMany`:

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
   async init(self) {
    self.apos.migration.add('change-featured-flag', self.changeFeaturedFlag);
  }
  methods(self) {
    return {
      async changeFeaturedFlag(req) {
        await self.apos.doc.db.updateMany(
          {
            type: 'article',
            featured: { $exists: false }
          },
          {
            $set: { featured: false }
          }
        );
      }
    }
  }
};
```
<template v-slot:caption>
  /modules/product/index.js
</template>

</AposCodeBlock>

In this case we are finding all the article piece-type documents that don't currently have a `featured` field. It then uses `$set` to create the field.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > The Database > Database Queries
DOC_PATH: guide/database-queries.md
URL: https://apostrophecms.com/docs/guide/database-queries
================================================================================
# Querying the database

When designing custom modules or customizing existing modules, it can quickly become necessary to fetch data that Apostrophe does not automatically make available. We might want to display a random image in a page banner or a few dynamically-chosen articles related to the page a visitor is on. Apostrophe has an API designed to help developers get as creative as they need to be.

One goal of the Apostrophe content query API is to facilitate common and advanced requests to the MongoDB database *without* requiring developers to know advanced MongoDB syntax. Understanding that low-level syntax will be helpful at times, but advanced knowledge should not be necessary.

This API also provides a layer of security. Queries made through Apostrophe (that maintain the original `req` request), will only return content the active website user is allowed to see.

::: info
We use the terms "query" and "query builders" here. For developers with advanced Apostrophe 2 experience, these are generally the same as the A2 concepts of "cursors" and "cursor filters."

## Initiating the database query

The page module (`@apostrophecms/page`) and all modules that *extend* the piece type module (`@apostrophecms/piece-type`), the two big "doc type" categories, have access to **a `find()` method** that initiates a database query. Any query using a doc type module's `find` method will be limited to that module type. This means that we can know that calling `self.find()` in a `product` piece module will only return products.

The `find` method takes up to three arguments:

| Argument | Required | Description |
| -------- | -------- | ----------- |
| `req` | TRUE | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `criteria` | FALSE | A [MongoDB criteria object](https://docs.mongodb.com/manual/tutorial/query-documents/). It is often as simple as properties that match schema field names assigned to the desired value. |
| `options` | FALSE | The options object is converted to matching [query builders](#using-query-builders). It is often easier to add query builders in the fluent interface described below. |

In the following example, we are writing the function that powers an [async template component](/guide/async-components.md). This hypothetical component would be passed the product `_id` property where it is shown as `productId`.

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-type',
    // ...
    components(self) {
      return {
        // Returning the five most recently created products.
        async latest(req, data) {
          // üëá Setting up our query criteria.
          const criteria = {
            _id: { $ne: data.productId }
          };

          // üëá The `find` method starting the query.
          const products = await self.find(req, criteria)
            .sort({ createdAt: -1 })
            .limit(5)
            .toArray();

          return { products };
        }
      };
    }
  };
  ```
  <template v-slot:caption>
    modules/product/index.js
  </template>
</AposCodeBlock>

::: info
For context, this is what it would look like to invoke this async component in a product show page template:

<AposCodeBlock>

  ``` nunjucks
  {% component 'product:latest' with { productId: data.piece._id } %}
  ```
  <template v-slot:caption>
    modules/product-page/views/show.html
  </template>
</AposCodeBlock>


**What is happening here?**

```javascript
async latest(req, data) {
  ...
}
```

Component functions are provided a request object, `req`, usually from a website visitor visiting a page that uses the component. The function also receives `data`, which is a data object a developer included when using the component in a template. (See the [async component guide](/guide/async-components.md)] for more on that feature.)

```javascript
const criteria = {
  _id: { $ne: data.productId }
};
```

We are going to get the most recently added products, but it wouldn't help visitors to see the product they're already looking at in this group. Here we create a `criteria` object that uses the MongoDB query syntax to look for documents whose `_id` property is not equal to (`$ne`) the ID of the active product.

```javascript
await self.find(req, criteria)
```

We are in the `product` module, so by calling the `find` method from `self` (which is the `product` module itself), our results are automatically limited to products. That's why our `criteria` object does not need to include that limitation, which would otherwise look like `type: 'product'`.

We pass in the `req` object we received from the component function parameters and the criteria object. In this case we are not including a third object for `options`.

::: info
It's important to understand that the `find` method is not the end of the process. It is only the beginning, setting up a query that may be refined and then needs to be executed by a separate method. There is more on that below, but for now make sure to understand that simply running `self.find()` by itself will not return any documents.

```javascript
  .sort({ createdAt: -1 })
  .limit(5)
```

These are **query builders**. Let's look at what query builders are before we identify what is happening in this example.

## Using query builders

Query builders are additional instructions added to the database query. These special methods may receive arguments, but many apply an effect without any arguments. They can be chained on a query, meaning that we can add multiple builders onto a query and each one will build on the rules established before it.

Examples of query builders include:
- `.limit(10)`: This limits the number of results that the query will return to the number we pass it.
- `.sort({ name: 1 })`: This builder sorts query results based on a document property value. This one sorts by the `name` property in ascending order.
- `.search('search term')`: This accepts a string and looks for documents that have that string in Apostrophe's full-text index.
- `.relationships(false)`: This builder accepts `false` or an array of relationship field names to avoid or limit relationship data loading onto the request response (saving some processing when it's not needed).
- `.areas(false)`: Similarly, this builder accepts `false` to prevent fetching relationships and doing similar work for any widgets nested in the documents, which can also help with performance where that information is unnecessary. You can also specify an array of specific area names whose widgets should be fully loaded.

As we can see here, query builders apply a wide variety of effects. See the [query builder reference page](/reference/query-builders.md) for a full list of query builders and how to use them.

Let's take another look at the builders in the example above.

```javascript
self.find(req, criteria)
  .sort({ createdAt: -1 })
  .limit(5)
```

This example is using two query builders, `sort` and `limit`. As described above, `sort({ createdAt: -1})` sorts the queried documents in descending order on their `createdAt` properties (most recent first). `limit(5)` then ensures the request will return no more than five documents.

::: info
Many aspects of querying the database are the same for both page and piece queries. One thing that is different are certain query builders that only apply to requests by the page module. These builders do things like update how results should include "child" or "ancestor" pages from the page hierarchy.

There is [a section for these builders](/reference/query-builders.md#page-document-query-builders) in the reference page. There is a similar section with a builder that only works on *image* piece queries as well.

### Projections: Reducing returned document data

One very useful query builder is `.project()`. We often know what specific data properties we want from a query and it is rarely *every single property*. By applying a query projection we reduce density of the data returned, making the response lighter, faster, and easier work with during development.

```
query
  .project({
    title: 1,
    _url: 1,
    _author: 1,
    publishedAt: 1
  })
```

The `project` builder is one that uses a MongoDB syntax. The object passed as an argument should include schema field names for the document type we're querying with each set to `1` or `true`. This tells the database that we only want these fields in each document we get back. In addition to simple fields, Apostrophe enhances `project` to handle relationship fields and the special property `_url`.

The `_id` property is always included no matter what projection is used.

::: info
In Apostrophe 2 this builder was named `projection`.

### Paginating query results

There are a few query builders that can work together to "paginate" query results. Sometimes that is better than receiving an unknown large number of results all at once.

```javascript
query
  .perPage(20)
  .page(2)
```

This example tells the query that its results should be returned in a group of no more than 20 (`.perPage(20)`) and that we want the second group of results based on the active sort order (`.page(2)`). These builders are used in the Apostrophe REST APIs and can be very helpful when dealing with large amounts of content. They use two other builders internally (`limit` and `skip`), but can be easier to use for common situations.

### Schema field builders

Apostrophe automatically creates query builders for most [schema fields](/guide/content-schema.md) configured on piece and page types. Passing a value into a schema field builder refines the query to fetch documents that have the provided value in the matching field.

For example, we might have a select field on a `product` piece type to identify a particular category:

<AposCodeBlock>

  ```javascript
  module.exports = {
    fields: {
      add: {
        //...
        category: {
          type: 'select',
          label: 'Product Line',
          choices: [
            { value: 'professional', label: 'Professional' },
            { value: 'hobbyist', label: 'Hobby' },
            { value: 'athletic', label: 'Athletic' }
          ]
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/product-page/views/show.html
  </template>
</AposCodeBlock>

We can query products matching a particular category:

```javascript
query.category('athletic')
```

The following field types get this query builder treatment:

- `string`
- `slug`
- `boolean`
- `checkboxes`
- `select`
- `radio`
- `integer`
- `float`
- `url`
- `date`
- `relationship`

`relationship` fields get special treatment with four query builders for each field. If the field name is `_products`, then:

- `._products(product._id)` matches only documents related to the product with the provided `_id`. You can also pass an array of product IDs, in which case documents related to *at least one* of those products will match.
- `.products(product.slug)` (no leading `_`) is similar, but supports matching by the `slug` property. You can also pass an array of product slugs, in which case only documents related to *at least one* of those products will match.
- `._productsAnd([ _id1, _id2, _id3...])` matches only documents related to *all* of the specified product IDs (one relation is not enough).
- `.productsAnd([ slug1, slug2, slug3...])` (no leading  `_`) matches only documents related to *all* of the specified product slugs (one relation is not enough).

`_id` properties are useful since they will never change, but slugs can be more readable (for humans) and are more typically used in URLs.

### Adding your own query builders

We're not limited to the query builders that come in Apostrophe core. It may help to create a builder that applies certain criteria and other builders that we might otherwise have to write repeatedly across a code base.

We can do this with the `queries()` customization function in the module configuration API. See the [module configuration API reference](/reference/module-api/module-overview.md#queries-self-query) for more information.

## Finishing with query methods

Initiating a query with `find()` and adding query builders are how we set up our data request. To get results we can use, the query ends with a **query method**. The query method takes the criteria and refinement we set up and adds logic that tells the database how we want our information back.

The simplest and most commonly used query methods are **`toArray`** and **`toObject`**. They either return an array of document results or a single document result, respectively.

### `toArray`
Our query example from above uses `toArray()`. Let's look at that again.

```javascript
const products = await self.find(req, criteria)
  .sort({ createdAt: -1 })
  .limit(5)
  .toArray();
```

As we've covered already, this code sets up the initial query with criteria (`self.find`) and adds builders with additional instructions (`sort` and `limit`). The final thing it does is run `toArray()` on the query. This is telling the database, "take all the instructions we provided and give us back an array of results based on those instructions. Please." So, at the end of this, `products` will be an array of up to five document objects.

::: info
See that in our example we use `await` before `self.find`, indicating that this is running an asynchronous operation. It is worth noting that `toArray()` is the only asynchronous part of the code since that's the part that actually talks to the database.

It is totally fine to set up queries synchronously (without `await`) and then execute the query in a separate step later.

```javascript
const query = self.find(req, criteria)
  .sort({ createdAt: -1 })
  .limit(5);

const products = await query.toArray();
```

### `toObject`

`toObject` is very similar to `toArray`, but it only returns one result as an object. In fact, `toObject` is basically the same as setting a `limit(1)` builder on the query then taking the single object out of the returned array. Using `toObject` simply makes it easier to write queries when we only want one result. For example, we may already know the unique `_id` of the document we want from the database.

```javascript
const productId = 'ckcqi1ye1005mof3rdgtlln0b:en:published';

const product = await self.find(req, { _id: productId })
  .toObject();
```

### `toCount`

The `toCount` query method is the easiest and quickest way to simply get the number of documents that match a query. The `toCount` query method will ignore any `page`, `skip` and `limit` query builders in order to get the total number.

If the query is using a `perPage` query builder it will also populate `totalPages` on the query, which can be retrieved with `query.get('totalPages')`.

```javascript
const productsCount = await self.find(req, criteria)
  .toCount();
```

### `toDistinct`

`toDistinct` allows us to retrieve the unique values for a particular document property from the documents that match query. For example, using `query.toDistinct('category')` will return an array with all the `category` property values across documents, with each category only appearing once in the array.

```javascript
const shoeColors = await self.find(req, { type: 'shoe' })
  .toDistinct('color');
```

### `toChoices`

The `toChoices` query method builds on `toDistinct` by returning each choice as an object with `label` and `value` properties. This can be useful when populating a select or other input field with options for a doc type property. For example, this is used for the document manager modal filter UI in Apostrophe.

`toChoices` accepts an options object as an optional second argument. Setting `counts: true` in that options object will include a `count` property on each returned choice indicating how many documents match that choice.

```javascript
const teamOffices = await self.find(req, { type: 'team' })
  .toChoices('office', { counts: true });
```

## Query across modules

The `find()` method in doc type modules is easy to use within each module as `self.find`. However this assumes we're looking for only content that is governed by the module where the method is called. There are two main ways to write these database queries from one module and get content managed by a separate module.

### Using another module's `find` method

The `self` object available in any Apostrophe module's customization functions can access other doc types on the `self.apos.modules` object. For example, if I'm working in the `article` module and want to query `author` pieces, I can access the `author` module with this:

```javascript
self.apos.modules.author
```

`self.apos.modules.author` is the same as `self` would be if we were operating within the `author` module. Therefore we can query author pieces directly by using that module's `find` method.

```javascript
const activeAuthors = self.apos.modules.author.find(req, { active: true })
  .toArray();
```

If a doc type module has been [assigned an alias](/reference/module-api/module-options.md#alias), then the doc type module will be directly on `self.apos`. For example, the `@apostrophecms/page` module is available as `self.apos.page` because `'page'` is its alias option value.

### Querying multiple doc types

As mentioned earlier, doc type modules' `find` methods will automatically restrict results to that document type. Sometimes we may want to fetch documents that match a query regardless of what doc type they are (e.g., all content tagged with a certain term). Or we may use a querying function across contexts and we don't know what doc type we will be looking for.

There is a module that governs all content documents: `@apostrophecms/doc`, which is aliased as `'doc'`. Its `find` method works the same as any individual doc type's, but it is not restricted to any one document type. We can then use it to look for a particular type with the `type` property or pass it criteria and get documents of multiple types in the results.

```javascript
const featuredContent = self.apos.doc.find(req, { featured: true })
  .toArray();


const featuredByType = self.apos.doc.find(req, {
  featured: true,
  type: selectedType // A hypothetical option a user selected.
})
  .toArray();
```

Using `self.apos.doc.find` has limitations, however. Significantly, pieces will not return with `_url` properties. We would have to run additional queries to the individual piece type module `find` methods once we knew what types we had. That is one reason why using `self.find()` from doc type modules is better when possible.

## Where in my code can I make database queries?

You can make database queries in async components (as shown above), routes
(such as in an [`apiRoutes`](../reference/module-api/module-overview.md#apiroutes-self) function), [server event handlers](./server-events.md),
middleware and in pretty much any async function in your server-side code.
However, you should avoid making database queries:

* In the `init()` function of a module, because schemas of other related
types might not yet be finalized, leading to errors in relationship queries.
* In an `apostrophe:modulesRegistered` server event handler, for the same reason.

If you wish to make queries in your module at the time the process
starts up (not on every request), writing a
`@apostrophecms/doc:beforeReplicate` server event handler is the safest
choice. If you are trying to make a query on every page request,
you should write an async component, or write an `@apostrophecms/page:beforeSend`
server event handler which will receive `(req)` as its first argument, giving
you a way to attach the query results to `req.data` for use in the template.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > The Database > Inserting and Updating Docs
DOC_PATH: guide/database-insert-update.md
URL: https://apostrophecms.com/docs/guide/database-insert-update
================================================================================
# Inserting and updating in server-side code

Apostrophe provides module methods for inserting and updating content documents in the database. These methods should be the primary tools for developers doing server-side data operations since they [emit events](/guide/server-events.md) that the CMS uses to keep all database collections updated and in sync. We will look at methods for both pieces and pages, which are similar but have some important differences.

::: info
Remember that the Apostrophe REST APIs for [pieces](/reference/api/pieces.md) and [pages](/reference/api/pages.md) are usually the best option when triggering content updates from the browser. Those API endpoints take advantage of the methods below while adding logic important to use in browsers.

## Updating content documents

When we have an existing piece document that to update, we use the `update()` method on the related piece type module. The `update` method takes the following arguments:

| Argument | Required | Description |
| -------- | -------- | ----------- |
| `req` | TRUE | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `piece` | TRUE | The document object that will *replace* the existing database document. |
| `options` | FALSE | An options object, currently only used for internal draft state management. |

For example, if we had a dog adoption website that used an external API, we may want to update `dog` pieces periodically with adoption status. This may be using a command line task that is run regularly by a cron job.

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-type',
    // ...
    methods (self) {
      return {
        // The hypothetical method is run once for each dog we're following from
        // the API. A separate method would add any new dogs.
        async updateDogStatus(req, dogId, status) {
          const dogDocument = await self.find(req, {
            dogId
          }).toObject();
  
          if (!dogDocument) {
            return null;
          };
  
          // We update the `status` property.
          dogDocument.status = status;
  
          const updateResult = await self.update(req, dogDocument);
  
          return updateResult;
        }
      };
    }
  };
  ```
  
  <template v-slot:caption>
    modules/dog/index.js
  </template>
</AposCodeBlock>

**What is happening here?**

```javascript
async updateDogStatus(req, dogId, status) {
  const dogDocument = await self.find(req, {
    dogId
  }).toObject();
  ...
}
```

Our method received the active request object, the API's identifier for a dog, and the dog's availability status (probably a string value). We then request the *full* database document. See the [database querying guide](/guide/database-queries.md) for more on this.

```javascript
if (!dogDocument) {
  return null;
};
```

If the identified dog isn't in our database yet, we would return a `null` value and the update task's function could insert the dog instead.

```javascript
// We update the `status` property.
dogDocument.status = status;

const updatedDraft = await self.update(req, dogDocument);

return updatedDraft;
```

We update the document property that tracks the dog's adoption status on the data object and use `self.update` to replace the previous document state with our update (with `await` as it is asynchronous). We finally return the result, which will be the updated document object.

Note that using the provided `req` object like this works only if the `req` object is from a user with *at least* "contributor" permissions for the `dog` piece type. **If we wanted to bypass that permission check**, or if we ever wanted to allow anonymous site visitors to insert or update content, we would pass `{ permissions: false }` as a third options argument to `self.update()`. That obviously raises security issues we would need to consider carefully.

::: info
All content documents have multiple versions, including "draft" and "published" versions. The `update()` methods only updates the "draft" copy, allowing editors to still review before publishing. If we *did* want to publish here as well, we would want to run the publishing method:

```javascript
await self.publish(req, updatedDraft);
```

**What if we are updating a document from a different doc type module?**

In the example above, `self` refers to the `dog` piece type module since that is where the method is registered. If we wanted to run the `update` method from a separate module we would replace `self` with a specific reference to the `dog` module: **`self.apos.modules.dog`**.

### Updating page documents

Updating pages works the same way as pieces with the same arguments to the `update` method. There are a few things to keep in mind when working on pages, however.

**We typically call the page `update` method from the main page module: `self.apos.page.update()`.** Since pages can change their `type` property (unlike pieces) they share a single `update` method from the `@apostrophecms/page` module. `self.update()` on individual page type modules is simply a wrapper around that method.

**`update()` is not the way to move pages within the [page tree](/guide/pages.md#connecting-pages-with-page-tree-navigation).** The `@apostrophecms/page` module has [a dedicated `move()` method](/reference/modules/page.md#async-move-req-pageid-targetid-position) for that purpose. The [REST API information about page tree placement](/reference/api/pages.md#post-api-v1-apostrophecms-page) has additional information.

## Inserting a new piece

Inserting a new piece works very similarly to updating an existing one. The `self.insert` method takes the same arguments: `self.insert(req, piece, options)`. The big difference, of course, is that there is no existing document to find, update, and resubmit.

Instead, use the `self.newInstance()` method to get a fresh document object of the proper document type. That method uses the doc type's [field schema](/guide/content-schema.md) to generate the essential document properties with any default values. We can then add any initial data to that essentially blank document object.

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-type',
    // ...
    methods (self) {
      async addNewDog(req, initialInfo) {
        // Generate a blank dog data object.
        let newDog = self.newInstance();
        // Add our initial information to the object.
        newDog = {
          ...newDog,
          ...initialInfo
        };
        // Insert the dog with the asynchronous `self.insert` method
        const insertResult = await self.insert(req, newDog);

        return insertResult;
      }
    }
  };
  ```
  <template v-slot:caption>
    modules/dog/index.js
  </template>
</AposCodeBlock>

## Inserting pages

As mentioned above, pages have a position within the page tree. The `insert` method for pages therefore requires additional arguments to place a new page in that hierarchy properly. Also [as described above](#updating-page-documents) we normally call the insert method directly from the `@apostrophecms/page` module, aliased in server-side code as `self.apos.page`.

The arguments for the `self.apos.page.insert()` method are:

| Argument | Required | Description |
| -------- | -------- | ----------- |
| `req` | TRUE | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
|`_targetId` | TRUE | The `_id` of an existing page to use as a target when inserting the new page. `_home` and `_archive` are optional conveniences for the home page and [archived section](/reference/api/pages.md#moving-pages-to-the-archive), respectively. |
|`_position` | TRUE | A numeric value will represent the zero-based child index under the `_targetId` page. `before`, `after`, `firstChild`, or `lastChild` values set the position within the page tree for the new page in relation to the target page (see `_targetId`). `before` and `after` insert the new page as a sibling of the target. `firstChild` and `lastChild` insert the new page as a child of the target. |
| `page` | TRUE | The page document object. |
| `options` | FALSE | An options object, primarily used for internal draft state management. |

As with pieces, this process will normally begin by generating an empty page document with the `newInstance()` method, which should be done using a specific page type module.


<AposCodeBlock>

  ```javascript
  let newPage = self.newInstance();

  newPage = {
    ...newPage,
    ...initialInfo
  };

  await self.apos.page.insert(req, '_home', 'lastChild', newPage);
  ```
  <template v-slot:caption>
    modules/special-page/index.js
  </template>
</AposCodeBlock>

::: info
With very few exceptions, the `_id` property is an automatically generated, randomized, and (always) unique property. It is also special in that it can never change for a given document.

## Inserting and updating relationships

As we have seen, [relationships](/guide/relationships.html) can be accessed as array properties after we locate
documents with the `find` method.

By the same principle, relationships can be inserted or updated as array properties. If our
`dog` piece type seen above has an `_owner` relationship with `person` pieces, we can prepopulate it like this:

```javascript
  // assumes the alias: 'person' option has been set for the person piece type
  const owner = await self.apos.person.find(req, { title: 'Frank' });
  // Before calling insert() in the example above
  newDog._owner = [ owner ];
  const insertResult = await self.insert(req, newDog);
```

We can do the same thing with `self.update`.

Note that inserting or updating a relationship in this way cannot insert or update related pieces
that do not already exist. This technique only updates the relationship.

## Inserting and updating relationship subfields

Some relationships have [subfields of their own](/guide/relationships.html#accessing-the-fields-of-a-relationship)
describing the relationship itself. These subfields can be set in the same way they are accessed:
by populating the `_fields` property of each related document. Here is an example:

```javascript
  // For this example to work, the _owner relationship field of the "dog" piece type
  // must have a "favorite" subfield of type boolean
  const owner = await self.apos.person.find(req, { title: 'Frank' });
  owner._fields = {
    favorite: true
  };
  newDog._owner = [ owner ];
  const insertResult = await self.insert(req, newDog);
```

This works the same way whether we are inserting or updating.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > The Database > Accessing the Database Directly
DOC_PATH: guide/database-access.md
URL: https://apostrophecms.com/docs/guide/database-access
================================================================================
# Accessing the database directly

## Working with collections
As stated earlier, the main goal of the Apostrophe JavaScript content API is to facilitate requests to the MongoDB database without the developer having to know advanced MongoDB syntax or worry about user permissions. However, there are instances where you might want to directly access and modify your collections without the overhead or restrictions of the [Apostrophe model layer](database-insert-update.md) without the possibility of a race condition.

A good example is updating one document property, like a "view counter" of a blog article. Everyone can see the page, so you don't care about permissions. You don't need to update the entire document object. You just want to update one small piece of it.

Here is an example of how to do that in a piece. We will override the `beforeShow()` method of the `@apostrophecms/piece-page-type`. This method lets us make modifications just before the `show.html` of the associated `@apostrophe/piece-page-type` is displayed to the user.

<AposCodeBlock>

```javascript
module.exports = {
  // remainder of the module properties
  methods(self) {
    return {
      async beforeShow(req) {
        await self.apos.doc.db.updateOne(
          { _id: req.data.piece._id },
          { $inc: { views: 1 } }
        );
      }
    };
  }
};
```

<template v-slot:caption>
modules/article-page/index.js
</template>
</AposCodeBlock>

Within the `beforeShow()` method we are gaining access to the `aposDocs` collection of the project database using `self.apos.doc.db`. This reference to the collection is shorthand for `self.apos.db.collection('aposDocs')`. Note that this is *not* the same thing as `self.apos.db`, which is the main MongoDB connection object. 

::: tip
There are references to other core apostrophe collections that can be accessed in this same way through `self.apos.<xxx>.db`. For example, `self.apos.attachment.db` gives access to CRUD (Create, Read, Update, Delete) operations on the `aposAttachments` collection. Note that the reference uses the singular version of the name.

Next, we are invoking a method of the MongoDB collection saying that we want to update one document within the database. You can read about other methods within the [MongoDB Node.js driver docs](https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/).

We are passing two arguments to the MongoDB method. The first is a MongoDB criteria object which ensures our query only matches the document with the desired `_id`. MongoDB objects always have an `_id` property, a unique identifier that can always be used to find that specific document.

The second argument is an object which passes a MongoDB operator `$inc` set to the name and value of the field we want to alter. In this case, *incrementing* the `views` field by 1. This could then be accessed in the `show.html` template for the `blog-page` using `data.piece.views`.

Keep in mind, this update to the record happened *after* the requested piece was already returned from the database because we used the `beforeShow()` method. So, if five people had looked at that blog article previously, `data.piece.views` in the template would be equal to 5 for the duration of the current request, but the database record views would now be 6 due to our `$inc`.

In addition to the `$inc` operator, there are a number of other MongoDB operators where it makes sense to access database directly. This includes `$set`, `$pull`, `$push`, `$addToSet`, and `$unset`. You can read more about their usage in the MongoDB [documentation](https://www.mongodb.com/docs/v6.0/reference/operator/update/).

These same methods of altering documents outside of the Apostrophe model layer can be used in [tasks](/reference/module-api/module-overview.html#tasks-self) created by any module. As examples, the Apostrophe modules expose multiple tasks like adding users through `node app @apostrophecms/user:add <name> <role>` from the `@apostrophecms/user` module or completely resetting your database (dangerous!) through `node app @apostrophecms/db:reset`.

## Making your own database connections

While the core of apostrophe depends on connections to MongoDB through the mongodb native module, that doesn't mean that your custom modules are limited in the same way. If you feel like using Mongoose, go ahead! If you want to use a different database, why not!

Just install the packages you need and invoke the functions of the appropriate library with `await` within the `async init(self)` function of your module. Then attach the returned connection object to a property of `self`, granting access to it later in any method, handler, route, etc. of the module. You should also clean up such connections in an `apostrophe:destroy` handler:

<AposCodeBlock>

``` javascript
handlers(self) {
   return {
      'apostrophe:destroy': {
        async closeMyConnection() {
          await self.myConnection.close();
        }
      }
   };
}
```
</AposCodeBlock>

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Keyboard Shortcuts
DOC_PATH: guide/command-menu.md
URL: https://apostrophecms.com/docs/guide/command-menu
================================================================================
# Adding keyboard shortcuts

The `@apostrophecms/command-menu` module adds keyboard shortcuts and additional pop-up menus to the Admin UI. The list of shortcuts can be accessed from any page or piece-type manager using the '?' key. There are several pre-programmed common shortcuts, with additional page-level shortcuts added automatically for each custom piece-type created. 

## Reassigning automatic shortcuts
Apostrophe assigns shortcuts for custom piece-types based on the first letter of the piece-type name. So, a piece-type of 'article' would get assigned a shortcut cord of `g` then `a`. However, you might have more than one module that starts with a particular letter, or starts with the same letter as a core piece-type. The automatically assigned shortcut can be changed by adding an array of the desired shortcut key combination(s) to the `shortcut` option in the module. You can disable a shortcut by setting the option `shortcut: false`.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    shortcut: 'g,z',
    // the remainder of the options
  }
};
```
<template v-slot:caption>
/modules/custom-piece/index.js
</template>
</AposCodeBlock>

There are three options - a single key, a key plus one or more modifiers, or a chord of two sequential key presses. You can pass multiple shortcuts by separating each with a space. **This is important when passing in shortcuts that use a modifier key that differs between Macintosh and Windows/Linux keymapping.** W3C has [published](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/) helpful guidance in selecting new shortcut keys. Keep in mind any existing shortcuts for [MacOS](https://support.apple.com/en-us/HT201236), [Windows 10 & 11](https://support.microsoft.com/en-us/windows/keyboard-shortcuts-in-windows-dcc61a57-8ff0-cffe-9796-cb9706c75eec), and [Ubuntu](https://help.ubuntu.com/stable/ubuntu-help/shell-keyboard-shortcuts.html.en).

For a single key, just pass that key as the string value to `shortcut`. The 'comma', 'space', and modifier keys (see below) shouldn't be used, but every other standard key can. See the [table](#keymappings) for additional keymappings for keys like the left arrow.

The modifiers that you can use are the 'command', 'option', 'alt', 'control', 'win', 'meta', and 'shift' keys. You can specify that one or more of these keys are held down at the same time as pressing a non-modifier key to activate the shortcut, for example, `Cmd+Shift+m`. See the [table](#keymappings) for the modifier keymappings.

Finally, you can assign a chord of two sequential keypresses to any shortcut by passing a string with each key separated by a comma. Remember that a space can be used as a key, so don't add a space after the comma.

‚ùå `shortcut: 'x, y'`

‚úÖ `shortcut: 'x,y'`


::: info
Shortcuts already defined by the browser cannot be used within the shortcut manager.

### Adding custom shortcuts
Any module can streamline the editorial workflow through the addition of custom shortcuts. These shortcuts are added to the `commands(self)` customization function section of the module's `index.js` file. Like the other customization functions, it should return an object. 

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  commands(self) {
    return {
    //...
    }
  }
}
```

<template v-slot:caption>
/modules/custom-widget/index.js
</template>
</AposCodeBlock>

## Registering shortcut commands
New shortcuts are registered by passing them as an object of objects to the `add` key. Each shortcut object requires a unique name as key. The best practice for ensuring the uniqueness of your shortcut name is to namespace it with the module name, for example, `custom-widget:shortcut-name`. If you are registering a shortcut in a base class that is extended by several modules, it may be programmatically easier to prefix with the registered name by using `` [`${self.__meta.name}:shortcut-name`] ``. Note the use of brackets and backticks to allow the use of template literals and to dynamically set our object key.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  commands(self) {
    return {
      add: {
        'custom-widget:new-shortcut': {
          type: 'item',
          label: 'New shortcut',
          action: {
            type: 'custom-widget-special-action',
            payload: {
              name: 'CustomWidgetActionShortcut'
              props: {moduleName: 'custom-widget'}
            }
          },
          shortcut: 'Ctrl+Shift+P Meta+Shift+P' 
        }
      },
      // ...
    }
  }
}
```

<template v-slot:caption>
/modules/custom-widget/index.js
</template>
</AposCodeBlock>

Each shortcut object takes four required properties.

The `type` key always takes a value of `item`. 

The second, `label`, takes a string to display within the menu next to the shortcut keys.

The `action` key takes an object with one required and one optional property. The `type` key is required and takes a string. This string will be emitted when the user completes the shortcut. This string can be detected and used to trigger a function using `apos.bus.$on('type-string', function)`. This can be added to the `mounted()` hook of your Vue component or in custom module JavaScript added to the `/modules/custom-widget/ui/apos/apps/custom.js` file. If used in a Vue component it is best practice to also remove the listener by adding `apos.bus.$off('type-string', function)` to the `destroyed()` hook. If this string is specific to this module it must be unique, but the string can also be shared by multiple modules to trigger changes. For example, many built-in piece-types like the `@apostrophecms/image` and `@apostrophecms/file` use a common string of `command-menu-manager-close` to trigger the closing of the manager modal.

The optional `payload` key takes an object with properties that will be passed to the event listener. In the above example, you would use:

<AposCodeBlock>

```javascript
// ...
async mounted() {
    apos.bus.$on('type-string', async state => {
      await self.function( state.name, state.props)
    });
  },
  destroyed() {
     apos.bus.$off('type-string', async state => {
      await self.function( state.name, state.props)
    });
  },
  // ...
```
<template v-slot:caption>
/modules/custom-widget/ui/apos/components/CustomWidgetDisplay.vue
</template>
</AposCodeBlock>

The final key required by the shortcut object is `shortcut`. This is set identically to the top-level `shortcut` option that is used to reassign automatically added shortcuts.

## Keymappings
Not that the key mappings below are shown with initial capitalization, but are case-insensitive.
| key(s) | Mapping |
|---|---|
| a-z, 0-9,`-=[]\;'./ | The same as the specific key (note that any upper case or symbol key that requires that the shift key be pressed will not work) |
| function keys 1-12 | fn1 - fn12 |
| MacOS `Command` or WinOS `Win` key | Meta |
| `Command` | Cmd, Command |
| `Option`/`Alt` | Alt, Option |
| `Control` | Ctrl, Control |
| `Escape` | Esc, Escape |
| `Space` | Space |
| `Tab` | Tab |
| `Shift` | Shift |
| `Caps lock` | Capslock |
| arrows | arrowleft, arrowup, arrowright, arrowdown |
| MacOS `Delete` or WinOS/Linux `Backspace` | Backspace |
| WinOS/Linux `Del` | Delete |
| `pgdn` | Pagedown |
| `pgup` | Pageup |

## Organizing shortcut commands

There are two types of shortcut menus. One is displayed on all page types, while the other is specific for each piece-type. Where each newly registered shortcut is displayed is determined by the `modal` property of the `commands(self)` function.

### Adding shortcuts to the page-level menu

The addition of shortcuts to the main page-level menu is accomplished by passing an object of objects to the `default` key. This key takes properties that specify either one of the four existing section ("content", "mode", "manager", or "general") or specifies the creation of a new section.

Each of the keys in the `default` object should start with `@apostrophecms/command-menu:` and be prefixed with the name of an existing or new section. For example, to add a new shortcut to the "general" section the key would be `@apostrophecms/command-menu:general`. For values, each key takes an object with a `commands` and an optional `label` property. The value of `commands` should be an array containing the names of all the shortcuts to be added to the section. The `label` key should be set to a string that will be added as a menu section header.

::: info
If you add a `label` property to a key that specifies an existing section, the passed-in `lable` string will override the existing label.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
    commands(self) {
    return {
      add: {
        'custom-widget:dark-toggle': {
          type: 'item',
          label: 'Toggle dark mode',
          action: {
            type: 'toggle-component-to-dark-mode'
          },
          shortcut: 'Meta+d'
        }
      },
      modal: {
        default: {
          '@apostrophecms/command-menu:mode': {
            commands: [ 'my-widget:dark-toggle' ]
          }
        }
      }
    };
  }
};
```

<template v-slot:caption>
/modules/custom-widget/index.js
</template>
</AposCodeBlock>

![command menu with custom shortcut added to the "Modes" section](../images/shortcut-menu.png)

### Adding shortcuts to the piece-type menu

Shortcuts can be added to the piece-type menu by specifying the particular module with a key made up of the module name followed by `:manager`. For example, `my-piece:manager`. This key gets a property of `@apostrophecms/command-menu:manager` that has an object composed of `commands` and optional `label` properties. Like the page menu, the `commands` key receives an array composed of the names of each shortcut to be added.

<AposCodeBlock>

```javascript
module.exports = {
  / ...
  commands(self) {
    return {
      add: {
        'article:spellcheck': {
          type: 'item',
          label: 'Trigger spellcheck',
          action: {
            type: 'trigger-spellcheck-of-article',
            payload: {
              language: 'en'
            }
          },
          shortcut: 'Cmd+Shift+.'
        }
      },
      modal: {
        'article:manager': {
          '@apostrophecms/command-menu:manager': {
            commands: [ 'article:spellcheck' ]
          }
        }
      }
    };
  }
};

```

<template v-slot:caption>
/modules/article/index.js
</template>
</AposCodeBlock>

![piece-type command menu with custom shortcut added](../images/piece-shortcut-menu.png)

In this case, we could add our listener into some custom JavaScript that powers our hypothetical spell checker.

<AposCodeBlock>

```javascript
export default () => {
  apos.bus.$on('trigger-spellcheck-of-article', (payload) => {
    console.log('Spellcheck triggered with language ', payload.language);
    // remainder of the spellcheck code
  });
};
```

<template v-slot:caption>
/modules/article/ui/apos/apps/spellcheck.js
</template>
</AposCodeBlock>

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Breakpoint Preview
DOC_PATH: guide/breakpoint-preview.md
URL: https://apostrophecms.com/docs/guide/breakpoint-preview
================================================================================
# Breakpoint Preview

## Device breakpoint preview

Apostrophe provides a convenient way to emulate devices, like phones and tablets, making it easy to see how your content will look at different screen sizes.

![Screen shot of breakpoint preview with ecommerce](../images/new-breakpoint-preview.png)
When device preview mode is enabled, you‚Äôll see icons in the admin bar for each of the breakpoints (sizes) that have been set through the `breakpointPreviewMode` of the `@apostrophecms/asset` module. By default, there are three shortcut device breakpoints added. Adding additional breakpoint preview sizes without `shortcut: true` will cause a dropdown menu with all the sizes to appear, in addition to the icons.

![Screen shot of the breakpoint preview dropdown menu](../images/new-breakpoint-menu.png)

Clicking on an icon or making a selection from dropdown menu will cause your page content to display in a container that matches the specific device size, so you can quickly check how the layout and styles respond. The displayed content will be fully editable, so that you can see how any new content is impacted by the current media queries. You can go back to editing in the full browser screen by clicking on the currently selected preview icon or clicking on the `X` to the right of the dropdown.

Custom styles you‚Äôve added with CSS media queries are converted by the `asset` module to container queries. Note that this only works with styles added or imported by stylesheets in the [`ui/src/index.scss` files of each module](/guide/front-end-assets.html#placing-client-side-code), it doesn't work with styles outside the build path, like styles added directly to the template.


Breakpoint preview is enabled by default, but if you want to change the configuration you can pass additional options to the `@apostrophecms/asset` module at project level.
<AposCodeBlock>

```javascript
module.exports = {
  options: {
    breakpointPreviewMode: {
      enable: true,
      screens: {
        desktop: {
          label: 'Desktop',
          width: '1440px',
          height: '900px',
          icon: 'monitor-icon',
          shortcut: true
        },
        tablet: {
          label: 'Tablet',
          width: '1024px',
          height: '768px',
          icon: 'tablet-icon',
          shortcut: true
        },
        mobile: {
          label: 'Mobile',
          width: '414px',
          height: '896px',
          icon: 'cellphone-icon',
          shortcut: true
        },
        ultrawide: {
          label: 'Ultrawide Monitor',
          width: '2560px',
          height: '1440px'
        },
        laptopLarge: {
          label: 'Large Laptop',
          width: '1680px',
          height: '1050px'
        },
        ipadPro: {
          label: 'iPad Pro',
          width: '1366px',
          height: '1024px'
        },
        surfaceDuo: {
          label: 'Surface Duo',
          width: '540px',
          height: '720px'
        },
        galaxyFold: {
          label: 'Galaxy Fold',
          width: '280px',
          height: '653px'
        }
      }
    }
  }
};
```
<template v-slot:caption>
modules/@apostrophecms/asset/index.js
</template>
</AposCodeBlock>

You can learn about all the properties that can be passed to the `breakpointPreviewMode` option on the [`@apostrophecms/asset` reference page](/reference/modules/asset.md#breakpointpreviewmode-properties). The two most critical are `enable` and `screens`. If you pass `enable: false` it will remove the breakpoint preview icons and menu from the adminbar. The `screens` property takes an object where each property is a different breakpoint. Adding the `breakpointPreviewMode` at the project level will override any default values, so you need to pass `enable: true` if you wish to add additional breakpoints.

Each of the individual breakpoint properties in the `screen` object take a `label` that will be displayed to the user when they hover over the icon. The `icon` property supplies the icon that will be displayed if the breakpoint is also given a property of `shortcut: true`. This icon name should be either an icon you can [register in this module](/reference/module-api/module-options.md#icon) or an icon that is [already registered](/reference/module-api/module-overview.md#icons). Finally, each breakpoint needs the `width` and `height`, in pixels, of the container that corresponds to the device being emulated.

---

## Limitations and Differences
While the ApostropheCMS breakpoint preview effectively converts many media queries to container queries, there are some key limitations and differences to be aware of. These limitations stem from fundamental differences between **media queries** (which target the viewport) and **container queries** (which target individual containers).

#### 1. **Unsupported Parameters**
Certain media query conditions do not translate well to container queries:

- **Orientation queries**:
  - Parameters like `orientation: landscape` or `orientation: portrait` don't have equivalent behavior in container queries, as containers don't have the same orientation concept as viewports.
  - Example of query:
    ```css
    @media (orientation: landscape) { ... }
    ```
- **Aspect ratio**:
  - Queries based on aspect ratio, such as `min-aspect-ratio` and `max-aspect-ratio`, may not behave as expected in container contexts.
  - Example:
    ```css
    @media (min-aspect-ratio: 16/9) { ... }
    ```

#### 2. **Valid Syntax Patterns**
The plugin supports both standard media query syntax and modern range syntax:

- **Standard syntax** (fully supported):
  ```css
  @media (min-width: 600px) { ... }
  @media (max-width: 1200px) { ... }
  ```

- **Range syntax** (fully supported):
  ```css
  @media (width >= 600px) { ... }
  @media (width <= 1200px) { ... }
  @media (600px <= width <= 1200px) { ... }
  ```

#### 3. **Behavioral Differences**
Media queries operate on the **viewport size**, whereas container queries respond to the **size of a specific container**. This distinction can lead to subtle differences in layout and behavior:

- **Viewport context**:
  - Media queries are global; they consider the entire screen or browser window. If a layout condition depends on the viewport, such as full-page navigation menus, it might not behave identically when converted to container queries.

- **Nested containers**:
  - Container queries work within the bounds of their parent container. If a nested container has a different size, the styles applied to its content may differ from expectations.

- **Resizing effects**:
  - Breakpoint preview resizes containers but does not simulate the entire viewport behavior. This can impact layouts that rely on viewport-relative units like `vw` and `vh`.

#### 4. **Viewport-relative Units**
While the conversion from viewport-relative units (`vw`, `vh`, `vmin`, `vmax`) to container-relative units (`cqw`, `cqh`, `cqmin`, `cqmax`) generally provides a good approximation for the breakpoint preview feature, there are some practical considerations to be aware of:

- Nested Container References

The preview container becomes the new reference point for all calculations, which may not accurately represent the actual viewport proportions in the final design.

- Fixed-Size Elements Lose Their Consistency

Some designs might intentionally use viewport units for consistent sizing across different views. For example, a header that should always be exactly 10vh tall regardless of container. Converting these to container query units changes this intended behavior.

- Mixed Unit Relationships Change

When designs mix viewport units with other units, their relative proportions will change in the preview:

```css
/* Original CSS with mixed units */
.sidebar {
  width: 30vw; /* 30% of viewport width */
  margin-right: 20px; /* Fixed margin */
}

/* When converted in preview */
.sidebar {
  width: 30cqw; /* 30% of container width */
  margin-right: 20px; /* Still a fixed margin */
}
```

#### 5. **User Preference Queries**
Media queries that target user preferences don't translate to container contexts:

- **Prefers-color-scheme**: Media queries like `@media (prefers-color-scheme: dark)` are not applicable to containers, as they rely on global user settings.
- **Prefers-reduced-motion**: Similar to color schemes, these queries target user preferences and cannot be container-specific.

---

### Summary of Support
| **Media Query Feature**       | **Support in Container Queries**       |
|-------------------------------|---------------------------------------|
| Standard width/height queries | ‚úÖ Fully supported |
| Range syntax queries | ‚úÖ Fully supported |
| Viewport-relative units | ‚úÖ Converted to container units |
| Print media queries| ‚úÖ Preserved |
| Complex logical conditions (multiple combined conditions) | ‚ö†Ô∏è May behave differently |
| User preference queries | ‚ùå Not applicable to containers |
| `orientation` | ‚ùå Not applicable to containers |
| `aspect-ratio` | ‚ùå Not applicable to containers |

---

## Transform Option

The transform option provides a workaround for handling special cases by allowing you to provide a custom function to modify how media query parameters are converted into container query parameters. This function only affects the media query transformation and does not impact the conversion of viewport units (vh/vw) to container query units (cqh/cqw) within rules.

### Usage

```js
require('postcss-viewport-to-container-toggle')({
  transform: (mediaFeature) => string
})
```

### Parameters

- `mediaFeature` (string): The original media query parameters that would be transformed into container query parameters.

### Return Value

- Returns a string containing the transformed container query parameters.

### Default Behavior

When no transform function is provided, the plugin uses the original media feature string without modification:

```js
transform = null // Default value
// Equivalent to:
transform = (mediaFeature) => mediaFeature
```

### Examples

### Basic Transform

```js
// Custom transformation of media queries
{
  transform: (mediaFeature) => {
    return mediaFeature.replace(/(\d+)px/g, '$1em');
  }
}

// Input
@media (width > 600px) {
  .element { width: 100vw; }
}

// Output
@media (width > 600px) {
  :where(body:not([data-breakpoint-preview-mode])) .element { width: 100vw; }
}
@container (width > 600em) {
  .element { width: 100cqw; }
}
```

### Complex Transform

```js
// Modify specific types of queries while preserving others
{
  transform: (mediaFeature) => {
    // Convert pixel-based width queries to percentage-based
    if (mediaFeature.includes('width')) {
      return mediaFeature.replace(/(\d+)px/g, ($0, $1) => `${($1 / 1920) * 100}%`);
    }
    // Leave other queries unchanged
    return mediaFeature;
  }
}

// Input
@media (width > 600px) and (orientation: landscape) {
  .element { width: 100vw; height: 50vh; }
}

// Output
@media (width > 600px) and (orientation: landscape) {
  :where(body:not([data-breakpoint-preview-mode])) .element {
    width: 100vw;
    height: 50vh;
  }
}
@container (width > 31.25%) and (orientation: landscape) {
  .element {
    width: 100cqw;
    height: 50cqh;
  }
}
```

## Important Notes

1. The transform function is called when converting media queries to container queries.
2. The plugin modifies selectors and creates container queries in the following way:
   - For the original media query, selectors are modified to include the conditional attribute, like `:where(body:not([data-breakpoint-preview-mode])) .selector`
   - A new `@container` query is created with the transformed parameters
3. The attribute name (`data-breakpoint-preview-mode`) can be customized via the `modifierAttr` option in your plugin configuration
4. Print-specific media queries (e.g., `@media print`) are preserved as-is without transformation
5. The transform function only affects the container query parameters, not the actual CSS properties

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Custom Admin UI
DOC_PATH: guide/custom-ui.md
URL: https://apostrophecms.com/docs/guide/custom-ui
================================================================================
# Customizing the user interface

This guide focuses on how to customize Apostrophe's administrative user interface, or "admin UI." The built-in functionality covers most situations, but sometimes you'll want to add or change functionality.

::: tip
Why customize the CMS UI? Tailoring the admin interface can streamline workflows, match branding, or simplify content editing for non-technical users.

::: warning
* Altering the UI should be done rarely and carefully. When possible, add new functionality like custom schema field types and custom manager view columns. Avoid overriding components entirely unless absolutely necessary.
* Overriding a UI component prevents the project from benefiting from future UI improvements and bug fixes related to that component.
* Make sure there is not a better way to achieve the desired goal. This includes [asking for help in Discord](https://chat.apostrophecms.org) and [requesting](https://roadmap.apostrophecms.com/roadmap) or [contributing](https://github.com/apostrophecms/apostrophe/blob/main/CONTRIBUTING.md#apostrophecms-contribution-guide) new features for the core.
* Apostrophe version 3.x used Vue 2.x to power the Admin UI components. With newer versions of Apostrophe, those same components are powered by Vue.js 3.x. We have taken care to include as much backward compatibility as possible, but custom components added in earlier versions of Apostrophe may need modification.

## Apostrophe admin UI file structure

Apostrophe's admin UI is implemented with Vue.js. It is built from many `.vue` files across various Apostrophe modules. These are typically found in Apostrophe core, but they can be anywhere in the project. This means that we can introduce our own Vue components to the admin UI just by adding `.vue` files to the `ui/apos/components` subdirectory of any Apostrophe module. As explained below, it is also possible to override existing components by supplying a component with the same name.

## Rebuilding the custom admin UI when we make changes

For performance reasons, Apostrophe projects are not configured to automatically rebuild the admin UI every time your code changes. This makes sense because in most projects there is no custom admin UI code, and it takes time to build.

However, we can "opt-in" to rebuilding the UI on every code change, like this:

```bash
APOS_DEV=1 npm run dev
```

For convenience, you may wish to set this environment variable for the lifetime of your terminal session:

```bash
export APOS_DEV=1
```

Of course the admin UI is always rebuilt when deploying. No special changes or environment settings are needed for production use.

## Registering custom field types

Apostrophe's [schema field types](content-schema.md) cover many situations, but we might wish to add a new one.

Since it is a larger topic that touches on more than just UI, we've created a [separate article on how to add a custom field type](/guide/custom-schema-field-types.md). However, note that you will find it easier to follow the remainder of this article if you read that article first.

## Adding custom columns to the ApostropheCMS piece type manager

Another common extension is a custom column for the piece type manager. By default the manager modal displays the title, certain flags, and the last time the piece was updated. We can extend this to display our custom star ratings.

### Implementing the server-side part

Let's look at a simple piece type module called `review` that takes advantage of the [`starRating` field type we define in a separate article](/guide/custom-schema-field-types.md). We'll add a `rating` field to the schema for the piece type, and also add a column to display it in the manager modal:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/piece-type',
  fields: {
    add: {
      rating: {
        type: 'starRating',
        label: 'Star Rating',
        required: true
      }
    }
  },
  columns: {
    // üëá Columns are a "cascade" just like fields,
    // we have an "add" property with a subproperty
    // for each column
    add: {
      rating: {
        // üëá Each column has a label property and a
        // component property. The component name must
        // exist as a Vue component
        label: 'Rating',
        component: 'ColumnStarRating'
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/review/index.js
  </template>
</AposCodeBlock>

### Implementing the browser-side part

This code makes reference to a Vue component, `ColumnStarRating`, that doesn't exist yet. Next we'll introduce that component:

<AposCodeBlock>

```js
<template>
  <p
    class="apos-table__cell-field"
    :class="`apos-table__cell-field--${header.name}`"
  >
    <span v-if="hasValue">
      <span v-for="index in 5" :key="index" class="rating">{{ isActive(index) ? '‚òÜ' : '‚òÖ' }}</span>
    </span>
    <span v-else>
      None
    </span>
  </p>
</template>

<script>
import AposCellMixin from 'Modules/@apostrophecms/ui/mixins/AposCellMixin';

export default {
  name: 'ColumnStarRating',
  mixins: [ AposCellMixin ],
  computed: {
    hasValue() {
      return this.get(this.header.name) != null;
    }
  },
  methods: {
    isActive(index) {
      return index <= (this.get(this.header.name) || 0);
    }
  }
};
</script>

```
  <template v-slot:caption>
    modules/star-range-field/ui/apos/components/ColumnStarRating.vue
  </template>
</AposCodeBlock>

While the Vue component could be placed in any module, it makes the most sense to group it in the `star-range-field` module because it might be used as a column in any piece type, not just a `review`.

This component uses `AposCellMixin` to do two important things:

* The component gains access to the configuration of the column by accessing the `header` prop, which is automatically declared by the mixin.
* The component can fetch properties from the piece by invoking `this.get` with any property name. Following Apostrophe's convention this method automatically fetches from the published version of the piece if it exists, otherwise from the draft.

## Overriding standard Vue.js components by name in ApostropheCMS

Most of the time we don't need to override admin UI components that ship with Apostrophe. But if we have a need, we can do so by **placing a file with the same name as a standard component in the `ui/apos/components` subdirectory of a project-level module.** You can also do this in a custom npm module to achieve reuse across projects.

::: warning
When you override a component in this way, you take responsibility for keeping up to date with changes made upstream in that component in new releases of Apostrophe. Common sense applies here: while we are unlikely to break your code that overrides the logo with a new Apostrophe update, overriding the entire document manager UI might involve a serious commitment on your part.

Apostrophe will use only the last version of a component that it finds during startup. The general startup order is:

1. Core Apostrophe modules
2. Installed and project-level modules, in the order they are configured in `app.js`

For instance, if the last module in our project's `app.js` modules list contains a `ui/apos/components/AposLogPadless.vue` file, that logo will be used in the admin bar, in place of the version that is normally loaded from Apostrophe core or in any module configured earlier.

::: info
For more information about the patterns used, props provided and APIs needed to override an existing core component, it's necessary to study the source code of the original.

### Example: overriding the Apostrophe logo

One of the easiest component overrides is the Apostrophe logo, seen in the admin bar by customers while they edit the site.

To do this, copy `AposLogoPadless.vue` and `AposLogo.vue` from the `apostrophe` module to the `ui/apos/components` subdirectory of a new `admin-ui-overrides` Apostrophe module in your own project, like this:

```bash
mkdir -p modules/admin-ui-overrides/ui/apos/components
# Copy both versions of the logo
cp node_modules/apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposLogo*.vue modules/admin-ui-overrides/ui/apos/components
```

Now, open `modules/admin-ui-overrides/ui/apos/components/AposLogo.vue`. The file looks like this:

<AposCodeBlock>

```js
<template>
  <svg viewBox="0 0 141.5 144.5">
    <!-- Lots of svg subelements here -->
  </svg>
</template>
```
  <template v-slot:caption>
    modules/admin-ui-overrides/ui/apos/components/AposLogo.vue
  </template>
</AposCodeBlock>

As you can see, it is **just an SVG file wrapped in a Vue `template` element,** nothing more.

So, you can replace its contents with those of your own logo in SVG format. SVG is a great choice, but if you
really wanted to, you could also use an `img` element or similar, pointing to a static asset. If you choose to
do that, make sure you follow our [static module assets](static-module-assets.md) guide.

Next, make similar changes to **your copy** of `AposLogoPadless.vue`.

Now **make sure you enable the `admin-ui-overrides` module in `app.js`, otherwise it will not be honored:**

<AposCodeBlock>

```js
const apostrophe = require({
  modules: {
    // ... Plenty of other modules should be here, this is just an example
    // that demonstrates enabling one more
    'admin-ui-overrides': {}
  }
});
```
  <template v-slot:caption>
    app.js
  </template>
</AposCodeBlock>

::: tip
The name `admin-ui-overrides` was chosen for convenience. You can override **any** admin UI Vue component
in **any** module of your project. The name of the component is what matters, so **do not change
the component name** if your intent is to override.

::: warning
Not seeing your changes take effect in development? Make sure you read [rebuilding the UI when you make changes](#rebuilding-the-custom-admin-ui-when-we-make-changes), above.

### Components with a "logic mixin" are safer and easier to override

Certain components have been refactored to make them safer and easier to override in this way. Specifically, these components import a Vue "mixin" from a `logic` subdirectory. Such components are safer to override because the `.vue` file you are copying will only contain markup and styles, not business logic.

Understand however that when you override such a component, you are still taking responsibility for staying up to date with upstream changes that do impact the template, such as new UI elements, props, click handlers in the template, etc.

Here is a partial list to give you an idea of what is easiest to override, keeping in mind that this list is ever-growing. To find and copy these files, open `node_modules/apostrophe` with your editor, keeping in mind you should **copy them to your project as seen in the example below,**. *Never* modify them inside `node_modules/apostrophe`.

```
AposSettingsManager.vue
AposPagesManager.vue
AposInputObject.vue
AposInputBoolean.vue
AposSchema.vue
AposInputArray.vue
AposInputWrapper.vue
AposInputRadio.vue
AposArrayEditor.vue
AposInputRelationship.vue
AposInputCheckboxes.vue
AposInputPassword.vue
AposSearchList.vue
AposInputRange.vue
AposInputDateAndTime.vue
AposInputColor.vue
AposInputAttachment.vue
AposInputArea.vue
AposSubform.vue
AposInputSlug.vue
AposInputSelect.vue
AposInputString.vue
AposDocContextMenu.vue
AposForgotPasswordForm.vue
AposLoginForm.vue
TheAposLogin.vue
AposResetPasswordForm.vue
```

### Example: overriding the look and feel of the login page

::: tip
This example assumes you have already followed the previous example. In particular, make sure you have an `admin-ui-overrides` module set up at this point.

Apostrophe's login page is a good example of an experience that makes use of components with logic mixins, components that are therefore safer to override than most.

In the previous example, we already saw how to change the Apostrophe logo, which also changes it on the login page. So for this example we'll focus on a different, but equally simple task: removing the Apostrophe version number from the login form. This makes sense if you are not interested in making this information visible, or perhaps wish to display your own project's version number, etc.

First, let's copy `TheAposLogin.vue` from the `apostrophe` npm module to the project-level `admin-ui-overrides` module we created and enabled in the last example:

```bash
cp node_modules/apostrophe/modules/@apostrophecms/login/ui/apos/components/TheAposLogin.vue modules/admin-ui-overrides/ui/apos/components
```

Now, let's take a look at that file. Parts not relevant to what we're changing have been left out for brevity, so **don't copy and paste from here,** edit the file you copied:

<AposCodeBlock>

```js
<template>
  <transition name="fade-stage">
    <div
      v-show="loaded"
      class="apos-login apos-theme-dark"
      data-apos-test="loginForm"
      :class="themeClass"
    >
      <!-- Code omitted for brevity -->
      <transition name="fade-outer">
        <div v-show="loaded" class="apos-login__footer">
          <AposLogo class="apos-login__logo" />
          <label class="apos-login__project-version">
            Version {{ context.version }}
          </label>
        </div>
      </transition>
    </div>
  </transition>
</template>

<script>
import TheAposLoginLogic from 'Modules/@apostrophecms/login/logic/TheAposLogin';

export default {
  name: 'TheAposLogin',
  mixins: [ TheAposLoginLogic ]
};
</script>

<style lang="scss">
  // styles here
</style>

<style lang="scss" scoped>
  // more styles here
</style>
```
  <template v-slot:caption>
    modules/admin-ui-overrides/ui/apos/components/TheAposLogin.vue
  </template>
</AposCodeBlock>

Here you can see several things:

* The code we want to remove is just one small part of the `template` element. We should leave the rest as-is.
* There is no business logic, instead we have a "logic mix-in" that we are **not copying**, so we do not have to take responsibility for maintaining a "fork" of it.
* The styles are also present in `style` elements. We can leave them as-is or change them as we see fit.

To remove the version number, change the contents of that final `transition` element and leave the rest the same:

```js
<transition name="fade-outer">
  <div v-show="loaded" class="apos-login__footer">
    <AposLogo class="apos-login__logo" />
    <!-- Goodbye version number! (You can remove this part entirely)
      <label class="apos-login__project-version">
        Version {{ context.version }}
      </label>
    -->
  </div>
</transition>
```

::: warning
Not seeing your changes take effect in development? Make sure you read [rebuilding the UI when you make changes](#rebuilding-the-custom-admin-ui-when-we-make-changes), above.

## Overriding standard Vue.js components through configuration in ApostropheCMS

There can be only one `AposDocsManager` component definition in a project, but sometimes we need different behavior for a specific piece type. We could work around this by overriding a core component and adding conditional logic, but this results in code that is hard to maintain, and also means we are stuck maintaining a copy of a complex component and missing out on bug fixes and improvements. It would be better to **specify a different, custom component name to be used** to manage a particular piece type.

Here is an example of how to do that:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    components: {
      managerModal: 'AnnouncementManager'
    }
  }
}
```
  <template v-slot:caption>
    modules/announcement/index.js
  </template>
</AposCodeBlock>


With this configuration, Apostrophe will look for a Vue.js component called `AnnouncementManager` when the user selects "Announcements" from the admin bar, bypassing `AposDocManager`.

As for the actual Vue.js code, we would place that in `modules/announcement/ui/apos/components/AnnouncementManager.vue`.

Of course there are other components that can be overridden in this way, and the list is growing over time. Here are the components that can currently be overridden through configuration:

| Module                       | Option                    | Default            |
| ---------------------------- | ------------------------- | ------------------ |
| `@apostrophecms/piece-type`  | `components.managerModal` | `AposDocsManager`  |
| `@apostrophecms/piece-type`  | `components.editorModal`  | `AposDocEditor`    |
| `@apostrophecms/page`        | `components.managerModal` | `AposPagesManager` |
| `@apostrophecms/page`        | `components.editorModal`  | `AposDocEditor`    |
| `@apostrophecms/widget-type` | `components.widgetEditor` | `AposWidgetEditor` |
| `@apostrophecms/widget-type` | `components.widget`       | `AposWidget`       |

For readability's sake, a `.` is used in the table above to separate sub-properties of `options` (see the example above for what the actual configuration looks like). If an option exists for `@apostrophecms/piece-type` it can be used for any module that extends it.

::: info
Since the type of an existing page can be changed, there is only one manager modal and only one editor modal for all pages, and those component names are configured on the `@apostrophecms/page` module. Piece and widget types can have their own type-specifc overrides.

If an option ends in `Modal`, the component is required to embed the `AposModal` component. For examples, look at the source code of the default components listed above.

The `AposWidgetEditor` component already provides a modal dialog box in which to edit the schema of any widget, so we won't need to configure a replacement unless we want to support editing directly on the page. `AposRichTextWidgetEditor` is an example of how to do this.

The `AposWidget` component has **nothing to do with a typical site visitor experience.** It is used only when displaying our widget while the page is in edit mode. While overriding this component is rare, the `@apostrophecms/rich-text-widget` module does so to provide a "click the text to edit" experience for rich text widgets. If you're just trying to enhance your widget with frontend JavaScript, you should write a [widget player](custom-widgets.md#client-side-javascript-for-widgets) instead.

Before you override an editor modal, consider [adding a custom schema field type](/guide/custom-schema-field-types.md) instead.

## Adding custom context menu items

Apostrophe offers a context menu that can be used to carry out certain operations on a document, such as "preview", "duplicate", and so on. You can add custom context menu items from within any module.

![A custom context menu item 'My Menu Item' in the Piece Editor Modal](../images/ui-custom-context-menu.png)

Custom context menu items can either:
1. Open a modal dialog box that implements `AposModal`. For an example of this, see the [code for the draft sharing modal](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/modal/ui/apos/components/AposModalShareDraft.vue).
2. Emit an event that can be listened for elsewhere in your code using `apos.bus.$on()`

It is important to note that context menu operations will appear for all documents, even if added by a module associated with a specific type of document. However, you can use the options described below to limit when they appear.

The menu registration should happen in the initialization phase. While context menu operations will appear for all documents by default, there are various options to control when they appear.

### Opening a Modal

Here's an example of adding a custom context menu item that opens a modal dialog box:

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Article',
    pluralLabel: 'Articles'
  },
  init(self) {
    self.apos.doc.addContextOperation({
      context: 'update',
      action: 'myUniqueAction',
      label: 'My Menu Item',
      modal: 'MyModalComponent',
      // Optional properties shown below
      conditions: [ 'canEdit', 'canPublish' ],
      if: {
        type: 'my-type'
      },
      moduleIf: {
        autopublish: true
      }
    });
  }
}
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

### Emitting Events

Alternatively, you can create a context menu item that emits an event instead of opening a modal:

<AposCodeBlock>

```js
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Article',
    pluralLabel: 'Articles'
  },
  init(self) {
    self.apos.doc.addContextOperation({
      context: 'update',
      action: 'refresh-related-content',
      label: 'Refresh Related Content',
      type: 'event',
      if: {
        type: self.__meta.name
      }
    });
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>


When a user clicks on an event-type context menu item, it triggers an event with the same name as the `action` property. You can listen for this event elsewhere in your code:

<AposCodeBlock>

``` javascript
// Listen for the event elsewhere in your code or another module
apos.bus.$on('refresh-related-content', (data) => {
  // Handle the event
  // data contains doc, moduleName, moduleLabels, and any props
  console.log('Refreshing related content for:', data.doc._id);

  // Example: Fetch related content based on tags
  if (data.doc.tags && data.doc.tags.length) {
    apos.http.get('/api/v1/article', {
      qs: {
        tags: { $in: data.doc.tags },
        _id: { $ne: data.doc._id },
        limit: 5
      }
    }).then(result => {
      // Update UI or cache with the fresh related content
      apos.notify('Related content refreshed', { type: 'success' });
    }).catch(err => {
      apos.notify('Failed to refresh related content', { type: 'error' });
    });
  }
});
```
</AposCodeBlock>

The event data passed with the event is an object which includes:

```js
{
  moduleName: operation.moduleName || this.moduleName,
  moduleLabels: this.moduleLabels,
  doc,
  ...docProps(doc),
  ...operation.props
}
```

### Configuration Options

| Property | Required | Description |
|----------|----------|-------------|
| `context` | Yes | Currently only `'update'` is supported (for previously saved documents) |
| `action` | Yes | A globally unique identifier for this operation |
| `label` | Yes | The text displayed in the context menu |
| `modal` | Only added for modals | The name of the modal component to open. Not required when type: 'event' is specified. |
| `type` | Only added for events | Set to 'event' to emit an event instead of opening a modal. Omit this property when using modal. |
| `conditions` | No | Array of built-in permission conditions that must all be satisfied |
| `if` | No | MongoDB-style query to match document properties |
| `moduleIf` | No | MongoDB-style query to match module properties |
| `modifiers` | No | Array of UI modifiers (e.g., `['danger']` for warning styling) |
| `manuallyPublished` | No | When `true`, item only appears for non-autopublished document types |
| `moduleName` | No | Override the module name passed to the modal |
| `props` | No | Additional custom properties to pass to the modal or event data |

#### Available Condition Checks

When using the `conditions` property, you can specify any of these built-in permission checks:
- `'canPublish'`
- `'canEdit'`
- `'canDismissSubmission'`
- `'canDiscardDraft'`
- `'canLocalize'`
- `'canArchive'`
- `'canUnpublish'`
- `'canCopy'`
- `'canRestore'`

For more complex conditions, use the `if` and `moduleIf` properties.

### Advanced Filtering

The `if` property allows you to filter menu items based on document properties:

```js
if: {
  type: 'article',
  'metadata.featured': true,
  $or: [
    { status: 'published' },
    { status: 'draft' }
  ]
}
```

The `moduleIf` property matches against module properties instead of document properties:

```js
moduleIf: {
  autopublish: false,
  localized: true
}
```

Both support MongoDB-style operators like `$or`, `$and`, and `$ne`, as well as dot notation for nested properties.

> **Warning:** Do not use core actions as your `action` property value. This would lead to unpredictable results and broken UI. You can find the core actions in the [AposDocContextMenu component logic props](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/doc-type/ui/apos/logic/AposDocContextMenu.js).

## Toggling the visibility of the ApostropheCMS admin-bar

There are times when you want to allow people that don't have editing or content creation permissions to log into your project site. For example, the visibility of a page or a piece document can be set to `login required`, so only those with an account can view it. In that case, it may be desirable to not display the admin-bar. The `@apostrophecms/admin-bar` module `getShowAdminBar()` method can be extended to return `false` which will hide the admin-bar for that role when logged in.

<AposCodeBlock>

``` js
module.exports = {
  extendMethods(self) {
    return {
      getShowAdminBar(_super, req) {
        if (req.user?.role === 'guest') {
          return false;
        }

        return _super(req);
      }
    };
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/admin-bar/index.js
  </template>
</AposCodeBlock>

::: info
Note that if you are using the [`@apostrophecms-pro/advanced-permission` module](https://apostrophecms.com/extensions/advanced-permission) it doesn't use roles, so you will need to implement a different check for determining if the admin bar should be hidden.

When electing to not display the admin-bar, you need to implement an alternative way for the user to log out.

<AposCodeBlock>

```js
export default () => {
  const insertLogoutButton = () => {
    // Function to insert the logout button
    function addLogoutButton() {
      // selects the end of the hidden admin-bar wrapper
      const navElement = document.querySelector('.bp-nav');
      // Check the nav element exists, the user is logged in, and the admin bar is hidden
      if (navElement && apos.login?.user && apos.adminBar?.showAdminBar === false) {
        // Create the logout button
        const logoutButton = document.createElement('button');
        logoutButton.id = 'logoutButton';
        logoutButton.textContent = 'Log Out';
        logoutButton.style.display = 'block';
        logoutButton.addEventListener('click', () => {
          // trigger logout from the @apostrophecms/login module
          apos.bus.$emit('admin-menu-click', '@apostrophecms/login-logout');
        });

        // Insert the button after the nav element
        navElement.insertAdjacentElement('afterend', logoutButton);
      }
    }
    addLogoutButton();
  };

  // Wrap the script in apos.util.onReady to refire when the editing
  // state changes
  apos.util.onReady(insertLogoutButton);
};
```
  <template v-slot:caption>
    modules/@apostrophecms/admin-bar/ui/src/index.js
  </template>

</AposCodeBlock>

In this script, the `apos.login?.user` is checked to determine if the user is logged in and the value of `apos.adminBar?.showAdminBar` is checked to determine if the particular user has the admin-bar as an option for logging out. Upon click, the button emits an event named `admin-menu-click` with an argument of `@apostrophecms/login-logout` to trigger user logout. You could also elect to add a logout button in your template where the visibility is toggled by these same checks. You can use a similar method to implement other controls, like page navigation when the admin bar is hidden.

## Adding custom modal controls

Most times the controls on the admin-bar and located within the context menu are sufficient. However, in some cases you might want to add additional controls to facilitate the creation or editing of pages and pieces. For example, you could add a button for creating a new post on a blog index page. The `apos.doc.edit()` method takes an object with one required and two optional properties. It triggers the opening of the editing modal for the corresponding document type and allows you to create, edit, and duplicate both pieces and pages. When awaited, the method returns either the edited document object, including the computed `_id` for the document, or 'undefined' if the modal is cancelled.

While this method enables the editing and management modals to open for any user, it does not bypass Apostrophe's permission checks. A user without permission to perform an operation on a particular page or piece will still be blocked. Best practice is to toggle any custom controls so that are only visible or active for a user with correct permissions. This can be done by checking that the value of the `canCreate` and `canEdit` properties for the piece type or `@apostrophecms/page` is true. The `canCreate` property applies to both creating and duplicating a document, since both add a document to the database. The `canEdit` property should be checked before adding a method call for editing a document.

### Creating a new document

In order to create a new document, whether page or piece, you pass the required `type` property set to either the piece type or `@apostrophecms/page` for creating a new page. For example, to trigger the creation of a new `blog` piece type from a button with an id of `create-new-piece` you could use the following code:

<AposCodeBlock>

```js
export default () => {
  apos.util.onReady(() => {
    const button = document.getElementById('create-new-piece');
    if (button && apos.module?.blog?.canCreate) {
      button.addEventListener('click', async function () {
        try {
          const createdDocument = await apos.doc.edit({
            type: 'blog'
          });
          if (createdDocument) {
            console.log('Document was created:', createdDocument);
          }
        } catch (error) {
          console.error('Error creating document:', error);
        }
      });
    }
  });
};
```
  <template v-slot:caption>
    modules/blog/ui/src/index.js
  </template>
</AposCodeBlock>


### Editing an existing document

To trigger editing of an existing piece or page you need to pass the computed `_id` of the document through the `_id` property along with the required `type`. Note that you will want to use the `_id` of the draft version of the document, not the published version.

```js
apos.doc.edit({
  type: '@apostrophecms/page',
  _id: 'clkie2enx00033xlsgus4a4nj:en:draft'
})
```

### Duplicating an existing document

The `apos.doc.edit()` method also gives you the option to create a new document of the designated type, but pre-filled with fields from an existing document of the same type. This is very similar to editing an existing document except that the `_id` of the existing document to be copied should be passed through the `copyOfId` property. In this case, you can pass the `_id` of either the draft or published document if they both exist.

```js
apos.doc.edit({
  type: '@apostrophecms/page',
  copyOfId: 'clkie2enx00033xlsgus4a4nj:fr:published'
})
```

## Adding custom login requirements

In some cases, we might wish to enhance Apostrophe's login form with additional, custom steps.

This too is a larger topic that touches on more than just UI, so we've created a [separate article on how to add a custom login requirement](/guide/custom-login-requirements.md).

## Editing custom widgets in context

While most widgets are edited most conveniently via the standard dialog box that appears when the edit button is clicked, some can be edited effectively "in context" right on the page. The standard rich text widget is a good example.

To learn how to implement this pattern for a custom widget, check out this [separate article on how to edit custom widgets in context](/guide/editing-custom-widgets-in-context.md).

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Custom Field Types
DOC_PATH: guide/custom-schema-field-types.md
URL: https://apostrophecms.com/docs/guide/custom-schema-field-types
================================================================================
# Custom schema field types

Apostrophe's [schema field types](../guide/content-schema.md) cover many situations, but we might wish to add a new one. This section of the documentation covers the creation of an entirely new schema field type. However, Apostrophe also allows you to easily combine existing field types to create a new input type which you can read about in the [tutorials](../tutorials/reusing-standard-fields.md).

A schema field has two parts: a server-side part and a browser-side part. The server-side part is responsible for sanitizing the input received from the browser, while the browser-side part is responsible for providing the admin UI.

## Implementing the server-side part

Any module can register a schema field type on the server side, like this one, which allows editors to set a "star rating" of 1 to 5 stars, as is often seen in movie and restaurant reviews.

Note that this code could be in any module. Here we've chosen to create a module just for this new field type, since it might be used in several modules.

<AposCodeBlock>

```js
module.exports = {
  init(self) {
    self.addStarRatingFieldType();
  },
  methods(self) {
    return {
      addStarRatingFieldType() {
        self.apos.schema.addFieldType({
          name: 'starRating',
          convert: self.convertInput,
          vueComponent: 'InputStarRating'
        });
      },
      async convertInput(req, field, data, object) {
        const input = data[field.name];
        if ((data[field.name] == null) || (data[field.name] === '')) {
          if (field.required) {
            throw self.apos.error('notfound');
          }
        }
        object[field.name] = self.apos.launder.integer(input, field.def, 1, 5);
      }
    }
  }
}
```
  <template v-slot:caption>
    modules/star-rating-field/index.js
  </template>
</AposCodeBlock>

In `init`, which runs when the module is initialized, we call our `addStarRatingFieldType` method. `init` is the right place to invoke code that should run when the Apostrophe process starts up.

In `addStarRatingFieldType`, we invoke `self.apos.schema.addFieldType` to add our custom field type on the server side. We provide:

* `name`, which can be used as a `type` setting when adding the field to a schema.
* `convert`, a function to be used to sanitize the input and copy it to a destination. We pass our `convertInput` method for this purpose. Methods of our module are available as properties of `self`.
* `component`, the name of a Vue.js component to be displayed when editing the field.

In `convertInput`, we sanitize the input and copy it from `data[field.name]` to `object[field.name]`. Since we must not trust the browser, we take care to sanitize it with [the `launder` module](https://npmjs.com/package/launder), which is always available as `apos.launder`. But we can validate the input any way we like, as long as we never trust the input.

## Implementing the browser-side part

On the browser side, we'll need a custom Vue.js component. Apostrophe provides a Vue.js mixin, `AposInputMixin`, that does much of the work for us.

<AposCodeBlock>

```js
<template>
  <AposInputWrapper
    :modifiers="modifiers" :field="field"
    :error="effectiveError" :uid="uid"
    :display-options="displayOptions"
  >
    <template #body>
      <div class="apos-input-wrapper">
        <button v-for="index in 5" :key="index" @click="setValue(index)" class="rating">{{ isActive(index) ? '‚òÜ' : '‚òÖ' }}</button>
        <button class="clear" @click="clear">Clear</button>
      </div>
    </template>
  </AposInputWrapper>
</template>

<script>
import AposInputMixin from 'Modules/@apostrophecms/schema/mixins/AposInputMixin';

export default {
  name: 'InputStarRating',
  mixins: [ AposInputMixin ],
  methods: {
    validate(value) {
      if (this.field.required) {
        if (!value) {
          return 'required';
        }
      }
      return false;
    },
    setValue(index) {
      this.next = index;
    },
    clear() {
      this.next = null;
    },
    isActive(index) {
      return index <= this.next;
    }
  }
};
</script>

<style lang="scss" scoped>
  .rating {
    border: none;
    background-color: inherit;
    color: inherit;
    font-size: inherit;
  }
</style>
```
  <template v-slot:caption>
    modules/star-rating-field/ui/apos/components/InputStarRating.vue
  </template>
</AposCodeBlock>

In our template element, `AposInputWrapper` takes care of decorating our field with a label, error messages, etc. All we have to do is pass on some standard props that are provided to us. Beyond that, our responsibility is to display the current `value` to the user. We also add event handlers to handle user input, as explained below.

In our script element, we have just two jobs: assigning a new value to `this.next` whenever the value changes, and validating the user's input. The `AposInputMixin` does the rest of the work for us.

To update `this.next`, we implement methods that respond to click events, like the `setValue` and `clear` methods in this example. To validate the user's input, we implement a `validate` method, which accepts the current value and checks constraints like the `required` property of the field. If there is a problem, we return an error code such as `required`, `min` or `max`, otherwise we return `false`. The field configuration is available to us as `this.field`.

The `style` element takes care of CSS for this component. Note that SCSS syntax is available. To avoid conflicts, using the `scoped` attribute is recommended.

::: warning
If it doesn't seem to work at first, make sure you launched `npm run dev` with the `APOS_DEV=1` environment variable setting as explained earlier. This ensures the Apostrophe admin UI is rebuilt on each code change. You can stop using it when you are finished changing admin UI code.

### Putting the new schema field type to work

Now we can use the new schema field type in any piece or widget much as we would use an `integer` field:

```javascript
fields: {
  add: {
    rating: {
      type: 'starRating',
      label: 'Star Rating',
      required: true
    }
  }
}
```

The resulting value is then available as the `stars` property of the piece or widget, with an integer value between `1` and `5`.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Adding Batch Operations
DOC_PATH: guide/batch-operations.md
URL: https://apostrophecms.com/docs/guide/batch-operations
================================================================================
# Custom batch operations

Apostrophe page and piece type modules both have access to a batch operation system in the user interface. This allows editors to take an action, such as archiving, on many documents at once. By default, all page and piece types have batch operation UI for archiving pieces and restoring pieces from the archive, for example.

![An article piece manager modal with arrow pointing at the archive button at top left](/images/archive-button.png)

We can add additional custom batch operations using [the provided module API](/reference/module-api/module-overview.md#batchoperations). Let's first look at how we would add a batch operation that resets piece field values to the configured defaults. This involves two major steps:

1. Configuring the batch operation itself
2. Adding the API route that powers the batch operation

## Configuring the batch operation

Batch operations are a ["cascading" configuration](/reference/module-api/module-overview.md#cascading-settings), so they use `add` and, optionally, `group` sub-properties to inherit existing batch operations properly. Here is an example of what the "Reset" batch operation configuration might look like. We'll then walk through each piece of this.

<AposCodeBlock>

```javascript
module.exports = {
  batchOperations: {
    add: {
      reset: {
        label: 'Reset',
        icon: 'recycle-icon',
        messages: {
          progress: 'Resetting {{ type }}...',
          completed: 'Reset {{ count }} {{ type }}.',
          completedWithFailures: 'Reset {{ count }} {{ type }} ({{ bad }} of {{ total }} failed).',
          failed: 'Resetting {{ type }} failed.',
        },
        if: {
          archived: false
        },
        modalOptions: {
          title: 'Reset {{ type }}',
          description: 'Are you sure you want to reset {{ count }} {{ type }}?',
          confirmationButton: 'Yes, reset the selected content'
        },
        permission: 'edit'
      },
    }
  },
  icons: {
    'recycle-icon': 'Recycle'
  },
};
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

Our new batch operation, `reset`, is in the `add` object, telling Apostrophe that this is a new operation to add to the module. It then has a number of configuration properties:

```javascript
label: 'Reset',
```

`label` defines its legible label. The label is used for accessibility when this is an *ungrouped* operation and is used as the primarily interface label when the operation is *grouped*. We should always include a label.

```javascript
icon: 'recycle-icon',
```

The `icon` setting is the primary visible interface when the operation is not in an operation group (see below for more on that). Note that this icon is [configured in the `icons` module setting](/reference/module-api/module-overview.md#icons) in the example.

```javascript
messages: {
  progress: 'Resetting {{ type }}...',
  completed: 'Reset {{ count }} {{ type }}.',
  completedWithFailures: 'Reset {{ count }} {{ type }} ({{ bad }} of {{ total }} failed).',
  failed: 'Resetting {{ type }} failed.',
},
```

The `messages` object properties are used in notifications that appear to tell the editor what is happening behind the scenes. The `progress` message appears when the operation begins and the `completed` messages appears when it is done. The `completedWithFailures` and `failed` messages are optional. The `completedWithFailures` message appears when it is done, but it contains some failures. The `failed` message appears when it is done and it has failed entirely.

They both can use the `type` interpolation key, which Apostrophe replaces with the piece type label. The `completed` message can also include a `count` interpolation key, which is replaced by the number of pieces that were updated.

```javascript
if: {
  archived: false
},
```

`if` is an optional property that allows you to define filter conditions when the option is available. In this case, the "Reset" operation is only available when the `archived` filter is `false` (the editor is not looking at archived pieces). This might be because archived pieces should be left as they are and not reset to their defaults. This property works similar to [conditional schema fields](/guide/conditional-fields.md), but in this case the conditions are for manager filters, not fields.

```javascript
modalOptions: {
  title: 'Reset {{ type }}',
  description: 'Are you sure you want to reset {{ count }} {{ type }}?',
  confirmationButton: 'Yes, reset the selected content'
}
```

The `modalOptions` object configures the confirmation modal that appears when an editor initiates a batch operation. This confirmation step helps to prevent accidental changes to possibly hundreds of pieces. If this is not included, the batch operation's `label` is used for the title, there is no description, and the standard confirmation button label is used (e.g., "Yes, continue.").

```javascript
permission: 'edit'
```

The `permission` setting takes a value that determines whether the editor has permission for the operation. Valid values are `edit`, `publish`, and `delete`/

With this configuration, we should immediately see a button for the "Reset" operation in the article piece manager.

![The article piece manager, now with a button using the recycle symbol](/images/batch-operation-recycle-button.png)

## Adding the API route

Right now if we clicked that new button and confirmed to continue nothing would happen except for an error notification saying something like "Batch operation Reset failed." Since the batch operation is called `reset`, the manager is going to look for an API route at `/v1/api/article/reset` (the piece type's base API path, plus `/reset`). We need to add that route to the piece type.

Batch operation route handlers will usually have a few steps in common, so we can look at those elements in the example below.

<AposCodeBlock>

  ```javascript
  module.exports = {
    // `batchOperations` and other module settings...
    apiRoutes(self) {
      return {
        post: {
          reset(req) {
            // Make sure there is an `_ids` array provided.
            if (!Array.isArray(req.body._ids)) {
              throw self.apos.error('invalid');
            }

            // Ensure that the req object and IDs are using the same locale
            // and mode.
            req.body._ids = req.body._ids.map(_id => {
              return self.inferIdLocaleAndMode(req, _id);
            });

            // Run the batch operation as a "job," passing the iterator function
            // as an argument to actually make the changes.
            return self.apos.modules['@apostrophecms/job'].runBatch(
              req,
              self.apos.launder.ids(req.body._ids),
              resetter,
              {
                action: 'reset'
              }
            );

            // The iterator function that updates each individual piece.
            async function resetter (req, id) {
              const piece = await self.findOneForEditing(req, { _id: id });

              if (!piece) {
                throw self.apos.error('notfound');
              }

              // ü™Ñ Do the work of resetting piece field values.

              await self.update(req, piece);
            }
          }
        }
      };
    }
  };
  ```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

Let's look at the pieces of this route, focusing on the parts that are likely to be common among most batch operations.

```javascript
apiRoutes(self) {
  return {
    post: {
      reset(req) {
        // ...
      }
    }
  };
}
```

We're adding our route to the [`apiRoutes` customization function](/reference/module-api/module-overview.md#apiroutes-self) as a `POST` route since the route will need to receive requests with a `body` object.

```javascript
if (!Array.isArray(req.body._ids)) {
  throw self.apos.error('invalid');
}
```

The Apostrophe user interface should take care of this for you, but it is always a good idea to include a check to make sure that the body of the request includes an `_ids` array.

```javascript
req.body._ids = req.body._ids.map(_id => {
  return self.inferIdLocaleAndMode(req, _id);
});
```

This step may not be obvious, but since Apostrophe documents have versions in various locales, as well as both "live" and "draft" modes, it's important to use the `self.inferIdLocaleAndMode()` method on the IDs in most cases. In this context it is primarily used to update the `req` object to match the document IDs.

```javascript
  return self.apos.modules['@apostrophecms/job'].runBatch(
    req,
    self.apos.launder.ids(req.body._ids),
    resetter,
    {
      action: 'reset'
    }
  );
  ```

  This is more or less the last part (though we'll also need to take a look at that `resetter` iterator). The job module, `@apostrophecms/job`, has methods to process long-running jobs, including `runBatch` for batch operations. `runBatch` takes the following arguments:
  - the `req` object
  - an array of IDs, `req.body._ids`, used to find database documents to update (we're running it through a method that ensures they are ID-like)
  - an iterator function (more on that below)
  - an options object, which we always use to include to define the `action` name for client-side event handlers

```javascript
async function resetter (req, id) {
  const piece = await self.findOneForEditing(req, { _id: id });

  if (!piece) {
    throw self.apos.error('notfound');
  }

  // ü™Ñ Do the work of resetting piece field values here...

  await self.update(req, piece);
}
```

Finally, the iterator, `resetter` in this example, will receive the request object and a single document ID. This is where we as developers need to do the work of updating each selected piece. Our example here finds the piece, throws an error if not found, then eventually uses the `update` method to update the piece document. The magic `ü™Ñ` comment is where we would add the additional functionality to actually reset values.

With that API route added, when we restart the website and run the batch operation again we should see our notifications indicating that it completed successfully.

![The articles manager modal with two notifications indicating that the batch operation completed successfully](/images/batch-operation-complete.png)

## Batch operations for pages
In this example, we added a `batchOperation` to a piece type, but a similar example could be used for a page. One thing to keep in mind is that batch operations are added to the `@apostrophecms/page` module at project-level and are applied to *any* selected page, regardless of page-type.

The process for adding a batch operation for a page is the same as for a piece.

1. Add and configure the batch operation itself
2. Add the API route that powers the batch operation

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > In-context Custom Widgets
DOC_PATH: guide/editing-custom-widgets-in-context.md
URL: https://apostrophecms.com/docs/guide/editing-custom-widgets-in-context
================================================================================
# Editing custom widgets in context

::: info
Be sure to read [customizing the user interface](custom-ui.md) first before proceeding with this guide. In this guide we will assume you are already familiar with `APOS_DEV=1` or using `hmr: 'apos'`, `ui/apos/components` and other concepts covered there.

Most [custom widgets](custom-widgets.md), and indeed most core widgets, are edited in a dialog box when the user clicks on the edit button. But there is another possibility: in-context editing on the page. The standard rich text widget is an example of this. The user types text directly on the page.

While editing a schema of fields in the provided dialog box is convenient for developers, sometimes editing directly on the page provides a better user experience. This guide explains how to do that.

::: warning
Editing on the page is not always the best path. Always consider the smallest space in which the widget might be placed when making this decision. Also bear in mind that the appearance of the widget will be different on different devices. The "what you see is what you get" experience can be misleading in some situations.

To implement on-page editing for a custom widget type, we must implement the following pattern:

## The basics of contextual editing

### Module configuration

The `contextual` option of the widget module must be set to `true`. This is the trigger for contextual editing. Otherwise the normal editing dialog box is displayed for the widget.

The `components` option of the widget module determines the Vue components to be used for the editing experience. Currently there is just one subproperty, `widgetEditor`, which is required for contextual editing.

The `defaultData` option of the widget module may be set to a default value for newly created widgets of this type.

### The widget editor

The Vue component name configured via the `widgetEditor` subproperty of the `components` option (the "widget editor") must display the content of the widget in an editable form. To provide a contextual editing experience, that interface should be similar to the ordinary read-only view generated by `widget.html`.

The widget editor receives a `modelValue` Vue prop containing the existing value of the widget (an object), and emits an `update` Vue event with a new object whenever appropriate. The component should *not* modify the `modelValue` prop given to it.

The widget editor **must not** attempt to save changes by itself. Instead it must emit the `update` event and let Apostrophe takes care of the rest. Never assume the widget will be in a particular document type. It may be in any area, nested in any document type. Apostrophe will handle this for you.

The widget editor also receives an `options` prop. This object contains any options that were passed to this particular widget as part of the configuration of an `area` field. For instance, this is how the rich text widget receives its `toolbar` option.

### Debouncing update events

If the value will be changing quickly, for instance as the user types, performance can suffer if an `update` event is generated for every keystroke. The widget editor can speed up the interface by emitting an `update` event no more than once per second. This is called "debouncing."

As a hint that input might not yet be saved, a widget that "debounces" `update` events should emit a `context-editing` event on every change, even if `update` is intentionally delayed. However this should only be done if the `docId` prop passed to the widget editor is equal to `windows.apos.adminBar.contextId`.

If the `focused` prop of the widget editor becomes `false` and an `update` event has been delayed for debouncing purposes, the widget should cancel its timer and immediately emit the update. Use Vue's `watch` feature to monitor `focused`.

### Saving the content

By default the `fields` section of a contextually edited widget has no effect on the user interface. Emitting a reasonable value is the task of the custom widget editor component. However configuring fields is still necessary since the server will still use them to sanitize the data before saving it.

If no `fields` section is configured, no data will be saved at all unless the `sanitize` method of the module is overridden to provide an alternative way to verify user input, as is done in the case of the core rich text widget.

## Example

Here is a simple "hero" heading widget. Both the heading and the width of the heading can be adjusted directly on the page. This gives the user immediate visual feedback.

<AposCodeBlock>

``` js
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    contextual: true,
    defaultData: {
      heading: '',
      width: 100
    },
    components: {
      widgetEditor: 'HeroWidgetEditor'
    }
  },
  fields: {
    add: {
      heading: {
        type: 'string',
        def: ''
      },
      width: {
        type: 'integer',
        min: 10,
        max: 100,
        def: 100
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/hero-widget/index.js
  </template>
</AposCodeBlock>

**What is happening here?**

This `index.js` file configures the `hero-widget` module. The `contextual: true` option enables contextual editing, `defaultData` provides a default value that satisfies the schema, and `components` configures the Vue component name to be used for editing.

The `fields` section provides a schema of fields to sanitize and store the data in the widget. Even though the interface does not use a traditional form, this is still a convenient way to verify the content meets expectations on the server side. Remember: it is never OK for the server to trust the browser.

::: warning
Don't forget to also enable the module in `app.js`, like any other module.

<AposCodeBlock>

``` nunjucks
<h1 class="contextual-heading" style="width: {{ data.widget.width }}%">
  {{ data.widget.heading }}
</h1>
```
  <template v-slot:caption>
    modules/hero-widget/views/widget.html
  </template>
</AposCodeBlock>

**What is happening here?**

This is a straightforward `widget.html` template, as might be found in any custom widget. The presentation is intentionally similar to that used in the widget editor component, below.

<AposCodeBlock>

``` js
<template>
  <div :class="{ focused }">
    <input
      class="contextual-heading"
      type="text"
      v-model="heading"
      placeholder="Heading"
      :style="style"
    />
    <div class="contextual-heading-controls">
      <button
        :class="buttonClasses(25)"
        @click.stop.prevent="setWidth(25)"
      >25%</button>
      <button
        :class="buttonClasses(50)"
        @click.stop.prevent="setWidth(50)"
      >50%</button>
      <button
        :class="buttonClasses(75)"
        @click.stop.prevent="setWidth(75)"
      >75%</button>
      <button
        :class="buttonClasses(100)"
        @click.stop.prevent="setWidth(100)"
      >100%</button>
    </div>
  </div>
</template>

<script>

export default {
  name: 'HeroWidgetEditor',
  props: {
    type: {
      type: String,
      required: true
    },
    options: {
      type: Object,
      required: true
    },
    modelValue: {
      type: Object,
      default() {
        return {};
      }
    },
    docId: {
      type: String,
      required: false,
      default() {
        return null;
      }
    },
    focused: {
      type: Boolean,
      default: false
    }
  },
  emits: [ 'update' ],
  data() {
    return {
      heading: this.modelValue.heading,
      width: this.modelValue.width
    };
  },
  watch: {
    heading() {
      this.emitUpdate();
    },
    width() {
      this.emitUpdate();
    }
  },
  computed: {
    style() {
      return {
        width: `${this.width}%`
      };
    }
  },
  methods: {
    emitUpdate() {
      this.$emit('update', {
        ...this.modelValue,
        heading: this.heading,
        width: this.width
      });
    },
    setWidth(n) {
      this.width = n;
    },
    buttonClasses(width) {
      return {
        [`width-${width}`]: true,
        active: this.width === width
      };
    }
  }
};
</script>

<style lang="scss" scoped>
  .contextual-heading-controls {
    display: none;
    text-align: center;
  }
  .focused .contextual-heading-controls {
    display: block;
  }
  .contextual-heading-controls button {
    font-size: 10px;
  }
  button.active {
    background-color: red;
    color: white;
  }
  .width-25 {
    width: 36px;
    height: 24px;
  }
  .width-50 {
    width: 72px;
    height: 24px;
  }
  .width-75 {
    width: 96px;
    height: 24px;
  }
  .width-100 {
    width: 144px;
    height: 24px;
  }
</style>
```
  <template v-slot:caption>
    modules/hero-widget/ui/apos/components/HeroWidgetEditor.vue
  </template>
</AposCodeBlock>

**What is happening here?**

This is `HeroWidgetEditor`, the custom widget editor Vue component for this widget type. The `focused` prop is used to decide whether to show the resizing buttons for the hero heading, so they don't clutter the page when the user is not editing this widget. When the user changes either the width or the heading text, the widget editor emits an `update` event with a new object containing the `width` and `heading` fields, **in addition to** any pre-existing properties of the original `modelValue` prop.

::: warning
When emitting an update, be sure to include any properties of `modelValue` that your editor does not directly edit, such as `type`. Otherwise a JavaScript error will occur. The easiest way to do this is with `...this.modelValue`, as shown here.

<AposCodeBlock>

```css
.contextual-heading {
  display: block;
  color: white;
  background-color: red;
  padding: 24px;
  border: 1px solid #f88;
  font-size: 24px;
  text-align: center;
  margin: auto;
  box-sizing: border-box;
}
```
  <template v-slot:caption>
    modules/hero-widget/ui/src/index.scss
  </template>
</AposCodeBlock>

**What is happening here?**

Last but not least, we still need styles for the widget's normal appearance when it is not being edited. A `ui/src/index.scss` file for the `hero-widget` module is a good place to do that and will automatically be loaded all the time, unlike the admin UI components in `ui/apos`.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Custom Widget Placeholders
DOC_PATH: guide/adding-custom-widget-placeholder-content.md
URL: https://apostrophecms.com/docs/guide/adding-custom-widget-placeholder-content
================================================================================
# Adding placeholders to custom widgets

Custom widgets can also take advantage of non-schema field placeholders by adding code to the widget module in question, preparing the widget template to show the custom placeholder content, and adding the placeholder content into an accessible folder.

## Basic placeholder addition

### Altering the `index.js` file

 In order to add a custom image file, two options should be set within the widget `index.js` file, `placeholder: true` and the `placeholderImage` option with the value set to the file extension of the placeholder content without any `.` prefix.

Next, to supply the URL of the placeholder content, the module should invoke the `determineBestAssetUrl('placeholder')` method in the `init(self)` initialization function.

Even though the option name ends with `Image`, this same method can be used for adding custom video placeholder content that will be uploaded into the module's `public` folder. In contrast, for videos that are hosted externally, you need to add the `placeholder: true` and `placeholderUrl` option with the value set to the URL of the resource. The initialization function in this case can be skipped.

Example for adding a custom image.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Custom Widget',
    placeholder: true,
    placeholderImage: 'png'
  },
  init(self) {
    self.determineBestAssetUrl('placeholder');
  },
  // remainder of the widget code
};
```

<template v-slot:caption>
  modules/custom-widget/index.js
</template>

</AposCodeBlock>

::: info
You can bypass the call to `determineBestAsetUrl()` for your images or videos stored in the `public` folder and instead pass the path to the asset using `placeholderUrl` in place of `placeholderImage`. This is discouraged because errors can be made in this path. It is better to let Apostrophe figure this out for you.

### Altering the widget.html file

The specific alteration of the `widget.html` template will depend on the type of placeholder content being delivered. Irrespective of file type, the template will have access to `data.widget.aposPlaceholder` and `data.manager.options.placeholderUrl` to populate the markup. 

The first, `data.widget.aposPlaceholder`, allows for confirmation that the placeholder should be displayed. This will return `true` when the widget is first added and return `false` once the widget has been edited.

The second, `data.manager.options.placeholderUrl`, will contain the path to the content placeholder asset. If you set the `placeholderImage`, this will either be the path computed by the call to `determineBestAssetUrl()`. Otherwise, it will be the URL passed directly through the `placeholderUrl` option.

This example demonstrates adding an image.

<AposCodeBlock>

``` nunjucks
<section data-custom-widget>
  <h1>Custom Widget</h1>
  {% if data.widget.aposPlaceholder and data.manager.options.placeholderUrl %}
  <img
    src="{{ data.manager.options.placeholderUrl }}"
    alt="{{ __t('nameSpace:imagePlaceholder') }}"
    class="custom-widget-placeholder"
  />
  {% else %}
    <!-- markup displayed after the user edits the widget -->
  {% endif %}
</section>
```
<template v-slot:caption>
  modules/custom-widget/views/widget.html
</template>

</AposCodeBlock>

This example demonstrates adding a self-hosted video.

<AposCodeBlock>

``` nunjucks
<section data-custom-widget>
  <!-- For videos uploaded to the `public` folder -->
  {% if data.widget.aposPlaceholder and data.manager.options.placeholderUrl %}
    <video controls width="250">
      <source src="{{ data.manager.options.placeholderUrl }}" type="video/mp4" />
    </video>
  {% else %}
    <!-- markup displayed after the user edits the widget -->
  {% endif %}
</section>
```

<template v-slot:caption>
  modules/custom-widget/views/widget.html
</template>

</AposCodeBlock>

### Add the placeholder content file
Your placeholder content should be added to the `public` folder of the custom widget. It should be named `placeholder.extension`, where the extension matches the extension passed into the `placeholderImage` option. In the first example above, the file should be `modules/custom-widget/public/placeholder.png`.

## Adding a placeholder with a custom name
In some cases, a widget might need to have more than a single piece of placeholder content, or you might want to give the placeholder content a different name than `placeholder.extension`. In this case, once again you need to modify the main module options, the Nunjuck template, and the contents of the public folder.

### Altering the `index.js` file for custom placeholders

As with the basic addition of a placeholder, for one or more custom placeholders the `placeholder` option should have a value of `true`. Next, the extension of any project-hosted custom placeholders should be passed in an option of `<name>Image`. For example, `customOneImage: 'png`' and `customTwoImage: 'png'`. For any videos that are not uploaded to the project, the URL can be added to an option of `<name>Url`, for example, `videoOneUrl`.

For each self-hosted placeholder, the initialization function should call the `determineBestAssetUrl()` method, with the name of the placeholder passed as an argument. For example `self.determineBestAssetUrl('customOne')` and `self.determineBestAssetUrl('customTwo')`. This is not required for assets using the `<name>Url` option.

If electing to add multiple placeholders to a single page, as soon as the user makes any edits, all placeholder content will be removed from the page because `aposPlaceholder` is only checked once to determine if the widget has been edited.

### Altering the Nunjucks template for custom placeholders

The template will still have access to `data.widget.aposPlaceholder` to determine if the widget has been edited and remove placeholder content. The URL for the placeholder can be accessed using `data.manager.options.<name>Url`. For example, `data.manager.options.customOneUrl` or `data.manager.options.videoOneUrl`. This will be available for each `<name>Image` and `<name>Url` option in the module.

The same conditional block that was used for a single basic placeholder should be used for each custom placeholder added to the template.

### Adding files for custom placeholders

All of the self-hosted custom placeholder assets should be copied to the module's `public` folder. The file names and extensions should match the options passed to the main module file. For the example above, this would be `modules/custom-widget/public/customOne.png` and `modules/custom-widget/public/customTwo.png`.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Custom Auth Requirements
DOC_PATH: guide/custom-login-requirements.md
URL: https://apostrophecms.com/docs/guide/custom-login-requirements
================================================================================
# Custom login requirements

Apostrophe's built-in login form handles the typical case where a user logs in with a username and password. And the [@apostrophecms/passport-bridge](https://github.com/apostrophecms/passport-bridge) module handles "single sign-on," in which users log in via a third-party system like Google Workspace, Twitter, Facebook, etc. These two solutions cover most situations. However in some cases developers may wish to extend the built-in login form with additional, custom login requirements. Often these are shipped as npm modules. This guide will explain how to implement such requirements.

The main focus of this guide is on implementing requirements involving custom UI, such as CAPTCHA, two-factor authentication (TOTP), "math problems" and other additional steps at login time. However we'll start by briefly addressing password complexity as it is a common requirement and implemented separately.

## Password complexity rules

While [most password complexity rules are often counterproductive](https://arstechnica.com/information-technology/2013/06/password-complexity-rules-more-annoying-less-effective-than-length-ones/), some organizations may have a business requirement to implement them. Currently the easiest rule to implement, and the most effective one, is to set a minimum length. You can do that by configuring the `@apostrophecms/user` module at project level:

<AposCodeBlock>

  ```javascript
  module.exports = {
    fields: {
      add: {
        // "Re-add" the standard password field
        // to reconfigure it
        password: {
          type: 'password',
          label: 'Password',
          // Minimum number of characters
          min: 10
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/user/index.js
  </template>
</AposCodeBlock>

## The phases of login

Apart from password complexity, most enhancements to the login form involve at least some new UI code. UI components added this way are integrated into the existing login interface. This involves both backend Node.js development and frontend Vue 2 [component](https://vuejs.org/v2/guide/components.html) development.

Apostrophe allows you to add extra login requirements during three different phases of the login process:

* `beforeSubmit`: Requirements in this phase are displayed before the user clicks the Login button. If the requirement has a visible UI, it appears at the bottom of the login form itself. Best used for requirements that have no visible interface but need to monitor user behavior on the form to determine if the user is "real," like [hCaptcha](https://docs.hcaptcha.com).
 * `uponSubmit`: Requirements in this phase are displayed after the user clicks the Login button, but before any password verification takes place. Best used for requirements that that have no visible interface and must re-run each time the user clicks on the Login button like [reCAPTCHA v3](https://developers.google.com/recaptcha/docs/v3).
* `afterPasswordVerified`: Requirements in this phase are displayed after the form is completed, the Login button is clicked, and the password is verified. Best used for requirements that have a visible interface and which require any special knowledge about the user, such as a Two-Factor Authentication (2FA) challenge. 

## The server side

Each distinct requirement has its own server-side code, which must be added to the `requirements(self)` module configuration function of the `@apostrophecms/login` module at project level, or to an npm module that enhances it via `improve`.

The object returned by `requirements` is similar to that returned by `fields`, in that it has an `add` property, and each individual login requirement is a sub-property of `add`.

Each requirement must have a unique name. The name of each requirement should be CapitalizedInCamelCase, as it doubles as a Vue component name, as explained below.

Each requirement has:

* A `phase` property, which must be `beforeSubmit`, `uponSubmit` or `afterPasswordVerified`.
* A `props()` function, which may be `async` and returns an object. The properties of the returned object become Vue `props` of the Vue component, as explained below. For `beforeSubmit` and `uponSubmit` the `props()` function receives `(req)`, for `afterPasswordVerified` it receives `(req, user)`.  The `req` object allows access to the [current Express request](https://expressjs.com/en/api.html#req), including `req.session` which can be useful for temporary storage not revealed to the browser. The `user` object allows access to the current user even though login is not yet complete.
* A `verify()` function, which may be `async`. For `beforeSubmit` and `uponSubmit` the `verify()` function receives `(req, data)`, for `afterPasswordVerified` it receives `(req, data, user)`. This function is responsible for throwing an exception if the requirement has not been met. Any data provided by the Vue component will be accessible here as the `data` argument.
* For `afterPasswordVerified` requirements only, an optional `askForConfirmation: true` property. If present the corresponding Vue component is responsible for displaying its own success message and emitting a `confirm` event as described later. Otherwise flow proceeds automatically to the next step.

To illustrate, the general structure on the server side is:

<AposCodeBlock>

  ```javascript
  module.exports = {
    requirements(self) {
      return {
        add: {
          RequirementName: {
            phase: 'afterPasswordVerified',
            async props(req, user) {
              return {
                propName: propValue
              };
            },
            async verify(req, data, user) {
              if (!verifyThisCodeIsCorrect(data)) {
                throw self.apos.error('invalid', 'appropriate message');
              }
            }
          }
        }
      };
    }
  };
  ```
  <template v-slot:caption>
    modules/@apostrophecms/login/index.js
  </template>
</AposCodeBlock>

## The browser side

Each distinct requirement also has browser-side code, which is implemented as a Vue component. As explained in the [custom UI guide](custom-ui.md), Vue components intended for the admin UI (including login requirements) must be placed in the `ui/apos/components` subdirectory of a module in the project. For this purpose they are typically placed in the `modules/@apostrophecms/login/ui/apos/components` module at project level, or in an npm module that enhances `@apostrophecms/login` via `improve`.

The developer is responsible for the appearance of the component. For `beforeSubmit` and `uponSubmit` requirements, the component will appear at the bottom of the login form itself. For `afterPasswordVerified` requirements, it will appear on its own, after the Login button is clicked and the password is verified. If there are multiple `afterPasswordVerified` requirements, the user will see them presented one at a time. Transitions are provided by Apostrophe and do not need to be included in login requirement components.

Each component is responsible for:

* Presenting its own UI, if any. Note that `afterPasswordVerified` requirements will appear in isolation, one at a time, while any UI for `beforeSubmit` components will appear simultaneously with the login form. Any UI for uponSubmit will appear after the Login button is clicked and remain until each has emitted a `done` event.
* Accepting the properties of the object returned by the server-side `props(req)` function as props.
* Emitting a `done` event with a payload providing proof that the requirement has been met. This proof is accessible to the `verify(req)` function on the server side as `req.body.requirements.RequirementName`. In the case of `afterPasswordVerified` requirements, the `done` event should not be emitted until the user has indicated their response is complete in some way.
* `beforeSubmit` requirements may emit a `block` event to cancel a previous `done` event so that the Login button cannot be clicked yet.
* `uponSubmit` requirements may emit a `block` event to cancel a previous `done` event so that the Login button can be clicked again.
* `afterPaswordVerified` requirements are responsible for displaying a custom error message when the `error` Vue prop is set to an error object.
* `afterPasswordVerified` requirements that set the `askForConfirmation` property are also responsible for displaying a custom success message when the `success` Vue prop is true.

While there is no fixed structure for the Vue components, a typical outline looks like:

<AposCodeBlock>

  ``` javascript
  <template>
    <fieldset>
      <label>What code did you receive?</label>
      <p>Hint: {{ hint }}</p>
      <input type="text" v-model="value" />
      <button type="button" @click="go">OK</button>
      <p v-if="error">{{ error.message }}</p>
    </fieldset>
  </template>
  <script>
  export default {
    emits: [ 'done' ],
    props: {
      // Comes from the hint property of the
      // object returned by props(req) on the server side
      hint: String,
      error: String
    },
    data() {
      return {
        value: ''
      };
    },
    methods: {
      go() {
        this.$emit('done', this.value);
      }
    }
  };
  </script>
  ```
  <template v-slot:caption>
    modules/@apostrophecms/login/ui/apos/components/RequirementName.vue
  </template>
</AposCodeBlock>

## Implementing `beforeSubmit` or `uponSubmit` requirements

Here is complete server-side code for a simple requirement to solve a math problem when logging in. The UI appears at the bottom of the login form because the password has not been verified yet.

<AposCodeBlock>

  ``` javascript
  module.exports = {
    requirements(self) {
      return {
        add: {
          MathProblem: {
            phase: 'beforeSubmit',
            async props(req) {
              if (!(req.session.mathProblem && req.session.mathAnswer)) {
                const x = Math.ceil(Math.random() * 5);
                const y = Math.ceil(Math.random() * 5);
                req.session.mathProblem = `${x} + ${y}`;
                req.session.mathAnswer = x + y;
              }
              return {
                mathProblem: req.session.mathProblem
              };
            },
            async verify(req, data) {
              const answer = self.apos.launder.integer(data);
              if ((!req.session.mathAnswer) || (answer !== req.session.mathAnswer)) {
                throw self.apos.error('invalid', 'math problem incorrect');
              }
            }
          }
        }
      };
    }
  };
  ```
  <template v-slot:caption>
    modules/@apostrophecms/login/index.js
  </template>
</AposCodeBlock>

**What is happening here?**

* The `props()` function of the requirement is invoked before the form appears and returns an object whose properties become props for the custom Vue component shown below. Because it has access to `req`, the [Express request object represnting the current browser request](https://expressjs.com/en/api.html#req), this function can store information about the "challenge" presented by the requirement in `req.session` so that it remains available for verifying the result **without disclosing the right answer** to the browser.
* The `verify()` function of the requirement is invoked when the login form is completed and the user clicks Login. Note that Apostrophe won't allow that to happen until the custom Vue component emits a `done` event, as shown below. `verify()` also has access to `req`, so it can consult `req.session` to see if the response is correct.
* If `verify()` throws an error, the error is displayed and the login form can be submitted again. If no requirements throw an error, login proceeds, to the `afterPasswordVerified` requirements if any.

::: warning
This simple example uses `req.session`, however be aware that if your site uses bearer tokens for headless REST API logins you will need to store temporary information between requests in another way, such as by using the `@apostrophecms/cache` module. Sessions are not available to headless API clients.

To complete the requirement we also need a Vue component on the browser side. As explained in the [custom UI guide](custom-ui.md), Vue components intended for the admin UI (including login requirements) must be placed in the `ui/apos/components` subdirectory of a module in the project, like this:

<AposCodeBlock>

  ``` javascript
  <template>
    <fieldset>
      <label>Math Problem: what is {{ mathProblem }}?</label>
      <input type="text" v-model="value" />
      <button type="button" @click="go">OK</button>
    </fieldset>
  </template>
  <script>
  export default {
    emits: [ 'done' ],
    props: {
      mathProblem: String
    },
    data() {
      return {
        value: ''
      };
    },
    methods: {
      go() {
        this.$emit('done', this.value);
      }
    }
  };
  </script>
  <style scoped>
    fieldset {
      color: white;
    }
  </style>
  ```
  <template v-slot:caption>
    modules/@apostrophecms/login/ui/apos/components/MathProblem.vue
  </template>
</AposCodeBlock>

::: info
Don't forget to set the `APOS_DEV` environment variable to `1` when developing admin UI code. Otherwise Apostrophe will not rebuild the admin UI automatically when you make changes to admin UI code, such as login requirement components.

If your project is derived from `starter-kit-essentials` you can type:

``` bash
APOS_DEV=1 npm run dev
```

If this is unfamiliar to you we recommend reading [Customizing the user interface](custom-ui.md) first.

**What is happening here?**

This Vue component has only one job: take the props returned by the server-side `props` function, display an appropriate interface, and emit a `done` Vue event with the user's response to the challenge. Everything else is handled for us by Apostrophe.

::: info
Apostrophe looks for a Vue component with the same name as the requirement.

## Implementing `afterPasswordVerified` requirements

Unlike the other phase, requirements displayed in the `afterPasswordVerified` phase can potentially access information about the user when returning props and verifying responses. This is essential for implementing features like 2FA (such as Google Authenticator support) because an additional secret must be stored in Apostrophe's user document.

Below is a simple example of a requirement to solve a weak form of 2FA challenge: entering a code that is assigned the first time the user logs in successfully.

<AposCodeBlock>

  ``` javascript
  module.exports = {
    requirements(self) {
      return {
        add: {
          Weak2FA: {
            phase: 'afterPasswordVerified',
            async props(req, user) {
              if (!user.weak2FA) {
                const code = Math.random().toString().replace('.', '').substring(0, 4);
                await self.apos.doc.db.updateOne({
                  _id: user._id
                }, {
                  $set: {
                    weak2FA: code
                  }
                });
                return {
                  code
                };
              }
              // A code is already set, don't return it, that would
              // defeat the purpose of ensuring the user can verify it
            },
            async verify(req, data, user) {
              if (data !== user.weak2FA) {
                throw self.apos.error('invalid', '2FA secret incorrect');
              }
            }
          }
        }
      };
    }
  };
  ```
  <template v-slot:caption>
    modules/@apostrophecms/login/index.js
  </template>
</AposCodeBlock>

**What is happening here?**

This code isn't too different from the `MathProblem` requirement. The most important differences are:

* `props()` and `verify()` both receive `(req, user)`. While the user is not completely logged in yet, we have access to the `user` piece in these functions. This allows us to use a MongoDB `updateOne` operation to `$set` a random 2FA challenge code on the first call to `props()`. Note that we only return the code the first time, as otherwise any script can "sniff" the right answer and defeat the requirement. In this simple example, the user is expected to remember it.

::: info
In a real 2FA system, a new challenge might be texted to the user's device each time ‚Äî or a stored code much like this one, but longer and more secure, might be used to generate a time-based one-time password (TOTP) as with Google Authenticator.

A real 2FA system requiring a "setup code" like this one would also continue to display it until the user successfully verifies it for the first time, marking the code as confirmed, in case the user doesn't succeed in setting it up on the first try.

Here is the front-end Vue component code for this requirement:

<AposCodeBlock>

  ```javascript
  <template>
    <fieldset>
      <p v-if="code">
        Welcome, first-time user!<br />
        Your 2FA code is {{ code }}<br />
        It will not be displayed again. Make a note of it.
      </p>
      <label>2FA code</label>
      <input type="text" v-model="value" />
      <button type="button" @click="go">OK</button>
    </fieldset>
  </template>
  <script>
  export default {
    emits: [ 'done' ],
    props: {
      code: String
    },
    data() {
      return {
        value: ''
      };
    },
    methods: {
      go() {
        this.$emit('done', this.value);
      }
    }
  };
  </script>
  <style scoped>
    fieldset {
      color: white;
    }
  </style>
  ```
  <template v-slot:caption>
    modules/@apostrophecms/login/ui/apos/components/Weak2FA.vue
  </template>
</AposCodeBlock>

**What is happening here?**

There's not much new here in comparison to the earlier requirement, which you should review as well. However note that the interface adapts to whether we're displaying a new `code` for the first time or not.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Webpack Configuration
DOC_PATH: guide/webpack.md
URL: https://apostrophecms.com/docs/guide/webpack
================================================================================
# Webpack

In modern Apostrophe (>=4.9.0), there are now two methods available for building project assets. By default, Apostrophe uses a [webpack](https://webpack.js.org/)-powered process to compile frontend JavaScript and SCSS automatically, so following the [frontend asset documentation](front-end-assets.md) is usually all you need. For those who prefer, Apostrophe now offers an optional build process using [Vite](https://vite.dev/) for either the Admin UI or public-facing assets. For details, refer to the [Vite configuration documentation](vite.md).

Sometimes we want to extend the way webpack processes our frontend code, specifically in two ways:

* By changing the webpack rules (the webpack configuration) via "extensions," or
* By breaking up the bundle into two or more files, to be loaded only on pages that really require them ("extra bundles").

This guide covers how to address both situations.

## Extending Webpack configuration

If you need webpack to do things that Apostrophe doesn't do by default, you can extend Apostrophe's webpack configuration to change the way code in `ui/src` is compiled.

Why might you want to do this? perhaps you want to add a new loader for a specific file type, such as `.jsx`. Or perhaps you want to add aliases to load imported modules from a nonstandard location.

It's possible to extend the webpack config from any module. To do so add a `webpack` property at module root, like so:

<AposCodeBlock>

  ```javascript
    module.exports = {
      // ...
      webpack: {
        extensions: {
          utilsAlias: {
            resolve: {
              alias: {
                'Utils': path.join(process.cwd(), 'lib/utils/')
              }
            }
          }
        }
      }
    };
  ```
  <template v-slot:caption>
    modules/my-module/index.js
  </template>
</AposCodeBlock>

Note that `extensions` is an object with named sub-properties. Each one is separately merged with the webpack configuration.

::: info
Everything inside `utilsAlias` in the above example is merged with the webpack configuration. It is not specific to Apostrophe. If you are not familiar with webpack configuration, see the [webpack configuration documentation](https://webpack.js.org/configuration/).

::: warning
Any extensions you make to webpack apply to all files compiled as part of Apostrophe's public build (anything coming from `ui/src` folders). Take care not to break reasonable assumptions made by other developers. For example, adding custom aliases and loaders for new file extensions is OK. Changing `.js` files to only compile if they are valid TypeScript would not be OK and you can expect it to break other modules in your project.

The Apostrophe admin UI, on the other hand, is not affected by what you do here. That webpack build is separate.

### Overriding other extensions

Why do the extensions have names? First, this way you can know the purpose of the extension at a glance. Second, this permits another module to override a previous extension by using the same name. In such a case, the last configured module wins.

Imagine your project contains a module you cannot modify which extends webpack in a way that doesn't work for your needs. You can override it in your own module by adding an extension with the same name.

Example:

<AposCodeBlock>

  ```javascript
  {
    modules: {
      // ...
      'test-1': {},
      'test-2': {}
    }
  }
  ```
  <template v-slot:caption>
    app.js
  </template>
</AposCodeBlock>

<AposCodeBlock>

  ```javascript
  module.exports = {
    webpack: {
      extensions: {
        addAlias: {
          resolve: {
            alias: {
              Special: path.join(process.cwd(), 'lib/original/')
            }
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/test-1/index.js
  </template>
</AposCodeBlock>

<AposCodeBlock>

  ```javascript
  module.exports = {
    webpack: {
      extensions: {
        addAlias: {
          resolve: {
            alias: {
              Special: path.join(process.cwd(), 'lib/different/')
            }
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/test-2/index.js
  </template>
</AposCodeBlock>

Because the two extensions have the same name (`addAlias`) and the `test-2` module is configured last, import paths starting with `Special/` will point to `lib/different/` and not to `lib/original/`.

By contrast, if you use different extension names, two separate modules can contribute their own aliases. This works because they are automatically merged together with the main webpack configuration using [webpack-merge](https://github.com/survivejs/webpack-merge).

### Passing extensions options from any module

Webpack extensions can also be functions that take an `options` parameter.
From any module, you can declare an `extensionOptions` property in your webpack object. 
For each webpack extension found in the project, it will look for all `extensionOptions` of the same name and merge them in a single options object passed to the extension itself.

Example:

<AposCodeBlock>

  ```javascript
  module.exports = {
    webpack: {
      extensions: {
        // Extension can be a function and return the final config
        addAlias (options) {
          return {
            stats: options.stats,
            resolve: {
              alias: options.alias || {}
            }
          }
        }
      },
      extensionOptions: {
        // Options can be a function to merge and return new options
        addAlias (options) {
          return {
            alias: {
              Special: path.join(process.cwd(), 'lib/different/'),
              ...options.alias || {}
            }
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/test-1/index.js
  </template>
</AposCodeBlock>

<AposCodeBlock>

  ```javascript
  module.exports = {
    webpack: {
      extensionOptions: {
        addAlias (options) {
          return {
            alias: {
              ...options.alias || {},
              New: path.join(process.cwd(), 'lib/new/'),
            }
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/test-2/index.js
  </template>
</AposCodeBlock>

<AposCodeBlock>

  ```javascript
  module.exports = {
    webpack: {
      extensionOptions: {
        // It also can be a simple object if nothing has to be merged
        // We take care of merging first level properties
        addAlias: {
          stats: 'normal'
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/test-3/index.js
  </template>
</AposCodeBlock>

Following this example, the options object passed to the `addAlias` extension will look like this:
```javascript
{
  alias: {
    Special: path.join(process.cwd(), 'lib/different/'),
    New: path.join(process.cwd(), 'lib/new/')
  },
  stats: 'normal'
}
```

This way you'll be able to contribute to any webpack extension from any module in a flexible way.

## Extra bundles

If you have large amounts of frontend JavaScript that are specific to just one page or widget, you can generate "extra bundles" to be loaded only when those pages or widgets are present. For example, a widget that doesn't appear on most pages might require a large and complicated [player function](custom-widgets.md#client-side-javascript-for-widgets) with many imports of its own.

You can also configure the `@apostrophecms/asset` module to regroup JavaScript supplied in npm modules to better reflect how often the code is utilized within the project. 

::: warning
While extra bundles are a great feature, when used incorrectly they make sites slower, not faster.

Always ask yourself this question: **will a typical site visitor eventually load this code?** If so, you should **leave it in the main bundle** (import it from `ui/src/index.js`). This way the frequently needed code is always loaded up front and reused by every page without an extra request to the server.

Extra bundles should **only be used if the user probably won't need them on most visits.**

### Extra bundles for widgets

We can contribute code to a new, named bundle by adding a `bundles` sub-section to `webpack` in any module. In this case we'll look at a module that implements a widget type called `test`:

<AposCodeBlock>

```javascript
  module.exports = {
    extend: '@apostrophecms/widget-type',
    webpack: {
      bundles: {
        'test': {}
      }
    }
  };
  ```
  <template v-slot:caption>
    modules/test-widget/index.js
  </template>
</AposCodeBlock>

Because we did this in a module that extends `@apostrophecms/widget-type`, Apostrophe  loads the bundle automatically on all pages that contain this particular widget.

### Where do I put my frontend code for the bundle?

Just like the main bundle, code for extra bundles lives in the `ui/src` subdirectory of your module. However rather than placing it in `ui/src/index.js` you will place it in `ui/src/bundlename.js`, where `bundlename` matches the name of your bundle. In the example above, it would be `ui/src/test.js`. That file might look like:

<AposCodeBlock>

```javascript
import { bigThing } from 'big-package';

export default () => {
  apos.util.widgetPlayers.test = {
    selector: '[data-test]',
    player: function (el) {
      // ... use bigThing here
    }
  };
};
```
  <template v-slot:caption>
    modules/test-widget/ui/src/test.js
  </template>
</AposCodeBlock>

For completeness, we can also deliver stylesheets specific to this bundle in a `ui/src/test.scss` file. However it is usually more efficient to combine all styles in the main bundle.

::: info
Just like `ui/src/index.js`, `ui/src/test.js` must export a function. The exported functions are called in the order the modules that contribute to that bundle are configured in the project.

### Extra bundles for page types

Let's say we have another bundle, `about-page`, and we want to load an extra bundle just on that particular page type. We can do it like this:

<AposCodeBlock>

  ```javascript
    module.exports = {
      extend: '@apostrophecms/page-type',
      webpack: {
        bundles: {
          'about': {}
        }
      }
    }
  ```
  <template v-slot:caption>
    modules/about-page/index.js
  </template>
</AposCodeBlock>

Since we named the bundle `about`, we should place our frontend code in the `ui/src/about.js` file of the `about-page` module.

### Extra bundles for piece page types

Now let's say we have a piece page type, `product-page`. this module extends `@apostrophecms/piece-page-type`, which has separate `index` and `show` templates (see [piece pages](piece-pages.md)). In this case, we want the `product` bundle to be loaded on the `index` pages but not on the `show` pages for individual pieces.

We can accomplish that with the `templates` sub-property:

<AposCodeBlock>

  ```javascript
    module.exports = {
      extend: '@apostrophecms/piece-page-type',
      webpack: {
        bundles: {
          'product': {
            templates: [ 'index' ]
          }
        }
      }
    }
  ```
  <template v-slot:caption>
    modules/product-page/index.js
  </template>
</AposCodeBlock>

Configuring `templates` is not mandatory. If we don't add the `templates` property, the bundle will be loaded on both `index` and `show` pages, which is often useful.

### Bundles can receive contributions from many modules

Note that since bundles have their own names, **any module can contribute to any bundle.** This includes support for multiple contributions to the same bundle from unrelated modules, and from "base class" modules like `@apostrophecms/piece-type`. This is deliberate because it helps us create a small number of bundles for more efficient page loading. Functionality that is usually found on the same page should be part of the same bundle.

### Shared dependencies

If a custom bundle imports packages that are also imported by the "main" bundle (the one created by `ui/src/index.js` files), those packages are only loaded once but are available to both bundles. This saves time loading the page. Dependencies that are imported by two separate *extra** bundles might be included twice, which should not impact functionality but can add to page load time.

### Deployment

Apostrophe will take care of deploying the output files of custom bundles alongside those generated by the main bundle. Apostrophe will also generate the needed `script` and `link` tags automatically.

### Rebundling resources

In some cases, an npm package will provide front-end code that is bundled in a way that doesn't reflect the needs of the project. In these cases, the bundle configuration set by each module can be overridden through the `rebundleModules` option of the `@apostrophecms/asset` module.

This option takes an object with module names, optionally combined with a `:` and a bundle name, as properties and new bundle names as values.

<AposCodeBlock>

``` js
module.exports = {
  options: {
    rebundleModules: {
      // Everything from the fancy-form module should go in the regular "main" bundle
      'fancy-form': 'main',
      // Everything from the basic-product module should go in the "secondary" bundle
      'basic-product': 'secondary',
      // Code originally designated as part of the `form` bundle from 
      // the @dcad/form module should be retargeted to the"secondary" bundle
      // but only that code, leave ui/src/index.js in the main bundle
      '@dcad/form:form': 'secondary'
    }
  }
};
```

<template v-slot:caption>
modules/@apostrophecms/asset/index.js
</template>
</AposCodeBlock>

If the module name is given, without specifying a bundle name, all of the JavaScript assets from the `module/ui/src` folder will be added to the newly specified bundle. If a bundle name is provided by appending it to the module name with a `:`, then only the assets of that bundle will be rebundled. Other assets in the same module's `ui/src` folder will behave according to the module's original bundle configuration, if any, or be left in the main bundle.

To avoid ambiguity, when using `rebundleModules` to move assets provided as part of the project-level configuration of an apostrophe module originally loaded from npm, such as code found in `modules/@apostrophecms/home-page/ui/src/index.js`, use the module name `@apostrophecms/my-home-page`. Without the `my-` prefix the code from the original npm module would be moved.

::: info
Sending all of the module assets to one bundle and then designating an entry point in that same folder to go to a different bundle is considered invalid. Instead, each individual entry point should be rebundled to achieve this goal.

## The Webpack cache

Apostrophe uses webpack's built-in support for caching of modules in the filesystem. In normal use you should never have to worry about this, you simply benefit from a speed improvement. However, in certain scenarios you may wish to configure the location of the cache or clear it.

### Clearing the Webpack cache

In cases such as a change to your webpack configuration that Apostrophe cannot automatically detect and therefore fails to cause a desired change in the compiled output, you may need to clear the webpack cache. You can do that with this command line task:

```bash
node app @apostrophecms/asset:clear-cache
```

This task will be used rarely, as most changes to the webpack configuration are automatically detected. You will never need it if all you are doing is updating your frontend code.

### Configuring the location of the Webpack cache

By default, the cache is written to `data/temp`, relative to the project root. This works well in development and can work well in production as well, as long as `data` is a persistent folder.

In development, this usually doesn't require any change. However some attention must be paid to get the same performance improvement on later deployments that one receives in a development environment.

If the `data` folder is ephemeral (if it is erased with each new deployment), the speed improvement of caching is lost. If containers are being used, one solution to this is to make `data` a persistent volume via Docker. However if another location is desired, the `APOS_ASSET_CACHE` environment variable can be set to control this.

::: info
If the cache folder is not a persistent volume, nothing bad will happen. The asset build task will still succeed. Later deployments just won't be faster than the first one.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Vite Configuration
DOC_PATH: guide/vite.md
URL: https://apostrophecms.com/docs/guide/vite
================================================================================
# Vite

[Vite](https://vite.dev/) is a modern build tool that significantly improves the development experience. Unlike traditional bundlers like webpack, Vite leverages native ES modules in the browser to enable faster builds and updates. During development, when using UI frameworks that support Hot Module Replacement (HMR) like Vue, React, or Svelte, your changes appear instantly in the browser without rebuilding the entire bundle or refreshing the page. For vanilla JavaScript or frameworks without HMR support, Vite still provides fast page reloads on changes. When building for production, Vite uses Rollup to create highly optimized assets.

For ApostropheCMS projects, this translates to faster development cycles, improved debugging with better source maps, and a more streamlined build process that requires less configuration. The dev server starts up instantly regardless of your application size, and HMR updates happen in milliseconds rather than seconds.

Using Vite in an ApostropheCMS project, rather than the default webpack build, is currently in beta. However, moving forward, webpack will slowly be deprecated. At this time we encourage you to test the new build in your `dev` environment. If you want to take advantage of HMR in your project-level non-Admin UI code, we recommend you start any new project using ESM modules in your frontend code. You can see the steps to begin this migration in our [documentation](/guide/migrating-to-esm). While HMR will work out of the box for the Admin UI with `hmr: 'apos'`, project-level code will need to use ESM syntax to get the full benefits of using Vite. Using CommonJS (e.g., require or module.exports) will break Vite builds due to incompatibility with Rollup, so it‚Äôs essential to switch to ESM syntax before using `hrm: 'public'`.

## Installation
Moving forward, all of our starter kits will have the Vite build option available. If you are creating a project from scratch without a starter kit, or want to enable Vite builds in an existing project you can install the package from npm.

```bash
npm install @apostrophecms/vite
```

The package then needs to be added to the `app.js` file:

<AposCodeBlock>

```javascript
require('apostrophe')({
  shortName: 'my-project',
  modules: {
    '@apostrophecms/vite': {},
  }
});
```
  <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

## Core Features and Configuration

The Vite bundler for ApostropheCMS comes with sensible defaults while remaining highly configurable. Hot Module Replacement (HMR) is enabled out of the box for ESM project code, allowing you to see your changes instantly without a full page refresh.

### Hot Module Replacement

HMR can be configured in three modes using the `@apostrophecms/asset` options:

<AposCodeBlock>

```javascript
// in app.js
require('apostrophe')({
  shortName: 'my-project',
  modules: {
    '@apostrophecms/vite': {},
    '@apostrophecms/asset': {
      options: {
        // Choose one of these HMR options:
        hmr: 'public',  // Default - enables HMR for project UI
        hmr: 'apos',    // Enables HMR for Admin UI
        hmr: false      // Disables HMR completely
      }
    }
  }
});
```
 <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

::: info
If you use the `hmr: 'apos'` option, we recommend you do not pass the `APOS_DEV` flag. The Vite build will selectively update altered code leading to a better development experience than `APOS_DEV=1`, which upon process reload will force rebuilding of the `apos` build. Vite is not using the build assets, so this doesn't make sense.

### WebSocket Configuration

By default, the HMR WebSocket server runs on your ApostropheCMS server port, typically port 3000. For cases where you need a separate port (like running behind certain proxy configurations), you can configure a custom port:

<AposCodeBlock>

```javascript
'@apostrophecms/asset': {
  options: {
    hmrPort: 3001  // Sets a custom WebSocket server port
  }
}
```
  <template v-slot:caption>
    app.js
  </template>
</AposCodeBlock>

### Source Maps in Production

For debugging production builds, you can enable source maps to see the original source code in your browser's developer tools:

<AposCodeBlock>

```javascript
'@apostrophecms/asset': {
  options: {
    productionSourceMaps: true  // Exposes source maps in production
  }
}
```
  <template v-slot:caption>
    app.js
  </template>
</AposCodeBlock>

### Default Public Build Configuration

While the `apos` build (code in `/ui/apos/` directories) is fully preconfigured, the `public` build (code in `/ui/src/`) comes with minimal configuration to give you more flexibility. Here's what's included by default:

1. **Core Features**:
   - PostCSS plugin for essential ApostropheCMS features (e.g., "Breakpoint Preview" when enabled)
   - `Modules/` alias for simplified module imports within `/ui/src/`
   - `@/` alias for cross-module and cross-build access

2. **Everything Else**:
   For additional features or frameworks, you'll need to configure them yourself. Common examples include:

   ```javascript
   // apos.vite.config.js
   import { defineConfig } from '@apostrophecms/vite/vite';
   import vue from '@vitejs/plugin-vue';
   import react from '@vitejs/plugin-react';

   export default defineConfig({
     plugins: [
       // Add framework support
       vue(),
       // or
       react(),

       // Add other Vite plugins as needed
       imagemin({
         // image optimization options
       })
     ],
     css: {
       // Additional PostCSS plugins
       postcss: {
         plugins: [
           autoprefixer(),
           tailwindcss()
         ]
       },
       // Preprocessor options
       preprocessorOptions: {
         scss: {
           additionalData: `$theme: "light";`
         }
       }
     }
   });
   ```

### Framework-Specific Configuration

When adding UI frameworks to your project, you'll need to:

1. Install the framework and its Vite plugin:
   ```bash
   # For Vue
   npm install vue @vitejs/plugin-vue
   
   # For React
   npm install react react-dom @vitejs/plugin-react
   ```

2. Configure the plugin in your Vite config
3. Follow the framework's best practices for file organization within your `ui/src/` directory

::: tip
Remember that while you have full control over the public build configuration, it's best to start minimal and add only what you need to keep your build process efficient.

## Built-in Aliases

ApostropheCMS's Vite integration provides two powerful path aliases to simplify imports in your project:

### The `@/` Alias

The `@/` alias is the recommended way to handle imports in your project. It is available for both public and admin UI builds and provides access to your entire project's source code. It follows the same path as your original source code but skips the `ui/` part of the path.

```javascript
// Current file: any file in any module inside of the `ui/` folder
// Actual path: modules/some-module/ui/src/lib/utils.js
import utils from '@/some-module/src/lib/utils.js';

// Actual path: modules/some-module/ui/apos/mixins/SomeMixin.js
import SomeMixin from '@/some-module/apos/mixins/SomeMixin.js';
```
::: warning
Important: When using the `@/` alias, you should exercise caution sharing code between the public and Admin UI builds through the import of files from `ui/apos` directories within files located in `ui/src`. If any of those `ui/apos` located files use the `Modules/` alias, it will not be resolved correctly and result in a build error. Note that a common example of this is importing SASS files.

### The `Modules/` Alias

The `Modules/` alias is available for both public and admin UI builds. It allows you to import modules without worrying about relative paths, **but** restricts you to sources inside either the `ui/src/` or `ui/apos` directories, respectively, depending on the build.

```javascript
// Current file: modules/another-module/ui/src/index.js
// Actual import path: modules/some-module/ui/src/lib/utils.js
import utils from 'Modules/some-module/lib/utils.js';
```

### Important Considerations

When using the `@/` alias:
- You can access `public` builds from within the `apos` build, and vice versa
- Use with caution as it might lead to import resolution issues if:
  - The imported file contains `Modules/` aliased imports
  - Deep imports within the imported file contain `Modules/` aliased imports
- Benefits of using `@/`:
  - More developer-friendly
  - Enables auto-completion in supported editors
  - More intuitive and readable paths
- Best practices:
  - Include mostly sources from your current build
  - Ensure imported sources don't contain `Modules/` aliased imports when cross-importing

### Resolving Alias Errors {#resolve-alias-errors}
The error message 'Unable to resolve module source "X/X/X/X.js" from alias "X/X/X.js"', typically occurs when the `Modules/` alias cannot correctly resolve the source file you're trying to import. This can happen for several reasons:

1. The target file doesn't exist in the expected location
2. You're trying to import a file from `ui/apos` using the `Modules/` alias (which only works with `ui/src` files)
3. The import path doesn't follow the expected structure for the `Modules/` alias

The Modules/ alias resolves paths using this pattern:

```
Modules/[module-name]/[path-within-src]
```

Where:

* `[module-name]` is the name of your module
* `[path-within-src]` is the path to your file, relative to that module's `ui/src` directory

If you're seeing this error, consider:

1. Double-checking the file path and ensuring the file exists
2. Using the `@/` alias instead, especially if you need to access files outside of `ui/src`
3. Reviewing the module name and path structure in your import statement

### Editor Configuration

To enable proper path resolution and autocompletion in your code editor, add a `jsconfig.json` file to your project root:

```json
{
  "compilerOptions": {
    "baseUrl": "./apos-build/@apostrophecms/vite/default",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

**Note:** If you've changed your project asset namespace from the default, adjust the `baseUrl` and `exclude` paths accordingly. For example, with a namespace of `my-namespace`:
- `baseUrl` should be `./apos-build/@apostrophecms/vite/my-namespace`
- `exclude` should include `apos-build/@apostrophecms/vite/my-namespace/dist`

When following imports in your editor (e.g., Ctrl + Click in VSCode), you'll be taken to the `apos-build` directory rather than the original source code. This is because the `apos-build` directory contains a complete copy of your project's source code (including Admin UI) from all modules (local and npm) and serves as Vite's actual source directory for building the project. Do not modify code in this folder as your changes will be lost. Change files in the original folder.

## Asset Handling

The Vite integration allows direct imports of static assets like images, fonts, and other files, as well as Sass files, in both public and admin UI builds.

### Importing Static Assets

You can import assets directly in your JavaScript/framework code:

```javascript
// Using aliases or relative paths
// Actual path: modules/some-module/ui/assets/logo.svg
import logo from '@/some-module/assets/logo.svg';
// The logo variable now contains the normalized path to the image
```

#### Framework-Specific Asset Imports

**Vue**
```vue
<template>
  <!-- Direct template imports -->
  <img src="@/some-module/assets/logo.svg" alt="My logo" />
</template>
```

**React**
```jsx
import logo from '@/some-module/assets/logo.svg';

function MyComponent() {
  return <img src={logo} alt="My logo" />;
}
```

### Importing Sass

You can import Sass files using standard import syntax:

```scss
/* Using aliases or relative paths */
/* Actual path: modules/some-module/ui/scss/_styles.scss */
@use '@/some-module/scss/styles';
```

### CSS URL Resolution

There are two ways to resolve URLs in your CSS:

1. **Using the Public Folder**
```css
/* File location: ./modules/some-module/public/font.ttf */
@font-face {
  font-family: MyFont;
  src: url("/modules/some-module/font.ttf") format("truetype");
}
```

2. **Using Source Root Path**
```css
/* File location: ./modules/some-module/ui/fonts/font.ttf */
@font-face {
  font-family: Inter;
  src: url("/src/some-module/fonts/font.ttf") format("truetype");
}
```

::: tip
You can inspect the sources in the `apos-build/@apostrophecms/vite/default` directory to understand how Vite resolves these paths when building your project.

## Extending Vite Configuration

ApostropheCMS's Vite integration provides two methods to customize your Vite configuration. You can either configure it through your module's code or via a dedicated configuration file in your project root.

### Method 1: Module Configuration

Use the `build.vite` property in your module to extend Vite's configuration:
<AposCodeBlock>

```javascript
module.exports = {
  build: {
    vite: {
      myViteConfig: {
        // Vite configuration options
        define: {
          __API_URL__: JSON.stringify('https://api.example.com'),
          __ANALYTICS_ENDPOINT__: JSON.stringify(process.env.ANALYTICS_URL)
        },
        css: {
          // CSS configuration options
          preprocessorOptions: {
            scss: {
              additionalData: `$injectedColor: orange;`
            }
          }
        }
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/analytics/index.js
  </template>
</AposCodeBlock>

### Method 2: Project Configuration File

For project-wide Vite settings, create either apos.vite.config.js (if your project uses ESM with "type": "module" in package.json) or apos.vite.config.mjs (if your project uses CommonJS) in your project root. The configuration code inside the file should always use ESM syntax regardless of your project type:

<AposCodeBlock>

```javascript
import { defineConfig } from '@apostrophecms/vite/vite';

export default defineConfig({
  // All standard Vite configuration options are supported
  plugins: [
    // Add Vite plugins
    svgLoader({
      svgoConfig: {/* custom SVG optimization options */}
    })
  ],
  build: {
    rollupOptions: {
      // Customize underlying Rollup bundle
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom']
        }
      }
    }
  }
});
```
  <template v-slot:caption>
    apos.vite.config.js
  </template>

</AposCodeBlock>

## Common Configuration Options

Here are some frequently used Vite configuration options:

- **define**: Replace constants in your code during build time
- **plugins**: Add Vite plugins for additional functionality
- **css**: Configure CSS processing and preprocessors
- **build**: Customize build output and bundling behavior
- **optimizeDeps**: Control dependency pre-bundling

In most cases, any **server** options shouldn't be touched in the Vite config. For a complete list of available options, refer to the [Vite Configuration Documentation](https://vitejs.dev/config/).

## Development-Specific Features

### Conditional Code Injection

When building UI components, you may want certain elements to appear only during development or when HMR is active. ApostropheCMS's Nunjucks components system makes this easy to manage.

### Component Setup

First, create your component template:

<AposCodeBlock>

```njk
<div class="dev-tools">
  <!-- Your development-only UI here -->
  <div class="dev-tools__status">HMR Active</div>
  <div class="dev-tools__reload">Force Refresh</div>
</div>
```
  <template v-slot:caption>
    modules/devTools/views/devTools.html
  </template>

</AposCodeBlock>

Then, register and configure the component in your module:

<AposCodeBlock>

```javascript
module.exports = {
  components(self) {
    return {
      devTools(req, data) {
        return {
          // Component data here
          status: 'connected'
        };
      }
    };
  },
  init(self) {
    // Insert the component into the page
    self.apos.template.prepend({
      where: 'head',  // or 'body', 'footer', etc.
      when: 'hmr',    // Show only when HMR is active
      bundler: 'vite', // Ensure Vite is the active bundler
      component: 'my-module:devTools'
    });
  }
};
```
  <template v-slot:caption>
    modules/devTools/index.js
  </template>

</AposCodeBlock>

### Visibility Options

The when option controls when your component appears:

```javascript
when: 'hmr'   // Only visible when HMR is active
when: 'dev'   // Visible in any development mode
when: 'prod'  // Only visible in production
```

The bundler option allows you to specify which bundler must be active for the component to appear:

```javascript
bundler: 'vite'    // Only visible when using Vite
bundler: 'webpack' // Only visible when using webpack
```

You can combine these options to precisely control when your component appears. For example, to show a component only when using Vite with HMR active, you would use both `when: 'hmr'` and `bundler: 'vite'`.

### Common Use Cases

- Development toolbars
- Debug information
- Performance monitoring
- Asset reload buttons

::: warning
Remember that components marked with `when: 'dev'` or `when: 'hmr'` will never appear in production, regardless of other settings.

## Migration and Technical Considerations

### Moving from Webpack to Vite

When migrating your ApostropheCMS project to use Vite, you'll need to make a few code adjustments:

1. **Update CSS/Sass Imports**
   ```scss
   // Old webpack style
   @import "~normalize.css";
   
   // New Vite style - remove the ~ prefix
   @import "normalize.css";
   ```

2. **Update Module Import Paths**
   ```javascript
   // Not recommended
   import Component from 'apostrophe/modules/module-name/ui/apos/components/Component.vue';
   
   // Recommended - use the alias
   import Component from 'Modules/module-name/components/Component.vue';
   ```

3. **Convert to ESM Syntax**
   ```javascript
   // Remove CommonJS syntax
   const myComponent = require('./component');
   module.exports = myComponent;
   
   // Use ESM instead
   import myComponent from './component.js';  // Note: File extension required
   export default myComponent;

   // When importing your own modules, always include the file extension
   import { helper } from './utils.js';
   import styles from './styles.css';
   import template from './template.html';
   ```

::: info
ESM requires file extensions in import paths. Always include `.js`, `.css`, `.vue`, etc. when importing your own modules. This is different from webpack, which allowed omitting extensions.
## Known Limitations and Solutions

### HMR Limitations

1. **New UI Directories**
   - **Issue**: HMR only watches existing `anyModule/ui` directories
   - **Solution**: After adding new `ui` directories, restart your development server:
     ```bash
     # Using nodemon (default setup)
     rs
     ```

2. **Vue and Admin UI**
   - **Issue**: Admin UI HMR (`hmr: 'apos'`) won't work when the public build contains Vue sources
   - **Solution**: Use separate pages for Vue development, or stick to `hmr: 'public'` when working with Vue components
   - **Note**: Public build HMR continues to work as expected

### Public Assets

- **Issue**: Changes to `ui/public` directories don't trigger HMR or page reloads
- **Solution**: Add the directories to your nodemon watch list in `package.json`:
  ```json
  {
    "nodemonConfig": {
      "watch": [
        "./app.js",
        "./modules/**/*",
        "./lib/**/*.js",
        "./views/**/*.html",
        "./modules/*/ui/public/**/*"
      ]
    }
  }
  ```

### Build and Performance

1. **Source Map Issues**
   - **Issue**: Source maps not working correctly in development
   - **Solutions**:
     - Clear your browser's DevTools cache
     - Disable source-map-related browser extensions
     - Verify file paths in your imports are correct

2. **Build Errors**
   - If you encounter build errors, try clearing your build cache:
     ```bash
     node app @apostrophecms/asset:reset
     npm run build
     ```

### Common Workarounds

- For most issues, try these steps in order:
  1. Clear your browser cache
  2. Reset the asset build
  3. Restart your development server
  4. Check the browser console for specific error messages

::: tip
Remember to check the terminal output and browser console for specific error messages. Most HMR issues will show clear error messages indicating the problem.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Using pnpm
DOC_PATH: guide/using-pnpm.md
URL: https://apostrophecms.com/docs/guide/using-pnpm
================================================================================
# Using pnpm

`pnpm` and `npm` are both package managers for JavaScript projects, but they have different approaches to managing dependencies. Node comes pre-packaged with `npm`, but `pnpm` presents a number of advantages such as better security, and monorepo support.

::: warning
The Apostrophe core is compatible with v7 and v8 of `pnpm`. However, if your project has custom extensions or testing that is not pnpm-compatible, for example, an extension that takes advantage of `npm` hoisting of core dependencies for functionality, your project will not build correctly. You should test this carefully before converting your project.

When creating a project from scratch, Apostrophe will attempt to automatically detect the use of `pnpm` by examining your project root directory for a `pnpm-lock.yaml` file. Some monorepo tools will interfere with automatic detection. You can force the use of `pnpm` by setting an option of `pnpm: 'true'` in your `app.js` file. 

When using the Apostrophe CLI tool to create a new project `npm` will be used by default to install your dependencies. This means that if you create a project using the CLI you will need to convert it to utilize `pnpm`.

This is as simple as deleting the `node_modules` folder and the `package-lock.json` files. Additionally, you want to change the `release` script of your `package.json` file to use `pnpm` instead of `npm`.

Finally, to install your packages run `pnpm install`. Using version 8 this will install any non-optional peer dependencies by default. For version 7 of `pnpm`, you need to either turn this on by passing the configuration in using `pnpm install --config.auto-install-peers=true`, or by setting it using `pnpm set auto-install-peers=true --global`. Using global will force this configuration on all projects built locally and you can leave this off. You can see other options in the [pnpm documentation](https://pnpm.io/).

Lastly, to spin your project up locally for development use `pnpm run dev` as you would with `npm`.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Webhooks
DOC_PATH: cookbook/creating-webhooks.md
URL: https://apostrophecms.com/docs/cookbook/creating-webhooks
================================================================================
# Creating webhooks

Webhooks allow applications to communicate with each other in real time by sending HTTP requests when certain events or triggers occur. This can allow your site to automatically send notifications when publishing a document or receive updates from payment portals, for example. This short recipe will demonstrate how to set up webhooks in your Apostrophe project.

## Outgoing webhooks

There are a wide variety of applications and services that expose webhooks for the transfer of information from your site. For example, you can post messages in specific Slack or Discord channels using a webhook. Apostrophe [handlers](/reference/module-api/module-overview.html#handlers-self) are able to capture a number of built-in [server-side events](../reference/server-events.md) and you also have the option of adding custom events emitted from your own modules. These events are perfect for automatically triggering the delivery of data about an event from your site to a 3rd party.

<AposCodeBlock>

```javascript
handlers(self) {
  return {
    'afterPublish': {
      async sendWebhook(req, data) {
        // data sent by the afterPublish event includes the document data 
        // and whether it is being published for the first time
        // https://apostrophecms.com/docs/reference/server-events.html#afterpublish
        if (!data.firstTime) {
          return;
        }
        const payload = {
          text: `Article ${data.published.title} was published.`
        };
        await self.apos.http.post('https://slack-webhook-url-here', {
          body: {
            text: `Article ${data.published.title} was published.`
        }
        });
      }
    }
  };
}
```
  <template v-slot:caption>
    /modules/article/index.js
    </template>

</AposCodeBlock>

In this block of code, we are using the `handlers(self)` module configuration function. We could use any server event, but in this case, we are using the `afterPublication` event that is emitted by our custom article piece-type module. This server event delivers two parameters, `req` and `data`. The `data` parameter contains information about the document being published including the content and whether this is the first time it is being published. In this case, we are adding an early return if this isn't the first time the document is being published.

The next section of code is involved in setting up the HTTP `POST` request using the `post` method of the [`@apostrophecms/http` module](/reference/modules/http.md#async-post-url-options) to send our data to the endpoint. Depending on the endpoint, the returned response might be as simple as a `200` success or a `400` failed response, or might contain additional data. You can wrap your `POST` in a try-catch block to catch any exceptions. You can then decide whether to throw an error or notify the user of a problem with `self.apos.notify(req, 'We were unable to send a notification to Slack.');`

## Incoming webhooks

Your project may require a webhook endpoint to receive incoming notices from services, like a payment portal or subscription manager. Much like Slack can add a message to a channel when it receives data from your site on the correct endpoint, your site can be set up to make changes to the database or perform other tasks when data is received at a specific endpoint. This can be accomplished by using the Apostrophe [`apiRoutes(self)` module configuration](/reference/module-api/module-overview.md#apiroutes-self) function. This allows you to easily set up an endpoint for any HTTP request method.

<AposCodeBlock>

```javascript
options: {
  csrfExceptions: [ '/webhooks' ]
},
apiRoutes(self) {
  return {
    post: {
      // change function name to match the desired endpoint URL
      '/webhooks': async function(req) {
        
        // Implement your own authorization check here
        // to make sure the data is from a genuine source
        // Each webhook provider likely has guidance and 
        // a specific type of authorization
        const authHeader = req.headers.authorization;
        if (!authHeader) {
          throw self.apos.error('forbidden');
        }

        // Use data passed by webhook to update database
        // or provide some other type of functionality
        const webhookData = req.body;
        async addNewSubscriber(webhookData);

        // Most webhook providers expect a 200 response
        // or they will attempt to resend the webhook
        return {};
      }
    }
  };
}
```
  <template v-slot:caption>
    /modules/subscription/index.js
  </template>

</AposCodeBlock>

In this code example, the webhook is being implemented using the `apiRoutes(self)` module configuration function. We are exposing a `POST` route, the one that is most typically used by webhook providers, by passing an object with our function to the `post` property. The function is named for the route it is exposing. In this case, it starts with a forward slash (`/`), indicating that this is relative to the project site itself, e.g. `https://www.my-project.com/webhooks`.

Within the function, we first are checking for the presence of an authorization header. If it isn't found we throw an error with the string 'forbidden'. This is mapped to a `403` error and returns it to the webhook originator. There are a number of other error strings detailed in the reference documentation for [`apiRoutes`](/reference/module-api/module-overview.md#returning-error-codes). Once authentication is complete you can pass the data off for sanitization and use.

Finally, most providers require the return of some type of success message, otherwise, they will attempt to resend the webhook. If no information needs to be supplied you can simply return an empty object. Alternatively, you can return an object that contains information to include in the body of the response. The header will still indicate a response of `200/OK`.

Lastly, since this page will be accessed using a POST method from an outside source, we have to add the route to the `csrfExceptions` option array to bypass CSRF protection.

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Server-side errors for fields
DOC_PATH: guide/server-side-field-errors.md
URL: https://apostrophecms.com/docs/guide/server-side-field-errors
================================================================================
# Generating errors for individual fields from the server side

## Motivation

Apostrophe provides useful ways to validate most field types in the browser, before the user ever tries to save them. For example, most field types support `required`, `min` and `max`, and string fields and their close relatives support `pattern`.

However, sometimes you won't know there is a problem until you try to do something on the server side. In that situation, it is helpful to be able to report the error to the browser in such a way that the message is associated with the correct field.

## Sample code

Here is sample code to forbid the user to use certain slugs. This code adds a `beforeSave` handler in the `@apostrophecms/doc-type` module, the base class of all piece and page types. That means it will be checked for *all* documents. If you want to do something similar but just for one document type, you can add the handler to a specific page or piece type module. If you want it for all pages, you can add it to `@apostrophecms/page-type`. For all pieces, add it to `@apostrophecms/piece-type`.

When you test out this code, you'll find it is not possible to save a page with the slug `/evil-page`, or save a piece with the slug `evil-piece`. And, a polite error appears in the right place.

::: tip
The folder name matters. Placing this code in `modules/@apostrophecms/doc-type/index.js` associates it with the right module.

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    forbiddenSlugs: [
      '/evil-page',
      'evil-piece'
    ]
  },
  handlers(self) {
    return {
      beforeSave: {
        checkForbiddenSlugs(req, doc) {
          if (self.options.forbiddenSlugs.includes(doc.slug)) {
            const e = self.apos.error('invalid', 'That slug is reserved.');
            e.path = 'slug';
            throw self.apos.error('invalid', {
              errors: [
                e
              ]
            });
          }
        }
      }
    }
  }
};
```
  <template v-slot:caption>
    /modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

This code first creates an error for the individual field, then attaches a `path` property specifying the field name, and then throws another error which contains the first one in an `errors` array. This is the format that Apostrophe's document editor expects, and as a result it allows the error to be associated with the correct field. Note that you can include more than one error in the `errors` array if multiple fields have problems.

## Monitoring events in other modules

If you prefer, you can add the handler code to a different module, as long as you specify the module you want to monitor:

```javascript
// This way the code can be in any module's index.js file

handlers(self) {
  return {
    '@apostrophecms/doc-type:beforeSave': {
      checkForbiddenSlugs(req, doc) {
        // See above
      }
    }
  };
}
```

================================================================================
COLLECTION: guides
NAV_PATH: Customizing & Extending > Migrating to ESM
DOC_PATH: guide/migrating-to-esm.md
URL: https://apostrophecms.com/docs/guide/migrating-to-esm
================================================================================
# Migrating to ESM in ApostropheCMS

Starting with version 4.9.0, ApostropheCMS supports ECMAScript Modules (ESM). This guide will help you convert your existing project to use ESM and understand why this transition is valuable for your development workflow.

::: info
If you are starting a new project, good news! You don't have to worry about modifying existing modules. Just fork the `vite-demo` branch of any starter kit. They are already setup as ESM projects.

## Why Migrate to ESM?

The transition to ESM brings several significant advantages for ApostropheCMS developers:

ESM provides a modern, standardized module system that improves your development experience through better static analysis, enhanced debugging, and clearer dependency management. With ESM, you'll benefit from improved tree-shaking for smaller production builds and better code organization through explicit imports and exports.

Migrating to ESM enables Hot Module Replacement (HMR) when using ApostropheCMS's new Vite build system. HMR dramatically speeds up development by updating your modules in real-time without requiring a full page refresh, maintaining application state during code changes. This means you can modify your templates, components, or styles and see the changes instantly in your browser.

ESM is also the future of JavaScript modules. All major JavaScript frameworks and tools are moving towards ESM as the default module system, and new features in the JavaScript ecosystem are being built with ESM in mind. By migrating now, you're future-proofing your ApostropheCMS projects and ensuring compatibility with the latest development tools and practices.

## Understanding ESM vs CommonJS

When planning your migration, keep these key points in mind:

Your project must commit fully to either CommonJS (CJS) or ESM - they cannot be mixed at the project level. However, a project using either ESM or CJS may freely use node modules written with either ESM or CJS - there is compatibility at the npm level. Moving forward, all new ApostropheCMS starter kits and extension packages will use ESM as their default module system.

## Migration Steps

### 1. Update Package Configuration

Add the following to your `package.json` to enable ESM for your project:

```json
{
  "type": "module"
}
```

### 2. Modify App Configuration

Update your app.js configuration to use ESM syntax:

```javascript
// Before (CommonJS)
require('apostrophe')({
  shortName: 'my-project',
  baseUrl: 'http://localhost:3000',
  modules: {
    // ... module configuration
  }
  // ... other configuration
});

// After (ESM)
import apostrophe from 'apostrophe';

apostrophe ({
  root: import.meta,
  shortName: 'my-project',
  baseUrl: 'http://localhost:3000',
  modules: {
    // ... module configuration
  }
  // ... other configuration
});
```

The addition of `root: import.meta` is crucial for ESM support. This property helps ApostropheCMS correctly resolve file paths in an ESM context and enables features like HMR with Vite.

### 3. Update Module Exports

ApostropheCMS requires every module's `index.js` to provide a **default export** when using ESM. Modules can export either objects or functions.

```js
// Before (CommonJS)
module.exports = {
  // module definition
};

// After (ESM)
export default {
  // module definition
};
```

Apostrophe will not load modules using named exports.

### 4. Update Import Statements

#### For Node Modules:
```javascript
// Before (Common JS)
const express = require('express');

// After (ESM)
import express from 'express';
```

#### For Local Files:
```javascript
// Before (CommonJS)
const myModule = require('./my-module');

// After (ESM)
import myModule from './my-module.js';  // Note: .js extension is required
```

## Common Patterns and Examples

### Module Imports

```javascript
// Before (CommonJS)
const { myModule } = require('@my/module');
const { existsSync } = require('fs');

// After (ESM)
import { myModule } from '@my/module';
import { existsSync } from 'fs';
```

### Local Module Imports

```javascript
// Before (CommonJS)
const myWidget = require('./modules/my-widget');
const config = require('./config/index');

// After (ESM)
import myWidget from './modules/my-widget.js';
import config from './config/index.js';
```

## Best Practices

1. Always include the `.js` extension for local file imports
2. Use named exports where appropriate to improve code clarity
3. Consider updating your linting configuration to enforce ESM patterns
4. Test thoroughly after migration, especially custom modules and extensions

## Common Issues and Troubleshooting

### Missing File Extensions
If you encounter errors like `ERR_MODULE_NOT_FOUND`, ensure you've added `.js` extensions to all local file imports.

### __dirname and __filename
These CommonJS variables aren't available in ESM. Instead, use:

```javascript
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

### Dynamic Imports
If you need to dynamically import modules:

```javascript
// Before (CommonJS)
const module = require(`./modules/${moduleName}`);

// After (ESM)
const module = await import(`./modules/${moduleName}.js`);
```

For example,
```javascript
// Instead of loading all locales upfront
import enTranslations from './locales/en.js';
import esTranslations from './locales/es.js';
import frTranslations from './locales/fr.js';

// You can load them dynamically based on user preference
async function loadTranslations(locale) {
  const translations = await import(`./locales/${locale}.js`);
  return translations.default;
}
```

## Next Steps

1. Update your CI/CD pipelines to account for ESM
2. Review and update any custom scripts or tools
3. Consider updating your development tools and IDE configurations
4. Test thoroughly in all environments

---

**Note**: While converting to ESM is recommended for new projects and updates, existing projects using CommonJS will continue to work, you just won't get the HMR benefits. Choose the best time for your team to make this transition.

================================================================================
COLLECTION: guides
NAV_PATH: Hosting & DevOps > Hosting in Production
DOC_PATH: guide/hosting.md
URL: https://apostrophecms.com/docs/guide/hosting
================================================================================
# Hosting Apostrophe in production

## Server requirements

We recommend hosting Apostrophe in self-hosted production environments with the following minimum specifications:

| Software | Minimum Version |
| ------------- | ------------- |
| Ubuntu | 22.04+ |
| [NGINX](https://www.nginx.com/) (or another reverse proxy like Caddy, Traefik) | Latest |
| [Node.js](https://nodejs.org/en/) | 20.x+ |
| [MongoDB](https://docs.mongodb.com/manual/administration/install-community/)  | 7.0+ (tested through 8.0) |


| Hardware specification | Minimum recommendation |
| ------------- | ------------- |
| RAM | **2GB** (to support the application and database) |
| Disk space | **20GB** (see note below) |

1GB of RAM may be sufficient if using a remote database service (e.g., MongoDB Atlas). Sites running in a multicore configuration will require additional 2G or more RAM and, of course, CPU cores.

::: info
MongoDB requires a minimum of 5GB free disk space at all times. Small websites may not need much more additional space than that. We have found that 20GB is sufficient for most Apostrophe applications, but more space may be necessary to handle an especially large number of file uploads or especially large uploaded files.

## Deployment basics

Deployment processes will vary depending on the hosting environment, technical requirements, and team preferences. There are a few steps that all deployment processes should include.

1. **Run the data migration task: `node app @apostrophecms/migration:migrate`.** This will run both core data migrations as well as project-level migrations.
2. **Run the build process: `node app @apostrophecms/asset:build`.** This runs automatically in development environments, but not if `NODE_ENV=production` or if the `autoBuild: false` option is set on the application. That is to ensure that the build is an intentional part of deployment and that developers can execute it along with other production build tasks as necessary.
3. If Apostrophe has been running on the server already, **stop the application process(es).**
4. **Start (or restart) the application process(es).**

## Best practices

### Set the `NODE_ENV` variable for production

Apostrophe includes performance enhancements when in "production mode." In production environments, or staging environments that replicate production, set the `NODE_ENV` to `production`. Be aware that this will disable the automatic user interface build. See the section above for more about running the build process.

### Run multiple processes

Running the website on multiple server processes is always a good idea in the production environment. You should run at least two processes to guarantee availability if one process is restarting, even if you only have one CPU core. If you have more than two CPU cores, you may run additional processes, one per additional core. If you have a lot of capacity, you might want to reserve a core for MongoDB.

We recommend using a utility such as [PM2](https://pm2.keymetrics.io/) to start and run these processes. PM2 will also restart the processes in the rare case of a crash.

### Minifying assets

Apostrophe concatenates [project-level front end code](/guide/front-end-assets.md#placing-client-side-code) and, when a user is logged in, delivers it to browsers with the user interface code as well. There is no advanced minification applied. If needed, apply any advanced minification prior to running the production build task.

## Hosting recipes

The information here applies to most all hosting platforms. Implementation will vary depending on the platform. To help get started on specific platforms, [we provide hosting recipes for popular options](/cookbook/index.md#hosting).

================================================================================
COLLECTION: guides
NAV_PATH: Hosting & DevOps > Docker
DOC_PATH: cookbook/using-docker.md
URL: https://apostrophecms.com/docs/cookbook/using-docker
================================================================================
# Hosting an Apostrophe project with Docker

[Docker](https://www.docker.com/) is a containerization platform that lets developers build an image for their projects and then run it anywhere. This guide is for production, not development. If you want to use Docker as a development environment, you can explore using a persistent Docker volume for your project, but bear in mind that commands like npm install can be very slow in such a configuration.

The initial steps of this guide will assume that you will be hosting your database, project, and uploaded assets on the same server. The second part will outline steps for configuring to use the AWS S3 service for hosting assets. Finally, the third portion will provide guidance for using the MongoDB Atlas multi-cloud database.

## Creating the image
### Install Docker

Docker can be installed on Mac, Windows, and Linux machines with either a CLI interface or using the Docker Desktop application, which acts as a graphical interface to the Docker engine. For this tutorial, we will use the CLI version. You can read more about Docker and install it on your machine by following the instructions in the Docker [docs](https://docs.docker.com/get-started/). Feel free to walk through the tutorials that you find there, but it isn't necessary before following this tutorial. We will cover any necessary terminology as we walk step-by-step through getting Apostrophe running. However, please verify that your Docker install works before continuing.

### Apostrophe project setup

For this tutorial, we will be using the [a3-demo](https://github.com/apostrophecms/a3-demo) template. However, you can also use an existing project or create a new one by following our getting started [tutorial](/guide/setting-up.md). If using the a3-demo, follow the link and click on the "Use this template" button to fork the template into your own repo. Next, clone the repo to your local machine and open it in your favorite code editor.

### Creating the dockerfile

The [`Dockerfile`](https://docs.docker.com/engine/reference/builder/) passes a series of command line instructions to build an image. Below is an example of a file to build a container for a basic Apostrophe project:

<AposCodeBlock>

```bash
FROM node:lts-alpine3.15

WORKDIR /srv/www/apostrophe

RUN chown -R node: /srv/www/apostrophe
USER node

COPY --chown=node package*.json /srv/www/apostrophe/

ENV NODE_ENV=production
RUN npm ci

COPY --chown=node . /srv/www/apostrophe/

RUN ./scripts/build-assets.sh

CMD ["node", "app.js"]
```
<template v-slot:caption>
  Dockerfile
</template>

</AposCodeBlock>

Let's walk briefly through each of the lines. The first line specifies that this image will extend an existing image with the long-term support version of node.js running on an alpine linux v3.15 operating system. If you need another version of node, another version of Alpine Linux, or prefer not to use Alpine Linux as your container OS, you should alter this line to build from an official node.js [image](https://hub.docker.com/_/node/) or a 3<sup>rd</sup> party image.

The `WORKDIR` command is used to define the working directory of the Docker container where all of the subsequent commands will be run. It implicitly runs both `mkdir` and `cd` commands.

By default, when we issue commands within the `Dockerfile` they are run within the container as a root user. Although Docker should ensure that the 'root' user inside the container can't see or interact with anything outside the container, it never hurts to use a non-root user inside the container too, just in case a flaw in the container system is found. Now that we have a directory, we reassign it to a low-level user `node` using the Docker `RUN` command and the linux `chown` command. Everything following `RUN` will be passed to the command line inside the container. Next, we switch to the new user using the `USER` command.

We are now going to install all of our dependencies inside of the working directory. First, we copy the `package.json` and `package-lock.json` into our project. Next, we pass our `NODE_ENV=production` environment variable into the build and then add those dependencies using `RUN npm ci`.

::: info
This means that you **must** commit the project `package-lock.json` and you must not list anything required to build the project assets as a "dev" dependency.  Your project doesn't need any of those in production, right? 

Following the dependency install, all of the necessary project files are copied into the container. Note that we will also create a `.dockerignore` file to exclude some files and folders from being copied.

Next, we run a script to trigger the apostrophe asset build (we will cover this script next). To set a unique `APOS_RELEASE_ID` environment variable each time we change files and redeploy, we are using the script to create a `release-id` file with a unique string. Otherwise, we would have to change this string each time manually.

Everything until this point helped build the container image. Those commands only run once when the container image is built or rebuilt. The final `CMD` line is what runs every time the container is started.

### Creating the install script

The alpine linux distribution is slim and doesn't include bash, but we can access the "busybox" shell, which is compatible with the basics, at `/bin/sh`. Into the `scripts` folder at the root of your project create the following file:

<AposCodeBlock>

```bash
#!/bin/sh

export APOS_RELEASE_ID=`cat /dev/urandom |env LC_CTYPE=C tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1`

echo $APOS_RELEASE_ID > ./release-id

node app @apostrophecms/asset:build
```

<template v-slot:caption>
  scripts/build-assets.sh
</template>

</AposCodeBlock>

We won't go through this file in detail. As covered in the previous section, it creates a random unique string and copies it out to the `release-id` file at the root of the project. It then triggers the `@apostrophecms/asset` module to build the assets. That module will read the `release-id` file and use the string in the build.

Building the assets inside this script, which is part of a **build step** in the Dockerfile, ensures the assets become part of the image, so they don't have to be re-generated every time the image is used. The same is true for the `release-id` file, which Apostrophe uses to identify the asset bundle it should be using. It'll be the same bundle at build time and at run time. If the image is rebuilt, we'll get a new image, new CSS URLs, and no stale stylesheets.

### Creating a `.dockerignore` file
The `.dockerignore` file prevents specific files from being copied into your final image. This is important to block sensitive or unnecessary files from being incorporated into your image. Simply go through your directory and copy any file or folder name not needed to build your project into your `.dockerignore` file. Note that folder names are followed by a `/`. I'm using Visual Studio Code in this tutorial, so the topmost folder listed won't be in your project if you use a different editor.

<AposCodeBlock>

```bash
.vscode/
apos-build/
badges/
data/
node_modules/
public/uploads/
.dockerignore
.env
.eslintignore
.gitignore
deploy-test-count
docker-compose.yaml
dockerfile
force-deploy
local.example.js
```

<template v-slot:caption>
  .dockerignore
</template>

</AposCodeBlock>

### Creating a `docker-compose.yaml` file
In this guide, we are starting by creating multiple containers and a persistent volume. This is so that we can provide both a MongoDB instance and a place to store uploaded assets. We are going to do this using [Docker Compose](https://docs.docker.com/compose/) and a `docker-compose.yml` file. In the following sections of the tutorial, we will look at removing the extra container and volume by taking advantage of cloud storage and database services. Create this file at the root of your project.

<AposCodeBlock>

```bash
services:
  db:
    image: mongo:4.4.14
    ports:
      - "27018:27018"
    volumes:
      - /data/db
  web:
    build:
      context: .
    container_name: "apostrophe-container"
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV
      - APOS_MONGODB_URI
      - APOS_CLUSTER_PROCESSES
    depends_on:
      - db 
    volumes:
      - /srv/www/apostrophe/public/uploads
```

<template v-slot:caption>
  docker-compose.yaml
</template>

</AposCodeBlock>

The spacing in this file is very important. Whitespace, not tab, indentation indicates that a particular line is nested within the object passed on the line above it. Walking through this file, it starts with `services:`. From the indentation, we can see that we are creating two services - a `db:` container and a `web:` container.  Much like our `Dockerfile`, within the `db:` we start by specifying an image to run. In this case, it is the `mongo:4.4.14` official image for running MongoDB v4.4.14. Other images can be found in the docker library GitHub repo [README](https://github.com/docker-library/docs/blob/master/mongo/README.md#supported-tags-and-respective-dockerfile-links). You should use the version that mirrors your development environment.

Next, we are specifying that the database should communicate over port `27018`. This is different from the port typically used in order to direct communication to the dockerized version and not a local MongoDB. If you need your database to communicate over a different port, you have to change it here and in your `.env` file.

Finally, we add a volume for the MongoDB storage engine to write files into. You shouldn't need to change this. Without the persistent volume at this stage, the database would appear to work, but all content would be lost on every restart.

Looking at the `web:` container, we aren't passing an image but instead passing `build`. Within this, we are adding `context: .` which specifies we should build the image for this container from the `Dockerfile` in the same directory.

To make accessing the container running our apostrophe easier, we are giving it a name using the `container_name` key. You can use any name you would like, but remember it for later.

The next two lines, starting with `ports:`, list the ports that the container should listen through, in this case, the typical port 3000.

The `environment:` key lists environment variables that will get passed into the container. We could set the value of these here but are using a `.env` file instead.

The `depends_on:` key indicates that our Apostrophe instance requires the presence of the `db` container that we created first.

Finally, much like with the database, we are persisting a volume for any uploads to be written into. Without this, any uploads would be lost the next time we deployed.

### Creating the `.env` file
The last file we need to create before bringing our project up is a `.env` file at the root of our project containing the environmental variables. In this example file, we are assuming that you are hosting on a single server. Therefore we are setting the `APOS_CLUSTER_PROCESSES` environment variable to `2` to ensure that there is availability in case of a restart due to a crash. This number could be increased depending on your server.

<AposCodeBlock>

```bash
NODE_ENV=production
APOS_MONGODB_URI=mongodb://db:27018/apostrophe
APOS_CLUSTER_PROCESSES=2
```

<template v-slot:caption>
  .env
</template>

</AposCodeBlock>

The only other line that might need alteration is the `APOS_MONGODB_URI` if your database needs to listen on a different port.

### Spinning our project up
Bringing our project up in Docker is a two-step process. First, from the CLI run `docker compose build`. This will create our project image. You should see commands from your `Dockerfile`, messages from the npm install, and then the familiar messages from Apostrophe as it builds the assets.

When this finishes, you can run the command `docker compose up`. This will bring your project up and if you are using the defaults, allow you to access the site at `http://localhost:3000`. At this point, you won't be able to log in because it is a fresh database. To do this, you need to open a session with your container running Apostrophe. With both containers still running, give the following command from your terminal.

```bash
docker exec -it <container_name> /bin/sh
```
The `<container_name>` should be substituted with the name you gave your container in the `docker-compose.yaml` file.

When the connection to your container is established, you issue the normal command for adding an Apostrophe admin to the database.

```bash
node app @apostrophecms/user:add admin admin
```

Now you should be able to log in as admin.

If you want to bring the site down use:

```bash
docker compose down
```

### Updating your project
Whenever your code or dependencies change, for example, when there is an update to Apostrophe, your container will have to be rebuilt. This can be done using the same steps as the initial build.

First, make sure your `package-lock.json` file is up to date by running `npm update` on your project repo. Then run:

```bash
docker compose build
```

After your container is re-built run:

```bash
docker compose restart
```

### Summary
While in this example, our project is still being hosted locally, any of these commands can be issued on a server that supports Docker once your project is deployed.

Right now, our Dockerized container is limited to a single server. For simple, low-traffic sites this could be fine. However, if we want to scale our site over several servers and add a load balancer like Nginix, we need to add support for cloud storage and a cloud database. Fortunately, Apostrophe makes this relatively easy.

## Using AWS S3 services
If you aren't hosting your project on a single server, you will need to have a different uploaded asset storage method. Typically this is a service like Amazon Web Services S3 or another similar service. Apostrophe is set up to easily use S3 services by adding environment variables. You can read more in the [documentation](/reference/modules/uploadfs.md#s3-storage-options). We can take advantage of this in Docker by expanding our `docker-compose.yml` and `.env` files.

### Changing the `docker-compose.yaml` file
In order to pass the environment variables into our project container we just need to add them inside the `environment:` key. If we are using S3 services at Amazon, we need to add four variables: `APOS_S3_REGION`, `APOS_S3_BUCKET`, `APOS_S3_KEY`, and `APOS_S3_SECRET`. For other S3-type storage solutions, such as [filebase](https://filebase.com/), you will also want to set the `APOS_S3_ENDPOINT` variable. For AWS, your `environment:` section should now look like this:

<AposCodeBlock>

```bash
‚Ä¶
    environment:
      - NODE_ENV
      - APOS_MONGODB_URI
      - APOS_CLUSTER_PROCESSES
      - APOS_S3_REGION
      - APOS_S3_BUCKET
      - APOS_S3_KEY
      - APOS_S3_SECRET
‚Ä¶
```

<template v-slot:caption>
  docker-compose.yaml
</template>

</AposCodeBlock>

### Changing the `.env` file
Next, the `.env` file should be modified to contain values for each of the new environment variables. Each will get populated with values specific to your S3 buckets. Again, add the `APOS_S3_ENDPOINT` with value if using a service not hosted by AWS.

<AposCodeBlock>

```sh
NODE_ENV=production
APOS_MONGODB_URI=mongodb://db:27018/apostrophe
APOS_S3_REGION=<your region>
APOS_S3_BUCKET=<your bucket name>
APOS_S3_KEY=<account key>
APOS_S3_SECRET=<account secret>
```

<template v-slot:caption>
  .env
</template>

</AposCodeBlock>

### Finishing up
While our Docker container is now configured for storing items on AWS S3, it won't fully work if we were to spin it up now. First, we have to configure our S3 bucket to allow the public to access it. This is easily done through the AWS control panel.

1) First, select the bucket from the S3 management console and then click on the "Permissions" tab. Click on the "Edit" button to edit your permissions.
![S3 console permissions tab](../images/s3-permissions-tab.png)

2) Uncheck the "Block all public access" box and save the changes. You will have to confirm that you want to do this.
![S3 console showing all public access blocks for S3 bucket turned off](../images/s3-public-permissions.png)

3) Scroll down the page to the "Object Ownership" section and click the "Edit" button.
![The S3 console Object Ownership section](../images/s3-object-ownership.png)

4) Select "ACLs enabled" and "Object writer" then acknowledge the warning and save the changes.
![S3 console object ownership edit screen](../images/s3-object-permission.png)

Just like with the Docker container previously, you can now bring the site up with:

```sh
docker compose up
```
Any assets uploaded through the site will now be stored in your S3 bucket rather than on the server directly.

## Using MongoDB Atlas
[MongoDB Atlas](https://www.mongodb.com/atlas/database) is a robust, multi-cloud database service. There are a number of advantages, but one is that using a cloud database means that our project can run on multiple servers but still all access the same database. If we run our project in a docker container without an accompanying database container, we don't have to use Docker Compose. However, since we have already built these assets, we can continue with these files. Two files must be altered - `docker-compose.yaml` and `.env`.

### Changing the `docker-compose.yaml` file
Since we no longer have to use the database container, we can simply delete that whole section from the `services:`. Likewise, we can also remove the `depends_on:` section since we no longer have that container.

### Changing the `.env` file
First, start by getting an account and setting up a project and cluster according to the [instructions](https://www.mongodb.com/docs/atlas/?_ga=2.115258319.959071482.1662986164-305956368.1655805952&_gac=1.50376795.1662898658.Cj0KCQjwjvaYBhDlARIsAO8PkE2KG3UP3yszcTYrzDpB8BRxDZ7vM2vLMafvX59emZZKkDExo_ZPZRIaAneGEALw_wcB) at the Atlas site. Once you do this, you can get the connect string for your database. The `APOS_MONGODB_URI` was already being set within the `.env` file. You simply need to substitute your connect string for the value.

::: info
Any special characters in your user name or password within the connection string need to be converted to %-encoding.

### Finishing up
Since this will create a new database, once you bring your site up you should add an admin user as was [detailed](#spinning-our-project-up) when we used the containerized version.

Then, to bring the site up use :
```sh
docker compose up
```

## Deploying

Great, so we have a working Apostrophe Docker image. How do we get it on the web? There are many options. Here are a few.

* [Automated builds from GitHub](https://docs.docker.com/docker-hub/github/)
* Install [Dokku](https://dokku.com/docs/getting-started/installation/) on the server then use [Dockerfile deployment](https://dokku.com/docs/getting-started/install/docker/)
* Use `docker save` and `docker load` to [deploy without a private registry](https://realguess.net/2015/02/04/docker-save-load-and-deploy/)
* Build the image directly on the server
* Many more (use a web search!)

================================================================================
COLLECTION: guides
NAV_PATH: Hosting & DevOps > Ubuntu
DOC_PATH: cookbook/ubuntu-hosting.md
URL: https://apostrophecms.com/docs/cookbook/ubuntu-hosting
================================================================================
# Ubuntu hosting setup

## Setting up the Ubuntu VPS

We'll start off by creating an Ubuntu VPS on AWS Lightsail. There are many services to use for hosting an Ubuntu VPS and the rest of the recipe is platform-agnostic.

1. In an [AWS Lightsail account](https://lightsail.aws.amazon.com), log in and  create an **Ubuntu 20.04 LTS** ("OS Only") instance. You need at least 1GB of RAM. We suggest 2GB to be safe.
   - There is a step on this first page to select or add an SSH key to connect securely from your computer. Follow Lightsail's directions to do this.
2. Complete any additional configurations you want, then **create the instance**. Once the instance is created, click on it to continue configuration.
3. On the "Networking" tab, you should see that the SSH and HTTP ports are already open. In addition, **open the HTTPS port** by clicking "Add rule" and selecting "HTTPS." You need this for `https://` connections.
   - Wait a couple minutes even after it says it's ready, to be sure it will accept your SSH connection.
4. SSH to your server's `ubuntu` account, according to the Lightsail instructions. This account has `sudo` privileges so you can take care of tasks that require root access.
5. **Install MongoDB Community Edition.**  Instead follow the [official instructions for installing MongoDB Community Edition on Ubuntu](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/).
   - **Be sure not to miss the command `sudo systemctl enable mongod`** which ensures it starts up on every reboot.
   - Don't use an Ubuntu package for this since they may be outdated.
6. **Install Node.js 18.x.** Don't use an obsolete Ubuntu package. Instead follow the [official instructions for installing Node.js 18.x on Ubuntu](https://github.com/nodesource/distributions/blob/master/README.md#debinstall)
   - Again, it's best to not use an Ubuntu package for this.
7. **Install nginx.** This one is up to date in nginx, so it's one line:

```sh
sudo apt-get install nginx
```

8. **Install `nano`.** This is a basic text editor we can use when configuring `nginx`.
   - If you prefer `vim`, or have remote editing support in your favorite visual text editor, that's fine too.

```sh
sudo apt-get install nano
```

9. **Install `pm2`.** This is a tool to start and restart the site for you and keep it running:

```sh
sudo npm install -g pm2
```

10. We shouldn't use an account with sudo privileges to run the site. So **create a *non-root* user** to manage your Apostrophe site:

```sh
sudo useradd nodeapps -d /home/nodeapps -m -s /bin/bash
```

::: info
The Apostrophe convention is to name this user `nodeapps`. This name is not required, but we will continue to use it in this recipe.

We're specifying the `bash` shell here because the default `sh` shell is no one's favorite, but you can change this.

11.  We're almost ready to use the account, but first **let's make sure `pm2` can restart our site** if the server reboots:

```sh
sudo su -c "pm2 startup ubuntu -u nodeapps --hp /home/nodeapps/var/www"
```

12. If there are no errors, we're ready to continue. **Now switch to that new user in your shell**:

```sh
sudo su - nodeapps
```

From here on out we never run a command as root, except as explicitly noted. This `nodeapps` account doesn't have sudo privileges, and that's a good thing for security.

### Deploying a site for the first time

::: info
You can do this series of steps each time you want to add a new site to the VPS. You can run more than one site on a server, but for security and performance you might prefer to run them on separate servers in production.

1. If you didn't already, SSH to the `ubuntu` user on your server (the last step of the previous section). Then run `sudo su - nodeapps` to switch users.
2. **Deploy the Apostrophe site code to the VPS.** We'll use the Apostrophe essentials starter kit project as an example.
   - We'll `git clone` a project in the home directory as a simple way to deploy it. You may use a CI/CD tool or some other method for regular deployments. You will also likely want to put the code in another location (e.g., `/var/www`).

```sh
git clone https://github.com/apostrophecms/starter-kit-essentials

cd starter-kit-essentials

npm install
```

3. **Build production front end assets** (including the Apostrophe user interface code):

```sh
npm run build
# This script in the starter kit is an alias for the Apostrophe task
# `NODE_ENV=production node app @apostrophecms/asset:build`
```

4. **Now we instruct `pm2` to launch the site and to keep it running.** Substitute the shortname of your own project for `starter-kit-essentials` below.

```sh
pm2 --name=starter-kit-essentials start npm -- run serve
pm2 save
# The second command saves our `pm2` configuration for future reboots.
```

At this point Apostrophe is running on port `3000`. We need to configure nginx as a proxy server to handle HTTP and HTTPS connections on port `80` and `443` and forward them.

### Adding your site to nginx

1. SSH to the `ubuntu` user shell where you have sudo access. If you followed the instructions above and are on the `nodeapps` user, simply type `exit` and submit.
2. Create the nginx configuration file, `/etc/nginx/conf.d/your-project-shortname-here.conf`.
   - Replace `your.host.name` with the DNS hostname you have pointed to your server's IP address for your site.

```sh
sudo nano /etc/nginx/conf.d/your-project-shortname-here.conf
```

3. In the editor, **paste the following, replacing `your.host.name` and `starter-kit-essentials` as directed**:

```nginx
server {
  listen *:80;
  # Replace `your.host.name` with your actual hostname
  server_name your.host.name;
  location @proxy {
    proxy_pass http://localhost:3000;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
  }
  location / {
    # Remember to replace `starter-kit-essentials` with your project directory name
    root /home/nodeapps/starter-kit-essentials/public;
    try_files $uri @proxy;
    expires 7d;
  }
}
# To save, press CTL+x, then follow the steps to confirm.
```

::: info
The `proxy_set_header` statements pass information to Apostrophe so it can still see the visitor's IP address.

The `root` and `try_files` statements let nginx serve static files directly, for
the best speed; if the URL isn't a static file, it is passed to Apostrophe. `expires 7d` allows the browser to cache the static files, for performance.

1. You'll want to **add SSL for HTTPS connections**, too. For that, follow the LetsEncrypt [Certbot documentation](https://certbot.eff.org/instructions?ws=nginx&os=snap). Certbot will make the necessary nginx configuration changes for you.

2. Now instruct `nginx` to restart:

```sh
sudo systemctl reload nginx
```

**Your site should be up!** Visit `http://your.host.name` to see it. If you didn't add it to your DNS yet, or it hasn't propagated, you won't be able to reach it yet.
<!-- You can try `http://your.server.ip.address` until DNS is set up. -->

## Working on the site after deployment

### Adding a user to a brand-new site

A newly-created site won't have much in the database yet, and **you need an admin user to start editing**.

1. **Make sure you are on the `nodeapps` user** (the non-sudo user). Any direct work on the Apostrophe site (as opposed to the server) should be done by `nodeapps`.
2.  Run the follow task to create a user with the name `lucy` to the "admin" group:

```sh
node app @apostrophecms/user:add lucy admin
# The command structure is:
# node app apostrophe-users:add userName groupName
```

3. When prompted, **enter a secure password.** And be sure to record it securely as well!

After that your account will be stored in the MongoDB database. Access it on the `/login` page of your website.

### Updating your site code

To update your site later, follow these steps using the `nodeapps` (non-sudo) user:

1. `cd` to the project root if you are not there already. Since we first deployed our code by cloning a git repository, we'll pull from that repo to update the code.

```sh
# Make sure we're in our project root directory.
cd && cd starter-kit-essentials
# Pull our code.
git pull
```

2. Now that we have the code updated, we will install any new or updated npm packages, build new production assets, and run any new database migrations:

```sh
npm install && npm run build && node app @apostrophecms/migration:migrate
```

::: tip
In projects based on the `starter-kit-essentials` code starter, the `npm run release` script takes care of all of this in one command. If your codebase does not include that script you will need to run each command directly.

3. Instruct `pm2` to restart the site:

```sh
pm2 restart starter-kit-essentials
```

Your site will restart after a few seconds. You can check the process logs with `pm2 logs starter-kit-essentials` to see whether it has started up yet.

### Viewing the Node.js console

Your site's console log messages are available from `pm2`:

```sh
pm2 logs starter-kit-essentials
```

## Recommended enhancements

This recipe is a simple, unopinionated production example. There are many things you can do to improve on this recipe.

### Run on multiple processes

One important step is to run at least two Apostrophe processes, in order to guarantee a second process can respond if the first has crashed and is restarting.

One way to do that is to start two separate processes with `pm2`, using two `--name` settings and two `PORT` environment variable settings, and configure [nginx round-robin load balancing](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/#choosing-a-load-balancing-method) to balance between them.

If you need more capacity, you can run as many processes as you have CPU cores on the server, possibly reserving one for MongoDB.

### Specify the `APOS_RELEASE_ID` if not deploying with git

Just a heads up: in this example, Apostrophe uses the current git commit ID to identify the current bundle of frontend assets.

If your preferred deployment process does not involve running `git clone` on the server, **you'll need to set the `APOS_RELEASE_ID` environment variable to a consistent value of your own** when running the asset build task *and* when starting up Apostrophe. Change that release ID value for both purposes *with each new deployment*.

```sh
APOS_RELEASE_ID=myLatestReleaseID npm run build &&
APOS_RELEASE_ID=myLatestReleaseID pm2 restart starter-kit-essentials
# Remember, starter-kit-essentials is the name of the pm2 process from this example.
# Replace that with the name of your pm2 process.
```

================================================================================
COLLECTION: guides
NAV_PATH: Hosting & DevOps > Heroku
DOC_PATH: cookbook/deploying-to-heroku.md
URL: https://apostrophecms.com/docs/cookbook/deploying-to-heroku
================================================================================
# Deploying Apostrophe in the Cloud with Heroku

There are many cloud hosting services, but they all present the same challenges. For example, separate servers often don't share a single filesystem. The database usually needs its own scalable cloud hosting. And performing tasks like minifying assets is often best done in your development environment, minimizing what has to be done in production.


## Deploying Apostrophe to Heroku

[Heroku](http://heroku.com) is a great starting point for cloud hosting because it is simple to set up, but all of the cloud's challenges come into play. What we learn by deploying to Heroku can be applied equally to Amazon EC2, Microsoft Azure, and other cloud hosting services.

To reduce costs for this how-to, we'll be using free services from Amazon Web Services and MongoDB Atlas, a MongoDB cloud hosting service from the creators of MongoDB. But remember that you can choose paid plans with much higher capacity and performance. Everything in this tutorial is designed to scale smoothly to those paid offerings. Heroku's offerings are in flux. They are eliminating the free tier, but they are offering low-price 'Eco' and 'Basic' plans with the same provisioning as the free tier used to write this tutorial.

## Before you begin

### Create the project (or use your own)
First, build an Apostrophe site! See the [setting up page](../guide/development-setup.md) to get started with the installation of the CLI. We will create a project called `heroku-tut`. Alternatively, you can use an existing Apostrophe site by simply skipping this step.

```bash
$ apos create heroku-tut
```
### Commit to Git
After creation, the project needs to be committed to a Git repository. If you don't already have Git installed on your system, you can learn about installation at the [official site](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).

The following example demonstrates initializing a Git repostitory for the `heroku-tut` project. You can skip this step if you have an existing project that is already being tracked.

```bash
$ cd heroku-tut
$ git init
Initialized empty Git repository in .../.git/
$ git add .
$ git commit -m "My first commit"
```

## First steps with Heroku

Create an account at [heroku.com](http://heroku.com).

Then create a Heroku app, choosing any app name and runtime location (US, Europe, etc.) you wish. While it is good to try and name your app the same as your project, this may not be possible if your app has a generic name like 'heroku-tut'. Remember the name of the app because we'll need it in future steps.

Following the instructions on the Heroku site, install the [Heroku CLI](https://devcenter.heroku.com/articles/heroku-command-line) if you haven't already.

*** From within your project directory log-in to heroku

```bash
$ heroku login
```

To enable deployment, add Heroku as a "git remote" to which your code can be pushed, substituting your Heroku app name created above:

```bash
$ heroku git:remote -a <yourAppName>
```

You can check to make sure this worked by using the command:

```bash
$ git remote -v
```
You should see output like, but with your app name at the end:

```bash
heroku  https://githeroku.com/apos-heroku-tut.git (fetch)
heroku  https://githeroku.com/apos-heroku-tut.git (push)
```
At this point, we can also tell Heroku that the site we will be spinning up is a production site. To accomplish this we will set the `NODE_ENV` environment variable to `production` using `heroku config:set`. The command should look like this:

```bash
$ heroku config:set NODE_ENV=production
```

## Add a MongoDB Atlas cluster
With our project set-up to deploy to Heroku, we need a database.

Heroku runs our node app, but it doesn't run MongoDB for us. So let's go to [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) and sign up.

Once you log-in to your account, create a project. I named my project 'apostrophe', but you can use any name you wish. Next, within that project, click on 'Build a Database'. Select the free 'Shared' tier and pick 'AWS' as your cloud provider and the same region you chose for Heroku.
For "Cluster Tier" choose "M0 Sandbox".

We recommend you give your cluster the same name as your project, in the case of this example, 'heroku-tut'.

You will need to set up an administrative MongoDB user for your cluster. These will be part of your MongoDB database connection credentials. **Be sure to set a secure, separate username and password,** do not use your Atlas login credentials. One thing to note: the characters `: / ? ! # [ ] @` in your username or password will need to be [URL-encoded](https://www.eso.org/~ndelmott/url_encode.html) in the database connection string.

### IP address allowing

MongoDB Atlas requires us to allowlist the IP addresses that should be allowed to talk to the database. **Yes, it is secured by an encrypted password,** but this still helps to reduce potential DOS attacks.

This is a problem with Heroku because it may connect from many IP addresses.

If you are buying a larger Atlas plan you may be able to use the "VPC Peering" option, the details of which are beyond the scope of this recipe. Otherwise, use this IP address range:

`0.0.0.0/0`

This will allow you to connect, but you might desire a fixed IP for your site. One solution is to use the [fixie-socks](https://elements.heroku.com/addons/fixie-socks) add-on from Heroku.

### Telling Heroku about your database

You will need to set an environment variable in Heroku so that your dynos can communicate with the database. Within your new database deployment, click on the 'connect' button next to the name. Next, click on 'Connect your application'. By default, the driver drop-down menu should be set to 'Node.js' and version '4.1 or later'. If they aren't, change them and then copy the connection string. Paste the string into a text editor and add your password. Again, make sure to URL encode any special characters. Now use this string to set an environment variable in Heroku. It should look something like this:

```
$ heroku config:set 'APOS_MONGODB_URI=mongodb+srv://<yourUserName>:<password>@heroku-tut.lrzxt0l.mongodb.net/?retryWrites=true&w=majority'
```

We use single quotes to avoid problems with most special characters in the URI. If you used the `'` character in the URI, you'll need to escape that with `\'`.

From here, you can test your site locally.

```bash
APOS_MONGODB_URI='YOUR-uri-goes-here' npm start
```

You should be able to view your website at the designated local port.

Press Control-C after you successfully test the site. Startup may take an extra moment because of the remote connection to MongoDB.

> At a small scale, "the cloud" is always slower than a single-server configuration. When things have to talk to each other, running them farther apart doesn't speed things up. However, after you reach a certain scale, a single server is impractical. And of course a single server is a single point of failure.

> If you do not run `npm start` with the environment variable set correctly, it'll seem to work because it will connect to your own mongodb. You can shut down your local mongodb server temporarily if you want to be really, really sure.

Now your database exists in the cloud, but it doesn't contain any users, so you won't be able to log in. So, let's use the command line to connect again to fix that:

```bash
$ APOS_MONGODB_URI='YOUR-uri-goes-here' node app @apostrophecms/user:add admin admin
```

*This is the same user-creation command you saw in our getting-started tutorial.* We're just talking to a different database.

> You can also copy a local database from an existing site to Atlas using the [`mongodump`](https://www.mongodb.com/docs/database-tools/mongodump/) and [`mongorestore`](https://www.mongodb.com/docs/database-tools/mongorestore/) commands. For additional examples of their use, see the `scripts/sync-down` and `scripts/sync-up` files in a CLI created project.

## Storing files with Amazon S3

**If you try to deploy now it might seem to work... but don't be fooled!** If you upload images and then redeploy later, or even just wait a day or so... forget it. They are gone forever. That's because, with Heroku, local files are "written on water." What's more, on any given page load you might not even hit the same dyno where the files were uploaded. And similar issues will break your static assets, like CSS and JS.

So we need to use Amazon S3 for persistent storage of both uploads and static assets.

First, [log into the Amazon Web Services console](https://aws.amazon.com/console/). Create an account if you haven't already. *You may have to provide a credit card but as of this writing, you can complete this how-to using their free service tier.*

From the Amazon Web Services control panel, click on S3. Then click "Create Bucket."

Choose a bucket name (the same as your app is nice but not mandatory) and a region. Then click "Create."

You can set your permissions right away.

1) Click on the "Permissions" tab. Click on the "Edit" button to edit your permissions.
![S3 console permissions tab](../images/s3-permissions-tab.png)

1) Uncheck the "Block all public access" box and save the changes. You will have to confirm that you want to do this.
![S3 console showing all public access blocks for S3 bucket turned off](../images/s3-public-permissions.png)

1) Scroll down the page to the "Object Ownership" section and click the "Edit" button.
![The S3 console Object Ownership section](../images/s3-object-ownership.png)

1) Select "ACLs enabled" and "Object writer" then acknowledge the warning and save the changes.
![S3 console object ownership edit screen](../images/s3-object-permission.png)

You can test it *without* Heroku, on your local machine, by setting the environment variables just for one run of your site (the trailing `\` characters are there to allow us to break one command line over multiple lines for readability in the `bash` shell):

```bash
$ APOS_S3_BUCKET=YOUR-bucket-name \
  APOS_S3_SECRET=YOUR-s3-secret \
  APOS_S3_KEY=YOUR-s3-key \
  APOS_S3_REGION=YOUR-chosen-region \
  node app
```

Upload an image to your site, then right-click it and inspect the image URL. It should be on an Amazon S3 server at this point, **not localhost**.

> "What if I want to use an S3-compatible service that isn't run by Amazon?" You can set the `APOS_S3_ENDPOINT` variable to a complete hostname. If you do, you should *not* set `APOS_S3_REGION`. See the tutorial in the Cookbook section for more information.

### Adding the S3 variables to Heroku

Just use `heroku config:set` again:

```bash
$ heroku config:set APOS_S3_BUCKET=YOUR-bucket-name
$ heroku config:set APOS_S3_SECRET=YOUR-s3-secret
$ heroku config:set APOS_S3_KEY=YOUR-s3-key
$ heroku config:set APOS_S3_REGION=YOUR-chosen-region
```

## Efficient asset delivery

In this setup, images are delivered efficiently via S3, and everyone can see all of the assets. However, we can set one more environment variable so that static assets like CSS and JS are served from S3.

```bash
$ heroku config:set APOS_UPLOADFS_ASSETS=1
```

Now, those assets will be copied to the S3 file storage and served from there.

> To ensure the contents of the bundle's `data/` subdirectory are still available, and to provide backwards compatibility for any URLs you have hard-coded in your templates that are not aware that the relevant contents of `public/` have been copied to S3, the assets are also extracted to the application's folder on Heroku. Apostrophe, however, will consistently reference the contents via S3 URLs instead.

## Deploying to Heroku

As a final step, we need to add a release id. There are a number of ways to accomplish this, but we will use a file named 'release-id' at the root of our project. This file doesn't have an extension and takes a short, unique string, like the date. Any time you make code changes and need to redeploy, the string in this file needs to be changed. We can do this by updating our build script within the `package.json` file.

First, create a new file called `heroku-release-tasks` within the `scripts` file at the root of your project. From the terminal at the root of your project issue the following command:

```bash
$ touch ./scripts/heroku-release-tasks && chmod 755 ./scripts/heroku-release-tasks
```

This command will create the file and then give it the permissions to be executed on the server. Open that file in your code editor and add the following:

```bash
export APOS_RELEASE_ID=`cat /dev/urandom |env LC_CTYPE=C tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1`

echo $APOS_RELEASE_ID > ./release-id

node app @apostrophecms/asset:build || exit 1
```

Next, the `"build"` script within the `package.json` file needs to be altered to run the new script. If you are building your project from scratch, you can simply replace the command that the `"build"` script runs with:

``` json
"build": "bash ./scripts/heroku-release-tasks"
```

Commit all your new files to your git repo and then type:

```bash
$ git push heroku main
```
::: info
My repo branch is named `main`, while yours might be named `master`.

Heroku will then start installing your dependencies via `npm install`, and you'll see the progress right in the terminal. Sometimes it can be easier to see the progress and trouble-shoot any problems by going to the Heroku dashboard. Select your app and then the 'Activity' tab. If you site has been successfully built you will see a 'Deployed' message at the top of the feed. If it is still building there will be a link to the build log that you can click.

When the site fully deploys you can visit:

https://YOUR-app-name-here.herokuapp.com/

And log in.

Victory!

## Updating your site

Any time we make changes to our project code we have to redeploy it to Heroku. Our modification to the `package.json` makes this easy. After making changes to our code, we simply have to commit those changes and push them to Heroku. Our script will give a new release id and rebuild the assets.

## If it doesn't work

**If your deployment fails,** type `heroku logs` to see what went wrong.

**If your images don't "stick" between restarts,** you probably skipped the Amazon S3 steps.

### Fonts, other assets, and CORS errors in the browser console

To ensure there are no CORS (Cross-Origin Resource) errors, visit your amazon S3 bucket settings to adjust the CORS configuration:

`Amazon S3 ‚Üí [bucket] ‚Üí Permissions Tab ‚Üí CORS configuration button`

Verify the value of `AllowedOrigin`. It should match the heroku url and/or the production URL of your project:

```
<AllowedOrigin>https://example.com</AllowedOrigin>
```

```
<AllowedOrigin>https://example.herokuapp.com</AllowedOrigin>
```

================================================================================
COLLECTION: guides
NAV_PATH: Hosting & DevOps > Amazon S3
DOC_PATH: cookbook/using-s3-storage.md
URL: https://apostrophecms.com/docs/cookbook/using-s3-storage
================================================================================
# Using S3 services with Apostrophe

Deploying Apostrophe to production requires that you specify hosting for the code base, the MongoDB instance, and storage for any uploaded content. Many hosting services can provide all three, but it is also possible and sometimes desirable to split these between different services. This tutorial looks at file storage solutions using the S3 API.

## What is the S3 API?
The S3 API is a REST API developed by Amazon as a means of communicating with their Simple Storage Service (S3). Versions of this API have since been adopted by many other providers. These alternative providers can sometimes provide lower cost points or desirable features, like IPFS. The `@apostrophecms/uploadfs` module provides an easy way to connect to most S3 API-powered services through environmental variables.

 Depending on the service used for hosting your code base, there are different ways to set these variables. For example, Heroku as we show in our [hosting tutorial](./deploying-to-heroku.md), allows you to configure your app either through their CLI or dashboard. For other hosting environments, you may need to set these variables through a `.env` or `.bashrc` file.

Let's start by looking at how to connect with Amazon Web Services (AWS) S3.

## Using AWS S3 services

For AWS S3 we need to add values for four environment variables: `APOS_S3_BUCKET`, `APOS_S3_REGION`, `APOS_S3_KEY`, and `APOS_S3_SECRET`.

1) Create an [Amazon AWS account](https://aws.amazon.com/pm/serv-s3/) and then log into the management console. From the "Services" menu select "Storage" and then "S3". Note that Amazon offers 12 months free with a fixed data cap.
2) This should take you to a dashboard screen where you can create a new bucket. Give your bucket a name. This is what we will use as a value for the `APOS_S3_BUCKET` environment variable.
3) Select an AWS region - this is the value we will use for the `APOS_S3_REGION` variable.
4) Leave everything else alone for now. We will come back to security in the next section.
5) From your account drop-down, select "Security credentials".
6) Open the "Access keys" section.
7) Click to "Create New Access Key"
8) This will create both our `APOS_S3_KEY` and `APOS_S3_SECRET` values. Make sure to save your secret value. You will be able to see your key from this page, but not your secret.

Setting these variables will allow for upload into your bucket, but until you change the permissions settings for the bucket your site won't be able to access the resources.

### Example Amazon S3 permissions

1) First, select the bucket from the S3 management console and then click on the "Permissions" tab. Click on the "Edit" button to edit your permissions.
![S3 console permissions tab](../images/s3-permissions-tab.png)

2) Uncheck the "Block all public access" box and save the changes. You will have to confirm that you want to do this.
![S3 console showing all public access blocks for S3 bucket turned off](../images/s3-public-permissions.png)

3) Scroll down the page to the "Object Ownership" section and click the "Edit" button.
![The S3 console Object Ownership section](../images/s3-object-ownership.png)

4) Select "ACLs enabled" and "Object writer" then acknowledge the warning and save the changes.
![S3 console object ownership edit screen](../images/s3-object-permission.png)

If you are using a CDN or want to make uploaded objects private for another reason, you can set the `bucketObjectsACL` to `private`. See the [`uploadfs` documentation](/reference/modules/uploadfs.html#s3-storage-options) for more information and options.

## Using FileBase for storage

The FileBase storage service uses a truncated version of the S3 API. However, we can use this service in almost the same manner as the AWS S3 service. In this case, we must pass in one additional environment variable, `APOS_S3_ENDPOINT`, and **not** set the `APOS_S3_REGION` variable. See the [`uploadfs` documentation](/reference/modules/uploadfs.html#s3-storage-options) for more information and options.

1) Create a [FileBase account](https://filebase.com/). While the service does have a free tier, it doesn't allow public access. This means our site won't be able to load resources, so you need to select one of their paid plans.
2) From the console switch to the "Buckets" tab and click on "Create Bucket".
3) Give the bucket a name. This is the value we will pass to the `APOS_S3_BUCKET` variable.
4) Leave the storage network as "IPFS" and click "Create Bucket".
5) Set the bucket access to public using the toggle next to the bucket name.
6) Click the "Access Keys" tab.
7) This screen will display the key and secret values we will add to the `APOS_S3_KEY` and `APOS_S3_SECRET` variables.
8) On this screen we can also get the value for the `APOS_S3_ENDPOINT` environment variable from the URL listed under 'S3 API Endpoint'. Note: you should **not** set the `APOS_S3_REGION` key.

### FileBase Security
While FileBase can accept many of the same type of CORS (cross-origin resource sharing) and ACL (access control list) rules as AWS S3, simply setting the security toggle to "public" on the "Buckets" screen should be enough for most sites. FileBase does not allow for object-level ACLs. The permissions for your uploads is based on the bucket the object is uploaded into, so the `bucketObjectsACL` option will not apply.

## Using Vultr for storage

The Vultr storage service uses a truncated version of the S3 API. However, we can use this service in almost the same manner as the AWS S3 service. In this case, we must pass in one additional environment variable, `APOS_S3_ENDPOINT`, and **not** set the `APOS_S3_REGION` variable. See the [`uploadfs` documentation](/reference/modules/uploadfs.html#s3-storage-options) for more information and options.

1) Create a [Vultr account](https://www.vultr.com/). While the service doesn't have a free tier, you should be able to find a free credit offer if you are a new customer.
2) Log in to your account and navigate to "Products".
3) Select "Objects" to begin creating a new storage object.
4) Select your preferred location. 
5) Add a label for your object - this object can contain multiple storage buckets.
6) Wait for the object to install and then click on the green arrow.
7) Under the S3 Credentials you will see your Hostname, Secret Key, and Access Key. These will be used for the `APOS_S3_ENDPOINT`, `APOS_S3_SECRET`, and `APOS_S3_KEY` variables. Note: you should **not** set the `APOS_S3_REGION` key.
8) Click the "Buckets" tab.
9) Click the "Create Bucket" button.
10) Add a bucket name following the noted limitations. This name will be used to set the `APOS_S3_BUCKET` variable.

### Vultr Security
While files uploaded to Vultr are private by default, the `@apostrophecms/uploadfs` module sets `bucketObjectsACL` to `public-read` by default. Therefore, you don't have to perform any further security changes in order for your site to be able to access the stored files.

## Using Wasabi for storage

The Wasabi storage service has an expanded API that supports some features not found in the AWS S3 REST API, but is compatible with the core S3 API that Apostrophe uses. We can use this service in almost the same manner as the AWS S3 service. In this case, we must pass in one additional environment variable, `APOS_S3_ENDPOINT`, and **not** set the `APOS_S3_REGION` variable. See the [`uploadfs` documentation](/reference/modules/uploadfs.html#s3-storage-options) for more information and options.

1) Create a [Wasabi account](https://www.wasabi.com/).  While the service does have a free tier, it doesn't allow public access. This means our site won't be able to load resources, so you need to select one of their paid plans. You may be able to find a credit offer if you are a new customer.
2) Once logged in, click on "Create Bucket".
3) Add a bucket name. This is the value we need to set for the `APOS_S3_BUCKET` variable.
4) Select a preferred region. Note the URL to the right of each region. This is the value for the `APOS_S3_ENDPOINT` variable. Although each bucket will have a region listed, this should **not** be added to the `APOS_S3_REGION` variable. This variable should not be set.
5) Click the "Next" button to step through the settings until the "Create bucket" button comes up. Nothing needs to be changed.
6) Click on the "Access Keys" menu item on the left.
7) Click the "Create new access key" button.
8) Download the credentials. You won't be able to get the secret again.
9) Get the `APOS_S3_SECRET` and `APOS_S3_KEY` values from the file.

If you didn't note the endpoint URL you can get it based on the region code (e.g. 'us-east-1') from this [page](https://wasabi-support.zendesk.com/hc/en-us/articles/360015106031-What-are-the-service-URLs-for-Wasabi-s-different-storage-regions-).

### Wasabi security
The files uploaded to the Wasabi bucket are publicly available right away without the need for any changes. However, if you click the menu to the right of the bucket name and select "Setting", it will bring up a page that allows you to alter permissions easily. See the [`uploadfs` documentation](/reference/modules/uploadfs.html#s3-storage-options) for more information and options.

## Using DigitalOcean Spaces for storage

The DigitalOcean Spaces API is a truncated version of the AWS S3 API that supports all the features we need for using it for storage with Apostrophe. We can use this service in almost the same manner as the AWS S3 service. In this case, we must pass in one additional environment variable, `APOS_S3_ENDPOINT`, and **not** set the `APOS_S3_REGION` variable. See the [`uploadfs` documentation](/reference/modules/uploadfs.html#s3-storage-options) for more information and options.

1) Create a [DigitalOcean account](https://www.digitalocean.com/). They don't have a free tier, but do offer a credit to new customers.
2) Once logged in, you'll be brought to a project page. Click on "Store static objects". In some cases, you might instead have to click "Start using Spaces".
3) Choose a preferred datacenter region.
4) Leave "Restrict File Listing" selected.
5) Create a name and select a project. If you haven't made one it will assign it to a default called "first-project". The name is the value for the `APOS_S3_BUCKET` variable.
6) Click on "Create a Space".
7) Click on the "Settings" tab.
8) Copy the "endpoint" URL. This is the value for the `APOS_S3_ENDPOINT` variable.
9) Click on the "API" tab in the left menu.
10) Scroll down to the "Spaces access keys" section and click "Generate New Key".
11) Add a name and hit return. It will take a few seconds to generate the key and secret. Copy them. You will be able to get the key again by returning to this page, but you won't be able to retrieve the secret.
12) Assign the key and secret values to the `APOS_S3_KEY` and `APOS_S3_SECRET` variables, respectively. The `APOS_S3_REGION` variable should **not** be set.

### DigitalOcean Security
The assets uploaded to the DigitalOcean Spaces are publicly readable by default. No security policy changes are required. If needed, you can configure the CORS (cross-origin resource sharing) through the settings of each space, and you shouldn't need to change anything.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/admin-bar
DOC_PATH: reference/modules/admin-bar.md
URL: https://apostrophecms.com/docs/reference/modules/admin-bar
================================================================================
# `@apostrophecms/admin-bar`

**Alias:** `apos.adminBar`

<AposRefExtends :module="$frontmatter.extends" />

This module implements Apostrophe's admin bar at the top of the page. Any module can register a button (or more than one) for the bar by calling this module's `add` method. Buttons can also be grouped into dropdown menus and restricted to those with particular permissions. The [@apostrophecms/piece-type module](/reference/modules/piece-type.md) takes advantage of this module automatically.

## Configuration options

Options are passed into the admin-bar module by creating a `modules/@apostrophecms/admin-bar/index.js` file in our project. Our project-specific configuration will merge gracefully with the defaults that come with the module.

|  Property | Type | Description |
|---|---|---|
|`groups` | Array | Adds one or more menu item group objects to be displayed in dropdown menus |

### `groups`

The `groups` option takes an array of one or more objects that group several menu items together in the admin bar as a dropdown menu. Each of the `groups` objects requires a `label` and an array of menu `items`. The `label` will be used as the label displayed in the menu. The `items` array contains the names of the individual menu items you want to appear in the dropdown, entered in the order you want them to appear. Note: Menu names for `piece-type` items are the name of the piece-type, not the label. For core items, like 'Images', the name is prefixed - '@apostrophecms/image'.

**Example**

<AposCodeBlock>

```javascript

module.exports = {
 options: {
   groups: [
     {
       name: 'media',
       label: 'Media',
       items: [
         '@apostrophecms/image',
         '@apostrophecms/file',
         '@apostrophecms/image-tag',
         '@apostrophecms/file-tag'
       ]
     }
   ]
 }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/admin-bar/index.js
  </template>
</AposCodeBlock>

This will result in grouping those four core modules into a single dropdown menu displayed as 'Media' on the menu bar.
![ApostropheCMS admin bar with open dropdown menu titled 'Media'](/images/group-menu.png)

## Featured methods

The following method belongs to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/admin-bar/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

Because this module has an alias, you can call these from another module from the alias path. For example, `self.apos.adminBar.add()`.

### `add(name, label, permission, options)`

Add an item to the menu bar.

The `name` for the item must be unique within the menu bar to avoid conflicts. When the menu item is clicked, the `name` argument will be emitted on `apos.bus` as the value of an `admin-menu-click` event. If this item controls a specific modal, this will be caught by `TheAposModals` to display the correct modal. If this is the case, `name` should be the module name with a `:editor` or `:manager` suffix. For example, `@apostrophecms/global:editor`. A more complex example is contained within the [`@apostrophecms/login` module](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/login/ui/apos/apps/AposLogin.js).

**Example**

Code added to handle click events on the new button in the admin UI frontend:

<AposCodeBlock>

```javascript
export default () => {
  apos.bus.$on('admin-menu-click', async (item) => {
    // Make sure it is the button we care about, leave others to their own handlers
    if (item !== 'myCustomModule') {
      return;
    }
    // Custom code for button action
  });
}
```
  <template v-slot:caption>
    /modules/myCustomModule/ui/apos/apps/CustomFunctions.js
  </template>
</AposCodeBlock>

::: info
Make sure to add this to the `ui/apos/apps/` folder, or import it into a file located there. If you try to load this code by adding it to `ui/src` you will get an error in the console because the admin functions won't be available, yet.

The `label` will be the name displayed for the button on the menu bar.

`permission` is optional and takes an object with `action` and `type` properties. If no permissions are present, anyone can see the button. The `action` property dictates what type of action the button will perform. These include `view`, `view-draft`, `edit`, `publish`, `upload-attachment`, and `delete`. The `type` property matches the name of the module the button is managing. This type must have a registered manager.

`options` can take several properties that control the positioning and display of the new menu item.

|  Property | Type | Description |
|---|---|---|
| `last` | Boolean | If truthy, it will cause the button to be displayed at the end of the list. |
| `contextUtility` | Boolean | If truthy, it will cause the button to be displayed in the tray of icons to the left of the page settings gear. |
| `icon` | String | If `contextUtility` is `true` an icon name is required for display. |
| `toggle` | Boolean | If truthy, the button will remain active until it is clicked a second time. |
| `tooltip` | Object \|\| String | Depending on the `toggle` value, a tooltip string or an object with `activated` and `deactivated` strings. |
| `user` | Boolean | Adds the button alongside the "Log Out" button on the personal dropdown at the upper right. Should be reserved for items that manage personal settings. |

#### `last`

If the `last` property is set to ‚Äòtrue‚Äô, the button will be displayed as the last item in the left list of buttons. Note: If more than one button has this property, the last one loaded will win.

#### `contextUtility`

If the `contextUtility` property is set to `true`, the button will be displayed as an icon in the tray of icons to the left of the page settings gear.

#### `icon`

 For proper display when setting `contextUtility` to true, a property of `icon` set to the value of an existing icon must also be passed. More can be read about icons [here](/reference/module-api/module-overview.md#icons). A list of the icons imported automatically by Apostrophe can be found in the [‚Äòasset‚Äô module in the ‚ÄòglobalIcos.js‚Äô file‚Äô within the ‚Äòlib‚Äô folder](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/asset/lib/globalIcons.js).

#### `toggle`

The `toggle` property is used in conjunction with `contextUtility`. If it set to `true` then the button will toggle between active and inactive states. This allows the addition of different tooltip text depending on state.

#### `tooltip`
The `tooltip` property can take either a string or an object. If `toggle` is falsy, then the value of `tooltip` is a string to display on hover. If `toggle` is truthy, then `tooltip` takes an object with two arguments, `activate` and `deactivate`. Both properties accept string values with the former being displayed for the activated state and the later the deactivated state.

### `getShowAdminBar(req)`
This method determines whether the admin-bar should be displayed. At project level, this method should be extended in the `modules/@apostrophecms/admin-bar/index.js` file `extendMethods(self)` customization function and should return a boolean value. By default, it returns the value of `!!req.user`, which is true if a user is logged in. An example of how to use this method is shown in the [custom admin ui](/guide/custom-ui.html#toggling-the-admin-bar-visibility) section of the documentation.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/asset
DOC_PATH: reference/modules/asset.md
URL: https://apostrophecms.com/docs/reference/modules/asset
================================================================================
# `@apostrophecms/asset`

**Alias:** `apos.asset`

<AposRefExtends :module="$frontmatter.extends" />

The `asset` module serves to organize, process, and output all project JavaScript and CSS assets during the build process. It also passes options for display of different breakpoints during development, accomplished by converting CSS assets to container queries. In addition, it provides access to modify the project webpack configuration and exposes two CLI tasks for project building and webpack cache clearing. Options are typically passed through the creation of a `modules/@apostrophecms/asset/index.js` file. They can also be passed in `app.js`.

## Options

|  Property | Type | Description |
|---|---|---|---|
| [`refreshOnRestart`](#refreshonrestart) | Boolean | If set to `true`, the browser will refresh on Apostrophe app restart. |
| [`watch`](#watch) | Boolean | If set to `false`, none of the UI assets will be watched to trigger a restart. |
| `watchDebounceMs` | Integer | Time in milliseconds to wait before re-triggering a restart on asset change. |
| [`uploadfs`](#uploadfs) | Object | Can be used to configure an `uploadfs` instance. |
| [`rebundleModules`](#rebundlemodules) | Object | Used to direct project wide asset files into new bundles. |
| [`breakpointPreviewMode`](#breakpointPreviewMode) | object | Enables and sets screen sizes for mobile preview. |
| [`hmr`](#hmr) | String or Boolean | Controls Hot Module Replacement mode. Values: `'public'` (default), `'apos'`, or `false` |
| [`hmrPort`](#hmrport) | Number | Sets custom WebSocket server port for HMR. Defaults to ApostropheCMS server port. |
| [`productionSourceMaps`](#productionsourcemaps) | Boolean | If `true`, includes source maps in production builds. |
| [`productionSourceMapsDir`](#productionsourcemapsdir) | String | Copies production sourcemaps to the directory specified. |

### `refreshOnRestart`

By default, `refreshOnRestart` is set to `false`. If this option has a falsy value, the browser will not automatically refresh following app restart.  If this option is truthy and `process.env.NODE_ENV` is not set to `production`, then restart of the Apostrophe app will trigger a browser refresh. This is very useful in combination with `nodemon` to deliver file changes to the browser.

### `watch`

By default, `watch` is set to `true`. A truthy value will cause the application to monitor for changes in any of the asset bundles in the `modules` and `node_modules` folders and trigger a webpack rebuild and browser refresh. A value of `false` will disable this behavior. Note that this option is disabled and has no impact if `process.env.NODE_ENV` is set to `production`.

### `uploadfs`

When the `APOS_UPLOADFS_ASSETS` environment variable is present, this optional property can be used to configure an `uploadfs` instance that differs from the one configured by the `attachment` module, allowing changes in where assets from the webpack build process are stored and how they are served. Full documentation for uploadfs can be found [here](https://www.npmjs.com/package/uploadfs).

### `devSourceMap`

::: warning Deprecated

This option is accepted for backwards compatibility and ignored since version `4.25.0`. Beginning with that release, the high quality `devtool: 'source-map'` is used consistently in webpack builds, and Vite has its own approach. For production builds dsee the `productionSourceMaps` option.

### `productionSourceMaps`

By default, source maps are not deployed in production. If you wish to enable this, set `productionSourceMaps: true`. This enables useful stack traces for production code in the browser console. This feature works with both webpack and Vite builds.

### `productionSourceMapsDir`

This option is only consulted if `productionSourceMaps: true` has already been set.

If you wish to build production source maps for your asset bundles, but don't wish to deploy them for the public, use this option to specify a folder where ApostropheCMS should place them. The next step after that is up to you. Creating and/or clearing this folder is your responsibility. Most developers will not need this option.

### `rebundleModules`

The `rebundleModules` option allows for overridding the `bundles` properties passed into webpack at the individual module level, including modules added through npm. This option takes an object with module names, or module names with a suffix made up of a `:` and bundle name, as properties. This property designates rebundling of either all the code in the former case, or a single named bundle in the later.

Each property takes a string value, indicating the name of the new bundle for the assets. This allows rebundling of code that used to go to a specific bundle from a particular module. Or, you can rebundle all the code from that module. Bundles from multiple modules can be rebundled into the same new end bundle.

#### Example

<AposCodeBlock>

``` js
module.exports = {
  options: {
    rebundleModules: {
      // Everything from the fancy-form module should go in the regular "main" bundle
      'fancy-form': 'main',
      // Everything from the basic-product module should go in the "secondary" bundle
      'basic-product': 'secondary',
      // Code originally designated as part of the `form` bundle from 
      // the @dcad/form module should be retargeted to the"secondary" bundle
      // but only that code, leave ui/src/index.js in the main bundle
      '@dcad/form:form': 'secondary'
    }
  }
};
```

<template v-slot:caption>
modules/@apostrophecms/asset/index.js
</template>
</AposCodeBlock>

To split files within a single `ui/src` folder into multiple bundles, assign each file separately with a property:value pair for each file.

Bundles in Vite can be controlled through the configuration options.

### hmr
Hot Module Replacement (HMR) automatically updates your browser when you make changes to your code, without requiring a full page refresh. The `hmr` option controls which parts of your application use this feature:

<AposCodeBlock>

```javascript
modules: {
  '@apostrophecms/asset': {
    options: {
      hmr: 'public'
    }
  }
}
```
<template v-slot:caption>
app.js
</template>
</AposCodeBlock>

- `'public'` (default): Enables HMR for your project's UI code, including any custom components, stylesheets, and client-side JavaScript in your project's modules.
- `'apos'`: Enables HMR for the ApostropheCMS admin UI, useful when developing admin UI modifications or custom admin components.
- `false`: Disables HMR completely, requiring manual page refreshes to see changes.

### hmrPort
Sets a custom port for the WebSocket server that handles HMR communications. By default, it uses your ApostropheCMS server port:

<AposCodeBlock>

```javascript
modules: {
  '@apostrophecms/asset': {
    options: {
      hmrPort: 3001
    }
  }
}
```
<template v-slot:caption>
app.js
</template>
</AposCodeBlock>

You typically only need to set this if you're running behind a proxy or have port conflicts.

### `productionSourceMaps`

Controls source map generation in production builds. This option replaces the previous webpack-specific devSourceMap option. You cannot use both devSourceMap and productionSourceMaps as they belong to different bundling systems. With the move from webpack to Vite, source map handling has been simplified:

- In development, Vite automatically provides high-quality source maps that work well with browser dev tools. Unlike webpack's `devtool` setting, this behavior is optimized by default and cannot be configured.

- For production, source maps are disabled by default to minimize build size. Setting `productionSourceMaps: true` will include them in the production build:

<AposCodeBlock>

```javascript
modules: {
  '@apostrophecms/asset': {
    options: {
      productionSourceMaps: true
    }
  }
}
```
<template v-slot:caption>
app.js
</template>
</AposCodeBlock>

This option applies to both admin UI and project UI builds, providing better debugging capabilities across your entire application compared to webpack's admin-UI-only source maps.

::: tip
Source maps in production will increase your build size but can be invaluable for debugging production issues. Consider your specific needs and deployment constraints when enabling this option.

### `breakpointPreviewMode`
The `breakpointPreviewMode` is enabled by default and adds shortcut icons plus a dropdown menu to the admin-bar for each of the breakpoints specified in the `screens` object. If only breakpoints with `shortcut: true` are present then the dropdown menu will not be added, only the icons. Clicking on an icon or making a selection from the dropdown menu will cause the markup to display as a CSS container of the specified dimensions. Any styling assets handled by the apostrophe build process added through a [`ui/src/index.scss` file of any module](/guide/front-end-assets.html#placing-client-side-code) will be transpiled and applied as container queries in this display. This is for preview purposes only, the project styling assets will not be directly altered. Any CSS breakpoint styling added through `<style>` blocks in the template will not change in response to the altered display size. There are also some standard CSS breakpoint declarations that cannot be directly converted into container queries, particularly those targeting the viewport height or those relying on global viewport conditions. You will receive console notifications when declarations that can't be converted are encountered if the `debug` property is set to `true`. These exceptions can potentially be handled using the [`transform` property](#transform) as detailed.

#### `breakpointPreviewMode` properties

| Property | Type | Description |
|---|---|---|
| `enabled` | boolean | Set to `true` by default, set to `false` to remove breakpoints to the admin-bar |
| `debug` | boolean | Set to `false` by default, set to `true` to get notifications about CSS declarations that can't be converted to container queries. |
| `resizeable` | boolean | Set to `false` by default, set to true to allow breakpoint displays to be resized by dragging the lower right corner. |
| [`screens`](#screens) | object | Takes an object with properties for each breakpoint to be enabled. |
| [`transform`](#transform) | null \|\| function | Alters the default conversion of CSS queries to container queries for compatibility. |

Below are the default settings for the `breakpointPreviewMode` option:

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    breakpointPreviewMode: {
      // Enable breakpoint preview mode
      enable: true,
      // Warn during build about unsupported media queries.
      debug: false,
      // Screens with icons
      // For adding icons, please refer to the icons documentation
      // https://apostrophecms.com/docs/module-api/module-overview.html#icons
      screens: {
        desktop: {
          label: 'apostrophe:breakpointPreviewDesktop',
          width: '1440px',
          height: '900px',
          icon: 'monitor-icon',
          shortcut: true
        },
        tablet: {
          label: 'apostrophe:breakpointPreviewTablet',
          width: '1024px',
          height: '768px',
          icon: 'tablet-icon',
          shortcut: true
        },
        mobile: {
          label: 'apostrophe:breakpointPreviewMobile',
          width: '414px',
          height: '896px',
          icon: 'cellphone-icon',
          shortcut: true
        }
      },
      // Transform method used on media feature
      // Can be either:
      // - (mediaFeature) => { return mediaFeature.replaceAll('xx', 'yy'); }
      // - null
      transform: null
    }
  }
};
```
<template v-slot:caption>
modules/@apostrophecms/asset/index.js
</template>
</AposCodeBlock>

::: warning
Adding a `breakpointPreviewMode` option at project level to add additional breakpoint sizes, for example, will replace *all* default values. This means that you must pass `enable: true` in the project level `@apostrophecms/asset/index.js` file to have breakpoints displayed if you want to change screen sizes.

##### `screens`
The `screens` object takes a property for each desired breakpoint. Those properties take an object composed of two required and three optional properties. Adding this property at project-level will override the default `screens` object. The `label` property is optional, but highly recommended, and takes a string that is displayed to the user when they hover over the icon for the breakpoint and as a label in the dropdown menu. The `shortcut` property takes a boolean and will add the breakpoint to the set of icons displayed to the left of the dropdown. The `icon` property is optional for non-shortcut breakpoints. It takes the name of a [registered icon](/reference/module-api/module-overview.md#icons) that is displayed in the admin-bar for toggling the breakpoint display. The final two properties, `width` and `height`, are required. These should be set to the `px` dimensions of the emulated device. Note that the mobile preview feature doesn't support device pixel-ratios or resolution. You can switch between preview modes by clicking other breakpoint shortcut icons or making a selection from the dropdown menu. Clicking on any active icon or the `X` to the right of the dropdown will exit out of preview mode.

##### `transform`
By default, the `transform` property will be set to `null` and accept the built-in transpiling of standard CSS queries into container queries. However, in cases where the standard queries can't be transpiled or the standard method needs adjustment you can pass the existing standard query to a function to provide a customized return.

For example, your media query might use widths based on `em` and the final layout is better reflected by converting those to `px` values:

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    breakpointPreviewMode: {
      enable: true,
      screens: {
        ...
      },
      transform: (mediaFeature) => {
        // Convert `min-width` and `max-width` from `em` to `px`, assuming 1em = 16px
        return mediaFeature.replace(/(\d+)em/g, (match, emValue) => {
          const pxValue = parseInt(emValue) * 16; // Convert em to px assuming a 16px base font size
          return `${pxValue}px`;
        });
      }
    }
  }
};
```
<template v-slot:caption>
modules/@apostrophecms/asset/index.js
</template>

</AposCodeBlock>

This will take a media query like:
```css
@media (min-width: 30em) and (max-width: 50em) {
  /*...*/
}
```
and convert it to:
```css
@media (min-width: 480px) and (max-width: 800px) {
  /*...*/
}
```

## Command Line Tasks

### `build`
The build command triggers the compilation, processing, and output of files within the `ui/apos`  and `ui/src` folders of each module. Logged-in users will receive assets from both folders, while logged-out users will only receive the later. You don't need this task in a development environment, it runs automatically when you start your app. It is necessary in a production environment.

Assets within the `ui/apos` folder modify the admin UI. Code to be passed to the build process should be organized into three subfolders, a `components` folder that contains any new Vue components, an `apps` folder that takes any additional admin-facing JavaScript, and a `tiptap-extensions` folder that contains any tiptap-extensions used within the admin UI.

During the build process, code located in the `ui/apos` subdirectory of any module is automatically detected and incorporated. Assets in the `components` folder are registered automatically by name as Vue components and do not need to be imported.

Unlike assets in the `ui/src` folder where only the `index.js` file is an entry point, all files in the `ui/apos/apps` folder are entry points. If this behavior is undesirable any files that should not be entry points can be placed into a sub-directory and imported into the main entry point file. See the [`@apostrophecms/login` module](https://github.com/apostrophecms/apostrophe/tree/main/modules/%40apostrophecms/login) for an example, including import of the Vue library within the [`AposLogin.js` file](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/login/ui/apos/apps/AposLogin.js). Customizing the admin UI is covered in-depth in the [guide documentation](/guide/custom-ui.md#customizing-the-user-interface).

Every file in the tiptap-extensions folder must be a [tiptap](https://tiptap.dev/) WYSIWYG rich text editor [extension](https://tiptap.dev/extensions), written in that format. Every such extension will be loaded and made available for potential activation by the developer in the rich text widget's editing toolbar.

Frontend JavaScript and SASS CSS for ordinary website visitors is located in the `ui/src` folders of each module. If a module has a `ui/src/index.js` file, that is automatically incorporated as a JavaScript entry point. If a module has a `ui/src/index.scss` file, that is automatically incorporated as a CSS entry point. `ui/src/index.js` files must export a function, and the browser will invoke these in the order the modules were configured.

In addition, files in `ui/public` are automatically concatenated into the `ui/src` JavaScript bundle "as-is."

In addition to the `ui/src/index.js` and `ui/src/index.scss` entry points, additional entry points can be defined by declaring [bundles via the `webpack` section](#bundles) of any module's main `index.js` file. These create separately compiled frontend bundles loaded only if a widget type or page type module declares a need for them.

If `NODE_ENV=production`, all of the final deployment files will be written out to a sub-folder located within either the `public/apos-frontend/releases` folder, or the `public/uploads/apos-frontend/releases/` folder if the `APOS_UPLOADFS_ASSETS` variable is also present. The name of the subfolder is derived from the release id. The `build` script will try to automatically set the release id using the hash if the project is a simple git checkout, environment variables for Heroku or platform.sh, or via the timestamp part of the project's deployment folder name for Stagecoach. When building for other environments, the release id must be set via the `APOS_RELEASE_ID` environment variable or with a root directory file named 'release-id' with the value of the id inside. The value should be a short, unique string identifier.

#### Example

<AposCodeBlock>

```sh
NODE_ENV=production APOS_RELEASE_ID='2022-01-01' node app @apostrophecms/asset:build
```
</AposCodeBlock>

### `clear-cache`
Some changes to the webpack configuration will not be detected automatically resulting in a failure to automatically rebuild the assets after those changes are first made. While this is rare, the caches for webpack can be emptied from the command line using the `clear-cache` task.

#### Example

<AposCodeBlock>

```sh
node app @apostrophecms/asset:clear-cache
```
</AposCodeBlock>

### `reset`
The `reset` task provides a more comprehensive cleanup than `clear-cache` by removing build artifacts, clearing the `public/apos-frontend` directory (without affecting releases), and emptying the cache. This is useful when you need a complete reset of your asset build system or when troubleshooting build-related issues.

#### Example

<AposCodeBlock>

```sh
node app @apostrophecms/asset:reset
```
</AposCodeBlock>

The key differences between `reset` and `clear-cache` are:
- `reset` removes all build artifacts in addition to clearing the cache - located by default at `data/temp/webpack-cache`
- `reset` empties the `public/apos-frontend` folder (excluding releases)
- `reset` provides a more thorough cleanup of the asset build system

You might need to use this task when:
- Making significant changes to your webpack of Vite configuration
- Troubleshooting persistent build issues
- Wanting to ensure a completely clean state for your asset build system

## Webpack configuration

The webpack configuration for building the front-facing page assets can be extended from any module. The `asset` module exposes three different properties for accomplishing this.

## Webpack options
|  Property | Type | Description |
|---|---|---|
| [`extensions`](#extensions) | Object | Adds extra processing functionality to webpack. |
| [`extensionOptions`](#extensionoptions) | Object | Adds functionality to any extensions added through the `extensions` option. |
| [`bundles`](#bundles) | Object | Allows delivery of additional assets when specific pages or pieces are displayed. |

### `extensions`
The `extensions` option allows the addition of custom webpack configuration methods for processing the Javascript and SCSS in the `ui/src` and `ui/apos` folders. The schema used within the option conforms to that used for configuring webpack, which you can learn more about [here](https://webpack.js.org/configuration/). Subproperties of extensions can be simple objects whose properties merge with the webpack configuration, or functions that accept an object of options and return such an object.

#### `extensions` simple object

#### Example

Modification of the `resolve` property of the webpack configuration using a simple object. New values will be merged with existing values:

<AposCodeBlock>

```javascript
const path = require("path");

module.exports = {
// ...
webpack: {
 extensions: {
   modifyResolve: {
     resolve: {
       alias: {
         'Utilities': path.join(process.cwd(), 'lib/utils')
       }
     }
   }
 }
},
// ...
};

```
<template v-slot:caption>
modules/my-module/index.js
</template>
</AposCodeBlock>

This example will expose a shortcut to the `lib/utils` folder that we can use in our frontend files. For example, to import a custom method from our `methods.js` library in this folder.

<AposCodeBlock>

```javascript
import  { customMethod } from ('Utilities/methods.js');

export default () => {
// Code utilizing customMethod
};
```
<template v-slot:caption>
modules/my-module/ui/src/index.js
</template>
</AposCodeBlock>

Adding a unique name for the extension within the apostrophe `extensions` property is important. This is because you can elect to override a module `extensions` object by passing an extension of the same name from another module that is loaded later.

#### `extensions` function

#### Example

Functions in the `extensions` property can take an `options` parameter to allow several modules to pass options to an extension through the [`extensionOptions`](#extensionoptions) property.

<AposCodeBlock>

```javascript
const path = require("path");

module.exports = {
// ...
webpack: {
 extensions: {
   addAlias(options) {
     return {
       resolve: {
         alias: {
           ...(options.alias || {}),
           Utilities: path.resolve(process.cwd(), './lib/utils')
         }
       }
     };
   }
 }
},
// ...
};

```
<template v-slot:caption>
modules/my-module/index.js
</template>
</AposCodeBlock>

### `extensionOptions`
Any module can pass options to an existing webpack `extension` as long as it was defined as a function accepting an `options` object. The `extensionOptions` property is an object that contains sub-properties matching each extension to be modified - in the preceding example, `addAlias()`. The values for each sub-property can be simple objects, in which case they merge into the options object to be passed to that extension. They can also be functions, in which case they take an `options` object containing the options so far and must return a new object with any desired changes made.

#### Example

Extending the previous example with an additional alias using a simple object:

<AposCodeBlock>

```javascript
module.exports = {
// ...
webpack: {
 extensionOptions: {
   addAlias: {
       alias: {
         Data: path.resolve(process.cwd(), './lib/data')
       }
     }
   }
 }
},
// ‚Ä¶
};
```
<template v-slot:caption>
module/my-new-widget/index.js
</template>
</AposCodeBlock>

### `bundles`
The `bundles` option allows delivery of frontend assets to a specific page or if a widget is on a page page. The `bundles` subproperty can be present in any type of module, not just widget type and page type modules. However, configuring a bundle in a widget type or page type module is the only way to cause it to actually be loaded. If a bundle is present in another type of module, that module can contribute code to it, but it will only get loaded when also configured for at least one widget type or page type. This option takes an object containing either the JavaScript or stylesheet file names without extension as properties. These files should be located in the module's `ui/src` folder. Each property takes either an empty object or a sub-property of `templates`. The `templates` sub-property accepts an array of page template names where the content should be loaded. The `templates` feature is most often relevant for piece-page-type modules; if it is not used, it is assumed both `index` and `show` templates should load the bundle.

Multiple modules can contribute to a single bundle by using the same bundle name, and webpack will merge these files in the final build. In addition, any shared dependencies between the extra bundles and the "main" bundle built from the code found in the `ui/src/index.js` files will be resolved so that only one instance is loaded.

::: warning
While extra bundles are a great feature, when used incorrectly they make sites slower, not faster.

Always ask yourself this question: **will a typical site visitor eventually load this code?** If so, you should **leave it in the main bundle** (import it from `ui/src/index.js`). This way the frequently needed code is always loaded up front and reused by every page without an extra request to the server.

Extra bundles should **only be used if the user probably won't need them on most visits.**


## Related documentation

- [Extending webpack configuration](../../guide/webpack.md)

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/attachment
DOC_PATH: reference/modules/attachment.md
URL: https://apostrophecms.com/docs/reference/modules/attachment
================================================================================
# `@apostrophecms/attachment`

**Alias:** `apos.attachment`

<AposRefExtends :module="$frontmatter.extends" />

The `attachment` module coordinates the addition and manipulation of any files added to the database and works alongside the `@apostrophecms/uploadfs` module. This includes rescaling and cropping of images, as well as the uploading of non-image files like '.pdf' or '.csv'. It exposes multiple template helpers and command line tasks for attachment retrieval and manipulation.

Options and configuration settings for this module are passed in through both `modules/@apostrophecms/attachment/index.js` and `modules/@apostrophecms/uploadfs/index.js`.

## Options

This reference is unusual compared to other reference pages in that it documents some settings that are passed directly to `@apostrophecms/uploadfs`. For these, see the [selected settings](#selecteduploadfssettings) of the `@apostrophecms/uploadfs` module section of this reference. 
|  Property | Type | Description |
|---|---|---|
| [`fileGroups`](#filegroups) | Array | Assigns uploaded files to either an 'image' or 'office' category to allow for upload and manipulation. |
| [`addFileGroups`](#addFileGroups) | Array | Allows addition of extension(s) to existing groups or creation of new groups. |

### `fileGroups`

This option should be passed to the `@apostrophecms/attachment` module. By default, this option is set to an array with two objects and any array passed through this option will *replace* the default values.

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    fileGroups: [
      {
        name: 'images',
        label: 'apostrophe:images',
        extensions: [
          'gif',
          'jpg',
          'png',
          'svg',
          'webp'
        ],
        extensionMaps: { jpeg: 'jpg' }
      },
      {
        name: 'office',
        label: 'apostrophe:office',
        extensions: [
          'txt',
          'rtf',
          'pdf',
          'xls',
          'ppt',
          'doc',
          'pptx',
          'sldx',
          'ppsx',
          'potx',
          'xlsx',
          'xltx',
          'csv',
          'docx',
          'dotx'
        ],
        extensionMaps: {}
      }
    ];
...
```
<template v-slot:caption>
  module/@apostrophecms/attachment/index.js
</template>

</AposCodeBlock>

The first default object's `name` property is set to `images` and an `extensions` key with an array of strings containing the non-prefixed extensions of file types that can be uploaded and attached to `@apostrophecms/image` pieces. In order to allow different spelling, e.g. 'jpg' or 'jpeg', the `extensionMaps` option takes an object with the alternative spelling as key and the extension it should map to as value.

::: info
Passing a new image extension type through replacement of the `@apostrophecms/attachment` default `fileGroups` option will not automatically cause the new image type to be re-sized or cropped, only added to the database and written to the designated uploadfs folder.

The second default object is very similar, but for the `name` key it takes a value of `office`, indicating that these file types can be attached to `@apostrophecms/file` pieces and should not be processed. Again, the `extensions` key takes an array of non-prefixed strings indicating the allowed file types. The `extensionMaps` maps alternative spellings to the specified extension.

### `addFileGroups`

This option should be passed to the `@apostrophecms/attachment` module and it takes an array of objects. This option allows you to specify new `fileGroups` containing allowed extensions for use in the `attachment` schema field. Passing this option an object with the same `name` property as an existing file group will merge the `extensions` and `extensionMaps` with the existing group.

A new extension can be added to the existing groups, either `office` or `image` by setting the object `name` property to the same value as the group you want to add the extension into.

### Example

<AposCodeBlock>

```javascript
module.exports= {
  options: {
    addFileGroups: [
      // adds tif extension to the 'images' group
      {
        name: 'images',
        extensions: [
          'tif'
        ],
        extensionMaps: {
          tiff: 'tif'
        }
      }
    ]
  }
};
```

<template v-slot:caption>
  modules/@apostrophecms/attachment/index.js
</template>

</AposCodeBlock>

In addition to `name`, the object can have both `extensions` and `extensionMaps` properties that take values just like the properties in the `fileGroups` options. Both are optional, you only are required to supply one, but can supply both.

The `addFileGroups` option can also be used to add a new grouping without eliminating the existing groups. This is accomplished through the addition of a new object containing `name`, `label`, `extensions` and `extensionMaps` properties. All are required.

### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    addFileGroups: [
      {
        name: 'logfiles',
        extensions: [
          'etl',
          'evt',
          'evtx'
        ],
        extensionMaps: {}
      }
    ]
  }
};
```

<template v-slot:caption>
  modules/@apostrophecms/attachment/index.js
</template>

</AposCodeBlock>

This example will make a new group, `logfiles`, but leave the `images` and `office` groups unaltered. This new group will be available to use in the `attachment` field `fileGroup` setting.

::: info
A single `addFileGroups` option can be used to both alter existing groups and add new groups by passing multiple objects in the array.

## Configuration

|  Property | Type | Description |
|---|---|---|
| [`imageSizes`](#imagesizes) | Object | Takes an object with `add` and `remove` properties to change the image sizes created upon image import. |

### `imageSizes`
This configuration setting should be passed to the `@apostrophecms/attachment` module. It gets passed as a top-level property, not within the `options` property. By default it is assigned an array containing six image size objects. Each of these objects has a `name`, `width`, and `height` property. The `width` and `height` values are unitless. The default sizes are:

```javascript
  imageSizes: {
    add: {
      max: {
        width: 1600,
        height: 1600
      },
      full: {
        width: 1140,
        height: 1140
      },
      'two-thirds': {
        width: 760,
        height: 760
      },
      'one-half': {
        width: 570,
        height: 700
      },
      'one-third': {
        width: 380,
        height: 700
      },
      'one-sixth': {
        width: 190,
        height: 350
      }
    }
  ```
  
Additional sizes can be added through an object composed of size objects containing `name`, `width`, and `height` properties. This object is passed as value to the `add` key of `imageSizes`. Default sizes can be removed by passing an array containing their names to the `remove` key of `imageSizes`.

::: info
The Apostrophe admin UI may display various sizes to help you manage your images, so remove sizes with care.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  imageSizes: {
    add: {
      mini: {
        width: 200,
        height: 200
      }
    },
    remove: ['one-half']
  },
};
```
<template v-slot:caption>
  modules/@apostrophecms/attachment/index.js
</template>
</AposCodeBlock>

## Featured methods

### `checkExtension(field, attachment)`
This method checks whether the supplied attachment file extension is allowed by a particular schema field. It will return `null` if the attachment file extension is allowed, an array of file extensions that are allowed if it is not, or an empty array if it is not allowed and the allowed extensions are not known.

The `field` parameter takes an object and informs the method what file extensions are allowed. To greenlist extensions by [fileGroup](#filegroups), `field.fileGroups` or `field.fileGroup` take a string, array, or object. The `attachment.group` key value will be checked against the passed value.To greenlist by `attachment.extension`, `field.extensions` or `field.extension` take a string, array, or object. The `attachment.extension` key value will be checked against the passed value.

### `insert(req, file, options)`
This method inserts the supplied file as an Apostrophe attachment. It returns `attachment` where `attachment` is an attachment object that can be passed to the [`url()` method](#urlmethod), or used for the value of a `type: 'attachment'` schema field.

The `file` parameter accepts an object with `name` and `path` properties. The `name` should be set to the name of the file, while the `path` should be the actual full path to the file on disk. This is designed to work well with the [`connect-multiparty`](https://www.npmjs.com/package/connect-multiparty) npm module, which is used as middleware by the upload route of this module. But you can also use it to copy files into uploadfs as part of a command line task or other server-side logic.

The `options` parameter is optional. If `options.permissions` is explicitly set to `false` then permissions are not checked.

### `crop(req, _id, crop)`
This method takes the image specified by the `_id` of an existing attachment, copies it to the uploadfs specified temporary location, applies the crop, and then saves it back into uploadfs storage. The `crop` parameter takes an object with `top`, `left`, `width`, and `height` properties. The passed values should be unitless, but must be JavaScript numbers, not strings.

### `addFileGroup(group)`
This method takes an object specifying either a new file group or that extends an existing group. For new file groups the object should have `name`, `extensions`, and `extensionMaps` properties that are set-up like the objects passed through array to the `fileGroups` option of this module.

To extend an existing file group the object should have a `name` property matching the `name` value of an existing file group (`office` or `images`, by default). The object should also have an `extensions` property, `extensionMaps` property, or both. These properties are structured like the properties of the same name in the `fileGroups` objects.


## Template helpers

Template helpers are methods available for use in template files. Because this module has an alias, you can call these in templates using the alias path.  For example, `apos.attachment.getWidth(attachment)`.

### `all(within, options)`
This helper finds all attachments referenced within a document, whether they are properties or sub-properties. It returns an array of attachment objects, or an empty array. Content found in the alt text, credit and credit url fields for image attachments will be returned, respectively,  in the `_alt`, `_credit`, and `_creditUrl` properties of the attachment object. Note: `apos.image.all(within, options)` is a wrapper for this helper that will automatically return only image attachments.

The `within` parameter is required and specifies the object to be searched. In general, the passed document should be the minimum necessary. So for example, use `data.piece._people` instead of `page.body`.

The `options` parameter is optional and takes an object with several potential properties.

`options.group` takes the `name` of the specific [`fileGroup`](#filegroup) to be searched - usually either `images` or `office`. 

`options.extension` takes a single extension type as a non-prefixed string and filters the returned array to only include those types.

`option.extensions` takes an array of non-prefixed strings used to filter the results.

`options.annotate` takes a boolean value. If set to true, it will add a `_urls` property to any image attachment objects in the returned array. The image `_urls` property contains sub-properties named for each image name size with the URL as a string value. The `_urls` will also contain an `uncropped` property with sub-properties named for each image name size and the URL as value. For non-image files, `annotate: true` will add a `_url` property to the object in the returned array with the URL of the attachment as value.

<AposCodeBlock>

``` nunjucks
{% if data.page._people %}
  {% set images = apos.attachment.all(data.page._people, { group: 'images' }) %}
  {% for selfie in images %}
    <img src="{{ selfie._urls['one-third'] }}">
  {% endfor %}
{% endif %}
```

<template v-slot:caption>
  modules/default-page/views/page.html
  </template>
</AposCodeBlock>

### `first`(within, options)
This helper finds the first attachment referenced within a document, whether it is a property or sub-property. It returns an object, or undefined if no attachments are found.  Content found in the alt text, credit and credit url fields for image attachments will be returned, respectively,  in the `_alt`, `_credit`, and `_creditUrl` properties of the attachment object. Note: `apos.image.first(within, options)` is a wrapper for this and will automatically return only image attachments.

The `within` parameter is required and specifies the object to be searched. In general, the passed document should be the minimum necessary. So for example, use `data.piece._people` instead of `page.body`.

The `options` parameter is optional and takes an object with several potential properties.

`options.group` takes the `name` of the specific [`fileGroup`](#filegroup) to be searched - usually either `images` or `office`. 

`options.extension` takes a single extension type as a non-prefixed string and filters the returned array to only include those types.

`option.extensions` takes an array of non-prefixed strings used to filter the results.

`options.annotate` takes a boolean value. If set to true, it will add a `_urls` property to any image attachment objects in the returned array. The image `_urls` property contains sub-properties named for each image name size with the URL as a string value. The `_urls` will also contain an `uncropped` property with sub-properties named for each image name size and the URL as value. For non-image files, `annotate: true` will add a `_url` property to the object in the returned array with the URL of the attachment as value.

<AposCodeBlock>

``` nunjucks
{% if data.page._people %}
  {% set image = apos.attachment.first(data.page._people, { group: 'images' }) %}
   <img src="{{ image._urls['one-third'] }}">
{% endif %}
```
<template v-slot:caption>
  modules/default-page/views/page.html
  </template>
</AposCodeBlock>


### `focalPointToObjectPosition(attachment)`
If the attachment has a focal point defined, this helper will return the focal point position converted to CSS syntax for `object-position` as a string with coordinates as percentages. This string does not have an `;` appended, so it must be added. If no focal point is set for the attachment it returns `center center`.

<AposCodeBlock>

``` nunjucks
{% if data.page._people %}
  {% set image = apos.attachment.first(data.page._people, { group: 'images' }) %}
  {% set focalPoint = apos.attachment.focalPointToObjectPosition(image) %}
   // focal point = '20% 20%'  
  <img src="{{ image._urls['one-third'] }}" style="object-position: {{ focalPoint }};">
{% endif %}
```
<template v-slot:caption>
  modules/default-page/views/page.html
  </template>
</AposCodeBlock>

### `getFocalPoint(attachment)`
If the attachment has a focal point defined, this helper will return an object containing an `x` property with the x-postition, and `y` property with the y-position, as percentages. The numbers are supplied unitless. If there is no focal point defined it returns null.

<AposCodeBlock>

``` nunjucks
{% if data.page._people %}
  {% set image = apos.attachment.first(data.page._people, { group: 'images' }) %}
  {% set focalPoint = apos.attachment.getFocalPoint(image) %}
   // focal point = '{ x: 20, y: 20 }'  
  <img src="{{ image._urls['one-third'] }}" style="object-position: left {{ focalPoint.x }}% top {{ focalPoint.y }}%;">
{% endif %}
```
<template v-slot:caption>
  modules/default-page/views/page.html
  </template>
</AposCodeBlock>

### `getHeight(attachment)`
Returns either the original size attachment height, or the cropped height if the image has been cropped in the document.

<AposCodeBlock>

``` nunjucks
{% if data.page._people %}
  {% set image = apos.attachment.first(data.page._people, { group: 'images' }) %}
  {% set imageHeight = apos.attachment.getHeight(image) %}  <img src="{{ image._urls['one-third'] }}" height="{{ imageHeight }}" >
{% endif %}
```
<template v-slot:caption>
  modules/default-page/views/page.html
  </template>
</AposCodeBlock>

### `getWidth(attachment)`
Returns either the original size attachment width or the cropped width if the image has been cropped in the document.

<AposCodeBlock>

``` nunjucks
{% if data.page._people %}
  {% set image = apos.attachment.first(data.page._people, { group: 'images' }) %}
  {% set imageWidth = apos.attachment.getWidth(image) %}
  <img src="{{ image._urls['one-third'] }}" width="{{ imageWidth }}" >
{% endif %}
```
<template v-slot:caption>
  modules/default-page/views/page.html
  </template>
</AposCodeBlock>

### `hasFocalPoint(attachment)`
Returns `true` if the image attachment associated with the document has a focal point set.

<AposCodeBlock>

``` nunjucks
{% if data.page._people %}
  {% set image = apos.attachment.first(data.page._people, { group: 'images' }) %}
  {% if hasFocalPoint(image) %}
    {% set focalPoint = apos.attachment.focalPointToObjectPosition(image) %}
    <img src="{{ image._urls['one-third'] }}" style="object-position: {{ focalPoint }};">
  {% endif %}
{% endif %}
```
<template v-slot:caption>
  modules/default-page/views/page.html
  </template>
</AposCodeBlock>

### `isCroppable(attachment)`
Checks the attachment extension against the `fileGroups` option to determine if the attachment can be cropped.

### `url(attachment, options)`<a name="urlmethod"></a>
Returns the URL of the passed attachment. If `options.size` is set to the name of an existing size, it will return the URL for that size. `options.full` will return the URL for the "full width" (1140px, by default), not the original. For the original, pass `original` as the `size` value. By default the full size is returned. if `options.uploadfsPath` is `true`, the uploadfs path will be returned.

## Module tasks

### `rescale`
This method will regenerate all sizes of all image attachments. This is useful after a new sizes is added to the configuration. Note: this might take a considerable amount of time.

Usage
```bash
node app @apostrophecms/attachment:rescale
```

## Selected `@apostrophecms/uploadfs` module settings<a name="selecteduploadfssettings"></a>

These options should be added to the `modules/@apostrophecms/uploadfs/index.js` file inside the `uploadfs` option. See the [`@apostrophecms/uploadfs` reference page](/reference/modules/uploadfs.html) for the remainder of the module options and settings.

|  Property | Type | Description |
|---|---|---|
| [`copyOriginal`](#copyoriginal) | Boolean | Undefined by default. If set to `false` the original image will not be copied to the database, only scaled images. |
| [`image`](#image) | String \|\| Object | Sets the image processor to 'sharp' (by default), 'imagemagick, or a custom processor passed in an object. |
| `orientOriginals` | Boolean | Unless set to `false`, the uploaded image will be reoriented according to header data. |
| [`postprocessors`](#postprocessors) | Array | Takes an array of objects detailing optional postprocessors for images. |
| `scaledJpegQuality` | Integer | Sets the JPEG quality setting for scaled images - defaults to 80. |
| `sizeAvailableInArchive` | String | Takes the name of a size to make available even if the document is archived. Defaults to 'one-sixth'. |

### `copyOriginal`

This setting should be passed to the `@apostrophecms/uploadfs` module. By default, the `copyOriginal` value is undefined, resulting in storage of the original image in the database. Explicitly setting this to `false` will block this behavior. This option is ignored for non-image files.

### `image`
This setting should be passed to the `@apostrophecms/uploadfs` module. The 'image' setting defaults to 'sharp' and using the built-in [sharp.js](https://www.npmjs.com/package/sharp) image processor. This property also accepts `imagemagick` if it has been installed or an object specifying a custom processor. See the `uploadfs` npm module [`sharp.js`](https://github.com/apostrophecms/uploadfs/blob/main/lib/image/sharp.js) file for example.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    uploadfs: {
      copyOriginal: false
    }
  }
};
```
<template v-slot:caption>
  module/@apostrophecms/uploadfs/index.js
</template>

</AposCodeBlock>

### `postprocessors`
This setting should be passed to the `@apostrophecms/uploadfs` module. It is possible to configure `uploadfs` to run a postprocessor on every custom-sized image that it generates. This is intended for file size optimization tools like `imagemin`.

Here is an example based on the `imagemin` documentation:

<AposCodeBlock>

```javascript
const imagemin = require('imagemin');
const imageminJpegtran = require('imagemin-jpegtran');
const imageminPngquant = require('imagemin-pngquant');

uploadfs({
  storage: 'local',
  image: 'sharp',
  postprocessors: [
    {
      postprocessor: imagemin,
      extensions: [ 'gif', 'jpg', 'png' ],
      options: {
        plugins: [
          imageminJpegtran(),
          imageminPngquant({quality: '0.3-0.8'})
        ]
      }
    }
  ]
});
```

  <template v-slot:caption>
    modules/@apostrophecms/uploadfs/index.js
  </template>
</AposCodeBlock>

## Related documentation

- [Attachment schema field](/reference/field-types/attachment.md#attachment)
- [API attachment response](/reference/api/field-formats.md#attachment)
- [API crop endpoint](/reference/api/media.md#post-api-v1-apostrophecms-attachment-crop)
- [API upload endpoint](/reference/api/media.md#post-api-v1-apostrophecms-attachment-upload)

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/cache
DOC_PATH: reference/modules/cache.md
URL: https://apostrophecms.com/docs/reference/modules/cache
================================================================================
# `@apostrophecms/cache`

**Alias:** `apos.cache`

<AposRefExtends :module="$frontmatter.extends" />

The `@apostrophecms/cache` module is a general-purpose cache implementation for improved performance in all areas where results can be retained and reused temporarily. Any number of namespaces can be used to separately maintain data. It is powered by a MongoDB collection.

## Methods

### `async set(namespace, key, value, lifetime)`
The `set()` method is asynchronous and should be called with an await to insure that any data is cached prior to trying to retrieve it. The method takes four parameters. The first, `namespace`, takes a string and is used to prevent collisions between keys when caching unrelated data. The `key` parameter takes a string and is the identifier that can be used to retrieve the item to be stored. The `value` parameter takes any JSON-friendly value and does not need to be stringified. The optional `lifetime` parameter takes the number of seconds for the value to exist as an integer. If set to zero or unspecified then there won't be an expiration time. However, the cache should not be used for primary storage as it could be cleared at any time, partially cleared to free space, et cetera.

#### Example

```javascript
‚Ä¶
const url = `http://api.weatherapi.com/v1/forecast.json?q=${zipCode}`;
// Check the cache for the data we want
let weatherData = await self.apos.cache.get('weatherApi', zipCode);
if (!weatherData) {
  // The data wasn't cached, so let's get it the hard way
  const response = await fetch(url, {options});
  weatherData = await response.json();
  // let's cache for an hour = 60 seconds * 60 minutes = 3600
  await self.apos.cache.set('weatherApi', zipCode, weatherData, 3600);
}
// Now we can use the data
‚Ä¶
```

### `async get(namespace, key)`
The `get()` method is asynchronous and should be called with await. It allows you to retrieve a value that was previously added to the database by the `set()` method. The retrieved value is specified by the same `namespace` string and `key` string used in the `set()` method. This method returns the cached value or `undefined` if the specified key does not exist in the specified namespace.

#### Example

```javascript
‚Ä¶
// Check the cache for the data we want
const url = `http://api.weatherapi.com/v1/forecast.json?q=${zipCode}`;
// Check the cache for the data we want
let weatherData = await self.apos.cache.get('weatherApi', zipCode);
if (!weatherData) {
  // The data wasn't cached, so let's get it the hard way
  const response = await fetch(url, {options});
  weatherData = await response.json();
  // let's cache for an hour = 60 seconds * 60 minutes = 3600
  await self.apos.cache.set('weatherApi', zipCode, weatherData, 3600);
}
// Now we can use the data
‚Ä¶
```

### `async clear(namespace)`
The `clear()` method is an asynchronous method and should be called with await. The method clears all keys that were set with the same `namespace` argument.

::: info
This method clears an entire namespace. To overwrite a single key's value, just call the `set()` method again.

### `async delete(namespace, key)`
The `delete()` method is asynchronous and should be called with await. The method allows the removal of a single `key` from the specified `namespace`.

## Module tasks

### `clear-cache <namespace(s)>`
This CLI task will clear all of the values in the supplied namespace(s).

Full command: `node app @apostrophecms/cache:clear-cache namespace1 namespace2`

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/db
DOC_PATH: reference/modules/db.md
URL: https://apostrophecms.com/docs/reference/modules/db
================================================================================
# `@apostrophecms/db`

<AposRefExtends :module="$frontmatter.extends" />

This module establishes `apos.db`, the MongoDB driver database object.

::: info
`apos.db` is the MongoDB database object, not an alias to this module. You shouldn't need to talk to this module after startup, but you can access it as `apos.modules['@apostrophecms/db']` if needed. You can also access `apos.dbClient` if you need the MongoClient object.

## Options

|  Property | Type | Description |
|---|---|---|
|`uri` | String | The MongoDB connection URI. See the [MongoDB URI documentation](https://docs.mongodb.com/manual/reference/connection-string/). |
|`connect` | Object | If present, this object is passed on as options to MongoDB's "connect" method, along with the uri. See the [MongoDB connect settings documentation](http://mongodb.github.io/node-mongodb-native/2.2/reference/connecting/connection-settings/). |
|`user` | String | Used to construct a database URI (with the `password` option) if the `uri` option is not used. |
|`password` | String |  Used to construct a database URI (with the `user` option) if the `uri` option is not used. |
|`host` | String | A hostname to use in the database URI if the `uri` option is not used. This falls back to `localhost`. |
|`port` | Integer | A port to use in the database URI if the `uri` option is not used. This falls back to `27017`. |
|`name` | String | The project's database name. This falls back to the project [shortname](/reference/glossary.md#shortname). |
|`client` | String |An existing MongoDB connection (MongoClient) object. If present, it is used and `uri`, `host`, `connect`, etc. are ignored. |
|`versionCheck` | Boolean | If `true`, Apostrophe checks the database and exits if it belongs to an older, incompatible major version of Apostrophe. Defaults to `true`. Set to `false` to avoid an extra query at startup. |

::: info
In addition to the `uri` option and the `host`, `port`, and other options that build a MongoDB connection URI, we can pass a connection URI using the `APOS_MONGODB_URI` environment variable.

```bash
APOS_MONGODB_URI=mongodb://db_user:D1fficultP%40ssw0rd@mongodb0.example.com:27017/?authSource=apos-site-db node app
```

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/db/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

Because this module has an alias, you can call these from another module from the alias path. For example, `self.apos.db.connectToMongo()`.

### `connectToMongo()`

Open the database connection. Always uses `mongo.MongoClient` with its sensible defaults. Build a URI if necessary, so we can call it in a consistent way. One default we override: if the connection is lost, we keep attempting to reconnect forever. This is sensible behavior for a persistent process that requires MongoDB in order to operate.

If you need to change the way MongoDB connections are made, override `connectToMongo` in your project. In many cases it is easier to just use the `client` option.

## Module tasks

### `reset`

Full command: `node app @apostrophecms/db:reset`

This task command fully resets the database. It drops *all* collections (other than system collections) and **destroys *all* project content**. Useful in local development. Very terrible in production.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/doc-type
DOC_PATH: reference/modules/doc-type.md
URL: https://apostrophecms.com/docs/reference/modules/doc-type
================================================================================
# `@apostrophecms/doc-type`

<AposRefExtends :module="$frontmatter.extends" />

This module establishes the basic structure and functionality for all content documents, including pages and pieces. More specifically, it is the foundation for piece *types* and page *types*. The features below are available on all piece and page types except where they are overridden in the `@apostrophecms/piece-type` and `@apostrophecms/page-type` modules.

This module is almost never configured or extended directly in Apostrophe projects. The only reason to configure this module directly would be to apply the changes to *every* page type and piece type, including those Apostrophe core (e.g., `@apostrophecms/user`, `@apostrophecms/home-page`). Project-level doc types should extend either `@apostrophecms/piece-type` or `@apostrophecms/page-type` instead.

## Options

|  Property | Type | Description |
|---|---|---|
| [`relatedDocument`](#relateddocument) | Boolean | Assign `true` on a doc-type module (almost always pieces) for those docs to be considered "related documents" in localization. |
| `slugPrefix` | String | A string Apostrophe should prepend to all slugs for a doc type. Only applicable to piece-type modules. |

### `relatedDocument`

When editors localize content, syncing it from one locale to other locales, there is an option to also localize "related documents" (docs connected through [relationship fields](/guide/relationships.md)). If this option is `true`, the type is selected by default for localization when related to a piece or page being localized. This is the default setting for `@apostrophecms/image` and `@apostrophecms/file`.

If this option is `null`, the type is offered for localization when related to a piece or page being localized, but not selected by default. This is the default setting for all other piece types.

If this option is `false`, the type is *never* offered for localization when related to a piece or page being localized. This is the default setting for `@apostrophecms/page-type`.

### `slugPrefix`

Document slugs, the `slug` property of content documents, must be unique within a database. Apostrophe will enforce this by adding numbers to the end of a duplicate slug when needed (e.g., `some-slug-0`). Registering a prefix for a piece type's slugs with `slugPrefix` is another way to prevent duplicate slugs across different piece types and also avoid the appended numbers. This should not be used for page types.

For example, the `@apostrophecms/image` module uses the `image-` slug prefix. Image document slugs are not as important as event slugs, so adding the prefix prevents an image from reserving a slug both might have used. An image with filename `2021-company-retreat.jpg` would otherwise have tried to have the same auto-generated slug as an event titled "2021 Company Retreat."

#### Example

<AposCodeBlock>

  ```javascript
  module.exports = {
    extend: '@apostrophecms/piece-type',
    options: {
      slugPrefix: 'pub-'
    },
    // ...
  }
  ```
  <template v-slot:caption>
    modules/publication/index.js
  </template>
</AposCodeBlock>

## Related documentation

- [Content document definition](/reference/glossary.md#doc)

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/doc-type/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

This module is meant as a base class for more specific content modules. As such, the methods should be used from those content modules, not directly from this one.

### `allowedSchema(req)`

Returns a new version of the doc type's schema containing only fields that the current user (`req.user`) has permission to edit.

### `async convert(req, input, doc, options)`

Process untrusted data supplied in an `input` object using the doc type's schema and update the `doc` object accordingly. This does not save anything to the database by itself.

If `options.presentFieldsOnly` is `true`, only fields that exist in `input` are affected. The default is `false`, which applies default values to any fields not already in `input`. To intentionally erase a field's contents when this option is present, use `null` for that input field or another representation appropriate to the type (an empty string for a string field).

If `options.copyingId` is present and assigned to a document `_id`, the doc with the given ID is fetched and used as the default values for any schema fields not defined in `input`. This overrides `presentFieldsOnly` as long as the fields in question exist in the doc being copied. The `_id` of the copied doc is added as the `copyOfId` property of the `doc` object.

### `fieldsPresent(input)`

Returns an array with the names of all doc type schema fields present in the `input` object.

### `async find(req, criteria, builders)`

The `find()` method initiates a database query. Learn more about initiating queries [in the database query guide](/guide/database-queries.md#initiating-the-database-query). This method takes three arguments:

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `criteria` | Object | A [MongoDB criteria object](https://docs.mongodb.com/manual/tutorial/query-documents/). It is often as simple as properties that match schema field names assigned to the desired value. |
| `builders` | Object | The builders object is converted to matching [query builders](/reference/query-builders.md). |

### `findForEditing(req, criteria, builders)`

Returns a query that finds documents the current user (based on the `req` request object) can edit. Unlike `find()`, this query defaults to including docs in the archive.

`criteria` is a MongoDB criteria object as in `find()`. The `builders` argument is a convenient way to apply many [query builder methods](http://localhost:4173/docs/guide/database-queries.html#using-query-builders) without making chained method calls. Note that the `builders` argument is assumed to be trustworthy, e.g. coming from developer-configured options. To invoke builders with untrusted user input, chain the `.applyBuilders(builders)` method after `findForEditing` instead.

### `async findOneForEditing(req, criteria, builders)`

`findOneForEditing()` is wrapper for `findForEditing()` that returns a single document matching the arguments, not simply a query.

### `inferIdLocaleAndMode(req, _id)`

This method is a wrapper for the `@apostrophecms/i18n` module [method of the same name](/reference/modules/i18n.md#inferidlocaleandmode-req-id). If the doc type is a piece type that is not localized, this will simply return the `_id`.

### `async isModified(req, doc)`

Returns `true` if the provided draft (`doc`) has been modified from the published version of the same document. If the draft has no published version it is always considered modified.

For convenience, you may also pass the published document version as `doc`. In this case the draft version is found and compared to the provided published version.

### `newInstance()`

This method returns an new document object with appropriate default values for the doc type's schema fields. This is useful as a starting point for programmatically constructed documents.

### `async publish(req, draft, options)`

When passed a `req` object and *draft* document object (`draft`), this method will publish the draft. This replaces an existing published version of the document, if there is one. It returns the draft doc with the `lastPublishedAt` and `modified` properties updated.

If `options.permissions` is explicitly set to `false`, permissions checks are bypassed. If `options.autopublishing` is true, then the `edit` permission is sufficient, otherwise the `publish` permission is checked for.

### `async revertDraftToPublished(req, draft, options)`

Reverts the given draft document (`draft`) to the most recent publication, clearing any changes. It returns the draft's new value, or `false` if the draft was not modified from the published version or no published version exists yet.

If the `options` object contains an `overrides` object, properties of the `overrides` object will be applied to the draft document before it is updated in the database.

Emits the [`afterRevertDraftToPublished` event](/reference/server-events.md#afterrevertdrafttopublished) before returning, which includes a payload object containing the draft document.

### `async revertPublishedToPrevious(req, published)`

Reverts a published document (`published`) to the previous published state and returns the updated published state. If this was already done (only one previous state is saved) or there is no previous publication, it throws an `invalid` exception.

Emits the [`afterRevertPublishedToPrevious` event](/reference/server-events.md#afterrevertpublishedtoprevious) before returning, which includes a payload object containing the published document.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/doc
DOC_PATH: reference/modules/doc.md
URL: https://apostrophecms.com/docs/reference/modules/doc
================================================================================
# `@apostrophecms/doc`

**Alias:** `apos.doc`

<AposRefExtends :module="$frontmatter.extends" />

This module is responsible for managing all documents (Apostrophe "docs") in the `aposDocs` MongoDB collection. It provides core functionality for document operations across all content types in Apostrophe.

The `getManager` method should be used to obtain a reference to the module that manages a particular doc type, allowing you to benefit from behavior specific to that module. The `apos.doc.find()` method returns a query for fetching documents of all types, which is useful when implementing features like the `@apostrophecms/search` module.

## Options

| Property | Type | Description |
|---|---|---|
| `advisoryLockTimeout` | Number | Sets the timeout (in seconds) for document advisory locks. Default is `15` seconds. |

### `advisoryLockTimeout`

Apostrophe locks documents while they are being edited to prevent conflicts when multiple users or browser tabs attempt to edit the same document simultaneously. These locks are refreshed frequently by the browser while held.

By default, if the browser is not heard from for 15 seconds, the lock expires. The browser refreshes the lock every 5 seconds under normal operation. This timeout should be kept relatively short since there is no longer a reliable way to force a browser to unlock a document when leaving the page.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    advisoryLockTimeout: 20
  }
}
```
<template v-slot:caption>
  modules/@apostrophecms/doc/index.js
</template>
</AposCodeBlock>

## Related documentation

- [Content document definition](/reference/glossary.md#doc)
- [Database query guide](/guide/database-queries.md)
- [Localization guide](/guide/localization/dynamic.md)

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/doc/index.js) for all methods that belong to this module.

### `find(req, criteria, builders)`

The `find()` method initiates a database query for documents of any type. Learn more about initiating queries [in the database query guide](/guide/database-queries.md#initiating-the-database-query). This method takes three arguments:

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `criteria` | Object | A [MongoDB criteria object](https://docs.mongodb.com/manual/tutorial/query-documents/). It is often as simple as properties that match schema field names assigned to the desired value. |
| `builders` | Object | The builders object is converted to matching [query builders](/reference/query-builders.md). |

### `getManager(type)`

Returns the module that manages documents of the given `type`. For example, `apos.doc.getManager('article')` would return the module managing article pieces. This allows you to access type-specific methods and behavior.

### `async getAposDocId({ _id, slug, locale })`

Retrieves the `aposDocId` for a document. This is the base identifier shared across all locales and modes of a document. Either `_id` or both `slug` and `locale` must be provided.

| Parameter | Type | Description |
| --------- | ---- | ----------- |
| `_id` | String | The full document `_id` (e.g., `pfh0haxfpzowht3oi213cqos:fr:draft`) |
| `slug` | String | The document slug (required if `_id` is not provided) |
| `locale` | String | The locale name (required if using `slug`) |

Returns the `aposDocId` string or throws an error if the document is not found.

### `async setAposDocId({ newId, oldId, slug, locale })`

Changes the `aposDocId` of an existing document across all modes (draft, published, and previous). This is useful for re-linking pages across locales when documents were imported rather than localized directly through Apostrophe.

| Parameter | Type | Description |
| --------- | ---- | ----------- |
| `newId` | String | The new `aposDocId` to assign (required) |
| `oldId` | String | The current `aposDocId` (required if `slug` is not provided) |
| `slug` | String | The document slug (required if `oldId` is not provided) |
| `locale` | String | The locale for which to change the `aposDocId` (required) |

Returns an object containing:
- `oldId`: The original `aposDocId`
- `newId`: The new `aposDocId`
- `locale`: The locale that was modified
- `renamed`: The number of documents that were changed

### `async getLocales(req, _id)`

Determines which locales exist for the given document `_id`. Returns an array of objects with `_id` and `aposLocale` properties for each locale version found. If the user does not have `view-draft` permission, only published versions are returned.

### `deduplicateWidgetIds(doc)`

Ensures all widgets within a document have unique `_id` values. If duplicate or missing widget IDs are found, new unique IDs are generated. This method walks through all areas in the document to check widget IDs.

## Module tasks

### `get-apos-doc-id`

Retrieves the `aposDocId` from either a full `_id` or a combination of `slug` and `locale`. The `aposDocId` is the base identifier that links all locale and mode versions of a document together.

**Usage with `_id`:**
```bash
node app @apostrophecms/doc:get-apos-doc-id --_id=pfh0haxfpzowht3oi213cqos:fr:draft
```

**Usage with slug and locale:**
```bash
node app @apostrophecms/doc:get-apos-doc-id --slug=about-us --locale=fr
```

**Options:**

| Option | Description |
|--------|-------------|
| `--_id` | The full document `_id` including locale and mode (e.g., `pfh0haxfpzowht3oi213cqos:fr:draft`) |
| `--slug` | The document slug (used with `--locale` if `--_id` is not provided) |
| `--locale` | The locale name (required when using `--slug`) |

**Output:**

The task outputs the `aposDocId` to the console. For example:
```
pfh0haxfpzowht3oi213cqos
```

**Use case:**

This task is useful when you need to find the shared identifier for documents across locales, particularly after importing content where locale relationships need to be established.

### `set-apos-doc-id`

Changes the `aposDocId` of an existing document to link it with documents in other locales. This updates the `aposDocId` across all modes (draft, published, and previous) for the specified locale.

**Usage with old ID:**
```bash
node app @apostrophecms/doc:set-apos-doc-id --new-id=tz4a98xxat96iws9zmbrgj3a --old-id=pfh0haxfpzowht3oi213cqos --locale=fr
```

**Usage with slug:**
```bash
node app @apostrophecms/doc:set-apos-doc-id --new-id=tz4a98xxat96iws9zmbrgj3a --slug=about-us --locale=fr
```

**Options:**

| Option | Description |
|--------|-------------|
| `--new-id` | The new `aposDocId` to assign (required) |
| `--old-id` | The current `aposDocId` (required if `--slug` is not provided) |
| `--slug` | The document slug (required if `--old-id` is not provided) |
| `--locale` | The locale for which to change the `aposDocId` (required) |

**Output:**

The task outputs a summary of the changes made:
```
"pfh0haxfpzowht3oi213cqos" has been changed to "tz4a98xxat96iws9zmbrgj3a" for locale "fr", 3 documents changed.
```

**Use case:**

This task is essential when pages have been imported into different locales independently rather than being localized through Apostrophe's built-in localization features. After import, you can use this task to link pages across locales by setting them to share the same `aposDocId`.

#### Example workflow for re-linking imported pages

When pages have been imported separately into multiple locales:

1. Identify corresponding pages in each locale (e.g., the "About Us" page in English and French)
2. Get the `aposDocId` of the page that should be the primary version:
   ```bash
   node app @apostrophecms/doc:get-apos-doc-id --slug=about-us --locale=en
   ```
3. Use the returned `aposDocId` to update the corresponding page in another locale:
   ```bash
   node app @apostrophecms/doc:set-apos-doc-id --new-id=<aposDocId-from-step-2> --slug=a-propos --locale=fr
   ```
4. Repeat for each locale where the page exists

After this process, all versions of the page across locales will share the same `aposDocId`, allowing Apostrophe's locale switcher and localization features to work correctly.

**Important notes:**

- This task only affects documents in the specified locale
- The new `aposDocId` should typically come from an existing document in another locale that represents the same content
- All modes (draft, published, previous) are updated together to maintain consistency
- Use with caution, as changing document identifiers can affect relationships and URL structures

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/email
DOC_PATH: reference/modules/email.md
URL: https://apostrophecms.com/docs/reference/modules/email
================================================================================
# `@apostrophecms/email`

<AposRefExtends :module="$frontmatter.extends" />

This module manages general email functionality that Apostrophe modules use. The most significant feature is the `nodemailer` option, which is used to configure the [Nodemailer](https://nodemailer.com/) third-party module.

## Options

|  Property | Type | Description |
|---|---|---|
|`from` | String | The default "from" address, either as the email address or with full name (e.g., `'"Jane Doe" <jane@doe.com>'`). |
|`nodemailer` | Object | An options object for Nodemailer. Required for sending email unless the transport is directly set on `self.transport`. It is passed to nodemailer's `createTransport` method. See the [Nodemailer](https://nodemailer.com/smtp/) documentation. |


### `nodemailer`

If using a pre-configured Nodemailer transport package that must be passed to the Nodemailer `createTransport` method (e.g., `nodemailer-mailjet-transport`, `nodemailer-mailgun-transport`), you may assign that package to the `nodemailer` option as well.

<AposCodeBlock>

  ```javascript
  const mailjetTransport = require('nodemailer-mailjet-transport');

  module.exports = {
    options: {
      from: '"Jane Doe" <jane.doe@my-website.com>',
      nodemailer: mailjetTransport({
        /// Mailjet configuration...
      })
    }
  };
  ```
  <template v-slot:caption>
    modules/@apostrophecms/email/index.js
  </template>
</AposCodeBlock>

If needed, you may assign the *fully* created transport directly to `self.transport` and omit the `nodemailer` option.

<AposCodeBlock>

  ```javascript
  const nodemailer = require('nodemailer');
  const mailjetTransport = require('nodemailer-mailjet-transport');

  module.exports = {
    init(self) {
      self.transport = nodemailer.createTransport(mailjetTransport({
        // Mailjet configuration...
      }), {
        // A full set of message defaults...
      })
    }
  };
  ```
  <template v-slot:caption>
    modules/@apostrophecms/email/index.js
  </template>
</AposCodeBlock>

## Related documentation

- [Guide to sending email from your Apostrophe project](/guide/sending-email.md)
- [The `self.email()` method in every module](/reference/modules/module.md#email-req-templatename-data-options)

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/error
DOC_PATH: reference/modules/error.md
URL: https://apostrophecms.com/docs/reference/modules/error
================================================================================
# `@apostrophecms/error`

<AposRefExtends :module="$frontmatter.extends" />

This module establishes an error method used throughout Apostrophe code to help format code errors consistently.

::: info
`apos.error` is the error construction method, not an alias to this module.

## Related documentation

- [HTTP module error codes](/reference/modules/http.md#adderrors)

## Featured methods

### `error(name, message, data)`

Returns an Error object suitable to throw. The `name` argument will
be applied to the Error object. Certain values of `name` match to certain HTTP status codes. [See the `@apostrophecms/http` module.](/reference/modules/http.md#adderrors)

`message` may be skipped completely, or included as a string for a longer description. `data` is optional and may contain data about the error, safe to share with an untrusted client.

If the error is caught by Apostrophe's [`apiRoutes`](/reference/module-api/module-overview.md#apiroutes-self), [`restApiRoutes`](/reference/module-api/module-overview.md#restapiroutes-self), and [`renderRoutes`](/reference/module-api/module-overview.md#renderroutes-self) mechanisms, and `name` matches to a status code, an appropriate HTTP error is sent. The HTTP response to the client will consist of a JSON object with `name`, `data`, and `message` properties (the latter two only if present). If the `name` argument does not match a code, a general 500 error is sent to avoid disclosing inappropriate information and the error is only logged by Apostrophe server-side.

``` json
{
  "name": "invalid",
  "data": {},
  "message": "Your credentials are incorrect, or there is no such user"
}
```

For brevity, this method is aliased as `apos.error`.

<AposCodeBlock>

  ```javascript
  module.exports = {
    // ...
    apiRoutes(self) {
      return {
        post: {
          async newest(req) {
            const product = await self.find(req).sort({
              createdAt: -1
            }).toObject();

            if (!product) {
              // üëá Throwing an error with the error method.
              throw self.apos.error('notfound', 'No products were found.');
            }

            return { product };
          }
        }
      };
    }
  };
  ```
  <template v-slot:caption>
    modules/product/index.js
  </template>
</AposCodeBlock>

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/express
DOC_PATH: reference/modules/express.md
URL: https://apostrophecms.com/docs/reference/modules/express
================================================================================
# `@apostrophecms/express`

<AposRefExtends :module="$frontmatter.extends" />

This module initializes the Express framework, which Apostrophe uses and extends to implement both API routes and page-serving routes. The Express `app` object is made available as `apos.app`, and the `express` object itself as `apos.express`. This module also adds a number of standard middleware functions and implements the server side of CSRF protection for Apostrophe.

## Options

|  Property | Type | Description |
|---|---|---|
|`address` | String | Apostrophe listens for connections on all interfaces (`0.0.0.0`) unless this option is set to another address. If the `ADDRESS` environment variable is set, it is used instead. |
|`apiKeys` | Object | Configure API keys for request authentication. See [the authentication guide](/reference/api/authentication.md#api-keys) for more. |
|`bodyParser` | Object | The `json` and `urlencoded` properties of this object are merged with Apostrophe's default options to be passed to the [`body-parser` npm module's](https://www.npmjs.com/package/body-parser) `json` and `urlencoded` methods. |
|`csrf` | Boolean/Object | Set to `false` to disable CSRF protection or to an object with a `name` property to customize the CSRF cookie name. See below. |
|`expressBearerToken` | Object | An options object passed to [`express-bearer-token`](https://www.npmjs.com/package/express-bearer-token) for the bearer token middleware. |
|`port` | Integer | Apostrophe listens for connections on port `3000` unless this option is set to another port. If the `PORT` environment variable is set, it is used instead. |
|`session` | Object | Properties of the `session` option are used to create the session middleware. See below. |
|`trustProxy` | Boolean | Enables the [trust proxy option for Express](https://expressjs.com/en/api.html#trust.proxy.options.table). Set to `true` to tell the Express app to  respect `X-Forwarded-* ` headers. This is helpful when Apostrophe is generating `http:` URLs even though a proxy like nginx is being used to serve it over `https:`. |
|`enableCacheOnDemand` | Boolean | Set to `false` to disable cache on demand. [See documentation](/guide/caching.html#express-cache-on-demand). |

### `session`

The `session` options object is passed to the
[express-session](https://npmjs.org/package/express-session) function. If each is not otherwise specified, Apostrophe enables the following defaults:

```javascript
{
  // Does not save sessions until something is stored in them. This greatly
  // reduces `aposSessions` collection size.
  saveUninitialized: false,
  // We are using the 3.x mongo store which is compatible with the
  // `resave: false` option, preventing the vast majority of session-related
  // race conditions.
  resave: false,
  // Always update the cookie, so that each successive access revives your
  // login session timeout.
  rolling: true,
  // This option should be customized in every project.
  secret: 'you should have a secret',
  name: self.apos.shortName + '.sid',
  cookie: {}
}
```

By default Apostrophe stores sessions in MongoDB so it is not necessary to install another solution. If you want to use another session store, you can pass an instance as the store sub-option, but it's easier to let Apostrophe do the work of setting it up:

<AposCodeBlock>

  ```javascript
  module.exports = {
    options: {
      session: {
        store: {
          name: 'connect-redis',
          options: {
            // redis-specific options here
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/express/index.js
  </template>
</AposCodeBlock>

Be sure to install `connect-redis`, or the store of your choice, as an npm dependency of your project.

### `csrf`

By default, Apostrophe implements [CSRF protection](https://en.wikipedia.org/wiki/Cross-site_request_forgery) via an `XSRF-TOKEN` cookie. All non-safe HTTP requests (not `GET`, `HEAD`, `OPTIONS` or `TRACE`) automatically receive protection via CSRF middleware, which rejects requests in which the CSRF token does not match the header. *If the request was made with a valid API key or bearer token it bypasses this check.*

If the `csrf` option is set to `false`, CSRF protection is disabled. **This is not recommended.** Set this option to an object with a `name` property to set that property's value as the CSRF cookie name.

You can configure exceptions to CSRF protection by setting the [`csrfExceptions` option](/reference/module-api/module-options.md#csrfexceptions) of any module to an array of route names specific to that module, or URLs (starting with `/`). Exceptions may use [Minimatch](https://github.com/isaacs/minimatch) wildcards (`*` and `**`).

You may need to use this feature when implementing `POST` form submissions that do not send the header.

## Environment variables

### `APOS_LOG_ALL_ROUTES`

If `APOS_LOG_ALL_ROUTES` is a nonempty string, Apostrophe will log the journey of each request through various middleware functions, often ending in a route. These messages appear on the server console. This is helpful when a URL does not seem to reach the intended [API route](../module-api/module-overview.md#restapiroutes-self).

Note that not every request ends in a route, as it is possible for middleware to redirect a request or send a response on its own.

## Related documentation

- [Custom express routes](/reference/module-api/module-overview.md#routes-self)
- [Authentication with API keys](/reference/api/authentication.md#api-keys)

## Featured methods

This module's methods are used to generate the Express app. Customization should be done using the options described above. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/express/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

## Module tasks

### `list-routes`

Full command: `node app @apostrophecms/express:list-routes`

As a debugging convenience, this task command lists all routes that ApostropheCMS added to Express via the `routes`, `apiRoutes`, `restApiRoutes` and `renderRoutes` module sections. This command currently does not list routes added to Express directly via `apos.app`, such as the `*` wildcard route for pages, although these may be included in the future.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/global
DOC_PATH: reference/modules/global.md
URL: https://apostrophecms.com/docs/reference/modules/global
================================================================================
# `@apostrophecms/global`

**Alias:** `apos.global`

<AposRefExtends :module="$frontmatter.extends" />

This module populates the `req.data.global` object with content or settings that are utilized site-wide. Like any core module, it comes with some built-in features, and we can add additional configuration by creating a `modules/@apostrophecms/global/index.js` file in our project. Our project-specific configuration will merge gracefully with the defaults that come with the module. New fields are added and grouped identically to any widget or pieces module. The data from these fields is available to templates as `data.global`.

::: info
`@apostrophe/global` is a piece type that only ever has one piece.

## Options
|  Property | Type | Description |
|---|---|---|
|`deferWidgetLoading` | Boolean | If set to `true`, any widget module with the option [`deferred: true`](/reference/modules/widget-type.md#deferred) will not be loaded until the end of loading the global doc. |

### `deferWidgetLoading`

If set to `true`, the `deferWidgetLoading` option reduces the number of queries required when loading the global doc. Any widget with the option `deferred: true` used on the page will not be loaded until the entire global doc is loaded.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
 options: {
   deferWidgetLoading: true
 },
 fields: {
   add: {
     githubUrl: {
       type: 'url',
       label: 'Organization GitHub url'
     },
     footerMissionStatement: {
       type: 'area',
       label: 'Footer mission statement',
       options: {
         widgets: {
           '@apostrophecms/rich-text': {}
         }
       }
     }
   }
 },
 group: {
   basics: {
     label: 'Basics',
     fields: ['githubUrl', 'footerMissionStatement']
   }
 }
};
```
<template v-slot:caption>
  modules/@apostrophecms/global/index.js
</template>
</AposCodeBlock>

## Related documentation

- [Global settings guide](/guide/global.md)

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/home-page
DOC_PATH: reference/modules/home-page.md
URL: https://apostrophecms.com/docs/reference/modules/home-page
================================================================================
# `@apostrophecms/home-page`

<AposRefExtends :module="$frontmatter.extends" />

This module sets up a page type used for the home page in the official Apostrophe starter project. It does not have any special fields or content areas by default, though the [default starter does provide some](https://github.com/apostrophecms/starter-kit-essentials/blob/main/modules/%40apostrophecms/home-page/index.js).

See [the page types guide](/guide/pages.md#activating-page-types) for information about using this and other page types.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/http
DOC_PATH: reference/modules/http.md
URL: https://apostrophecms.com/docs/reference/modules/http
================================================================================
# `@apostrophecms/http`

**Alias:** `apos.http`

<AposRefExtends :module="$frontmatter.extends" />

This module adds methods for easy HTTP requests in Apostrophe project and module server-side code. These methods are compatible with the respective [client-side HTTP methods](/guide/front-end-helpers.md#http-request-methods). It also defines error codes for use with the main `apos.error()` method.
<!-- TODO: Link to the error module reference. -->

## Options

|  Property | Type | Description |
|---|---|---|
|`addErrors` | Object | An object of error names and their associated HTTP response codes. |

### `addErrors`

<!-- TODO: Link to the error module reference. -->
This module's named errors are used in the `apos.error()` method. The default error names and their codes in Apostrophe are:
- `min`: 400
- `max`: 400
- `invalid`: 400
- `forbidden`: 403
- `notfound`: 404
- `required`: 422
- `conflict`: 409
- `locked`: 409
- `unprocessable`: 422
- `unimplemented`: 501

Unnamed errors are returned with the 500 error code, so it does not need to be registered. Additional error codes can be added with the `addErrors` option.

<AposCodeBlock>

  ```javascript
  module.exports = {
    options: {
      addErrors: {
        timeout: 408
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/http/index.js
  </template>
  
</AposCodeBlock>

## Related documentation

- [Front end HTTP helper methods](/guide/front-end-helpers.md#http-request-methods)

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/http/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

Because this module has an alias, you can call these from another module from the alias path. For example, `self.apos.http.addError()`.

### `addError(name, code)`

An alternate way to register error names to HTTP error codes. Pass the semantic name as the first argument, followed by the `code` integer. The error code number becomes the HTTP status code when the error name is used in the `self.apos.error()` method.
<!-- TODO: Link to the error module reference. -->

### `async get(url, options)`

Fetch the given URL (`url`) via a `GET` request and return the response body. If the URL is relative (starts with `/`) it will be requested from the Apostrophe site itself. This is helpful to avoid needing to construct the base URL across environments.

Accepts the following properties on the optional `options` object:

| Option | Type |Description |
| -------- | ------ | ----------- |
| `qs` | Object | An object of query parameters and values. It may contain nested objects, arrays, and properties with null values. |
| `jar` | Object | Pass in a cookie jar obtained from `apos.http.jar()`. |
| `parse` | String | Set to `json` to always parse the response body as JSON, otherwise the response body is parsed as JSON only if the `content-type` is `application/json`. |
| `headers` | Object | An object containing header names and values. |
| `fullResponse` | Boolean | If `true`, return an object with `status`, `headers` and `body` properties, rather than returning the body directly. The individual `headers` are canonicalized to lowercase names. If a header appears multiple times an array is returned for it. |

If the status code is >= 400 an error is thrown. The error object will be
similar to a `fullResponse` object, with a `status` property.

### `async head(url, options)`

Make a `HEAD` request for the given URL and return the response object,
which will include a `status` property as well as `headers`. If the URL is relative (starts with `/`) it will be requested from the Apostrophe site itself. This is helpful to avoid needing to construct the base URL across environments.

Accepts the following properties on the optional `options` object:

| Option | Type |Description |
| -------- | ------ | ----------- |
| `qs` | Object | An object of query parameters and values. It may contain nested objects, arrays, and properties with null values. |
| `jar` | Object | Pass in a cookie jar obtained from `apos.http.jar()`. |
| `headers` | Object | An object containing header names and values. |

If the status code is >= 400 an error is thrown. The error object will be
similar to a `fullResponse` object, with a `status` property.

### `async post(url, options)`

Send a `POST` request to the given URL and return the response body. If the URL is relative (starts with `/`) it will be requested from the Apostrophe site itself. This is helpful to avoid needing to construct the base URL across environments.

Accepts the following properties on the optional `options` object:

| Option | Type |Description |
| -------- | ------ | ----------- |
| `qs` | Object | An object of query parameters and values. It may contain nested objects, arrays, and properties with null values. |
| `jar` | Object | Pass in a cookie jar obtained from `apos.http.jar()`. |
| `send` | String | Can be 'json' to always send `options.body` JSON-encoded, or `form` to send it URL-encoded. |
| `body` | Variable | The request body. If an object or array, it is sent as JSON. If a [`FormData` object](https://www.npmjs.com/package/form-data), it is sent as a `multipart/form-data` upload. Otherwise it is sent as-is, unless the `send` option is set. |
| `parse` | String | Set to `json` to always parse the response body as JSON, otherwise the response body is parsed as JSON only if the `content-type` is `application/json`. |
| `headers` | Object | An object containing header names and values. |
| `csrf` | Boolean/String | If set to `true`, which is the default, and the `jar` contains the CSRF cookie for this Apostrophe site due to a previous `GET` request, send it as the X-XSRF-TOKEN header. If a string, send the current value of the cookie of that name in the `jar` as the X-XSRF-TOKEN header. If `false`, disable this feature. |
| `fullResponse` | Boolean | If `true`, return an object with `status`, `headers` and `body` properties, rather than returning the body directly. The individual `headers` are canonicalized to lowercase names. If a header appears multiple times an array is returned for it. |

If the status code is >= 400 an error is thrown. The error object will be
similar to a `fullResponse` object, with a `status` property.

### `async delete(url, options)`

Send a `DELETE` request to the given URL and return the response body. If the URL is relative (starts with `/`) it will be requested from the Apostrophe site itself. This is helpful to avoid needing to construct the base URL across environments.

Accepts the following properties on the optional `options` object:

| Option | Type |Description |
| -------- | ------ | ----------- |
| `qs` | Object | An object of query parameters and values. It may contain nested objects, arrays, and properties with null values. |
| `jar` | Object | Pass in a cookie jar obtained from `apos.http.jar()`. |
| `send` | String | Can be 'json' to always send `options.body` JSON-encoded, or `form` to send it URL-encoded. |
| `body` | Variable | The request body. If an object or array, it is sent as JSON. If a [`FormData` object](https://www.npmjs.com/package/form-data), it is sent as a `multipart/form-data` upload. Otherwise it is sent as-is, unless the `send` option is set. |
| `parse` | String | Set to `json` to always parse the response body as JSON, otherwise the response body is parsed as JSON only if the `content-type` is `application/json`. |
| `headers` | Object | An object containing header names and values. |
| `csrf` | Boolean/String | If set to `true`, which is the default, and the `jar` contains the CSRF cookie for this Apostrophe site due to a previous `GET` request, send it as the X-XSRF-TOKEN header. If a string, send the current value of the cookie of that name in the `jar` as the X-XSRF-TOKEN header. If `false`, disable this feature. |
| `fullResponse` | Boolean | If `true`, return an object with `status`, `headers` and `body` properties, rather than returning the body directly. The individual `headers` are canonicalized to lowercase names. If a header appears multiple times an array is returned for it. |

If the status code is >= 400 an error is thrown. The error object will be
similar to a `fullResponse` object, with a `status` property.

### `async put(url, options)`

Send a `PUT` request to the given URL and return the response body. If the URL is relative (starts with `/`) it will be requested from the Apostrophe site itself. This is helpful to avoid needing to construct the base URL across environments.

Accepts the following properties on the optional `options` object:

| Option | Type |Description |
| -------- | ------ | ----------- |
| `qs` | Object | An object of query parameters and values. It may contain nested objects, arrays, and properties with null values. |
| `jar` | Object | Pass in a cookie jar obtained from `apos.http.jar()`. |
| `send` | String | Can be 'json' to always send `options.body` JSON-encoded, or `form` to send it URL-encoded. |
| `body` | Variable | The request body. If an object or array, it is sent as JSON. If a [`FormData` object](https://www.npmjs.com/package/form-data), it is sent as a `multipart/form-data` upload. Otherwise it is sent as-is, unless the `send` option is set. |
| `parse` | String | Set to `json` to always parse the response body as JSON, otherwise the response body is parsed as JSON only if the `content-type` is `application/json`. |
| `headers` | Object | An object containing header names and values. |
| `csrf` | Boolean/String | If set to `true`, which is the default, and the `jar` contains the CSRF cookie for this Apostrophe site due to a previous `GET` request, send it as the X-XSRF-TOKEN header. If a string, send the current value of the cookie of that name in the `jar` as the X-XSRF-TOKEN header. If `false`, disable this feature. |
| `fullResponse` | Boolean | If `true`, return an object with `status`, `headers` and `body` properties, rather than returning the body directly. The individual `headers` are canonicalized to lowercase names. If a header appears multiple times an array is returned for it. |

If the status code is >= 400 an error is thrown. The error object will be
similar to a `fullResponse` object, with a `status` property.

### `async patch(url, options)`

Send a `PATCH` request to the given URL and return the response body. If the URL is relative (starts with `/`) it will be requested from the Apostrophe site itself. This is helpful to avoid needing to construct the base URL across environments.

Accepts the following properties on the optional `options` object:

| Option | Type |Description |
| -------- | ------ | ----------- |
| `qs` | Object | An object of query parameters and values. It may contain nested objects, arrays, and properties with null values. |
| `jar` | Object | Pass in a cookie jar obtained from `apos.http.jar()`. |
| `send` | String | Can be 'json' to always send `options.body` JSON-encoded, or `form` to send it URL-encoded. |
| `body` | Variable | The request body. If an object or array, it is sent as JSON. If a [`FormData` object](https://www.npmjs.com/package/form-data), it is sent as a `multipart/form-data` upload. Otherwise it is sent as-is, unless the `send` option is set. |
| `parse` | String | Set to `json` to always parse the response body as JSON, otherwise the response body is parsed as JSON only if the `content-type` is `application/json`. |
| `headers` | Object | An object containing header names and values. |
| `csrf` | Boolean/String | If set to `true`, which is the default, and the `jar` contains the CSRF cookie for this Apostrophe site due to a previous `GET` request, send it as the X-XSRF-TOKEN header. If a string, send the current value of the cookie of that name in the `jar` as the X-XSRF-TOKEN header. If `false`, disable this feature. |
| `fullResponse` | Boolean | If `true`, return an object with `status`, `headers` and `body` properties, rather than returning the body directly. The individual `headers` are canonicalized to lowercase names. If a header appears multiple times an array is returned for it. |

If the status code is >= 400 an error is thrown. The error object will be
similar to a `fullResponse` object, with a `status` property.

### `jar()`

This method returns a "cookie jar," a set of HTTP cookies, compatible with the `jar` option in the request methods and the `getCookie()` method. The use of other cookie stores is not recommended.

### `getCookie(jar, url, name)`

Given a cookie jar received from `apos.http.jar()` and a context URL (`url`), this returns the current value for the given cookie (`name`), or `undefined` if there is no cookie set to that name.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/i18n
DOC_PATH: reference/modules/i18n.md
URL: https://apostrophecms.com/docs/reference/modules/i18n
================================================================================
# `@apostrophecms/i18n`

**Alias:** `apos.i18n`

<AposRefExtends :module="$frontmatter.extends" />

This module governs internationalization functionality and localization tools. Apostrophe projects will configure locales through `@apostrophecms/i18n`.

The module makes an instance of the [i18next](https://npmjs.org/package/i18next) npm module available in Nunjucks templates via the `__t()` helper function. That function is also available on `req` objects as `req.t()` and in user interface Vue.js components as `this.$t()`.

`apos.i18n.i18next` can be used to directly access the `i18next` npm module instance if necessary. It usually is not necessary. Use `req.t` if you need to localize in a route.

## Options

|  Property | Type | Description |
|---|---|---|
|`defaultLocale` | String | The locale that will be used by the UI and server rendering if no other is specified. |
|[`locales`](#locales) | Object | The set of [locales](../glossary.md#locale) to use in the application. |
|`redirectToFirstLocale` | Boolean | If enabled, and all locales matching the currently requested hostname have a prefix defined, it will redirect to the locale defined first. If the request does not match any explicit hostname assigned to locales, redirects to the first locale that does not have a configured hostname. |
| [`adminLocales`](#adminlocales) | Array | The locales that can be selected by the users for the admin UI |
| `defaultAdminLocale` | String | Optionally takes the locale key for the default Admin UI language. If not present, it will default to match the locale language. Overridden by the user preferences. |
| `stripAccentsFromSlugs` | Boolean | If set to true, accents and diacritical marks will be automatically removed from slugs when they are generated. For example, "caf√©" becomes "cafe". Defaults to false to maintain backward compatibility. This setting affects all new slugs created after it is enabled. |

### `locales`

The locale object should include one or more (usually two or more) locale configuration object. Each locale key is a short code, typically a two letter country code (e.g., `ca`), language code (`fr`), or one of each with a dash separating them (`fr-CA`). This local name is used to reference the locale throughout Apostrophe.

Each locale may have the following settings:

|  Locale setting | Type | Description |
|-----|-----|-----|
| `label` | String | The human-readable label for the locale. |
| `hostname` | String | A hostname (e.g., 'example.net') that will trigger the locale to be shown. |
| `prefix` | String | A URL path prefix that will trigger the locale to be shown. |
| `private` | Boolean | Setting this to true exposes this locale to logged-in users only. |

Hostname and the path prefix are both factors in deciding what locale to display to visitors. There is prioritization that factors into identifying the correct one to use. The priority ranking for choosing the correct locale is:

1. The locale has both `hostname` and `prefix` settings and the URL matches *both* settings.
2. The URL matches the locale's configured `hostname` and the locale has no `prefix`
3. The URL matches the locale's configured `prefix` and the locale has no `hostname`.
4. The locale is the default locale (when no other locale matches).

Other notes:

- Two or more locales may not be registered with the same `hostname` *and* the same path `prefix`. Apostrophe will throw an error in this case.
- The **default locale** (either the `defaultLocale` setting or the first registered locale) does not need a `hostname` or path `prefix` setting.
- If *any* locale has a `hostname` setting *one* of these must be true:
  1. **The Apostrophe app must have a `baseUrl` set in the `data/local.js` or similiar server configuration file** (a best practice in most cases anyway) or set through the `APOS_BASE_URL` environment variable, OR
  2. **All locales must have a hostname setting** (even if several are the same, using different `prefix` settings).
- If the URL does not match any locale's set `hostname` or `prefix` (and all locales have one or both settings), Apostrophe will use the default locale.

#### Project configuration examples

<AposCodeBlock>

  ```javascript
  module.exports = {
    options: {
      defaultLocale: 'fr',
      locales: {
        fr: {
          label: 'French'
        },
        'en-CA': {
          label: 'Canada (English)',
          prefix: '/ca/en'
        },
        'fr-CA': {
          label: 'Canada (French)',
          prefix: '/ca/fr'
        },
        'es-MX': {
          label: 'Mexico',
          hostname: 'example.mx'
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    /modules/@apostrophecms/i18n/index.js
  </template>
</AposCodeBlock>

With `redirectToFirstLocale` option enabled.

In the following example, _**every** locale has a prefix_ so if we request the base URL of the site without a locale prefix (`/en` or `/us/en`) in the URL, the first locale will be taken into account (`en`) and we will be redirected to `/en`.  
Same thing if we request `example.ca` with no locale prefix, we will be redirected to `/ca/en` as it is the first locale configured with that hostname.

<AposCodeBlock>

  ```javascript
  module.exports = {
    options: {
      defaultLocale: 'en',
      redirectToFirstLocale: true,
      locales: {
        en: {
          label: 'English',
          prefix: '/en'
        },
        'en-US': {
          label: 'English',
          prefix: '/us/en'
        },
        'en-CA': {
          label: 'Canada (English)',
          prefix: '/ca/en',
          hostname: 'example.ca'
        },
        'fr-CA': {
          label: 'Canada (French)',
          prefix: '/ca/fr',
          hostname: 'example.ca'
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    /modules/@apostrophecms/i18n/index.js
  </template>
</AposCodeBlock>

### `adminLocales`

The `adminLocales` takes an array of objects. Each of the objects should have a label that is presented to the user in both the user manager editor, and in the user preferences menu. This menu can be accessed through the dropdown at the right hand side of the admin-bar menu. The objects should also have a `value` property that takes the name of one of the configured `locales` or a JSON translation file being supplied to the project.

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    defaultLocale: 'fr',
    locales: {
      fr: {
        label: 'French'
      },
      'en-CA': {
        label: 'Canada (English)',
        prefix: '/ca/en'
      },
      'fr-CA': {
        label: 'Canada (French)',
        prefix: '/ca/fr'
      },
      'es-MX': {
        label: 'Mexico',
        hostname: 'example.mx'
      }
    },
    adminLocales: [
      {
        label: 'Fran√ßais',
        value: 'fr'
      },
      {
        label: 'English',
        value: 'en-CA'
      },
      {
        label: 'Espan√µl',
        value: 'es-MX'
      }
    ]
  }
}
```

<template v-slot:caption>
  /modules/@apostrophecms/i18n/index.js
</template>
</AposCodeBlock>

## Related documentation

- [Static localization guide](/guide/localization/static.md)
- [Dynamic content localization guide](/guide/localization/dynamic.md)

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/i18n/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

### `inferIdLocaleAndMode(req, _id)`

Infer `req.locale` and `req.mode` from `_id` if they were not set already by explicit query parameters. Conversely, if the appropriate query parameters were set, rewrite `_id` accordingly. Returns `_id`, after rewriting if appropriate.

### `isValidLocale(locale)`

Given a locale name, this will return a boolean value indicating whether it is a locale configured for the Apostrophe website.

### `matchLocale(req)`

Return the best matching locale for the request based on the hostname and path prefix. If available the first locale matching both hostname and prefix is returned, otherwise the first matching locale that specifies only a hostname or only a prefix. If no matches are possible the default locale is returned.

## Module Tasks

### `rename-locale`

The `rename-locale` command moves all content from one locale name to another, using the `--old` and `--new` options. Note that the value of `--new` should match a locale name that is currently configured by the @apostrophecms/i18n module. By default, any duplicate keys for content existing in both locales will stop the process. However you can specify which content to keep in the event of a duplicate key error using the `--keep=<localename>` option where `<localname>`is either the old or new locale.

Usage: `node app @apostrophecms/i18n:rename-locale --old=de-DE --new=de-de --keep=de-de`

### `strip-accents-from-slugs`

The `strip-accents-from-slugs` command removes accents and diacritical marks from all existing slugs in the database. This is useful when you enable the `stripAccentsFromSlugs` option and want to update slugs that were created before the option was turned on.

By default, the task runs in "dry run" mode, showing you what changes would be made without actually modifying the database. To apply the changes, add the `--live` flag.

**Important:** This task will modify slugs across all content types and locales. Make sure to back up your database before running it with the `--live` flag.

Usage examples:

```bash
# Preview what changes would be made (safe, no modifications)
node app @apostrophecms/i18n:strip-accents-from-slugs

# Actually apply the changes to the database
node app @apostrophecms/i18n:strip-accents-from-slugs --live
```

The task will display each slug that would be changed (or is being changed in live mode), showing the before and after values.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/log
DOC_PATH: reference/modules/log.md
URL: https://apostrophecms.com/docs/reference/modules/log
================================================================================
# `@apostrophecms/log`

**Alias:** `apos.structuredLog`

<AposRefExtends :module="$frontmatter.extends" />

This module provides structured logging for Apostrophe projects. It intercepts the log notifications emitted by the `logDebug()`, `logInfo()`, `logWarn()`, and `logError()` methods of every Apostrophe module and creates new objects. These objects can be sent to third-party logging packages and easily filtered based on event-type and severity.

## Options

|  Property | Type | Description |
|---|---|---|
| [`logger`](#logger) | Object/Function | Optional. Used for outputting logs to third-party packages or custom logging functions. |
| [`messageAs`](#messageas) | String | Optional. If this option is set, it converts the log notification from a string and object to just an object with the `messageAs` string as a property with the notification string as value. |
| [`filter`](#filter) | Object | Optional. Takes named objects that determine what log notices are emitted |

### `logger`
The `logger` option can take an object or a function. Any passed function should take `apos` and return an object of methods. Alternatively, the object can be passed directly to `logger`. The object should include methods for `debug()`, `info()`, `warn()`, and `error()`. An example implementation of these methods can be found in the Apostrophe [`util/lib/logger.js` file](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/util/lib/logger.js). Optionally, this object can also include a `destroy()` method that will be called and awaited during the `apostrophe:destroy` event. Typically the `logger` takes a third-party logging package as value.

<AposCodeBlock>

``` javascript
const { pino } = require('pino');

module.exports = {
  options: {
    logger: pino({
      transport: {
        targets: [
          {
            // output to stdout and stderr
            level: 'debug',
            // if optional pino-pretty package installed
            target: 'pino-pretty',
            options: {}
          },
          {
            // sends error notifications to the error.log file
            level: 'error',
            target: 'pino/file',
            options: {
              destination: './error.log',
              // create the destination file if it does not exist
              mkdir: true
            }
          },
          {
            // sends all notifications to the combined.log file
            level: 'debug',
            target: 'pino/file',
            options: {
              destination: './combined.log',
              mkdir: true
            }
          }
        ]
      }
    }),
    messageAs: 'msg'
  }
};

```

<template v-slot:caption>
/modules/@apostrophecms/log/index.js
</template>
</AposCodeBlock>

### `messageAs`
Some third-party logging packages require an object for each log event. Setting the `messageAs` option to a string will convert the returned log notification from a string plus an object to an object only. The value of this option will be used as a key in the new object and the notification string will be added as value.

For example:
``` javascript
self.logError('event-type', 'notification message', { key: 'value' });
```
Will log:
``` sh
'current-module-name: event-type: notification message',
{
  type: 'event-type',
  severity: 'error',
  module: 'current-module-name',
  key: 'value'
}
```
If the `messageAs` is set to a string of `myMessage`, instead the log will return:
``` sh
{
  type: 'event-type',
  severity: 'error',
  module: 'current-module-name',
  key: 'value',
  myMessage: 'current-module-name: event-type: notification message'
}
```

The string value for `messageAs` will depend on the logging package being used. Several examples are presented in the [logging section](/guide/logging.html#popular-package-set-up) of the guide.

### `filter`
The `filter` option allows for the selection of a subset of log notifications. It takes an object of named sub-objects. The name for each of the sub-objects should either be a module name, like `@apostrophecms/login`, or an `*` wildcard to indicate that the filtering rules should apply to all modules. Each sub-object can have two properties. The `severity` key takes an array of strings for each severity level that is allowed for the named module. If using the stock log methods, valid values are `debug`, `info`, `warn`, and `error`. The `events` key takes an array of strings for event-type names that are allowed for the named module. These event-type names are passed as the first argument to the [`@apostrophecms/module`](/reference/modules/module.html) module logging methods.

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    logger: 'pino',
    messageAs: 'msg',
    filter: {
      // By module name, or *. We can specify any mix of severity levels and specific event types,
      // and entries are kept if *either* criterion is met
      '*': {
        severity: [ 'warn', 'error' ]
      },
      'apostrophecms/login': {
        events: [ 'success', 'failure' ]
      }
    }
  }
};
```

<template v-slot:caption>
modules/@apostrophecms/log/index.js
</template>
</AposCodeBlock>

These filters can also be passed through an environment variable, `APOS_FILTER_LOGS`. For example, the filters passed through this `index.js` example would be:

``` sh
export APOS_FILTER_LOGS='*:severity:warn,error;@apostrophecms/login:events:success,failure'
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/login
DOC_PATH: reference/modules/login.md
URL: https://apostrophecms.com/docs/reference/modules/login
================================================================================
# `@apostrophecms/login`

<AposRefExtends :module="$frontmatter.extends" />

This module manages Apostrophe's standard login form and related capabilities.

## Options
 
|  Property | Type | Description |
|---|---|---|
| [`loginUrl`](#loginurl) | String | Sets the login endpoint.|
|[`localLogin`](#locallogin) | Boolean | If false, the login form is disabled.|
|[`passwordReset`](#passwordreset) | Boolean | If true, a password reset link is added to the login. |
| [`passwordResetHours`](#passwordresethours) | Integer | If `passwordReset` is true it controls how many hours a reset token is valid. |
|[`bearerTokens`](#bearertokens) | Object | If set to an object, the `lifetime` subproperty determines the lifetime of a bearer token for the REST API.| 
|[`throttle`](#throttle) | Object | Used to prevent brute-force password guessing.|
| [`whoamiFields`](#whoamifields) | Array | Additional user fields to include in `whoami` API responses.|
| [`minimumWhoamiFields`](#minimumwhoamifields) | Array | Core user fields always included in `whoami` API responses.|

### `loginUrl`

The default login endpoint for access to the ApostropheCMS backend is `/login`. Passing a string to the `loginUrl` option will change this endpoint. Note that the desired endpoint should be prefixed with a forward slash, e.g. `/admin-login`.
### `localLogin`

Defaults to `true`. If set to `false`, the normal login form at `/login` is completely disabled.

### `passwordReset`

Defaults to `false`. If both `localLogin` and `passwordReset` are set to `true`, a password reset link is added to the login form. Clicking on this link brings up a form for the user to enter the email address associated with their account. The address is compared to the list of existing user emails and a reset link is sent if that email is found. Note, the site email settings must be correctly configured prior to using the password reset. See the [email guide](/guide/sending-email.html) for help in configuring the module. It is also recommended that the `baseUrl` be set in the `data/local.js` or other server configuration file or through the `APOS_BASE_URL` environment variable. The user will not be notified if the email check fails or if the email fails to send due to improper configuration. However, debug information will output in the terminal.

### `passwordResetHours`

Defaults to `48`, giving the user 48 hours to reset the password based on the emailed link.

### `bearerTokens`

If set to an object with a `lifetime` subproperty, a bearer token is valid for that many milliseconds. If this option is not set, the lifetime defaults to 2 weeks. To
convert days to milliseconds, you can use logic like: `86400 * 1000 * days`

### `throttle`

Can be set to an object with the subproperties `allowedAttempts` (defaults to 3), `perMinutes` (defaults to 1), and `lockoutMinutes` (defaults to 1). Prevents brute-force guessing of a single user's password.

### `whoamiFields`

An array of additional user field names to include in responses from the `/api/v1/@apostrophecms/login/whoami` endpoint. These fields are combined with `minimumWhoamiFields` to determine what user information is returned.

<AposCodeBlock>

```javascript
export default {
  options: {
    whoamiFields: ['email', 'firstName', 'lastName', 'phone']
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/login/index.js
  </template>
</AposCodeBlock>

Only fields that exist on the user document and are not `undefined` will be included in the response.

### `minimumWhoamiFields`

An array of core user field names that are always included in `whoami` API responses, regardless of the `whoamiFields` configuration. This ensures essential user identification fields are always available.

The default minimum fields typically include basic identifiers like `_id`, `username`, and `title`. You can extend this list if your application requires additional fields to always be present:

<AposCodeBlock>

```javascript
export default {
  options: {
    minimumWhoamiFields: ['_id', 'username', 'title', 'role']
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/login/index.js
  </template>
</AposCodeBlock>

**Security note:** The `whoami` endpoint only returns explicitly configured fields, never the complete user object. This prevents accidental exposure of sensitive user data like password hashes or internal system fields.

## API Routes

### POST `/api/v1/@apostrophecms/login/login`
Authenticates a user and returns a bearer token or establishes a session. See the [REST API reference](/reference/api/authentication.html#bearer-tokens) for details.

### POST `/api/v1/@apostrophecms/login/logout` 
Ends the current user session and invalidates tokens. See the [REST API reference](/reference/api/authentication.html#end-session) for details.

### GET/POST `/api/v1/@apostrophecms/login/whoami`
Returns information about the currently authenticated user. See the [REST API reference](/reference/api/authentication.html#getting-current-user-information) for details.

### GET/POST `/api/v1/@apostrophecms/login/context`
Returns login context information including environment and requirements.

### POST `/api/v1/@apostrophecms/login/resetRequest`
Initiates a password reset process (if `passwordReset` is enabled).

### POST `/api/v1/@apostrophecms/login/reset`
Completes a password reset (if `passwordReset` is enabled).

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/migration
DOC_PATH: reference/modules/migration.md
URL: https://apostrophecms.com/docs/reference/modules/migration
================================================================================
# `@apostrophecms/migration`

**Alias:** `apos.migration`

<AposRefExtends :module="$frontmatter.extends" />

This module provides services for database migrations. These **migrations are used to make changes to the database** at the time of a new code deployment, typically because of *data structure changes* in code or *to fix data errors*. This is completely separate from transferring data between environments or between major versions of Apostrophe.

The `@apostrophecms/migration:migrate` task carries out all migrations that have been registered with this module, though typically only new migrations will run (see the warning below). In development environments all new migrations also run on every site startup.

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/migration/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

Because this module has an alias, you can call these from another module from the alias path. For example, `self.apos.migration.add()`.

### `add(name, fn)`

Add a migration function (`fn`) to be invoked when the `@apostrophecms/migration:migrate` task is invoked. Each migration is only invoked once, however they will all be invoked on a brand-new site, so they must check whether a change is actually needed before executing changes. They must also be harmless to run twice.

Functions receive no arguments, but have access to the modules where they are registered (via `self`) and the Apostrophe object (`self.apos`).

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type'
  init(self) {
    // üëá Adding a data migration related to this module.
    self.apos.migration.add('fix-roses', self.paintRosesRed);
  },
  methods(self) {
    return {
      // üëá Registering a method to run in the migration.
      async paintRosesRed () {
        await self.apos.migration.eachDoc({
          type: 'rose',
          color: 'white'
        }, async (doc) => {
          await self.apos.doc.db.updateOne({
            _id: doc._id
          }, {
            $set: { color: 'red' }
          });
        });
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/rose/index.js
  </template>
</AposCodeBlock>

::: warning
If running multiple instances of the website on a server, note that previous instances of the site are not stopped automatically while migrations are run. Migrations must minimize their impact on currently running instances of older versions of the site. It is safer to copy data to new properties and to not *remove* existing data until a subsequent migration.

### `async eachDoc(criteria, limit, iterator)`

Invokes the `iterator` function once for each doc in the `aposDocs` collection. The iterator function receives the document as an argument and is run as an `async` function. This method will never visit the same doc twice in a single call, even if modifications are made.

The `criteria` object is used to find documents to process, using the same format as in a [MongoDB `find` operation query](https://docs.mongodb.com/v4.4/reference/method/db.collection.find/). `limit` should be an integer and the number of documents to process in parallel, though it may be omitted. If only two arguments are passed in, `limit` is assumed to be 1 (only one doc may be processed at a time).

**Note:** This API is meant for migrations and task use only. It has no built-in security checks.

### `async each(collection, criteria, limit, iterator)`

This method is similar to [`eachDoc`](#async-eachdoc-criteria-limit-iterator), but it also accepts a database collection as its first argument. When working on normal website content, `eachDoc` will be better to use, though this method can be useful if operating on other database collections, such as the attachments collection (`self.apos.attachment.db`).

**Note:** This API is meant for migrations and task use only. It has no built-in security checks.

### `async eachArea(criteria, limit, iterator)`

Invokes the `iterator` function once for *every area* in *every doc* in the `aposDocs` collection. This method will never visit the same doc twice in a single call, even if modifications are made.

 The `iterator` function receives the following arguments:
 - `doc`: The full document object
 - `area`: The area object within the document
 - `dotPath`: The dot notation series leading to the area within the doc. If the area is a top-level field on the doc type's schema this will simply be the field name.

`criteria` may be used to limit the docs for which this is done, similar to its use in [`eachDoc`](#async-eachdoc-criteria-limit-iterator). `limit` should be an integer and the number of documents to process in parallel, though it may be omitted. If only two arguments are passed in, `limit` is assumed to be 1 (only one doc may be processed at a time).

**Note:** This API is meant for migrations and task use only. It has no built-in security checks.

### `async eachWidget(criteria, limit, iterator)`

Continuing from `eachArea()`, this method goes one level deeper. Invokes the `iterator` function once for *every widget* in *every area* in *every doc* in the `aposDocs` collection. This method will never visit the same doc twice in a single call, even if modifications are made.

 The `iterator` function receives the following arguments:
 - `doc`: The full document object
 - `widget`: The widget object within the document
 - `dotPath`: The dot notation series leading to the widget within the doc. If the area is a top-level field on the doc type's schema this will simply be the field name.

`criteria` may be used to limit the docs for which this is done, similar to its use in [`eachDoc`](#async-eachdoc-criteria-limit-iterator). `limit` should be an integer and the number of documents to process in parallel, though it may be omitted. If only two arguments are passed in, `limit` is assumed to be 1 (only one doc may be processed at a time).

**Note:** This API is meant for migrations and task use only. It has no built-in security checks.

## Module tasks

### `migrate`

Full command: `node app @apostrophecms/migration:migrate`

Run this command-line task to run all migrations. Migrations do not run automatically in production environments, so in that context this must be run manually or as part of a deployment process.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/module
DOC_PATH: reference/modules/module.md
URL: https://apostrophecms.com/docs/reference/modules/module
================================================================================
# `@apostrophecms/module`

This module is the foundation of all other Apostrophe modules. It is not *directly* used for any functionality, but [every other module inherits its behavior and functionality](/guide/modules.md#module-inheritance). Every other module has access to use the features documented here. Critically, this module includes initialization behavior that all modules need to start up correctly and register features.

**This module should almost never be configured directly in project code.** In other words, there should almost never be a `modules/@apostrophecms/module/index.js` file in a project codebase. The only reason to do so would be to add a feature that every other module will need. There should *never* be a `@apostrophecms/module: {}` line in an `app.js` file.

**Instead, configure the options below on other modules as needed** (e.g., configure the `alias` option on a module to create an easy reference to *that* module). Similarly, run the methods below as needed from the most appropriate module (e.g., use `self.email` from a contact page-type module).

## Options

|  Property | Type | Description |
|---|---|---|
|`alias` | String | A name to use for quick access to the module on the `apos` object (e.g., `'book'` to access a module on `self.apos.book`). Otherwise the longer syntax is necessary (e.g., `self.apos.modules.book`). |
|`templateData` | Object | An object of properties to include on the `data` object in templates belonging to that module. |

## Featured methods

The following methods belong to this module and may be useful in project-level code. As noted above, *they should be used via another module.* They cannot be directly called from this module as it is not instantiated.

See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/module/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

### `async render(req, template, data)`

Returns rendered HTML for a template with the data provided. You must pass `req`, a request object, as the first argument. The `template` argument should be the name of a template file in the module's `views` directory. If the `template` argument has no file extension Apostrophe will look for an `.html` or `.njk` file.

All properties of `data` can be used in Nunjucks templates as properties of the `data` object. This argument may be omitted to include no additional data.

### `async renderString(req, string, data)`

Returns rendered HTML for a Nunjucks-style string with the data provided. You must pass `req`, a request object, as the first argument. The `string` argument will be used as the template itself for rendering (not the template filename).

All properties of `data` can be used in Nunjucks templates as properties of the `data` object. This argument may be omitted to include no additional data.

### `async send(req, template, data)`

The `send()` method renders a template with data as with the [`render()`](#async-render-req-template-data), then sends the rendered HTML as a response to the request (`req`).

### `async sendPage(req, template, data)`

Similar to the [`send()`](#async-send-req-template-data) method, this renders a template and sends the rendered HTML as a response to the request (`req`). Where `send()` is used to render general template files, `sendPage()` is specifically used to render and send *full pages* for Apostrophe projects. Page templates should extend the outer layout template &ndash; either directly (`{% extends data.outerLayout %}`) or by extending a template that does so.

Templates rendered and sent with this method have full access to all template [data properties](/guide/template-data.md) appropriate for the related module. The template is also wrapped with the proper layout file (`'@apostrophecms/template:outerLayout.html'` by default), including the full `head` tag.

This method triggers the `@apostrophecms/page` module to emit a [`beforeSend` event](/reference/server-events.md#beforesend).

### `enableBrowserData(scene)`

Call this method from a module's [initialization function](/reference/module-api/module-overview.md##initialization-function) if the module implements the [`getBrowserData()` method](#getbrowserdata-req). **This is only necessary for modules that do not already do this** (all doc type and widget type modules already do this). The data returned by `getBrowserData(req)` will then be available on `apos.modules['the-module-name']` in the browser.

The `scene` argument is only needed if making the data available while logged-out. By default browser data is pushed only for the `apos` scene (the logged-in context), so the anonymous site visitor experience will include the extra data (except on the /login page and other pages that opt into the `apos` scene). If `scene` is set to `public` then the data is available to all visitors.

### `getBrowserData(req)`

The `getBrowserData()` method can be extended to adjust or add data that the module makes available in the browser. It should return an object to make the data available in browsers (as controlled by [the `enableBrowserData()` method](#enablebrowserdata-scene)).

The data will be available on a property of the `apos.modules` object matching the module name. For example, `@apostrophecms/i18n` module data is available on `apos.modules['@apostrophecms/i18n']`. If the module has an alias the data will also be accessible via `apos.yourAlias`.

Many Apostrophe core modules already populate browser data, including piece type, page type, and widget type modules. For this reason, **it is ususally correct to *extend* this method to add additional browser data** using the module's [`extendMethods` customization function](/reference/module-api/module-overview.md#extendmethods-self).

Avoid returning large data structures, as this will impact page load time and performance.

### `getOption(req, dotPathOrArray, def)`

This is a convenience method to fetch properties of `self.options` in a module. It will look for, then return the option identified by the second argument.

`req` is required to provide extensibility. Modules can use it to change the response based on the current page and other factors tied to the request. The second argument, `dotPathOrArray`, may be a dot path (`'flavors.grape.sweetness'`) or an array `[ 'flavors', 'grape', 'sweetness' ]`.

The optional `def` argument is returned if the property, or any of its ancestors, does not exist. If no third argument is given in this situation, `undefined` is returned.

#### Using `getOption()` in templates

`getOption()` is also made available in templates as a global function (directly as `getOption()`), not as a property of a module or the `apos` object. *In templates, skip the `req` argument.*

Normally in templates this returns options located in the module that called `render()` (often the module the template file belongs to). If you prefix the option path with a cross-module key, such as `module-name:optionName`, it will return the option located in the specified module.

### `email(req, templateName, data, options)`

Use the `email()` method to send email messages from a module. It renders an HTML email message using the template specified by `templateName`, which receives the third argument as its `data` object.

**Either the `nodemailer` option must be configured on the `@apostrophecms/email` module or another Nodemailer transport must be defined on that module as  `self.transport` before this method can be used.** Examples of other email transports include ones built for particular services that wrap Nodemailer themselves (e.g., `nodemailer-mailjet-transport`, `nodemailer-mailgun-transport`).

A plain text version is automatically generated for email clients that require or prefer it, including plain text versions of links. You do not need a separate plain text template.

The `options` object is passed on to the email transport except that `options.html` and `options.plaintext` are automatically provided via the template.

In particular, the `options` object should contain:
- `from`: The email address the message should come from.
- `to`: One or more email recipient addresses (comma-separated in a string for multiple).
- `subject`: The subject line

You can also configure a default `from` address, either globally by setting the `from` option of the `@apostrophecms/email` module, or locally for a particular module by adding an `email` option with a `from` property. If you need to localize `options.subject`, you can call `req.t(subject)`.

This method returns `info` as per the Nodemailer documentation. With most transports, a successful return indicates the message was handed off but has not necessarily arrived yet and could still bounce back at some point.

### `emit(name, ...args)`

The `emit()` method is used to emit server-side events. Events are automatically associated with the module that emitted them. The first argument is the name of the event. Additional arguments are passed, in order, to the event handlers listening to the event.

See the [server events guide](/guide/server-events.md) for more on this subject.

### `logInfo(req, 'event-type', 'notification message', { key: 'value' })`

The `logInfo()` method is used to log notifications with a severity of `info`. The `event-type` argument is required and uniquely identifies the notification. The remainder of the arguments are optional.

Adding the `req` object populates the log notification with the `originalUrl`, `path`, `method`, `ip`, `query`, and `requestId` from this object.

The `notification message` and object added as the final argument will both be added to the notification by the [`@apostrophecms/log` module](/reference/modules/log.html).

### `logDebug(req, 'event-type', 'notification message', { key: 'value' })`

The `logDebug()` method is used to log notifications with a severity of `debug`. The `event-type` argument is required and uniquely identifies the notification. The remainder of the arguments are optional.

Adding the `req` object populates the log notification with the `originalUrl`, `path`, `method`, `ip`, `query`, and `requestId` from this object.

The `notification message` and object added as the final argument will both be added to the notification by the [`@apostrophecms/log` module](/reference/modules/log.html).

### `logWarn(req, 'event-type', 'notification message', { key: 'value' })`

The `logWarn()` method is used to log notifications with a severity of `warn`. The `event-type` argument is required and uniquely identifies the notification. The remainder of the arguments are optional.

Adding the `req` object populates the log notification with the `originalUrl`, `path`, `method`, `ip`, `query`, and `requestId` from this object.

The `notification message` and object added as the final argument will both be added to the notification by the [`@apostrophecms/log` module](/reference/modules/log.html).

### `logError(req, 'event-type', 'notification message', { key: 'value' })`

The `logError()` method is used to log notifications with a severity of `error`. The `event-type` argument is required and uniquely identifies the notification. The remainder of the arguments are optional.

Adding the `req` object populates the log notification with the `originalUrl`, `path`, `method`, `ip`, `query`, and `requestId` from this object.

The `notification message` and object added as the final argument will both be added to the notification by the [`@apostrophecms/log` module](/reference/modules/log.html).

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/notification
DOC_PATH: reference/modules/notification.md
URL: https://apostrophecms.com/docs/reference/modules/notification
================================================================================
# `@apostrophecms/notification`

**Alias:** `apos.notification`

<AposRefExtends :module="$frontmatter.extends" />

This module implements a way to display notifications to logged-in users that can be triggered from either the server- or browser-side using `apos.notify`. These notifications can be customized for type, e.g. `success`, and can also emit bus events that can be used to trigger actions. The module itself has two options for controlling new notice polling frequency.

## Options

|  Property | Type | Default | Description |
|---|---|---|---|
| [`queryInterval`](#queryinterval) | integer | 500 | Interval in milliseconds between MongoDB queries |
| [`longPollingTimeout`](#longpollingtimeout) | integer | 10000 | Interval in milliseconds for the polling request to stay open. |

### `queryInterval`
This option sets the duration in milliseconds (ms) between MongoDB queries while long polling for notifications. It defaults to 500ms (1/2 a second). If you prefer fewer queries you can set this to a larger value, however, the queries are indexed queries on a small amount of data and shouldn't impact your app.

### `longPollingTimeout`
This option sets the duration of the long polling request in milliseconds. It defaults to 10000ms (10 seconds). This duration is typically a good balance between reducing overall server requests and avoiding timeouts from network intermediaries like proxy servers. It also helps in managing server resources efficiently by not keeping connections open excessively long and ensures a responsive user experience by providing timely updates without the overhead of constant querying.

## Usage
The usage of `apos.notify` differs slightly for server- vs client-side created notifications. In both cases, you need to pass the desired message string and an object of options. When using the method server-side, the first argument should be either the `req` object or a user `_id` string.

Server-side example:
```javascript
await self.apos.notify(req, 'message', options, interpolation);
```
When using this client-side, from either on-page JavaScript or within an admin UI Vue component, this argument should not be included.

Client-side example:
```javascript
await apos.notify('message', options, interpolation);
```
The message will be interpolated by i18next if there is a corresponding localization key, or passed directly if no key is found. You can pass additional keys to be interpolated and added to the message using either an `interpolation` object passed as the third argument, or as `options.interpolation`.

### Example
![A screenshot of the resulting notification from the code example](../../images/notification-success-message.png)
The translation strings file:
<AposCodeBlock>

```json
{
  "eventRegistrationSuccess": "Thank you, {{name}}, for registering for {{eventName}}!"
}
```
  <template v-slot:caption>
    modules/event/i18n/en.json
  </template>

</AposCodeBlock>

The form submission JavaScript:

<AposCodeBlock>

```javascript
export default () => {
  function onFormSubmit(formData) {
    const messageKey = 'eventRegistrationSuccess';
    const interpolate = {
      name: formData.name,
      eventName: formData.eventName
    };

    apos.notify(messageKey, {
      interpolate: interpolate,
      type: 'success',
      icon: 'plus-icon'
    });
    // or
    apos.notify(messageKey, {
      type: 'success',
      icon: 'plus-icon'
      },
      interpolate
    );
  }
};

```
  <template v-slot:caption>
    modules/event/ui/src/index.js
  </template>

</AposCodeBlock>

Within the `options` argument object, passed after the `message` string, you can pass several different properties.

The value of the `type` property dictates the styling of the notification. In the example above the `success` type was used, but this property also accepts other values: `danger` for irrevocable actions like deleting a file, `error` for serious issues that need immediate attention, `warning` for situations that might require caution or are potentially problematic, and `info` for general notifications. If no type is specified, the default is set to `info`.

The optional `icon` property takes the name of an already [registered icon](/reference/module-api/module-overview.md#icons). This icon is displayed in the notification to the left of the message.

The `dismiss` property takes either a boolean or integer representing the time in seconds. By default, notifications need to be dismissed manually by the user. If this property is set to `true`, the notification will automatically disappear after 5 seconds. If passed an integer, the notification will disappear after that specified number of seconds.

The `classes` option can take an optional array of additional class names that should be added to the notification wrapper. If you wish to use the notification to trigger an event using `options.buttons` or `options.event`, and do not want the user to see the notification itself you can pass `classes: [ 'apos-notification--hidden' ]` in the options object.

The `return` option takes a boolean and defaults to `false`. If set to true, invoking a notification returns an object containing the `noteId` property. The value of this property can be used to retrieve details about the notification from the `aposNotifications` collection of the database.

The optional `buttons` property allows for the display of one or more buttons within the notification. It takes an array of objects with each having at least `label`, `name`, and `type` properties. Currently, the `type` property only takes `event` as a value. The `label` property takes an i18n string that will be displayed to the user. The `name` property takes the name of an event that will be emitted when the button is clicked. Modules can listen for this on the client-side using [`apos.bus.$on(<name-value>, callback);`](/tutorials/admin-ui.md#adding-button-functionality). An optional `data` property can be used to pass an object to the module receiving the bus event. Clicking on a button will cause the notification to close.

### Example

In the browser, we could have functionality that allows users to add or delete comments on an article.

<AposCodeBlock>

```javascript
export default () => {
  // listen for notification button click to undo deletion
  // pass the data to the callback function
  apos.bus.$on('undoDeleteComment', async (commentId) => {
    try {
      await undoDeleteComment(commentId);
      // notify the user of success
      apos.notify('Comment deletion cancelled.', { type: 'success' });
    } catch (error) {
      // or error
      apos.notify('Error undoing item deletion.', { type: 'error' });
    }
  });

  function undoDeleteComment(commentId) {
    // Logic to undo deletion of the comment
    // YOUR CODE HERE
  }

  function deleteComment(commentId) {
    // Logic to delete the item triggered from a client-side button
    // YOUR CODE HERE

    // Show notification with undo option
    apos.notify('Comment deleted. Undo?', {
      type: 'warning',
      // dismiss undo notification after 5 seconds
      dismiss: true,
      // pass the commentId as the data payload of the bus event
      buttons: [
        {
          label: 'Undo deletion',
          type: 'event',
          name: 'undoDeleteComment',
          data: commentId
        }
      ]
    });
  }
};

```
  <template v-slot:caption>
    modules/article/ui/apos/apps/index.js
  </template>

</AposCodeBlock>

If the user deletes their comment it triggers the `deleteComment()` method. This then presents a notification with a button to undo that deletion. If the user clicks the button, `undoDeleteComment` is emitted on the bus along with the `commentId` as the `data` object payload. This bus event is picked up by the `$on` listener, which uses the data `commentId` to undelete the comment.

Much like the event triggered by clicking on the button, you can elect to trigger a bus even without the user having to click a button by using the `event` property. This property takes an object with `name` and an optional `data` property, like the `buttons` array objects. This event will be triggered as soon as the notification is presented to the user.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/page-type
DOC_PATH: reference/modules/page-type.md
URL: https://apostrophecms.com/docs/reference/modules/page-type
================================================================================
# `@apostrophecms/page-type`

<AposRefExtends :module="$frontmatter.extends" />

This module serves as the cornerstone for creating page types in Apostrophe. It allows developers to define multiple page types, each with their own configuration methods, schema fields, and template(s). This module extends the schema fields provided by the `@apostrophecms/doc-type` module with the `type` field and introduces the `orphan` field (labeled `visibility`), which controls page visibility in the navigation. Any newly created page type needs to be added to the `app.js` file, but also to the `types` array in the options of the [`@apostrophecms/page` module](/reference/modules/page.html). The object for each page type should have a `name` property that takes the module name and a `label` property that is used to populate the choices of page types presented to the content manager when they create a new page.

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    types: [
      {
        name: '@apostrophecms/home-page',
        label: 'Home'
      },
      {
        name: 'default-page',
        label: 'Default'
      },
      {
        name: 'article-page',
        label: 'Article Index'
      }
    ],
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>

</AposCodeBlock>

The `page-type` module can expose multiple views, but by default serves the template located at `<module-name>/views/page.html`. Additional views can be exposed using the `dispatch()` method.

## Featured Methods:
The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/tree/main/modules/%40apostrophecms/page-type) for all the methods that belong to this module.

### `dispatchAll()`
The `dispatchAll()` method is a utility method for registering multiple `dispatch()` routes. It is invoked during project start-up by the `init` method of this module, so it provides a convenient method for managing and consolidating routing logic.

<AposCodeBlock>

```javascript
dispatchAll() {
  self.dispatch('/', req => self.setTemplate(req, 'index'));
  self.dispatch('/:slug', req => self.setTemplate(req, 'show'));
}
```

</AposCodeBlock>

### `dispatch(pattern, ...middleware, handler)`
The `dispatch()` method provides a way to add Express-style routing for ApostropheCMS pages. This method allows you to define custom behavior for URLs that extend beyond the basic page slug, matching specified URL patterns. For example, this method is used in the `@apostrophecms/piece-page-type` to redirect from the `index.html` template to the `show.html` template when the URL matches the pattern `/:slug`. The `pattern` argument takes a string that can contain a mix of static and dynamic values. The dynamic values, or parameters, are proceeded with a `:` and will match any string passed in that position of the URL string. For instance, in the pattern `/user/:userId`, `:userId` is a dynamic segment that will match any string in its place. When a user accesses a URL like `/user/123`, the `req` userId parameter will be set to `123`.

A `pattern` can have multiple dynamic segments. For example, consider an online learning platform where users can access multiple courses and each course has multiple lessons and quizes. You could set up a dispatch route of `/course/:courseId/lessons/:lessonId` to be able to deliver a specified template for individual lessons and another route `/course/:courseId/quizzes/:quizId` to deliver the quiz template.

This method takes an optional `middleware` argument that can take any number of middleware functions. These functions are executed in the order they are provided, prior to the final handler. Middleware in this context can be used for a variety of purposes, such as authentication checks, logging, request data manipulation, error handling, or any other preparatory work that needs to occur before the request reaches the final handler. If any middleware function explicitly returns `false`, then no further middleware will be run and the final handler will also not be run.

The final `handler` argument handles any URL matching the pattern and receives the `req` object. In most cases, this is used to set the template that is rendered using `setTemplate(req, '<template-name>')`, where the template name is the name of the file to be used from the `modules/custom-module/views` folder minus the `.html` extension. The handler method must be an async function, and it will be awaited.

The `dispatch()` and `dispatchAll()` methods can be effectively used to create dynamic routes, potentially based on data retrieved from an API. For instance, you can fetch a list of available routes from an API at startup and dynamically register them using dispatch.

```javascript
methods(self) {
  return {
    dispatchAll() {
      // Route for listing all products
      self.dispatch('/', async (req) => {
        try {
          // Fetch product data from an external API using another method
          const products = await self.fetchApiData();
          // Add fetched products to the request object for use in the template
          req.data.products = products;
          // Render the product index template
          return self.setTemplate(req, 'productIndex');
        } catch (error) {
          // Log the error and render an error page in case of failure
          console.error('Error fetching products:', error);
          // render the 'views/errorTemplate.html' template
          return self.setTemplate(req, 'errorTemplate');
        }
      });

      // Route for specific product details
      self.dispatch('/:product', async (req) => {
        try {
          // Fetching details for a specific product using its slug from the URL
          const response = await fetch(`https://apiEndpoint/${req.params.product}`);
          // Check if API response is successful
          if (!response.ok) {
            throw new Error(`API responded with status ${response.status}`);
          }
          const data = await response.json();
          // Adding product details to the request object
          req.data.product = req.params.product;
          req.data.details = data.message;
          // Render the product details template
          return self.setTemplate(req, 'productDetails');
        } catch (error) {
          // Log the error and render an error page in case of failure
          console.error('Error fetching product details:', error);
          return self.setTemplate(req, 'errorTemplate');
        }
      });
    }
  }
}

```
In this example, your custom module would have a `modules/custom-module/views/productIndex.html` template that would be used to display all of the products returned from the API when a user navigates to `https://your-site.com/your-product-page/`. This template would create dynamic links using a loop over the `data.products` object. For example, <span v-pre>`<a href="{{data.page._url}}/{{product}}">{{ product }}</a>`</span>. When clicked, this would then trigger the `/:product` dispatch route and render the template located at `modules/custom-module/views/productDetails.html`. The specific product name and details would be available through `data.product` and `data.details` in the template.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/page
DOC_PATH: reference/modules/page.md
URL: https://apostrophecms.com/docs/reference/modules/page
================================================================================
# `@apostrophecms/page`

**Alias:** `apos.page`

<AposRefExtends :module="$frontmatter.extends" />

This module provides the majority of functionality for serving and generally working with [pages](/reference/glossary.md#page) in Apostrophe.

For creating page types, see the `@apostrophecms/page-type` module instead.

## Options

| Property | Value type | Description |
|---------|---------|---------|
| [`builders`](#builders) | Object | Set query builder values to be used when pages are served. |
| [`cache`](#cache) | Object | Provides control over cache headers for both ordinary page requests and the REST API. |
| [`home`](#home) | Boolean/Object | Change how the home page is added to `req.data` when pages are served. |
| [`minimumPark`](#minimumpark) | Array | Override default parked pages, including the home page. |
| [`park`](#park) | Array | Set pages to be created on site start with configuration. |
| [`publicApiProjection`](#publicapiprojection) | Object | Set query builder values to be used when pages are served. |
| [`quickCreate`](#quickcreate) | Boolean | Set to `false` to remove pages from the quick create menu. |
| [`redirectFailedUppercaseUrls`](#redirectfaileduppercaseurls) | Boolean | Set to `false` to override the conversion of URLs to lowercase upon 404. |
| [`types`](#types) | Array | Set the page types available for new pages. |


### `builders`

The `builders` option can be used to apply any existing query builders when a page is served by its URL. This affects the data available on the page object, `req.data.page` (`data.page` in templates). All of the [documented query builders](/reference/query-builders.md) are valid, but in a key/value syntax rather than as method receiving arguments.

The default value is:
```javascript
{
  children: true,
  ancestors: { children: true }
}
```

In this example, page objects are fetched with one level of page tree "children" as `_children` and their "ancestor" pages, each with one level of their child pages, on `_ancestors`.


#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    builders: {
      children: { depth: 2 }
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

In this example, we are not including ancestor pages and are requesting two levels of child pages (direct children and their direct children).

### `cache`

`cache` can be set to an object with optional `page` and `api` subproperties, and a `maxAge` subproperty within each, determining the cache lifetime in seconds. If enabled, Apostrophe will send a `Cache-Control` header with the specified maximum age. The actual caching is provided by the browser, or by an intermediate CDN or reverse proxy.

The `page` subproperty controls cache headers for ordinary page requests, while the `api` subproperty controls cache headers for REST API requests using the `GET` method.

Note that Apostrophe already provides "cache on demand" by default, to improve performance when simultaneous `GET` requests arrive for the same piece. Unlike "cache on demand," setting the `cache` option introduces the possibility that some visitors will see older content, up to the specified lifetime.

If a user is logged in, or `req.session` has content, Apostrophe always disables caching. However such a user could encounter a previously cached document from before logging in. Apostrophe contains logic to mitigate this in the editing experience.

#### Example

<AposCodeBlock>

```javascript
options: {
  cache: {
    page: {
      // Specified in seconds
      maxAge: 6000
    },
    api: {
      // Specified in seconds
      maxAge: 3000
    }
  }
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

### `home`

The home page document is added to all page requests on `req.data.home` so it can be referenced in all page templates. That home page object also includes a `_children` property containing an array of top level page objects. The `home` option offers minor performance improvements for large sites by setting one of the following values:

| Setting | Description |
|---------|-------------|
| `false` | Disables adding the home page document to the requests. |
| `{ children: false }` | Includes the home page document, but without the child pages array. If the [`builders` option](#builders) has an `ancestors` property, that will take precedence. |

#### Example

<AposCodeBlock>

```javascript
// modules/@apostrophecms/page/index.js
module.exports = {
  options: {
    home: { children: false }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

### `minimumPark`

The `minimumPark` option sets the initial defaults for the home page and archive "page" (the page archive). This should normally be left as it is. A possible use case for changing this might be when building an installable module meant to change the defaults for all websites that use it.

::: warning
Configuring this poorly, especially by leaving out one of the two required pages, will break page functionality. In almost every situation it is better to use the [`park`](#park) option instead, including for updating home page properties.

The default is:
```javascript
[
  {
    slug: '/',
    parkedId: 'home',
    _defaults: {
      title: 'Home',
      type: '@apostrophecms/home-page'
    }
  },
  {
    slug: '/archive',
    parkedId: 'archive',
    type: '@apostrophecms/archive-page',
    archived: true,
    orphan: true,
    title: 'Archive'
  }
]
```

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    minimumPark: [
      {
        slug: '/',
        parkedId: 'home',
        _defaults: {
          title: 'Welcome',  // üëà
          type: 'welcome-page' // üëà
        }
      },
      {
        slug: '/archive',
        parkedId: 'archive',
        type: '@apostrophecms/archive-page',
        archived: true,
        orphan: true,
        title: 'Archive'
      }
    ]
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

### `park`

Use the `park` option to add an array of pages that should be created when the app starts up if they do not already exist. Each page is added as an object with initial properties, including the required `parkedId`. If a page in this array has the same `parkedId` as one in [`minimumPark`](#minimumpark), the version in the `park` option will be used.

Required and recommended parked page properties include:

| Setting | Requirement | Description |
|---------|-------------|-------------|
| `parkedId` | Required | A unique ID value used to identify it among parked pages. |
| `slug` | Required | The page [slug](/reference/glossary.md#slug). |
| `type` | Required | The page type to be used for the parked page. |
| `title` | Recommended | The page title. If not set, it will be "New Page." |

If added on the top level of the page object, these properties will not be editable through the user interface. Properties other than `parkedId` may be included in a `_defaults` property instead, which will allow them to be edited in the UI.

#### Example

<AposCodeBlock>

```javascript
// modules/@apostrophecms/page/index.js
module.exports = {
  options: {
    park: [
      // Customizing home page properties, including title and page type.
      {
        slug: '/',
        parkedId: 'home',
        title: 'Our Business',
        type: 'custom-home-page'
      },
      // The blog page has a permanent slug, title, and type.
      {
        parkedId: 'blogParkedId',
        slug: '/blog',
        title: 'Blog',
        type: 'blog-page'
      },
      // The team page has a permanent type, but editable slug and title.
      {
        parkedId: 'teamParkedId',
        type: 'staff-page',
        _defaults: {
          slug: '/team',
          title: 'Our Team',
        }
      }
    ]
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

### `publicApiProjection`

By default the built-in Apostrophe REST APIs are not accessible without proper [authentication](/reference/api/authentication.md). You can set an exception to this for `GET` requests to return specific document properties with the `publicApiProjection` option.

This should be set to an object containing individual field name keys set to `1` for their values. Those fields names included in the `publicApiProjection` object will be returned when the `GET` API requests are made without authentication.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    publicApiProjection: {
      title: 1,
      _url: 1 // üëà Dynamic properties are allowed
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

Unauthenticated [`GET /api/v1/@apostrophecms/page`](/reference/api/pages.md#get-api-v1-apostrophecms-page) requests would return each piece with only the `title` and `_url` properties.

### `quickCreate`

Pages are included in the admin bar "quick create" menu by default. Setting `quickCreate: false` on the page module will disable this.

#### Example

<AposCodeBlock>

```javascript
// modules/@apostrophecms/page/index.js
module.exports = {
  options: {
    quickCreate: false
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

### `redirectFailedUppercaseUrls`

If a requested URL is not found and the requested URL contains uppercase letters, by default the `@apostrophecms/page` module will convert the *entire* requested URL to lowercase and attempt to redirect to this altered URL. For example, the request `/pArent/Child.html` will be coverted to `/parent/child.html`. Setting the `redirectFailedUppercaseUrls` to false will override this behavior.

### `types`

The `types` array defines the page types available to users when creating or editing pages. Each item in the array should have a `label` property and a `name` property, which matches an active page type. If no `types` array is set, only the core "Home" page type will be available.

[Parked pages](#park) may use page types that are not in the `types` option array. This allows developers to do things such as parking a single search page but not allowing users to create additional search pages.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    types: [
      {
        name: 'default-page',
        label: 'Default'
      },
      {
        name: 'article-page',
        label: 'Article Index'
      }
      {
        name: '@apostrophecms/home-page',
        label: 'Home'
      }
    ]
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

## Related documentation

- [Pages guide](/guide/pages.md)
- [Pages REST API](/reference/api/pages.md)

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/page/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

Because this module has an alias, you can call these from another module using the alias. For example, `self.apos.page.find()`.

### `async find(req, criteria, builders)`

The `find()` method initiates a database query. Learn more about initiating queries [in the database query guide](/guide/database-queries.md#initiating-the-database-query). This method takes three arguments:

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `criteria` | Object | A [MongoDB criteria object](https://docs.mongodb.com/manual/tutorial/query-documents/). It is often as simple as properties that match schema field names assigned to the desired value. |
| `builders` | Object | The builders object is converted to matching [query builders](/reference/query-builders.md). |

### `findForEditing(req, criteria, builders)`

Returns a query that finds pages the current user (based on the `req` request object) can edit. Unlike `find()`, this query defaults to including docs in the archive.

`criteria` is a MongoDB criteria object as in `find()`. The `builders` argument should be an object of query builders, in the same style as the [module option of the same name](#builders).

### `async findOneForEditing(req, criteria, builders)`

`findOneForEditing()` is wrapper for `findForEditing()` that returns a single document matching the arguments, not simply a query.

### `async insert(req, targetId, position, page, options)`

The `insert()` method is used to add a new page. It requires specific arguments to place the new page in a specific location in the page tree hierarchy. See the [guide for inserting documents in code](/guide/database-insert-update.md#inserting-pages) for more on this.

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
|`targetId` | String | The `_id` of an existing page to use as a target when inserting the new page. `_home` and `_archive` are optional conveniences for the home page and [archived section](/reference/api/pages.md#moving-pages-to-the-archive), respectively. |
|`position` | Integer/String | A numeric value will represent the zero-based child index under the `_targetId` page. `before`, `after`, `firstChild`, or `lastChild` values set the position within the page tree for the new page in relation to the target page (see `_targetId`). `before` and `after` insert the new page as a sibling of the target. `firstChild` and `lastChild` insert the new page as a child of the target. |
| `page` | Object | The page document object. |
| `options` | Object | An options object, primarily used for internal draft state management. |

### `async update(req, page, options)`

The `update()` method is used to update data for an existing page. Note that the second argument must be a *complete page object* to replace the existing one. You will typically use [`find()`](#async-find-req-criteria-options) to get the existing document object, alter that, then pass it into this method. See the [guide for updating pages in code](/guide/database-insert-update.md#updating-page-documents) for more on this.

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `page` | Object | The document object that will *replace* the existing database document. |
| `options` | Object | An options object, currently only used for internal draft state management. |

### `getBrowserData(req)`

The page module's implementation of [`getBrowserData`](module.md#getbrowserdata-req). This establishes the data that is used in the browser (including by the user interface). If adjusting this **remember to [*extend* this method](/reference/module-api/module-overview.md#extendmethods-self) rather than overwriting it** to avoid breaking the UI.

### `newChild(page)`

This method creates and returns a new object suitable to be inserted *as a child of the specified parent page* (`page`) via `insert()`. It *does not* insert the page to the database. That should be done as a subsequent step. If the parent page is locked down such that no child page types are permitted, this method returns `null`. Visibility settings are inherited from the parent page.

### `allowedChildTypes(page)`

This module returns an array of page types allowed to be used for child pages of page (`page`) passed in as an argument. By default, this method simply returns an array of all page types, but it can be extended or overwritten to be more restrictive.

### `async move(req, pageId, targetId, position)`

This is the proper method to use to move a page within the page tree hierarchy. Since pages have positional relationship with each other we need to provide the `_id` properties of the page we're moving, the page it should be moved *in relation to*, and the position in relation to the target page.

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
|`pageId` | String | The `_id` of an existing page to use as a target when inserting the new page. `_home` and `_archive` are optional conveniences for the home page and [archived section](/reference/api/pages.md#moving-pages-to-the-archive), respectively. |
|`targetId` | String | The `_id` of an existing page to use as a target when inserting the new page. `_home` and `_archive` are optional conveniences for the home page and [archived section](/reference/api/pages.md#moving-pages-to-the-archive), respectively. |
|`position` | Integer/String | A numeric value will represent the zero-based child index under the `_targetId` page. `before`, `after`, `firstChild`, or `lastChild` values set the position within the page tree for the new page in relation to the target page (see `_targetId`). `before` and `after` insert the new page as a sibling of the target. `firstChild` and `lastChild` insert the new page as a child of the target. |

### `async archive(req, _id)`

The `archive()` method moves a page, identified by its unique `_id`, into the page tree's archive section. It returns an object with two properties: `parentSlug`, the slug of the page's former parent; and `changed`, an array of objects with `_id` and `slug` properties, identifying all child pages of the moved page that were also archived.

### `async publish(req, draft, options)`

When passed a `req` object and *draft* document object (`draft`), this method will publish the draft. This replaces an existing published version of the page, if there is one. The options object (`options`) is currently only used for internal draft state management.

### `async localize(req, draft, locale, option)`

Localize the draft page (`draft`), copying it to another locale (`locale`). This creates that locale's draft for the first time if necessary. By default existing documents are not updated, but setting `update: true` in the `options` object will update existing ones.

### `async revertDraftToPublished(req, draft)`

Reverts the given draft page (`draft`) to the most recent publication, clearing any changes. It returns the draft's new value, or `false` if the draft was not modified from the published version or no published version exists yet.

Emits the [`afterRevertDraftToPublished` event](/reference/server-events.md#afterrevertdrafttopublished) before returning, which includes a payload object containing the draft document.

### `async revertPublishedToPrevious(req, published)`

Reverts a published page document (`published`) to the previous published state and returns the updated published state. If this was already done (only one previous state is saved) or there is no previous publication, it throws an `invalid` exception.

Emits the [`afterRevertPublishedToPrevious` event](/reference/server-events.md#afterrevertpublishedtoprevious) before returning, which includes a payload object containing the published document.

### `normalizeSlug(req)`

Normalizes and replaces `req.slug` to account for unneeded trailing whitespace, trailing slashes other than the root, and double slash based open redirect attempts.

### `isPage(doc)`

Returns `true` if the document object, `doc` is identifiable as a page.


### `getBaseUrl(req)`

Returns the effective base URL for the given request (`req`). If a hostname is configured for the active locale (`req.locale`), then the base URL will include it, inferring the protocol from `req.protocol`. Otherwise, if Apostrophe's top-level `baseUrl` option or `APOS_BASE_URL` environment variable is set it will be used. If there is neither an active locale hostname nor a configured `baseUrl` option, the base URL will be an empty string. This makes it easier to build absolute URLs (when `baseUrl` is configured), or to harmlessly prepend the empty string (when it is not configured). The Apostrophe queries used to fetch Apostrophe pages consult this method.

### `inferIdLocaleAndMode(req, _id)`

This method is a wrapper for the `@apostrophecms/i18n` module [method of the same name](/reference/modules/i18n.md#inferidlocaleandmode-req-id).

## Template helpers

Template helpers are methods available for use in template files. Because this module has an alias, you can call these in templates using the alias path. For example, `apos.page.isAncestorOf(doc1, doc2)`.

#### `isAncestorOf(possibleAncestorPage, page)`

Returns a boolean value indicating whether the first argument page object (`possibleAncestorPage`) is an ancestor of the second argument page (`page`) in the page tree.

## Module tasks

### `unpark`

Full command: `node app @apostrophecms/page:unpark /page/slug`

Running this task will unlock a page that was ["parked"](#park) by including its slug as an argument. The page must first be removed from the [`park` option array](#park). This allows editors to then change any properties that were not editable previously.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/pager
DOC_PATH: reference/modules/pager.md
URL: https://apostrophecms.com/docs/reference/modules/pager
================================================================================
# `@apostrophecms/pager`

**Alias:** `apos.pager`

<AposRefExtends :module="$frontmatter.extends" />

This module provides a template macro and helper methods for standard pagination on piece index pages. See the [index page guide](/guide/piece-pages.md#pagination) for usage.

## Related documentation

- [Piece index page pagination](/guide/piece-pages.md#pagination)

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/piece-page-type
DOC_PATH: reference/modules/piece-page-type.md
URL: https://apostrophecms.com/docs/reference/modules/piece-page-type
================================================================================
# `@apostrophecms/piece-page-type`

<AposRefExtends :module="$frontmatter.extends" />

This module adds two specialized views to those exposed by the `page-type` module, which `piece-page-type` extends. The [index page](/reference/glossary.html#index-page) displays all pieces of a particular `piece-type` in a paginated, filterable manner. The [show page](/reference/glossary.md#show-page) is for presenting individual pieces. These features are added to those exposed by the [`@apostrophecms/page`](/reference/modules/page.md) module.

Once an editor adds a page of this type to the site via the user interface, it becomes possible to view a listing of pieces by visiting that page's URL. Individual pieces of the relevant type can be viewed by adding the piece slug to the page's URL, like this: `/slug-of-index-page/slug-of-piece`.

It is possible to add more than one index page for a particular piece-type and add custom logic to decide which pieces should be associated with each. For example, you could have an `article` piece type with index pages for different topics, like sports, finance, and tech. This can be accomplished by overriding the [`filterByIndexPage()`](#filterbyindexpage-query-page) method to fetch the pieces you think most appropriate given the settings of each index page. Conversely, override [`chooseParentPage()`](#chooseparentpage-pages-piece) to associate the individual review show pages with the correct index.

Any index page is searchable using the `search` query parameter. This parameter takes advantage of MongoDB indexes automatically created by the `@apostrophecms/doc` module. This query is limited to the piece data being delivered to the page, so any [`piecesFilters`](#piecesfilters) will limit the results that are returned.

<AposCodeBlock>

```nunjucks
<form action="" method="GET">
  <input type="text" name="search" placeholder="Search here..." value="{{ data.query.search | safe }}" />
  <button type="submit">Search</button>
  {% if data.query.search %}
    <button type="button" onclick="window.location.href='{{ data.url | build({search: null}) }}'">Clear Search</button>
  {% endif %}
</form>
```
  <template v-slot:caption>
    modules/article-page/views/index.html
  </template>

</AposCodeBlock>

This example implements a search box that can be integrated into an `index.html` file. This box utilizes the `search` parameter to refine the page's content, showing only the items that correspond to the search term entered by the user. As written, this will clear all of the existing query parameters that have been added to the URL. You would have to further parse the `data.query` object to retain existing parameters. The empty `action` attribute of the form element will, by default, direct the form submission to the current URL. The button to clear the search query takes advantage of the Apostrophe-supplied Nunjucks [`build()` filter](/guide/template-filters.md#build-url-path-data) to manipulate the query parameters.

Most schema fields of a piece can also be used to filter content using query parameters. For instance, you could filter by an `_author` relationship schema field to retrieve a list of all articles authored by Bob Smith using `https://my-website.com/article-page?author=bob+smith`. This example and the previous one demonstrate how to filter the pieces delivered to an `index.html` page by manipulating the URL, but you can also use the schema fields or other custom queries within the `piecesFilters` option, as described below, to create structured filtering options.

## Options

|  Property | Type | Description |
|---|---|---|
| [`next`](#next) | Boolean \|\| Object | If set to `true`, `data.next` is the next piece based on the sort. |
| [`perPage`](#perpage) | Integer | The number of pieces to include in a set of `GET` request results. |
| [`piecesFilters`](#piecesfilters) | Array | Takes an array of objects where each contains a `name` key and a value of a field in the piece to filter on. |
| [`pieceModuleName`](#piecemodulename) | String | Optionally sets the `piece-type` to a specific name other than the default inferred from the module name. |
| [`previous`](#previous) | Boolean \|\| Object | If set to `true`, `data.previous` is the previous piece based on the sort. |

### `next`
If this option is set to true, it exposes the next piece in the current [sort order](/reference/module-api/module-options.md#sort) as `req.data.next` (`data.next` in the template) when serving a [show page](/reference/glossary.md#general-terms). This can be used to provide a link to the next item in a series (e.g., the next oldest blog post).

This option can also be set to an object whose keys are [query builders](/reference/query-builders.md#query-builders), such as `project`, and whose values are the parameters passed to each query builder.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    next: true
  },
  // ‚Ä¶
}

// OR

module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    // The next article piece would be returned with only the `title, `_url`
    // and `lastPublishedAt` properties.
    next: {
      project: {
        title: 1,
        _url: 1,
        lastPublishedAt: 1
      }
    }
  },
  // ‚Ä¶
}
```
<template v-slot:caption>
  modules/article-page/index.js
</template>
</AposCodeBlock>

### `perPage`
The `perPage` option should be set to an integer and specifies the number of pieces displayed per page for the `index.html` page before pagination is offered. It is set to 10 items per page by default.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    perPage: 20
  },
// ‚Ä¶
}
```
  <template v-slot:caption>
    modules/article-page/index.js
  </template>
</AposCodeBlock>

### `piecesFilters`
The `piecesFilters` takes an array of objects to assist in filtering on the index page. Each object must have a `name` property associated with a valid [query builder](/reference/module-api/module-overview.md#queries-self-query).

These include:
* Custom query builders configured in an app that include a `launder` method
* Field names whose field types automatically get builders:
    - boolean
    - checkboxes
    - date
    - float
    - integer
    - relationship
    - select
    - slug
    - string
    - url

When the index page is served, filter data will be returned in the `req.data.piecesFilters` object (`data.piecesFilters` in the template). This object consists of an array for each configured filter. That array contains objects with `value` and `label` properties for every `piece-type` that matches the filter. Passing filter values back to the index page as query string parameters will filter the results accordingly. If `counts: true` is included for the filter query, each object in the array will also have a `count` property with the number of matching pieces.

A simplified schema for a 'book' `piece-type`:
<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Book',
    pluralLabel: 'Books'
  },
  fields: {
    add: {
      _author: {
        label: 'Author',
        type: 'relationship'
      },
      genre: {
        label: 'Genre',
        type: 'select',
        choices: [
          // category choices here
        ]
      }
    }
    // ‚Ä¶
  }
};
```
  <template v-slot:caption>
    modules/book/index.js
  </template>
</AposCodeBlock>

A partial schema, including a `piecesFilters` option, for the 'book-page' `piece-page-type`:
<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    piecesFilters: [
      { name: 'author' },
      {
        name: 'genre',
        counts: true
      }
    ]
  }
  // ...
};
```
  <template v-slot:caption>
    modules/book-page/index.js
  </template>
</AposCodeBlock>

An example of the `data.piecesFilters` object delivered to the 'book-page' `index.html` template:
<AposCodeBlock>

```
{
  author: [
    {
      _id: 'cloqajh0v0007selseq2c2np6:en:published',
      type: 'author',
      metaType: 'doc',
      _edit: true,
      _publish: true,
      label: 'Gibson',
      value: 'gibson'
    },
    {
      _id: 'cloqak2rl000jsels2a20anjt:en:published',
      type: 'author',
      metaType: 'doc',
      _edit: true,
      _publish: true,
      label: 'Herbert',
      value: 'herbert'
    },
    {
      _id: 'cloqajsju000dsels8o2e3dgb:en:published',
      type: 'author',
      metaType: 'doc',
      _edit: true,
      _publish: true,
      label: 'Le Guin',
      value: 'le-guin'
    }
  ],
  genre: [
    { value: 'cyberpunk', label: 'Cyberpunk', count: 6 },
    { value: 'dystopian', label: 'Dystopian', count: 3 },
    { value: 'fantasy', label: 'Fantasy', count: 9 }
  ]
}
```
<template v-slot:caption>
data.piecesFilters
</template>

</AposCodeBlock>

Example usage of the `data.piecesFilter`:

<AposCodeBlock>

```nunjucks
{% extends "layout.html" %}

{%- macro here(url, changes) -%}
  {{ url | build({
    author: data.query.author,
    genre: data.query.genre
  }, changes) }}
{%- endmacro -%}

{% set authors = data.piecesFilters.author %}
{% set genres = data.piecesFilters.genre %}

{% block main%}
<h3>Authors</h3>
<ul>
  {% for author in authors %}
    <li><a style="{{ 'font-style: italic' if data.query.author == author.value }}" href="{{ here(data.url, {author: author.value}) }}">{{ author.label }}</a></li>
  {% endfor %}
</ul>
<h3>Genres</h3>
<ul>
  {% for genre in genres %}
    <li><a style="{{ 'font-style: italic' if data.query.genre == genre.value }}" href="{{ here(data.url, {genre: genre.value}) }}">{{ genre.label }} has {{ genre.count }} entries</a></li>
  {% endfor %}
</ul>
{% for piece in data.pieces %}
  <p><strong>{{ piece.title }}</strong> ({{ piece.genre }}) by {{ piece._author[0].name }} </p>
{% endfor %}
{% endblock %}
```
  <template v-slot:caption>
    modules/book-page/views/index.html
  </template>

</AposCodeBlock>

### `pieceModuleName`
Piece page types are associated with a single piece type. If named with the pattern `[piece name]-page`, the associated piece type will be identified automatically. You can override this pattern by explicitly setting `pieceModuleName` to an active piece type. This is useful if there is more than one piece page type for a single piece type (e.g., to support different functionality in each).

<AposCodeBlock>

```javascript
// üëÜ This module name would look for a piece type
// named `fiction` if not for `pieceModuleName`
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    pieceModuleName: 'book'
  }
  // Code to select and group only fiction books
  // ‚Ä¶
};
```
<template v-slot:caption>
modules/fiction-page/index.js
</template>
</AposCodeBlock>

### `previous`
If this option is set to true, it exposes the previous piece in the current [sort order](/reference/module-api/module-options.html#localized) as `req.data.previous` (`data.previous` in the template) when serving a [show page](/reference/glossary.md#general-terms). This can be used to provide a link to the previous item in a series (e.g., the next newest blog post).

This option can also be set to an object whose keys are [query builders](/reference/query-builders.md#query-builders), such as `project`, and whose values are the parameters passed to each query builder.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    previous: true
  },
  // ‚Ä¶
}

// OR

module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    // The previous article piece would be returned with only the `title`, `_url`
    // and `lastPublishedAt` properties.
    next: {
      project: {
        title: 1,
        _url: 1,
        lastPublishedAt: 1
      }
    }
  },
  // ‚Ä¶
}
```
<template v-slot:caption>
  modules/article-page/index.js
</template>
</AposCodeBlock>

## Related Documentation

* [Piece index and show pages](/guide/piece-pages.md)
* [Piece page type options](/reference/module-api/module-options.md#options-for-piece-page-types)

## Featured methods
The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/piece-page-type/index.js) for all the modules that belong to this module.

### `indexQuery(req)`
This method should be overridden for a piece-type to call additional [query builders](/reference/query-builders.md#query-builders) when generating the index page.

### `showQuery(req)`
This method should be overridden for a piece-type to call additional [query builders](/reference/query-builders.md#query-builders) when generating the show page.

### `async beforeIndex(req)`
This method is called before `indexPage`. Within the core module it does nothing, so it can be easily overridden by supplying a new method in the `methods` section of the custom module. It is a convenient method for manipulating the `req` being supplied to that page.

### `async beforeShow(req)`
This method is called before `showPage`. Within the core module it does nothing, so it can be easily overridden by supplying a new method in the `methods` section of the custom module. It is a convenient method to extend for manipulating the `req` being supplied to that page.

### `dispatchAll()`
This method can be extended to override the default behavior of invoking `showPage` if the URL has an additional path after the base, e.g. `/blog/good-article`. As example, you could override to use `/:year/:month/:day/:slug` to invoke `self.showPage`. This should be used in conjunction with the [`buildUrl()`](#buildurl-req-page-piece)) method of this module. See [@apostrophecms/page-type](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/page-type/index.js) for more about what you can do with dispatch routes.

### `buildUrl(req, page, piece)`
This method can be overridden to change the URLs that are generated as the `_url` property for individual pieces. Note that the [`dispatchAll`](#dispatchall) method often must also be overridden to ensure those URLs actually reach those pieces.

### `filterByIndexPage(query, page)`
This method invokes query builders on the supplied query argument to ensure it only fetches results appropriate to the given page. This is typically done when there is more than one pieces-page per page type. Within the core module it does nothing, so it can be easily overridden by supplying a new method in the `methods` section of the custom module. This should be used in conjunction with the [`chooseParentPage`](#chooseparentpage-pages-piece) method of this module.

### `chooseParentPage(pages, piece)`
The `pages` parameter of this method takes an array of all of the index pages for a particular piece-type, and the `piece` parameter is an individual piece-type name. The default version of this method will give a warning if it sees more than one page in the array, as it is up to the developer to override this method to provide a sensible way of deciding which page is the best 'parent' for each piece.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/piece-type
DOC_PATH: reference/modules/piece-type.md
URL: https://apostrophecms.com/docs/reference/modules/piece-type
================================================================================
# `@apostrophecms/piece-type`

<AposRefExtends :module="$frontmatter.extends" />

This module is the foundation for all [piece types](/guide/pieces.md) in Apostrophe. It is not typically configured or referenced in project code directly since each piece type should be managed independently in most cases. For example, the options documented below would be configured on a custom piece type, e.g., `article`, rather this piece type base module.

The only reason to configure this module directly would be to apply the changes to *every* piece type, including those in Apostrophe core (e.g., `@apostrophecms/user`).

## Options

|  Property | Type | Description |
|---|---|---|
| [`autopublish`](#autopublish) | Boolean | Set to `true` to publish all saved edits immediately. |
| [`cache`](#cache) | Object | Provides control over cache headers for the REST API. |
| [`label`](#label-for-doc-types) | String | The human-readable label for the doc type. |
| [`localized`](#localized) | Boolean | Set to `false` to exclude the doc type in the locale system. |
| [`perPage`](#perpage) | Integer | The number of pieces to include in a set of `GET` request results. |
| [`pluralLabel`](#plurallabel) | String | The plural readable label for the piece type. |
| [`publicApiProjection`](#publicapiprojection) | Object | Piece fields to make available via a public REST API route. |
| [`quickCreate`](#quickcreate) | Boolean | Set to `true` to add the piece type to the quick create menu. |
| [`searchable`](#searchable) | Boolean | Set to `false` to remove the piece type from search results. |
| `showCreate` | Boolean | Set to `false` to disable UI related to creating new pieces of that type. |
| `showArchive` | Boolean | Set to `false` to disable UI related to archiving pieces of that type. |
| `showDiscardDraft` | Boolean | Set to `false` to disable UI related to discarding draft pieces of that type. |
| `showDismissSubmission` | Boolean | Set to `false` to disable UI related to dismissing draft submissions for pieces of that type. |
| `singleton` | Boolean | Set to `true` to ensure that no one can create a new piece of that type. The global doc module uses this, as only one should ever exist. |
| [`sort`](#sort) | Object | The value for a piece type's default sort order query builder. |

### `autopublish`

Set `autopublish` to `true` to automatically publish any changes saved to docs of this type. There is then effectively no draft mode for this doc type, but there will be draft document versions in the database.

The core image and file modules use this option, for example. It eliminates the need for users to think about the distinction between draft and published content while preserving the possibility of translation for different locales.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    autopublish: true
  },
  // ...
}
```
<template v-slot:caption>
modules/article-category/index.js
</template>
</AposCodeBlock>

### `cache`

`cache` can be set to an object with an `api` subproperty, and a `maxAge` subproperty within that, determining the cache lifetime in seconds. If enabled, Apostrophe will send a `Cache-Control` header with the specified maximum age. The actual caching is provided by the browser, or by an intermediate CDN or reverse proxy.

Note that Apostrophe already provides "cache on demand" by default, to improve performance when simultaneous `GET` requests arrive for the same piece. Unlike "cache on demand," setting the `cache` option introduces the possibility that some visitors will see older content, up to the specified lifetime.

If a user is logged in, or `req.session` has content, Apostrophe always disables caching. However such a user could encounter a previously cached document from before logging in. Apostrophe contains logic to mitigate this in the editing experience.

#### Example

```javascript
  cache: {
    api: {
      // Specified in seconds
      maxAge: 3000
    }
  }
```

### `label`

`label` should be set to a text string to be used in user interface elements related to this doc type. This includes buttons to open piece manager modals.

If not set, Apostrophe will convert the module name to a readable label by splitting the `name` property on dashes and underscores, then capitalizing the first letter of each word.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Featured Article'
  },
  // ...
}
```
<template v-slot:caption>
modules/feature/index.js
</template>
</AposCodeBlock>

### `localized`

Defaults to `true`. If set to `false`, this doc type will _not_ be included in the locale system. This means there will be only one version of each doc, regardless of whether multiple locales (e.g., for languages or regions) are active. There is no distinction between draft and published, including in the database.

The "users" piece type disables localization in this way. It can also be useful for piece types that are synchronized from another system that has no notion of locales and no distinction between "draft" and "published" content.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    localized: false
  },
  // ...
}
```
<template v-slot:caption>
modules/administrative-category/index.js
</template>
</AposCodeBlock>

### `perPage`

In piece types, the `perPage` option, expressed as an integer, sets the number of pieces that will be returned in each "page" [during `GET` requests](/reference/api/pieces.md#get-api-v1-piece-name) that don't specify an `_id`. It also controls how many are displayed in the manager modal user interface. This value defaults to 10.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    perPage: 20 // REST `GET` requests will return 20 pieces per page.
  },
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `pluralLabel`

Similar to `label` for all doc types, the `pluralLabel` option sets the string the user interface will use to describe a piece type in plural contexts.

If no `pluralLabel` value is provided, Apostrophe will append the `label` (whether set manually or generated [as described](#label)), with "s", as is typical for English words. **Even in English this is often not correct, so `pluralLabel` should usually be defined explicitly.**

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Goose',
    pluralLabel: 'Geese'
  },
  // ...
}
```
<template v-slot:caption>
modules/goose/index.js
</template>
</AposCodeBlock>

### `publicApiProjection`

By default, the built-in Apostrophe REST APIs are not accessible without proper [authentication](/reference/api/authentication.md). You can set an exception to this for `GET` requests to return specific document properties with the `publicApiProjection` option.

This should be set to an object containing individual field name keys set to `1` for their values. Those fields names included in the `publicApiProjection` object will be returned when the `GET` API requests are made without authentication.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    publicApiProjection: {
      title: 1,
      authorName: 1,
      _url: 1 // üëà Dynamic properties are allowed
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

Unauthenticated [`GET /api/v1/article`](/reference/api/pieces.md#get-api-v1-piece-name) requests would return each piece with only the `title`, `authorName`, and `_url` properties.

### `quickCreate`

Setting `quickCreate: true` on a piece adds that piece type to the admin bar "quick create" menu. The Apostrophe admin bar user interface includes the quick create menu button to add new pieces without first opening their respective manager modals.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    quickCreate: true
  },
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `searchable`

<!-- TODO: link to documentation of Apostrophe search when available. -->
Setting `searchable: false` on a piece type will exclude that piece type from the results in Apostrophe's built-in search.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    searchable: false
  },
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `sort`

The `sort` option for a doc type defines a sorting order for requests to the database for that type. The option is set to an object containing field name keys with `1` as a property value for ascending order and `-1` for descending order.

The default sort for all doc types is `{ updatedAt: -1 }`, meaning it returns documents based on the `updatedAt` property (the date and time of the last update) in descending order. The `sort` object can have multiple keys for more specific sorting.

#### Example

This `sort` setting will return articles first based on a custom `priority` field in ascending order, then by the core `updatedAt` property in descending order.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    sort: {
      priority: 1,
      updatedAt: -1
    }
  },
  fields: {
    add: {
      priority: {
        type: 'integer',
        min: 1,
        max: 5
      },
      // ...
    }
  }
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

## Related documentation

- [Pieces guide](/guide/pieces.md)
- [Pieces REST API](/reference/api/pieces.md)

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/piece-type/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

This module is meant as a base class for more specific content modules. As such, the methods should be used from those content modules, not directly from this one.

### `async find(req, criteria, builders)`

The `find()` method initiates a database query. Learn more about initiating queries [in the database query guide](/guide/database-queries.md#initiating-the-database-query). This method takes three arguments:

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `criteria` | Object | A [MongoDB criteria object](https://docs.mongodb.com/manual/tutorial/query-documents/). It is often as simple as properties that match schema field names assigned to the desired value. |
| `builders` | Object | The builders object is converted to matching [query builders](/reference/query-builders.md). |

### `getManagerApiProjection(req)`

The `getManagerApiProjection()` method defines which fields are returned when pieces are loaded in the manager modal, improving performance by reducing the amount of data transferred. By default, when `managerApiProjection` is not configured, this method returns `null`, which means all fields will be fetched. This default behavior ensures all data is available, but can be less efficient.

Setting `managerApiProjection: true` in your module's options causes the method to only include the essential fields and visible columns, which can improve performance when working with thousands of pieces. Alternatively, you can provide an object with specific field projections (e.g., `{ customField: 1, authorReference: 1 }`). When you provide an object, those fields will be returned in addition to the essential fields, which is a convenient way to include extra fields without having to extend the method.

Essential fields are always included in the projection, even if not specified in your custom projection. These essential fields are:

```javascript
{
  _id: 1,
  _url: 1,
  aposDocId: 1,
  aposLocale: 1,
  aposMode: 1,
  docPermissions: 1,
  slug: 1,
  title: 1,
  type: 1,
  visibility: 1
}
```

These fields provide document identifiers, permissions, and metadata required for the manager interface to function properly. When columns are configured for the manager view, their field names are automatically added to the projection, with any "draft:" or "published:" prefixes properly handled.

**Example: Configuring the Projection in Options**

```javascript
export default {
  extend: '@apostrophecms/piece-type',
  options: {
    // Only return essential fields and columns
    managerApiProjection: true,

    // Or specify additional fields to include
    // managerApiProjection: {
    //   customField: 1,
    //   authorReference: 1
    // }
  }
  // ...
}
```

When extending this method, remember to use the `_super` parameter to call the original method and build upon its results. Check if the original projection is `null` before attempting to add fields, as `null` indicates that all fields should be fetched.

**Example: Extending the Projection**

```javascript
export default {
  extend: '@apostrophecms/piece-type',
  extendMethods(self) {
    return {
      getManagerApiProjection(_super, req) {
        // Get the original projection using _super
        const projection = _super(req);

        // If projection is null, it means "fetch everything"
        if (projection === null) {
          return null;
        }

        // Add your custom fields to the projection
        projection.customField = 1;
        projection.authorReference = 1;

        return projection;
      }
    };
  }
  // ...
}
```

**When to Use Options vs. Extending the Method**

Configuring `managerApiProjection` in your options is simpler and sufficient for most use cases when you just need to add specific fields. You should use the `extendMethods` approach when you need more complex logic, such as:

1. When your projection needs to be dynamic based on the request
2. When you need to perform conditional logic to determine which fields to include
3. When you need to access other module methods or services to decide on the projection
4. When you're building upon a module that might already have extended this method

### `async insert(req, piece, options)`

The `insert()` method is used to add a new piece in server-side code. See the [guide for inserting documents in code](/guide/database-insert-update.md#inserting-a-new-piece) for more on this.

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `piece` | Object | The piece document object. |
| `options` | Object | An options object. Setting `permissions: false` will bypass all permission checks. |

### `async update(req, piece, options)`

The `update()` is used to update data for an existing piece. Note that the second argument must be a *complete piece object* to replace the existing one. You will typically use [`find()`](#async-find-req-criteria-options) to get the existing document object, alter that, then pass it into this method. See the [guide for updating pages in code](/guide/database-insert-update.md#updating-content-documents) for more on this.

| Property | Type | Description |
| -------- | -------- | ----------- |
| `req` | Object | The associated request object. Using a provided `req` object is important for maintaining user role permissions. |
| `piece` | Object | The document object that will *replace* the existing database document. |
| `options` | Object | An options object. Setting `permissions: false` will bypass all permission checks. |

### `getBrowserData(req)`

Piece type modules' implementation of [`getBrowserData`](module.md#getbrowserdata-req). This establishes the data that is used in the browser (including by the user interface). If adjusting this **remember to [*extend* this method](/reference/module-api/module-overview.md#extendmethods-self) rather than overwriting it** to avoid breaking the UI.

## Module tasks

### `generate`

Full command: `node app [piece-type name]:generate --total=[integer]`

This task is used to generate sample documents for a given piece type. This can be helpful during project development to quickly create test content. The task will generate 10 items if the `--total` argument is *not* included. If `--total` is included with a number argument, it will generate that number of items.

For example, `node app article:generate --total=2000` will generate 2,000 documents for an `article` piece type.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/search
DOC_PATH: reference/modules/search.md
URL: https://apostrophecms.com/docs/reference/modules/search
================================================================================
# `@apostrophecms/search`

**Alias:** `apos.search`

The `@apostrophecms/search` module implements a sitewide search powered by the full-text search features of MongoDB. The module also provides the `@apostrophecms/search` page type to be used as a [parked page](/reference/modules/page.html#park). Like other page types, the module must be added to your `app.js` and project level `@apostrophecms/page/index.js` files.

<AposCodeBlock>

``` js
module.exports = {
  options: {
    park: [
      {
        slug: '/search',
        parkedId: 'search',
        title: 'Search',
        type: '@apostrophecms/search'
      }
    ]
  }
};

```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

## Customizing the search template

The `@apostrophecms/search` module template can be customized through adding files to the project-level `modules/@apostrophecms/search/views` folder. The default template is `index.html`. This file can be copied to your project-level folder for modification or used as an example to build a page from scratch. The main block of this template contains a form for adding any filters to the search if the `filters` option has been populated, as well as the query terms. Below the form is a section to output the search results returned to the page in the `data.doc` object. Finally, the page includes the [standard pagination section](/guide/piece-pages.md#pagination). In this case, it is added using `{% include "pager.html" %}` to load it in from another file in the `views` folder so that it can be easily reused. You can elect to add the pager directly to your project template or keep it as a separate file.

## Options

|  Property | Type | Description |
|---|---|---|
`perPage` | Integer | Search results per page. Defaults to 10. |
[`types`](#types) | Array | An array of page and piece type names to be searched. |
[`filters`](#filters) | Array | An array of filters offered to the user to refine results. |

### Types

The `types` option takes an array of page-type and piece-type document names that will be included within the search results. By default, all page and piece docs are searchable. Piece types can opt out of searching by adding an option of `seachable: false`. Adding an array to the `types` option will provide search results from just those types of pages and pieces, regardless of the value of the `searchable` option of any piece type. Excluding a page type from the `types` array is the only way to exclude search results from a particular page type.

<AposCodeBlock>

``` js
module.exports = {
  options: {
    // search only the product piece-type, blog piece-types, and blog page-types
    // not adding 'product-page' will exclude results from product `index.html` page
    // including '@apostrophecms/blog-page' will include the 'index.html' blog page,
    // including `@apostrophecms/blog` will include results from individual 'show.html'pages
    types: [ 'product', '@apostrophecms/blog', '@apostrophecms/blog-page' ]
  }
};

```
<template v-slot:caption>
modules/@apostrophecms/search/index.js
</template>
</AposCodeBlock>

### Filters

The `filters` option takes an array of objects that each have `name` and `label` properties. The `name` key takes a piece or page type document name as value. The `label` key takes a l10n-localizable string that is presented to the user. On the search page, the user will be presented with a list of filters by label, along with a checkbox to toggle the filter on and off. In addition to the filters derived from this array, users will also be presented with an `Everything else` filter that will allow the user to filter any other piece or page documents that are not included in the named filters.

<AposCodeBlock>

``` js
module.exports = {
  options: {
    filters: [
      {
        name: 'product',
        label: 'Product'
      },
      {
        name: 'default-page',
        label: 'Default Page'
      }
    ]
  }
};

```

<template v-slot:caption>
modules/@apostrophecms/search/index.js
</template>
</AposCodeBlock>

## Module tasks

### `index`

Full command: `node app @apostrophecms/search:index`

Rebuild the search index. Normally this happens automatically. This should only be needed if you have changed the "searchable" property for various fields or types.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/settings
DOC_PATH: reference/modules/settings.md
URL: https://apostrophecms.com/docs/reference/modules/settings
================================================================================
# `@apostrophecms/settings`

**Alias:** `apos.settings`

<AposRefExtends :module="$frontmatter.extends" />

This module governs the Personal Settings menu that allows users to change their preferences. Apostrophe projects can configure this menu through `@apostrophecms/settings`. As such, these settings are personal to the user. If you're looking for sitewide settings that govern overall site behavior, check out [`@apostrophecms/global`](/guide/global.md).

## Options

|  Property | Type | Description |
|---|---|---|
| [`subforms`](#subforms) | Object | Each object defines a set of input fields in the Personal Settings dialog box, with its own Update button. |
| [`groups`](#groups) | Object | This option allows for the organization of subforms on tabs in the Personal Settings menu. |

### Requirements

All fields added to the subforms except `adminLocale` must already exist as default schema fields of the core `@apostrophecms/user` module or be added at project level. 
If the `adminLocales` option is set in the `@apostrophecms/i18n` module, this field will be automatically added to the available subform schema fields and will add a select input for Admin language to the User management modal.

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    subforms: {
      // The `adminLocales` option **must** be configured in the `@apostrophecms/i18n` module for this to be allowed
      // adminLocale: {
      //   fields: [ 'adminLocale' ]
      // },
      changePassword: {
        // This will have `protection: true` automatically.
        fields: [ 'password' ]
      },
      displayName: {
        // The default `title` field is labeled 'Display Name' in the `@apostrophecms/user` module.
        // Changing this field will **not** change the Username or Slug of the user.
        fields: [ 'title' ]
      },
      fullName: {
        // Passing in a label so that it doesn't use the label for `lastName`
        label: 'Full Name',
        // Schema fields added at project level
        fields: [ 'lastName', 'firstName' ]
      }
    },
    groups: {
      account: {
        label: 'Account',
        subforms: [ 'displayName', 'fullName', 'changePassword' ]
      },
      // preferences: {
      //   label: 'Preferences',
      //   // The `adminLocales` option **must** be configured in the `@apostrophecms/i18n` module for this to be allowed
      //   subforms: [ 'adminLocale' ]
      // }
    }
  }
};

```

<template v-slot:caption>
  /modules/@apostrophecms/settings/index.js
</template>
</AposCodeBlock>


<AposCodeBlock>

``` javascript
module.exports = {
  fields: {
    add: {
      firstName: {
        type: 'string',
        label: 'First Name'
      },
      lastName: {
        type: 'string',
        label: 'Last Name'
      },
      displayName: {
        type: 'string',
        label: 'Display Name'
      }
    },
    group: {
      account: {
        label: 'Account',
        fields: [
          'firstName',
          'lastName',
          'displayName'
        ]
      }
    }
  }
};

```

<template v-slot:caption>
  /modules/@apostrophecms/user/index.js
</template>
</AposCodeBlock>

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    defaultLocale: 'en',
    locales: {
      en: { label: 'English' },
      fr: {
        label: 'French',
        prefix: '/fr'
      },
      es: {
        label: 'Spanish',
        prefix: '/es'
      }
    },
    // only allow "locking" of the admin language to a sub-set of locales
    adminLocales: [
      {
        label: 'English',
        value: 'en'
      },
      {
        label: 'French',
        value: 'fr'
      }
    ]
    // We can also set a default UI language
    // defaultAdminLocale: 'en'
  }
};

```

<template v-slot:caption>
  /modules/@apostrophecms/i18n/index.js
</template>
</AposCodeBlock>

### `subforms`

The `subforms` option takes an object of named objects.  Each individual object has a required `fields` property that takes an array of strings that are the names of existing schema fields in the `@apostrophecms/user` settings. By default, the `password` and `adminLocale` fields are available for addition. Note that the `adminLocale` field needs to be enabled by [setting the `adminLocales` option](/reference/modules/i18n.html) of the `@apostrophecms/i18n` module.

In addition to the required `fields` property, each object can take six additional optional properties.

The `label` property takes a string to display to the user in both preview, when not editing that subform, and edit mode, as a label at the left or a heading label, respectively. If not supplied, Apostrophe will use the label for the first schema passed to the `fields` property.

The `protection` property can take a value of either `true` or `"password"`. These values are equivalent and will require that the user enters their password when attempting to change the value(s) of this `fields` object. Additional fields that are protected by default can be added through the `addProtectedField()` method of the module.

The `reload` property defaults to false, but can take a value of `true` if the page should update after the user makes a change, clarifying to the user that the setting change took effect.

#### Previewing options

The remaining three subform options govern the display of information to the user in preview mode. This lets the user know the current value for that field, or in the case of complex fields, some type of other messaging.

These preview options are optional. If none are added, as is the case with the example above, Apostrophe will create a preview by combining the values of any schema fields within the individual `subforms` object as a space-separated string. For example, if the object has two schema fields, `firstName` and `lastName`, the resulting preview would be equivalent to <code v-pre>{{ firstName }} {{ lastName }}</code>. While this would work well for an object with a small number of fields, this might not be optimal for an object with a larger number.

For complex subforms with multiple fields, or with sensitive information like a password, the `help` option can be used. It takes a string (or i18n key) to display to the user.

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    subforms: {
      // other subforms
      fullName: {
        // Passing in a label so that it doesn't use the label for `lastName`
        label: 'Full Name',
        // Schema fields added at project level
        fields: [ 'lastName', 'firstName' ],
        preview: '{{ firstName }} {{ lastName}}'
      }
    },
    // remainder of configuration
};

```

<template v-slot:caption>
  /modules/@apostrophecms/settings/index.js
</template>
</AposCodeBlock>

In order to show the user a preview of selected subform fields, or to take advantage of localization you can use the `preview` option. This option receives a string that can include subform schema field names, like <code v-pre>{{ firstName }} {{ lastName}}</code>, leveraging i18next as a built-in templating system and allowing different locales to put them in different orders as appropriate.

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    subforms: {
      // other subforms
      displayInitials: {
        label: 'Display Initials',
        // Schema fields added at project level
        fields: [ 'firstName', 'lastName' ],
        previewComponent: 'SettingsDisplayInitialsPreview',
        protection: true,
        reload: true
      },
    },
    // remainder of configuration
};

```

<template v-slot:caption>
  /modules/@apostrophecms/settings/index.js
</template>
</AposCodeBlock>

Finally, the `previewComponent` property takes the name of a Vue component that has been added to your project through any `modules/my-custom-module/ui/apos/components` folder. The string passed to this property should not contain the file extension. This component is rendered and displayed to the right of the subform label in the preview mode and has access to the values provided in the subform by the user. [See below](#previewcomponent) for further information about the component structure.

You should avoid setting all three of these options on a single subform. However, if you do, the `previewComponent` will be used preferentially, followed by the `help` and then the `preview` option.

### groups

The `groups` property takes an object of named objects. Each of the individual objects takes two properties, `label` and `subforms`. The label is displayed as the left hand tab name in the Personal Settings menu. The `subforms` property takes an array of `subforms` object names as strings. These subforms will be added to the tab in the order that they appear in the array. If no groups property is added to the settings, the `subforms` objects will be added to a tab named "Ungrouped" in the order that they were created. Similarly, any `subforms` objects not explicitly added to a `groups` object will be added to the "Ungrouped" tab.

### `previewComponent`

<AposCodeBlock>

``` javascript
<template>
  <span>{{ myComputedValue }}</span>
</template>
<script>
export default {
  name: 'SettingsDisplayNamePreview',
  props: {
    subform: {
      type: Object,
      required: true
    },
    values: {
      type: Object,
      required: true
    }
  },
  computed: {
    myComputedValue() {
      // this.subform is the config, this.values is the current field values
      var firstName = this.values.firstName || '';
      var lastName = this.values.lastName || '';
      var initials = firstName.charAt(0).toUpperCase() + lastName.charAt(0).toUpperCase();
      return initials;
    }
  }
};
</script>
```

<template v-slot:caption>
  /modules/@apostrophecms/settings/ui/apos/components/SettingsDisplayInitialsPreview.vue
</template>
</AposCodeBlock>

::: info
In this example, we are adding the preview component into the `@apostrophecms/settings` folder at the project level. However, you could also elect to create a single module for all of the Vue components you are adding to your project, as long as the component files are being added to the `/ui/apos/components/` folder of the module.

The preview Vue component takes two props, `subform` and `values`. The values prop can be used to retrieve the values the user adds to the schema fields and then manipulate and output those values. In this example, we are simply retreiving the `lastName` and `firstName` field values from the associated subform, then returning the users initials for display.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/task
DOC_PATH: reference/modules/task.md
URL: https://apostrophecms.com/docs/reference/modules/task
================================================================================
# `@apostrophecms/task`

**Alias:** `apos.task`

<AposRefExtends :module="$frontmatter.extends" />

This module provides the functionality needed to create and run command line tasks. It also provides utilities for generating request objects when one is not available and is needed.

Command line tasks are invoked with the general structure:

```bash
node app module-name:task-name --arguments

# Example
node app @apostrophecms/migration:migrate
node app article:generate --total=20
```

Apostrophe is fully initialized before a task is run, except that it does not listen for connections. We may access all general Apostrophe features in a task.

::: info
**New to creating tasks?** See the [Creating Command-Line Tasks tutorial](/tutorials/creating-command-line-tasks.md) for a step-by-step guide with practical examples.

## Related documentation

- [Module task configuration](/reference/module-api/module-overview.md#tasks-self) - How to define tasks in your module
- [Creating Command-Line Tasks tutorial](/tutorials/creating-command-line-tasks.html) - Complete guide to building tasks

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/task/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

Because this module has an alias, you can call these from another module from the alias path. For example, `self.apos.task.invoke(...)`.

::: danger
`getReq` and the related methods below should be used very carefully. It is easy to accidentally grant admin-level (or other higher role) access when lower level permissions are better applied. Those methods are primarily meant for writing unit tests and CLI tasks.

It is almost always the case that an existing request object should be used instead when available (e.g., in an API route handler or event handler such as `beforeInsert`).

### `invoke(name, args, options)`

For use when you wish to execute an Apostrophe command line task from server-side code and continue with other work. This avoids using the command line directly or using the Node.js `child_process` module. The method returns a Promise (it can be run with the `async/await` syntax).

**The `name` argument** is the only one that is required. It must be the name of a task, including the name of the module where it was registered, e.g., `'@apostrophecms/user:add'`.

If present, **the `args` argument should be an array of positional arguments** that would be provided to the task in a CLI, *not including* the task name.

If present, **the `options` argument is an object that contains optional parameters** that would normally be hyphenated, i.e. at the command line you might write `--total=20`. This can be passed as the second argument if `args` is omitted.

```javascript
// CLI equivalent: node app @apostrophecms/user:add 'alf' 'admin'
await self.apos.task.invoke('@apostrophecms/user:add', [ 'alf', 'admin' ]);

// CLI equivalent: node app product:generate --total=20
await self.apos.task.invoke('product:generate', { total: 20 });

// With both positional arguments and options
await self.apos.task.invoke('article:generate', [ 'technology' ], { total: 20 });
```

The `args` and `options` arguments may be completely omitted, though individual tasks should indicate whether arguments are required when they are run.

::: info
It is better to call a module's method *directly* rather than invoking a task when possible. This method is for cases where that option is not readily available.

During the execution of the task, `self.apos.argv` will have a new, temporary value to accommodate tasks that inspect this property directly rather than examining their `argv` argument. `self.apos.argv` will be restored at the end of task execution.

Test carefully as some tasks may not be written to be "good neighbors." For instance, a task developer might assume they can exit the process directly.


### `getReq(options)`

Return a `req` object suitable for command line tasks and unit tests. The `req` object returned is a mockup of a true Express `req` object.

The `options` argument should be an object. If `options.role` is set, it may be:
- `anon` (no user role and no `req.user`)
- `guest`
- `contributor`
- `editor`
- `admin` (the default)

The methods below provide quick access to create request objects for each role. See [the users guide](/guide/users.md#user-roles) for information about each role.

Other properties of `options` are assigned as properties of the returned `req` object before any initialization tasks (such as computing `req.absoluteUrl`).

#### Example: Using getReq in a task

```javascript
tasks(self) {
  return {
    'list-articles': {
      usage: 'List all articles in the database',
      async task(argv) {
        // Database queries require a request object
        const req = self.apos.task.getReq();

        // Now we can query the database with admin permissions
        const articles = await self.find(req).toArray();

        console.log(`Found ${articles.length} articles:`);
        for (const article of articles) {
          console.log(`- ${article.title} (${article.aposMode})`);
        }
      }
    }
  };
}
```

#### Example: Choosing the appropriate permission level

```javascript
tasks(self) {
  return {
    'compare-visibility': {
      usage: 'Compare what admins vs anonymous users can see',
      async task(argv) {
        // Get all content with admin permissions
        const adminReq = self.apos.task.getReq();
        const allArticles = await self.find(adminReq).toArray();

        // Get only published content (what anonymous users see)
        const anonReq = self.apos.task.getAnonReq();
        const publicArticles = await self.find(anonReq).toArray();

        console.log(`Admin can see: ${allArticles.length} articles`);
        console.log(`Public can see: ${publicArticles.length} articles`);
        console.log(`Unpublished: ${allArticles.length - publicArticles.length} articles`);
      }
    }
  };
}
```

#### Example: Specifying locale in a task

```javascript
tasks(self) {
  return {
    'list-french': {
      usage: 'List articles in the French locale',
      async task(argv) {
        // Create a request object with a specific locale
        const req = self.apos.task.getReq({
          locale: 'fr',
          mode: 'published'
        });

        const articles = await self.find(req).toArray();

        console.log(`Found ${articles.length} French articles`);
      }
    }
  };
}
```

### `getAnonReq(options)`

A convenience wrapper for `getReq`. This returns a request object simulating an anonymous site visitor, with no role and no `req.user`.

**When to use:** Use `getAnonReq` when you need to see content exactly as unauthenticated visitors would see it - typically only published content that has public visibility.

See [`getReq`](#getreq-options) for information about the `options` argument.

#### Example: Testing public visibility

```javascript
tasks(self) {
  return {
    'test-public-access': {
      usage: 'Test what anonymous users can access',
      async task(argv) {
        const req = self.apos.task.getAnonReq();

        // This will only return published, public content
        const articles = await self.find(req).toArray();

        console.log(`Anonymous users can see ${articles.length} articles`);

        // Test a specific article
        const slug = argv.slug || 'test-article';
        const article = await self.find(req, { slug }).toOne();

        if (article) {
          console.log(`‚úì Article "${slug}" is publicly accessible`);
        } else {
          console.log(`‚úó Article "${slug}" is NOT publicly accessible`);
        }
      }
    }
  };
}
```

### `getGuestReq(options)`

A convenience wrapper for `getReq`. This returns a request object simulating a user with the `guest` role.

**When to use:** Use this when you need to test how content appears to logged-in users with minimal permissions (guests can typically view more than anonymous users but cannot edit content).

See [`getReq`](#getreq-options) for information about the `options` argument.

### `getContributorReq(options)`

A convenience wrapper for `getReq`. This returns a request object simulating a user with the `contributor` role.

**When to use:** Contributors can typically create and edit their own content but cannot publish it. Use this to test workflows or content visibility at the contributor permission level.

See [`getReq`](#getreq-options) for information about the `options` argument.

#### Example: Simulating contributor permissions

```javascript
tasks(self) {
  return {
    'test-contributor-workflow': {
      usage: 'Test what contributors can do with content',
      async task(argv) {
        const req = self.apos.task.getContributorReq();

        // Try to create a draft article
        const article = {
          title: 'Contributor Test Article',
          aposMode: 'draft'
        };

        try {
          await self.insert(req, article);
          console.log('‚úì Contributor can create draft articles');
        } catch (error) {
          console.log('‚úó Contributor cannot create articles:', error.message);
        }

        // Try to publish (this should fail)
        article.aposMode = 'published';
        try {
          await self.update(req, article);
          console.log('‚úì Contributor can publish articles');
        } catch (error) {
          console.log('‚úó Contributor cannot publish articles (expected)');
        }
      }
    }
  };
}
```

### `getEditorReq(options)`

A convenience wrapper for `getReq`. This returns a request object simulating a user with the `editor` role.

**When to use:** Editors can create, edit, and publish content but typically cannot manage users or access admin-only features. Use this to test content management workflows at the editor permission level.

See [`getReq`](#getreq-options) for information about the `options` argument.

### `getAdminReq(options)`

A convenience wrapper for `getReq`. This returns a request object simulating a user with the `admin` role. This is the default behavior of `getReq()`.

**When to use:** Use this (or simply `getReq()`) for most tasks where you need full access to all content, including unpublished drafts, archived content, and admin-only features. This is the most common choice for maintenance tasks, data generation, and migrations.

See [`getReq`](#getreq-options) for information about the `options` argument.

#### Example: Admin-level maintenance task

```javascript
tasks(self) {
  return {
    'cleanup-old-drafts': {
      usage: 'Delete draft articles older than 90 days',
      async task(argv) {
        // Use admin permissions to access all drafts
        const req = self.apos.task.getAdminReq();

        const ninetyDaysAgo = new Date();
        ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);

        // Find old drafts (admin can see drafts, others cannot)
        const oldDrafts = await self.find(req, {
          aposMode: 'draft',
          updatedAt: { $lt: ninetyDaysAgo }
        }).toArray();

        console.log(`Found ${oldDrafts.length} drafts older than 90 days`);

        if (!argv['dry-run']) {
          for (const draft of oldDrafts) {
            await self.delete(req, draft);
            console.log(`‚úì Deleted: ${draft.title}`);
          }
        } else {
          console.log('DRY RUN - No articles were deleted');
        }
      }
    }
  };
}
```

## Common Patterns

### Pattern: Dry run option

Always include a `--dry-run` option for tasks that modify or delete data:

```javascript
tasks(self) {
  return {
    'dangerous-operation': {
      usage: 'Perform a destructive operation. Use --dry-run to preview changes.',
      async task(argv) {
        const req = self.apos.task.getReq();
        const dryRun = argv['dry-run'];

        // Find items to modify
        const items = await self.find(req, { /* criteria */ }).toArray();

        if (dryRun) {
          console.log(`DRY RUN: Would modify ${items.length} items`);
          return;
        }

        // Perform actual modifications
        for (const item of items) {
          await self.update(req, item);
        }
      }
    }
  };
}
```

### Pattern: Progress reporting

For long-running tasks, report progress to keep users informed:

```javascript
tasks(self) {
  return {
    'process-many': {
      usage: 'Process a large number of items',
      async task(argv) {
        const req = self.apos.task.getReq();
        const items = await self.find(req).toArray();
        const total = items.length;

        console.log(`Processing ${total} items...`);

        for (let i = 0; i < items.length; i++) {
          await processItem(items[i]);

          // Report progress every 10 items
          if ((i + 1) % 10 === 0) {
            console.log(`Progress: ${i + 1}/${total} (${Math.round((i + 1) / total * 100)}%)`);
          }
        }

        console.log('‚úì Complete!');
      }
    }
  };
}
```

### Pattern: Validating required arguments

Always validate that required arguments are present:

```javascript
tasks(self) {
  return {
    'require-args': {
      usage: 'Task that requires arguments.\nUsage: node app module:require-args <filename> --format=json',
      async task(argv) {
        // Check positional argument
        const filename = argv._[1];
        if (!filename) {
          console.error('Error: filename argument is required');
          console.log(this.usage);
          process.exit(1);
        }

        // Check named option
        const format = argv.format;
        if (!format) {
          console.error('Error: --format option is required');
          console.log(this.usage);
          process.exit(1);
        }

        // Proceed with task
        console.log(`Processing ${filename} in ${format} format...`);
      }
    }
  };
}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/ui
DOC_PATH: reference/modules/ui.md
URL: https://apostrophecms.com/docs/reference/modules/ui
================================================================================
# `@apostrophecms/ui`

 The `@apostrophecms/ui` module provides the components and mixins for creating the admin UI seen by logged-in users with editing privileges. It also provides the UI styling with some built-in theming capabilities that can be leveraged to create a custom admin experience. This module has no impact on the experience of ordinary logged-out site visitors.

## Options

|  Property | Type | Description |
|---|---|---|
| `widgetMargin` | String | CSS margin value for widget spacing, default is `'20px 0'` |

### `widgetMargin`
This option sets the padding on nested areas and only impacts what a logged-in user with editing privileges will see. It has no impact on the CSS for logged-out users or users without editing privileges.

## Core Components

The `@apostrophecms/ui` module provides the following key UI components:

### Basic UI Components
- **AposButton** - Button component with various styles and states
- **AposCheckbox** - Checkbox input component
- **AposSelect** - Dropdown select component
- **AposToggle** - Toggle switch component
- **AposIndicator** - Icon display component
- **AposSpinner** / **AposLoading** - Loading indicators

### Layout Components
- **AposTable** - Table for displaying data
- **AposTree** - Hierarchical tree display
- **AposSlatList** - List component for "slats" (item cards)
- **AposContextMenu** - Context menu for dropdown actions
- **AposPager** - Pagination component

### Interaction Components
- **AposFile** - File upload component
- **AposLocalePicker** - Locale selection component
- **AposTagList** / **AposTag** - Tag management components

## Admin UI Customization

The `@apostrophecms/ui` module provides the foundation for customizing the admin interface. For complete guidance on customizing the admin UI, refer to the [Customizing the User Interface](/guide/custom-ui.md) guide.

Common customization options include:

- [**Overriding standard components**](/guide/custom-ui.html#overriding-standard-vue-js-components-by-name) by placing files with the same name in project modules
- [**Adding custom field types**](/guide/custom-ui.html#registering-custom-field-types) to extend schema capabilities
- [**Creating custom manager view columns**](/guide/custom-ui.html#adding-custom-columns-to-the-piece-type-manager) to display piece-specific data
- [**Defining custom context menu operations**](/guide/custom-ui.html#adding-custom-context-menu-items) for documents

## Theming

### CSS Variables

ApostropheCMS uses CSS variables for consistent styling across the admin UI. These variables are defined in the `modules/@apostrophecms/ui/ui/apos/scss/global/_theme.scss` file.

#### Colors

```css
--a-primary: #6516dd;           /* Default primary color */
--a-danger: #eb443b;            /* Error/danger color */
--a-success: #00bf9a;           /* Success color */
--a-warning: #ffce00;           /* Warning color */
--a-text-primary: #000;         /* Primary text color */
--a-text-inverted: #fff;        /* Inverted text color */
--a-background-primary: #fff;   /* Primary background color */
```

#### Typography

```css
--a-family-default: -apple-system, system-ui, "BlinkMacSystemFont", "Segoe UI",
  "Roboto", "Helvetica", "Arial", sans-serif;
--a-type-base: 12px;
--a-type-label: 13px;
--a-type-large: 14px;
--a-type-heading: 22px;
```

#### Layout

```css
--a-border-radius: 5px;
--a-border-radius-large: 10px;
--a-box-shadow: 0 3px 13px 4px rgb(0 0 0 / 8%);
```

### Dark Mode Theme

ApostropheCMS has a built-in dark mode theme that can be activated by adding the class `apos-theme-dark` to either the body element or the admin-bar wrapper, as [detailed below](#creating-custom-themes).

To activate dark mode through the standard ApostropheCMS Nunjucks layout, use the `bodyClass` block in your template:

<AposCodeBlock>

```nunjucks
{% extends "layout.html" %}

{% block bodyClass %}apos-theme-dark{% endblock %}
```
  <template v-slot:caption>
    views/layout.html
  </template>
</AposCodeBlock>

::: tip
If you need to add dark mode while keeping any existing body classes added to this same block use:

```nunjucks
{% block bodyClass %}{{ super() }} apos-theme-dark{% endblock %}
```

You can implement a front-end UI toggle between the default light theme and the dark theme by adding and removing the `apos-theme-dark` class.

### Color Themes

ApostropheCMS supports several pre-defined color themes that can be applied to the admin UI. These themes change the primary color used throughout the interface.

Available themes:
Available themes:
- `apos-theme--primary-default` (Purple: <span class="theme-swatch" style="background:#6516dd"></span> #6516dd)
- `apos-theme--primary-blue` (Blue: <span class="theme-swatch" style="background:#0062ff"></span> #0062ff)
- `apos-theme--primary-orange` (Orange: <span class="theme-swatch" style="background:#e65100"></span> #e65100)
- `apos-theme--primary-aqua` (Aqua: <span class="theme-swatch" style="background:#1eacc7"></span> #1eacc7)
- `apos-theme--primary-sun` (Yellow: <span class="theme-swatch" style="background:#f7a704"></span> #f7a704)
- `apos-theme--primary-green` (Green: <span class="theme-swatch" style="background:#00b075"></span> #00b075)
- `apos-theme--primary-pink` (Pink: <span class="theme-swatch" style="background:#fd9ec0"></span> #fd9ec0)

Unlike the dark theme, these classes need to be added to the admin-bar wrapper.

#### Server-Side Theme Configuration

ApostropheCMS has some built-in theme support in the `@apostrophecms/ui` module. To change the primary theme, you simply need to add a schema field named `aposThemePrimary` that passes a theme color as value to either:

1. The global document (applies to all users)
2. The user document (applies to a specific user, overrides global setting)

Depending on your preference, you can add the following to either the `modules/@apostrophecms/global/index.js` or the `modules/@apostrophecms/user/index.js` schema fields:

<AposCodeBlock>

```javascript
export default () => ({
  fields: {
    add: {
      aposThemePrimary: {
        type: 'select',
        label: 'Admin UI Theme',
        choices: [
          { label: 'Default (Purple)', value: 'default' },
          { label: 'Blue', value: 'blue' },
          { label: 'Orange', value: 'orange' },
          { label: 'Aqua', value: 'aqua' },
          { label: 'Yellow', value: 'sun' },
          { label: 'Green', value: 'green' },
          { label: 'Pink', value: 'pink' }
          // Add your custom themes here shown below
          { label: 'Custom', value: 'custom' }
        ],
        def: 'default'
      }
    },
    group: {
      appearance: {
        label: 'Appearance',
        fields: ['aposThemePrimary']
      }
    }
  }
});
```
</AposCodeBlock>

With these schema additions, the existing `getBrowserData` method in the UI module will automatically detect and apply the theme settings to the admin-bar wrapper HTML markup.

### Creating Custom Themes

You can create your own custom theme by:

1. Creating a new SCSS file in your project (e.g., `modules/asset/ui/src/scss/custom-theme.scss`)
2. Adding the modern Sass module imports along with Apostrophe's mixins:

<AposCodeBlock>

```scss
// Required for using the core ApostropheCMS Sass mixins
@use 'sass:math';
@use 'sass:color';

// Import Apostrophe's mixins
@import 'apostrophe/modules/@apostrophecms/ui/ui/apos/scss/mixins/_theme_mixins';

// Custom theme definition
// change "custom" to give your theme a different name
// and pass it in the schema above as value
.apos-theme--primary-custom {
  @include apos-primary-mixin(#ff5722); // Your custom primary color

  // You can also override other CSS variables within this selector
  --a-warning: #ffa000;
  --a-success: #00c853;
  --a-border-radius: 8px;
}

// Optional: Create a dark variant of your custom theme
// Note that the `.apos-theme-dark` can be added to the
// body or to the same wrapper div as the `.apos-theme--primary-XXX`
.apos-theme-dark .apos-theme--primary-custom {
  // Override specific variables for dark + custom combo
  --a-primary-light-40: #ff8a65;
  --a-base-9: #212932;
  --a-base-10: #171d24;
}
```
</AposCodeBlock>

## Related Documentation

- [Customizing the User Interface](/guide/custom-ui.md)
- [Custom Schema Field Types](/guide/custom-schema-field-types.md)
- [Editing Custom Widgets in Context](/guide/editing-custom-widgets-in-context.md)

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/uploadfs
DOC_PATH: reference/modules/uploadfs.md
URL: https://apostrophecms.com/docs/reference/modules/uploadfs
================================================================================
# `@apostrophecms/uploadfs`


 Much as `@apostrophecms/express` configures Express or `@apostrophecms/db` makes a connection to MongoDB, the `@apostrophecms/uploadfs` module creates an instance of the `uploadfs` module and makes it available to the rest of Apostrophe. The `uploadfs` module copies files to a web-accessible location and provides a consistent way to get the URLs that correspond to those files.  It includes S3-based, Azure-based, GCS-based, and local filesystem-based backends and you may supply others. `uploadfs` can also resize, crop, and autorotate uploaded images.

An instance of the `uploadfs` module is available through `self.apos.uploadfs`. This can be used for custom uploads as long as the existing `/attachments` and `/apos-frontend` prefixes are avoided. This is the typical use case. If you really need access to the `@apostrophecms/uploadfs` module itself in order to obtain a new, separate instance of uploadfs for an unusual application, use `self.apos.modules['@apostrophecms/uploadfs']`.

## Selected Options
::: info
These are only selected options. For additional options, see the [documentation](https://www.npmjs.com/package/uploadfs) for the `uploadfs` npm package. While the `uploadfs` module handles image manipulation, these image-related options are configured mostly by the `attachment` module and will be covered by the reference page for that module.

The `uploadfs` module storage options can be configured in several ways. For the Amazon S3 service you can set the most common options through [environment variables](#environment-variables). Options that are common to both attachments and assets can be configured through the `uploadfs` property within the module `options` in `modules/@apostrophecms/uploadfs/index.js`. For less common asset storage use cases, like alternative CDN usage for attachments and assets, additional configuration can be passed in the same manner through the `modules/@apostrophe/asset/index.js` file.

<AposCodeBlock>

```javascript
module.exports = {
  options: {
üëâüèª  uploadfs: {
      storage: 'local'
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/uploadfs/index.js
  </template>
</AposCodeBlock>

The options documentation for this module are split into those that are general storage options and those that are service-specific for local, AWS S3, Microsoft Azure, and Google Cloud Storage. A number of the options are described in greater detail in the official documentation for the specific service and links are provided. If you are using an S3 compatible service, the options provided through the `storage: 's3'` option are a good starting point and may be sufficient, along with the `endpoint` option which is needed to point to an alternative provider.

## General Storage Options
|  Property | Type | Description |
|---|---|---|
| [`cdn`](#cdn) | String \|\| Object | Takes either a string representing the URL of the CDN, or an object with `url` and `enabled` properties. |
| `prefix` | String | Allows prefixing of static assets that share a single, multisite backend bucket |
| [`storage`](#storage) | String \|\| Object  | Storage backend specified as string for built-in solutions or an object for custom storage. |
| [`tempPath`](#temppath) | String | Defaults to `data/temp/uploadfs` relative to the project root. Directory location for creating the temporary folder and files during processing. |

### `cdn`
If you choose to host assets on a CDN, set the `cdn` property value to the URL of the CDN. This property can also take an object with two properties - `url` and `enabled`. The `url` property value is the URL of the CDN and `enabled` takes a boolean which determines if the CDN will be used. This results in Apostrophe outputting URLs that point to the CDN rather than directly to the storage backend. Configuring your CDN of choice to automatically obtain files from your storage backend is your responsibility.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    uploadfs: {
      cdn: {
        url: 'https://wpc.cdnurl.com',
        enabled: true
      }
    }
  }
};

```
  <template v-slot:caption>
    modules/@apostrophecms/uploadfs/index.js
  </template>
</AposCodeBlock>

### `storage` 
This property takes either a string designating one of the built-in storage options to be used, or an object for custom storage needs. Built-in values are `azure` (Microsoft Azure), `gcs` (Google Cloud Storage), `local` (local file storage only), and `s3` (Amazon Simple Storage Service). See the [`s3.js`](https://github.com/apostrophecms/uploadfs/blob/main/lib/storage/s3.js) file for an example of creating a custom storage solution.

### `tempPath`
During processing of files, the `uploadfs` module first copies them to a temporary location until the pipeline is finished. By default this is set to `data/temp/uploadfs` by the `@apostrophecms/uploadfs` module. The `tempPath` property takes a local directory path for creating the `/temp` folder that houses these files.

---

## Local Storage Options
|  Property | Type | Description |
|---|---|---|
| [`disabledFileKey`](#disabledfilekey) | String | Used along with the `enable` and `disable` methods to rename and obfuscate files to block access. |
| [`uploadsPath`](#uploadspath) | String | Changes the storage location of uploadfs on the local filesystem from the default `public/uploads` subdirectory of the project root. |
| [`uploadsUrl`](#uploadsurl) | String | Sets the endpoint for asset access. Defaults to `/uploads`. |

### Minimal Local Example
<AposCodeBlock>

```javascript
module.exports = {
  options: {
    uploadfs: {
      storage: 'local' // this is also the default
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/uploadfs/index.js
  </template>
</AposCodeBlock>

### `disabledFileKey`
This property takes a string (longer is better) and provides an alternative way to make uploaded assets disabled for access when using local storage. Explicitly preventing web access using the `disable` method blocks local file system access by modifying the file permissions which will lead to problems syncing content with `rsync` or similiar commands. This can be circumvented by using a string passed to the `disabledFileKey` property. This value is used with the filename to create an HMAC key hash that is appended to the filename. This is typically sufficient to obfuscate the file name and prevent access. It is recommended that this option be used from the start of the project, but the module exposes a method, [migrateToDisabledFileKey](#migratetodisabledfilekey-callback), to switch later if desired.

### `uploadsPath`
By default, this is set to the `/public/uploads` directory at the root of your project by the `@apostrophecms/uploadfs` module. If desired, you can reassign this to a different directory.

### `uploadsUrl`
By default, this is set to your local apostrophe instance base URL, plus any localization prefix, plus `/uploads` by the `@apostrophecms/uploadfs` module. If desired, you can reassign this to a different directory.

---

## S3 Storage Options
The options listed below are ApostropheCMS specific. Any AWS S3-specific options can be passed as options using the properties listed in the AWS SDK [documentation](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#constructor-property). This option is viable for other storage vendors that use S3-compatible methods, like DigitalOcean or Linode.
|  Property | Type | Description |
|---|---|---|
| [`agent`](#agent) | Object | The Agent object used to perform HTTP requests - passed into the `params.httpOptions`. |
| `bucket` | String | Sets the bucket name. |
| [`contentTypes`](#contenttypes) | Object | Adds additional project asset file extensions, without leading '.', as properties with corresponding mimetype as value. |
| [`endpoint`](#endpoint) | String | Sets the endpoint URI to send requests. |
| `https` | Boolean | Setting this to true forces `https:` transfer to the endpoint. |
| [`noGzipContentTypes`](#nogzipcontenttypes) | Array | Designates file types that should not be gzipped and replaces the default list. |
| [`addNoGzipContentTypes`](#addnogzipcontenttypes) | Array | Adds to the default list of files that should not be gzipped. |
| [`region`](#region) | String | Used to build a standard AWS `endpoint`. |
| `style` | String  | If set to `path` it forces path style URLs for S3 objects - the same as passing `s3ForcePathStyle: true`. |
| `port` | Integer | Sets the port. |
| [`secret`](#secret) | String | Provides the account `secretAccessKey`. |
| [`key`](#key) | String | Provides the account `accessKeyId`. |
| [`token`](#token) | String  | Provides an optional `sessionToken`. |
| [`bucketObjectsACL`](#bucketobjectsacl) | `private` or `read-only` | Can be optionally set to `private` to prevent public download of the asset. |

Also see the (environment variables)[#environment-variables], which are often sufficient to select and configure S3 without any options in the code.

### Minimal S3 Example
<AposCodeBlock>

```javascript
module.exports = {
  options: {
    uploadfs: {
      storage: 's3',
      // Get your credentials at aws.amazon.com
      secret: 'xxx',
      key: 'xxx',
      // Bucket name created on aws.amazon.com
      bucket: 'bucketname',
      // Region name for endpoint
      region: 'us-east-1'
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/uploadfs/index.js
  </template>
</AposCodeBlock>

### `storage` {#s3storage}
The `storage` option should be set to `s3` to use the Amazon Web Services S3 or any other S3-compatible service, like DigitalOcean or Linode.

### `agent`
The `agent` property takes either `http.Agent` or `https.Agent`. This value will be used to set the `params.httpOptions.agent` value for the S3 service object. See the [documentation](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html) for more details.

### `contentTypes`
The `contentTypes` property is populated by default with an object taken from the [`contentTypes.js`](https://github.com/apostrophecms/uploadfs/blob/main/lib/storage/contentTypes.js) file of the module. This object has all valid project file extensions as properties and their mimetype as value. Any object supplied to the `contentTypes` is merged with the existing default object.

### `endpoint`
The `endpoint` option allows setting of an endpoint to which to send requests. For the AWS S3 service it is constructed from the `region` option. However, this option allows for custom URLs for other non-AWS S3-compatible storage services, like DigitalOcean or Linode. This can also be set using an [environment variable](#environment-variables).

### `noGzipContentTypes`
By default, an array of MIME types that should not be gzip compressed is loaded from the `/lib/storage/noGzipContentTypes.js` file in the `uploadfs` npm module. If you pass an array through the `noGzipContentTypes` option it will replace this default list. 

### `addNoGzipContentTypes`
Adding an array of MIME types to the `addNoGzipContentTypes` will result in merging of those MIME types with the existing default array of types that should not be compressed.

### `region`
The `region` option is used to pass a specific AWS S3 region to build the endpoint. The allowed values are listed in the [official documentation](https://docs.aws.amazon.com/general/latest/gr/s3.html). If you are using a third party S3 provider like DigitalOcean, you should specify `endpoint` instead. This can also be set using an [environment variable](#environment-variables).

### `secret`
The `secret` option is used to pass the value of the `secretAccessKey` to the `AWS.Credentials()` credentials object. See the [official documentation](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#constructor_details) for alternative ways to present the credentials. This can also be set using an [environment variable](#environment-variables).

### `key`
The `key` option is used to pass the value of the `accessKeyId` to the `AWS.Credentials()` credentials object. See the [official documentation](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#constructor_details) for alternative ways to present the credentials. This can also be set using an [environment variable](#environment-variables).

### `token`
The `token` option is used to pass the value of the optional `sessionToken` to the `AWS.Credentials()` credentials object. See the [official documentation](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#constructor_details) for alternative ways to present the credentials.

### `bucketObjectsACL`
The `bucketObjectsACL` option sets the access control level (ACL) for files uploaded to AWS S3, with a default of `public-read`. If you want to make your S3 bucket private and serve content through the Amazon CloudFront service, you need to set `bucketObjectsACL: 'private'` to block public access. Additionally, follow the [documentation](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) to ensure your bucket is set up with an Origin Access Control correctly, otherwise, CloudFront will not be able to access it.

---

## Azure Storage Options
See the [Azure documentation](https://docs.microsoft.com/en-us/rest/api/storageservices/) for additional details.
|  Property | Type | Description |
|---|---|---|
| `account` | String | Required. Sets the storage account name. |
| `allowedMethods` | Array | Configures CORS allowed methods. |
| `allowedHeaders` | Array | Configures CORS allowed headers. |
| `allowedOrigins` | Array | Configures CORS allowed origins. |
| `container` | String | Sets the storage container name. |
| [`disabledFileKey`](#azuredisabledfilekey) | String | Required. Works along with the `enable` and `disable` methods to rename and obfuscate files to block access. |
| `exposedHeaders` | Array | Configures the exposure or the CORS response headers. |
| `key` | String | Required. Sets the access key. |
| `maxAgeInSeconds` | Integer | Sets the maximum amount of time the browser should cache the preflight OPTIONS request. |
| [`replicateClusters`](#replicateclusters) | Array |Array of objects to replicate content across a cluster. |

### Minimal Azure Example
<AposCodeBlock>

```javascript
module.exports = {
  options: {
    uploadfs: {
      storage: 'azure',
      account: 'storageAccountName',
      container: 'storageContainerName',
      key: 'accessKey',
      // Always required for Azure
      disabledFileKey: 'a random string of your choosing'
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/uploadfs/index.js
  </template>
</AposCodeBlock>

::: warning
If using Azure as your storage choice, you must always set `disabledFileKey` option. With Azure, the permissions for a single blob (file) can't be changed, so it must be duplicated and renamed to disable web access.

### `storage` {#azurestorage}
The `storage` option should be set to `azure` to use the Microsoft Azure service.

### `disabledFileKey` {#azuredisabledfilekey}
This required property takes a string (generate a random, secure password of at least 8 characters) and provides a way to make uploaded assets disabled for access. This value is used with the filename to create an HMAC key hash that is appended to the filename. This is typically sufficient to obfuscate the file name and prevent access.

### `replicateClusters`
This property takes an array of objects describing individual containers to replicate data across. Each object takes `account`, `container`, and `key` properties.

#### Example
<AposCodeBlock>

```javascript
uploadfs: {
    storage: 'azure',
    replicateClusters: [
      {
        account: 'storageAccountName1',
        container: 'storageContainerName1',
        key: 'accessKey1',
      },
      {
        account: 'storageAccountName2',
        container: 'storageContainerName2',
        key: 'accessKey2',
      },
    ]
}
```
<template v-slot:caption>
   modules/@apostrophecms/uploadfs/index.js
</template>
</AposCodeBlock>

---

## GCS Storage Options
See the [Google Cloud Storage (GCS) documentation](https://googleapis.dev/nodejs/storage/latest/Bucket.html
) for additional details.
|  Property | Type | Description |
|---|---|---|
| `bucket` | String | Sets the bucket name. |
| [`contentTypes`](#gcscontenttypes) | Object | Adds additional project asset file extensions as properties with corresponding mimetype as value. |
| `cachingTime` | Integer | Changes the default 1 hour caching time to a new amount of time, in seconds, for an asset. |
| `endpoint` | String | Sets the endpoint URI to send requests. |
| `https` | Boolean | Setting this to true forces `https:` transfer to the endpoint. |
| `port` | Integer | Sets the port. |
| `validation`| String \|\| Boolean | Method for checking data integrity - 'md5', 'crc32c', or false. |

### Minimal GCS Example
<AposCodeBlock>

```javascript
module.exports = {
  options: {
    uploadfs: {
      storage: 'gcs',
      // Create bucket in the Google Cloud Console
      bucket: 'bucketname',
      // Select your region
      region: 'us-west-2'
    }
  }
};

```
  <template v-slot:caption>
    modules/@apostrophecms/uploadfs/index.js
  </template>
</AposCodeBlock>

### `storage` {#gcsstorage}
The `storage` option should be set to `gcs` to use the Google Cloud Storage service.

### `contentTypes` {#gcscontenttypes}
The `contentTypes` property is populated by default with an object taken from the [`contentTypes.js`](https://github.com/apostrophecms/uploadfs/blob/main/lib/storage/contentTypes.js) file of the module. This object has all valid project file extensions as properties and their mimetype as value. Any object supplied to the `contentTypes` is merged with the existing default object.

---

## Environment variables

Apostrophe exposes a number of environmental variables for easily setting a number of options for the AWS S3 and GCS services.

For the AWS S3 service and similar S3-type services, these variables cover the most common options needed to use the service.

### `APOS_S3_BUCKET`
 The 'APOS_S3_BUCKET' takes the bucket name and is required. Adding a value to this variable will also automatically set the `storage` option to `s3` and enables setting the other S3 options using environment variables. This value will override the value passed in through the corresponding option.

### `APOS_S3_SECRET`
The `APOS_S3_SECRET` variable is required and takes the `secretAccessKey` option for the account. This value will override the value passed in through the corresponding option.
### `APOS_S3_KEY`
The `APOS_S3_KEY` variable is required and takes the `accessKeyId` for the account. This value will override the value passed in through the corresponding option.
### `APOS_S3_REGION`
The `APOS_S3_REGION` variable will be used to set the endpoint and is required when using the AWS S3 service. If using a S3-type service, like DigitalOcean or Linode` it is optional and `APOS_S3_ENDPOINT` is required. This value will override the value passed in through the corresponding option.

### `APOS_S3_ENDPOINT`
The `APOS_S3_ENDPOINT` variable is used with S3-type services offered by vendors other than AWS and is required when using these types of services. This value will override the value passed in through the corresponding option.

### `GOOGLE_APPLICATION_CREDENTIALS`
The GCS service `storage` option requires that the `GOOGLE_APPLICATION_CREDENTIALS` environment variable be set to the location of a service account file obtained from the Google Cloud Console.

#### Example
```sh
export GOOGLE_APPLICATION_CREDENTIALS=./projectname-f7f5e919aa79.json
```

## Featured methods

### `copyIn(localPath, path, options, callback)`
This method is used for handling uploads by the various storage types exposed by `uploadfs`. It is used by both the `asset` and `attachment` modules, but can also be used to handle files that aren't covered by the `attachment` module. The `copyIn()` method takes a local filename through the `localPath` argument. This file is copied to a uploadfs path specified by the `path` argument. Any necessary intermediate folders that don't exist will be created. The optional `options` argument is used to pass additional options to the selected storage. Finally, the callback receives any errors. It is often useful to wrap this function in  `promisify` to convert it to a promise-based function.

#### Example
```javascript
async handleFile( file, uploadfsPath) {  
  const copyIn = require('util').promisify(self.uploadfs.copyIn);
  try {
    await copyIn(file, uploadfsPath)
  } catch (e) {
    console.error(e);
};  
```

### `copyOut(localPath, path, options, callback)`
Much like the `copyIn` method, the `copyOut` method takes a `localPath` and a uploadfs `path` and copies the file back from uploadfs to the local file system. This is used when an existing asset needs to be updated, such as supplying additional cropping or other image processing. It should be used sparingly because it can result in poor storage service performance. Like the `copyIn` method, wrapping `copyOut` in `promisify` is often useful.

#### Example

```javascript
async modifyImage( file, uploadfsPath) {  
  const copyOut = require('util').promisify(self.uploadfs.copyOut);
  const copyIn = require('util').promisify(self.uploadfs.copyIn);
  try {  
    await copyOut(file, uploadfsPath);
    await newImageCrop(file);
    await copyIn(file, uploadfsPath);
   } catch (err) {
    console.error(err);
  }
};
```

### `migrateFromDisabledFileKey(callback)` {migratefromdisabledfilekey}
The `migrateFromDisabledFileKey` function provides a way to switch any file previously disabled using the `disabledFileKey` option to use the `disable` method instead. Note: the `disabledFileKey` option should be removed before invoking this method.

#### Example

```javascript
self.apos.uploadfs.migrateFromDisabledFileKey(function(e) { ‚Ä¶ });
```

### `migrateToDisabledFileKey(callback)` {migratetodisabledfilekey}
The `migrateToDisabledFileKey` function provides a way to switch any file previously disabled using the`disable` method to use the `disabledFileKey` option. Note: `disabledFileKey` must be set before invoking this method.

#### Example

```javascript
self.apos.uploadfs.migrateToDisabledFileKey(function(e) { ‚Ä¶ });
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/util
DOC_PATH: reference/modules/util.md
URL: https://apostrophecms.com/docs/reference/modules/util
================================================================================
# `@apostrophecms/util`

**Alias:** `apos.util`

<AposRefExtends :module="$frontmatter.extends" />

The `@apostrophecms/util` module contains utility methods and tools that do not clearly belong in any other module.

## Options

|  Property | Type | Description |
|---|---|---|
|`logger` | Function | Deprecated in favor of the new option exposed in the `@apostrophecms/logging` module. A function that accepts the Apostrophe instance object (`self.apos`) and returns an object with at least `info`, `debug`, `warn`, and `error` methods for logging messages. Similarly named `util` module methods use these functions. See [the default logger function](https://github.com/apostrophecms/apostrophe/blob/main/modules/@apostrophecms/util/lib/logger.js) for an example. Overrides should be written with support for substitution strings. See the [`console.log` documentation](https://developer.mozilla.org/en-US/docs/Web/API/Console/log). |
| `stackLimit` | Integer | Defaults to 50. This is the maximum size of the asynchronous stack, tracking active widget loaders, async components, and relationship loaders. |

## Featured methods

The following methods belong to this module and may be useful in project-level code. See the [source code](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/util/index.js) for all methods that belong to this module.
<!-- Some are used within the module and would just create noise here. -->

Because this module has an alias, you can call these from another module from the alias path. For example, `self.apos.util.log()`.

### Logging utilities

The descriptions for `log`, `info`, `debug`, `warn`, and `error` below reflect default behavior. See the `logger` option description above for information about custom behavior. The `info`, `debug`, `warn`, and `error` methods have been deprecated going forward in favor of the structured logging methods `logInfo`, `logDebug`, `logWarn`, and `logError`, respectively, available on every module.

#### `log(msg)`

Logs a message or input, `msg`. The default implementation wraps `console.log` and passes on all arguments, so substitution strings may be used.

If a `logger` option function does not include a `log` function, the `info` method will be used. This allows an instance of [bole](https://www.npmjs.com/package/bole) or similar loggers to be passed to the `logger` option.

#### `info(msg)`

Logs a informational message. The default implementation wraps `console.info` and passes on all arguments, so substitution strings may be used.

#### `debug(msg)`

Logs a debugging message. The default implementation wraps `console.debug` (or `console.log` if that's unavailable) and passes on all arguments, so substitution strings may be used.

#### `warn(msg)`

Logs a warning message. The default implementation wraps `console.warn` and passes on all arguments, so substitution strings may be used.

#### `warnDev(msg)`

Identical behavior to [`apos.util.warn`](#warn-string) except that the warning is not displayed if `process.env.NODE_ENV` is `production`. It will log the message every time it is called. See `warnDevOnce()` for a quieter version when messages may become repetitive.

#### `warnDevOnce(name, msg)`

Identical to `apos.util.warnDev`, except that the warning is only displayed once for each registered `name`. `name` should be a string not already used in an unrelated `warnDevOnce` call.

Example:
```javascript
apos.util.warnDevOnce('github-connection-error', 'There was an error connecting to your Github account.')
```

The warnings will be allowed in production mode if the command line option `--all-[name]` is present when running the app (or CLI task): `node app --all-github-connection-error`.

All warnings for a particular name will be *muted* if the option `--ignore-[name]` is used: `node app --ignore-github-connection-error`.

#### `error(msg)`

Logs an error message. The default implementation wraps `console.error` and passes on all arguments, so substitution strings may be used.

### String manipulation methods

#### `globalReplace(source, target, replacement)`

Globally replaces a target string within a source string. This allows global string replacement without using regular expressions. It replaces the original `source` string and does not return a value.

Arguments are:

- **`source`**: A string that will be replaced after updating `target` string segments.
- **`target`**: A string that should be replaced every time it appears in `source`.
- **`replacement`**: A string used to replace `target` wherever it appears in `source`.

#### `truncatePlaintext(string, length, pruneString)`

Truncate a `string` at the specified number of characters (`length`) without breaking words if possible. `pruneString` will be used at the end of the result as long as it does not force the end result to be longer than `length`. `'...'` will be used if `pruneString` is omitted.

See the [Underscore.String.js `prune` function](https://gabceb.github.io/underscore.string.site/#prune), of which this is a copy (replacing RegExp with XRegExp for better UTF-8 support).

#### `escapeHtml(string, options)`

Escape a plaintext `string` correctly for use in HTML. `options` is an object of options, but may be omitted.

If `{ pretty: true }` is in the `options` object, new lines become `br` tags, and URLs become links to those URLs. Otherwise this does basic escaping. For backwards compatibility, if the second argument is truthy and not an object, `{ pretty: true }` is assumed.

If `{ single: true }` is in the `options` object, single-quotes are escaped, otherwise double-quotes are escaped.

#### `htmlToPlaintext(htmlString)`

A method to convert a string of HTML to simple plain text (no rich text indicators). This is meant for basic HTML conversion, such as converting the contents of a piece's rich text widget teaser into unformatted text to be displayed on the index page. It returns a string of plain text.

#### `capitalizeFirst(string)`

`capitalizeFirst` accepts a string argument and returns the string with the first letter capitalized.

#### `cssName(camelString)`

This method is used to convert "camel case" strings (`spiderMan`) into CSS-friendly "kebab case" (`spider-man`). It returns the converted string.

#### `camelName(string)`

This method converts a string to camel case and returns the converted string. Any characters that are not alphanumeric will be removed and the following character (if alphanumeric) will be capitalized.

#### `addSlashIfNeeded(path)`

`addSlashIfNeeded()` accepts a string and returns it with a slash at the end only if there is not one already. It is useful for ensuring uniform URL paths in code.

#### `slugify(string, options)`

This is a wrapper for the [sluggo](https://www.npmjs.com/package/sluggo) utility. It accepts a string and options object. It returns the string lower cased and with spaces and non-alphanumeric characters replaced with a dash (by default). See the sluggo documentation for other options.

#### `sortify(string)`

`sortify` does the same thing as `slugify`, but whitespace and non-alphanumeric characters are replaced with a single space instead of a dash. This is used to make strings uniform for sorting, including for populating document properties such as `titleSortified` that store the uniform version.

### Other utility methods

#### `generateId()`

Returns a unique identifier (ID) for a new page or other object. IDs are generated with the `cuid` module which prevents collisions and ensures a certain level of complexity. This should not be used for passwords, however.

#### `md5(string)`

Perform an md5 checksum on a string. Returns a hex string.

#### `async md5File(filepath)`

Perform an md5 checksum on a file at a given path. Async. Returns a Promise that resolves to a hex string.

#### `async fileLength(filepath)`

Accepts a file path and returns a Promise that resolves to the file size in bytes.

#### `clonePermanent(object, keepScalars)`

Clone the given object recursively, discarding all properties whose names begin with underscores (`_`) except for `_id`. Returns the cloned object.

This removes the output of relationships and other dynamic loaders, so that dynamically available content is not stored redundantly in MongoDB. Object values that are `Date` objects are cloned as such. All other non-JSON objects are cloned as plain JSON objects.

If `keepScalars` is true, properties beginning with underscores are kept as long as they are not objects. This is useful when using `clonePermanent` to limit JSON inserted into browser attributes, rather than filtering for the database. Preserving simple string properties like `_url` is usually a good thing in the former case.

If the `object` argument is an array, the clone is also an array. Arrays are cloned as such only if they are true arrays (`Array.isArray()` returns `true`).

#### `orderById(ids, items, idProperty)`

`ids` should be an array of identifiers (`_id` properties, by default). The elements of the `items` array, which should be the result of a mongodb query, are returned in the order specified by the `ids` array.

This is useful after performing an `$in` query with MongoDB (`$in` does _not_ sort its results in the order given). Any IDs that do not actually exist for an item in the `items` array are not returned, and vice versa. You should not assume the result will have the same length as either array.

Optionally you may specify a property name other than `_id` as the third argument (`idProperty`). You may use dot notation in this argument.

#### `isAjaxRequest(req)`

Returns `true` if the `req` request object is an AJAX request (`req.xhr` is set, or `req.query.xhr` is set to emulate it) _and_ Apostrophe's main content area refresh mechanism is not in play (`req.query.aposRefresh` is not `'1'`).

#### `insensitiveSort(strings)`

Sort an array of strings (`strings`) in place, comparing strings in a case-insensitive way. It does not return a value.

#### `insensitiveSortByProperty(objects, property)`

Sort an array of objects (`objects`) in place, based on the value of the given `property` of each object, in a case-insensitive way. It does not return a value.

#### `findNestedObjectById(object, _id, options)`

Within an `object` (typically a full content document or widget object), find and return a nested object with the given `_id` property. This works regardless of the target object's nesting depth. Useful to locate a specific widget within a document.

Pass `{ ignoreDynamicProperties: true }` as the `options` argument to skip objects set on dynamic properties (those starting with `_`) during this check. This is useful to ignore documents loaded via relationships.

#### `findNestedObjectAndDotPathById(object, _id, options)`

Similar to `findNestedObjectById`. Within an `object` (typically a full content document or widget object), find a nested object with the given `_id` property. This works regardless of the target object's nesting depth. Useful to locate a specific widget within a document.

Unlike `findNestedObjectById`, **this returns an object with two properties:**
- `object`: The target object as returned by the other method.
- `dotPath`: The dot notation path to the target object.

Pass `{ ignoreDynamicProperties: true }` as the `options` argument to skip objects set on dynamic properties (those starting with `_`) during this check.

#### `getManagerOf(object)`

Given a widget or document object, this returns the appropriate manager module.

#### `get(obj, path)`

Returns the value at the given `path` from the object or array `obj`.

`path` supports dot notation like MongoDB. If the first dot notation segment of `path` begins with `@xyz` (or `@` followed by any alphanumeric value) the nested object within `obj` with an `_id` property equal to `xyz` is found and returned, no matter how deeply nested it is.

#### `set(obj, path, val)`

Set a value (`val`) at the provided `path` within the object or
array `obj`, mutating `obj`.

`path` supports dot notation like MongoDB. If the first dot notation segment of `path` begins with `@xyz` (or `@` followed by any alphanumeric value) the nested object within `obj` with an `_id` property equal to `xyz` is located, no matter how deeply nested it is. If `@xyz` is the full `path` argument, the nested object is replaced with `val`. If there are further components via dot notation, they are used to locate the final location for `val`.

The `@` syntax works only for locating nested objects. You may not pass `@abc` where `abc` is the `_id` of `obj` itself.

#### `cloneReq(req, properties)`

Returns a *new* `req` object with the properties of the original plus any in the optional `properties` parameter. Used when a request object with one change is desired, such as `mode: 'published'`. Avoids the need to push and pop properties of the original `req`. Also available as `req.clone(properties)`.

#### `runPlayers(el)`

Runs all the widget players that have not been run in the whole document. Passing an optional DOM element to the `el` parameter will restrict the search for unplayed players to that element only. This function is useful when dynamic content has been added after `apos.util.onReady` has fired.

## Template helpers

Template helpers are methods available for use in template files. Because this module has an alias, you can call these in templates using the alias path. For example, `apos.util.log()`.

Some of these utility helpers replicate JavaScript APIs that are not available in Nunjucks templates natively.

#### `slugify(string, options)`

A wrapper of the [`slugify()` method](#slugify-string-options) described above.

### `log(msg)`

A wrapper of the [`log()` method](#log-msg) described above.

### `generateId()`

A wrapper of the [`generateId()` method](#generateid) described above.

### `isCurrentYear(d)`

Returns `true` if the `Date` object (`d`) refers to a date in the current year.

### `isUndefined(val)`

Returns `true` if the value `val` is strictly equal to `undefined`.

### `isFalse(val)`

Returns `true` if the value `val` is strictly equal to `false`.

### `isFunction(val)`

Returns `true` if the value `val` is a function (`typeof val === 'function'`).

### `startCase(str)`

Returns a string `str` to start case (first letter of each word is capitalized).Used to make default labels out of camel case property names.

### `eqStrict(a, b)`

Returns `true` if values `a` and `b` are strictly equal. The Nunjucks template syntax does not recognize `===` to test this.

### `contains(list, val)`

Returns `true` if the list `list` contains the specified value, `val`. `list` may be an array, object, or string (to look for a substring). This uses the [lodash `includes` method](https://lodash.com/docs/4.17.15#includes).

If `val` is an array, this returns `true` if the list contains *any of* the specified values.

### `containsProperty(list, prop)`

Returns `true` if the list contains *at least* one object with the named property, `prop`. `list` may be an array, object, or string (to look for a substring). This uses the [lodash `has` method](https://lodash.com/docs/4.17.15#has).

If `list` is a single object, this function returns `true` if that object has a property `prop`.

## Object and array helpers

### `inspect(obj)`

Logs the properties of an object, `obj`, in detail. Invokes the Node.js [`util.inspect()`](https://nodejs.org/docs/latest-v8.x/api/util.html#util_util_inspect_object_options) method on the object, to a depth of 10.

### `reverse(arr)`

Returns the array, `arr`, in reverse order.

### `beginsWith(list, val)`

If the `list` argument is a string, returns `true` if it starts with the value `val`. If the `list` argument is an array, returns true if *at least one* of its items begins with `val`.

### `find(arr, prop, val)`

Finds and returns the *first* array (`arr`) item, if any, that has the specified value (`val`) for the specified property (`prop`).

### `filter(arr, prop, val)`

Finds and returns *all* array (`arr`) items, if any, that have the specified value (`val`) for the specified property (`prop`).

### `reject(arr, prop, val)`

Returns the array (`arr`), *filtering out* any items, if any, that have the specified value (`val`) for the specified property (`prop`).

### `filterNonempty(arr, prop)`

Finds and returns *all* array (`arr`) items, if any, that have *truthy values* for the specified property (`prop`).

### `filterEmpty()`

Finds and returns *all* array (`arr`) items, if any, that have *falsy values* for the specified property (`prop`).

### `isEmpty(obj)`

Returns `true` if the specified array or object (`obj`) is considered empty Objects are empty if they have no own enumerable properties. Arrays are considered empty if they have a length of 0.

### `pluck(arr, prop)`

Given an *array of objects* (`arr`) with the given property (`prop`), return an array with the value of that property for each object.

### `omit(obj, paths)`

Given an object (`obj`), returns an object without the named path or property paths (`paths`). `paths` may be a string or array of strings.

### `difference(arr1, arr2, prop)`

Given the arrays `arr1` and `arr2`, this returns a subset of elements in `arr1` that *do not* appear in `arr2`. If `arr2` is not an array it is treated as an empty array.

If `prop` is present, then that property of each object in `arr1` is compared to `arr2` items. This is useful when `arr1` contains field choice objects (e.g., in [select fields](/reference/field-types/select.md#choices-configuration)) with a `value` property, while `arr2 `just contains actual values.

A deep comparison is performed with the [lodash `isEqual` method](https://lodash.com/docs/4.17.15#isEqual).

### `concat(arr1, arr2, /* arr3, arr4... */)`

Concatenate all of the array and/or value arguments into a single array. If an argument is an array, all of its elements are individually added to the
resulting array. If an argument is a non-array value, it is added directly to the array.

### `groupBy(items, key)`

Returns an object that groups items in a collection (`items`) by the property named by `key` on each of the values.

If the first item in `items` has an array on the property named by `key`, this returns an object that groups each item by their shared array values.

### `object(/* key1, value1, key2, value2... */)`

Given a series of alternating keys and values, this function returns an object with the keys set to the following values. For instance, `apos.util.object('name', 'bob')` returns `{ name: 'bob' }`. This is useful since Nunjucks does not allow you to create an object with a property whose name is unknown at the time the template is written.

### `merge(/* obj1, obj2, obj3... */)`

This helper accepts any number of object arguments. It then merges them into a new object and the returns resulting object. If several objects have a property, the last object passed in wins.

If any argument is `null`, it is skipped gracefully. This allows you to pass in an unexamined variable without checking if it is `null`.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Core Modules > @apostrophecms/widget-type
DOC_PATH: reference/modules/widget-type.md
URL: https://apostrophecms.com/docs/reference/modules/widget-type
================================================================================
# `@apostrophecms/widget-type`

<AposRefExtends :module="$frontmatter.extends" />

This module is the foundation for all widget types in Apostrophe, including the [core widgets](../../guide/core-widgets.md) as well as [custom widgets](../../guide/custom-widgets.md). It is not typically configured or referenced in project code directly since each widget type should be managed independently in most cases. For example, the options documented below would be configured on a custom widget type, e.g., `article-widget`, rather this widget type base module.

The only reason to configure this module directly would be to apply the changes to *every* widget type, including those in Apostrophe core (e.g., `@apostrophecms/image-widget`).

### `widgetOperations`

This configuration cascade allows you to define custom operations that appear in the menu that appears when editing the widget on page. These operations can trigger modals, perform actions, or be conditionally displayed based on widget state and user permissions.

The `widgetOperations` should be a function that takes `self` and `options` as parameters and returns an object specifying operations to add to the widget context menu:

```javascript
widgetOperations(self, options) {
  return {
    add: {
      operationName: {
        // Required properties
        label: 'Label text or i18n key',   // Text displayed in the menu
        modal: 'ComponentName',            // Modal component to open when clicked

        // Required for addition to the primary display menu
        icon: 'icon-name',                 // Icon to display (needs to be registered already)

        // Optional properties
        tooltip: 'Tooltip text or i18n key', // Text shown on hover

        // Conditional display based on widget state
        if: {
          // MongoDB-style query conditions against the widget
          'fieldName': value,              // Simple equality check
          'nestedField.0': { $exists: true }, // Check if field exists
          'someField': { $ne: 'value' },   // Not equal check
          '$or': [                         // Logical OR
            { condition1: value1 },
            { condition2: value2 }
          ],
          '$and': [                        // Logical AND
            { condition1: value1 },
            { condition2: value2 }
          ]
        },

        // Conditional display based on user permissions
        permission: {
          action: 'edit|delete|publish|view', // Required permission action
          type: 'article|page|etc'            // Document type the permission applies to
        }
      }
    }
  };
}
```
#### Modal Interaction
When a user clicks on an operation that specifies a modal property, the modal component will be launched with the following props:
```javascript
{
  widget,       // The current widget instance
  widgetSchema  // The schema for the widget
}
```

To update the original widget from your modal, you must emit a `modal-result` event before closing:
```javascript
// Inside your modal component emit the updated data
this.$emit('modal-result', widgetData);
```

Note the following important considerations:

  - The widget's `type` and `_id` properties must not be changed.
  - If the modal closes without emitting a `modal-result` event, the original widget remains unchanged.

**Example:**

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Image'
  },
  widgetOperations(self, options) {
    const {
      relationshipEditor = 'AposImageRelationshipEditor',
      relationshipEditorLabel = 'apostrophe:editImageAdjustments',
      relationshipEditorIcon = 'image-edit-outline'
    } = options.apos.image.options || {};

    return {
      add: {
        adjustImage: {
          label: relationshipEditorLabel,
          icon: relationshipEditorIcon,
          modal: relationshipEditor,
          tooltip: relationshipEditorLabel,
          if: {
            '_image.0': {
              $exists: true
            }
          }
        }
      }
    };
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/image-widget/index.js
  </template>
</AposCodeBlock>

This example adds an "Adjust Image" operation to the image widget's context menu that appears only when an image has been selected, and opens a modal for editing image adjustments when clicked.

## Options

::: info
These are options to *the module itself*, so they apply to *every* instance of the widget. They are separate from the options that can be passed when adding the widget to an area field, and from the template options that be passed via the `with` keyword when inserting an area in a template.

|  Property | Type | Description |
|---|---|---|
| [`className`](#classname) | String | Core widgets apply it to themselves if set. |
| [`components`](#components) | Object | Vue components to be used when editing. |
| [`contextual`](#contextual) | Boolean | The widget is edited directly on the page, not in a modal. |
| [`defaultData`](#defaultdata) | Any | Default value of a contextual widget. |
| [`deferred`](#deferred) | Boolean | This widget type should load last. |
| [`icon`](#icon) | String | Icon name. |
| [`initialModal`](#initialmodal) | Boolean | Determine whether to display modal when added to page. |
| [`label`](#label) | String | Identifies this widget in a list of widget types. |
| [`neverLoad`](#neverload) | Array | Widget types never loaded recursively by this widget. |
| [`neverLoadSelf`](#neverloadself) | Boolean | The widget should never recursively load itself. |
| [`preview`](#preview) | Boolean | Allow for in-context preview during widget edit. |
| [`scene`](#scene) | String | **Deprecated.** Can specify that this widget type requires logged-in assets. |
| [`template`](#template) | String | The Nunjucks template name to render. |
| [`width`](#width) | String | Define the size of the widget modal. |
| [`origin`](#origin) | String | Define the position of the widget modal (left or right). |

### `className`

All of the core widget type modules of Apostrophe, such as `@apostrophecms/image`, will apply the class name set by this option to their outer wrapper element if configured for that widget type module and not overridden when the widget is configured as part of an area. Since Apostrophe is unopinionated on the front end, there is no default value.

Custom widgets have no default template, but may choose to support the same pattern:

``` nunjucks
{# in a custom widget.html file #}

{% if data.options.className %}
  {% set className = data.options.className %}
{% elif data.manager.options.className %}
  {% set className = data.manager.options.className %}
{% endif %}
<div {% if className %} class="{{ className }}"{% endif %}>
  ...
</div>
```

### `components`

If present, the `components` option must be an object and is consulted to determine the name of the Vue component to be used for editing, via its `widgetEditor` subproperty. If the `contextual` option is set to `true`, then the component must implement the [contextual editing pattern](../../guide/editing-custom-widgets-in-context.md). Otherwise it must implement a modal dialog box implementing the same pattern as the standard widget editor dialog box (the `AposWidgetEditor` Vue component), which is usually not necessary as it is simpler to add existing and custom schema fields to be displayed by the existing dialog box.

### `contextual`

When the `contextual` option is set to `true`, an edit button is not displayed for the widget, and the widget is not edited in a dialog box according to a schema of fields. Instead, the widget is edited directly on the page.

To support this, the widget must implement the [contextual editing pattern](../../guide/editing-custom-widgets-in-context.md).

Defaults to `false`.

### `defaultData`

The `defaultData` option may contain an object providing defaults for contextually edited widgets. This is required for contextually edited widgets because they do not always use the `fields` section. Normal widgets that use the usual dialog box to edit schema fields may rely on the `def` property of each field instead. There is no default value.

### `deferred`

Widget types may contain `relationship` and `relationshipReverse` fields that load other documents. By default this is done in the order the widgets are encountered when loading the page, with requests relating to the same type of widget grouped together for performance. This is a recursive process. Widget types that specify `deferred: true` will resolve their "loaders" at the very end of the process, after all other widget types and their relationships have been recursively loaded. This is beneficial for widget type modules like `@apostrophecms/image-widget` because they can be efficiently grouped together in a single database call. Defaults to `false`.

### `icon`

The name of the icon to be displayed for this widget type in a menu of widget types. This icon name must correspond to an icon loaded via [the `icons` module section](/reference/module-api/module-overview.md#icons). If not configured the widget type is listed without an icon.

### `initialModal`

The `initialModal` option is set to `true` by default. If set to `false`, it will prevent the initial modal from opening when a widget is added to the area.

### `label`

The label to be displayed for the icon in a menu of widget types and in certain other contexts in the UI. This should be brief but informative and should be capitalized, like `Slideshow`. By default it is derived from the module name, but we recommend configuring an explicit label.

### `neverLoad`

This option specifies an array of widget types that should never be loaded recursively by this widget type. While documents that contain those widget types might be loaded by relationships, additional relationships within those widget types will not be loaded. This can be a helpful guard against runaway recursion and the associated performance hit. There is no default because the default setting of [`neverLoadSelf`](#never-load-self) solves the runaway recursion problem for most widgets. However this option can further improve performance if certain widget types have relationships of their own, might be present via relationships specified for this widget, and are not necessary to present this widget.

### `neverLoadSelf`

If this option is set to `true`, and the widget has relationships with documents that contain more widgets of the **same** type, those widgets will **not** load their own relationships. This option defaults to `true`, which is an effective guard against runaway recursion and performance problems. Disabling this option should be done with care to ensure infinite loops do not become possible when loading the page.

### `preview`

Defaults to true. When set to true, widgets update in real time as edits are made, helping editors immediately see their impact. Note that new widgets will not appear until all required fields are completed. The editing modal will attempt to open without overlapping the widget, automatically positioning itself to the left or right as needed.

Setting this option globally enables the behavior for all widgets. To enable or disable it for specific widgets only, set the option in the individual widget module at project level.

### `scene`

**Deprecated.** If this option is set to `user`, Apostrophe will load all of the JavaScript associated with the logged-in editing experience when this widget type is present. Since the admin UI is primarily designed for editors and not for the fast page load time, we do not recommend this approach and may remove this option in a future release of ApostropheCMS. By default this option is not set.

### `template`

The name of the template in the `views` folder of the module that should be rendered to display the widget. This option defaults to `widget`, and it is generally not necessary to change it.

### `width`

The size of the widget modal can be configured via this option:
- `undefined` (default): the widget modal width is set to 540px.
- `"half"`: the widget modal takes 50% of the screen.
- `"two-thirds"`: the widget modal takes 66% of the screen.
- `"full"`: the widget modal takes 100% of the screen.

Any other value will not impact the width of the modal, resulting in keeping the default width.

No matter what, the widget modal width will take 100% of the screen for screens with a width below 800px.

### `origin`

Choose the side from where the widget modal will open:
`left` or `right` (default).

## Related documentation

- [Core widgets](/guide/core-widgets.md)
- [Custom widgets](/guide/custom-widgets.md)

## Featured methods

### `getBrowserData(req)`

This method returns an object of properties to be exposed on the browser side. If the module name is `hero-widget`, then this data is exposed as `window.apos.modules['hero-widget']`.

Since the default implementation exposes essential information, always use `extendMethods` to extend it, like this:

``` js
extendMethods(self) {
  return {
    getBrowserData(_super, req) {
      return {
        ..._super(req),
        newProperty: value
      };
    }
  };
}
```

### `async output(req, widget, options, _with)`

Apostrophe invokes this method to render the widget. In most cases it is best to provide a `widget.html` template and rely on the default implementation of this method. However it is possible to override this method to render a widget in an entirely different way. The method must return a string of markup already marked as safe. If a custom implementation does not use Nunjucks then it may be returned as safe with the following code:

``` js
return self.apos.template.safe(string);
```

The `widget` argument contains the widget object with its schema fields, the `options` argument contains any options configured for this widget in the relevant `area` field, and the `_with` argument contains any template-level options passed via the `with` keyword.

### `addSearchTexts(widget, texts)`

This method is called to make the text of the widget available to Apostrophe's built-in search features. If the widget relies on schema fields for its content then it should not be necessary to override this method. However widget type modules like `@apostrophecms/rich-text-widget` that do not use fields will need to provide their own implementation, like this:

``` js
methods(self) {
  return {
    addSearchTexts(item, texts) {
      texts.push({
        weight: 10,
        text: self.apos.util.htmlToPlaintext(item.content),
        silent: false
      });
    }
  };
}
```

Currently texts with weights greater than `10` are available as part of `autocomplete` search, which affects the "Manage Pieces" dialog box. Texts marked `silent` impact search results but are not included in the `searchSummary` property of the overall document.

### `sanitize(req, input, options)`

When the user edits a widget and the browser attempts to save that change, Apostrophe invokes this method to sanitize the user input. If the widget relies on schema fields, it is usually not necessary to override this method. It is most often overridden in modules like `@apostrophecms/rich-text-widget` that have special needs like sanitizing HTML markup. This method receives the Express request (`req`), an object representing a new value for the widget which contains untrusted data from the user (`input`), and the options configured for this widget type in the relevant `area` field (`options`). The return value must be an object and is stored as the new value of the widget, along with certain automatically-supplied properties like `type` and `_id` that this method does not need to concern itself with.

### `load(req, widgets)`

::: tip
**The standard version of this method always automatically loads any `relationship` fields defined in your widget's schema.** You **do not** need to implement a custom `load` method to load relationship fields. Overriding this method is to be considered only when you want something unusual to happen, beyond loading ordinary relationships. If you don't see the data you are expecting for nested relationships, you may need to configure the [`withRelationships`](../field-types/relationship.md#populating-nested-relationships-using-withrelationships) property of your widget's `relationship` fields.

Apostrophe invokes the `load` method to load or compute any additional, dynamic properties of the widget on the fly. To create an opportunity for optimizations, the method is passed an array which may contain any number of widgets of this module's type.

Those choosing to override the method to perform additional loading of another kind should use `extendMethods` to invoke the original version as well, unless `relationship` and `reverseRelationship` fields are guaranteed to be absent.

A useful extension of the `load` method might look like:

```javascript
fields: {
  add: {
    zip: {
      type: 'string',
      label: 'Zip Code',
      required: true
    },
    // Other fields may appear here, including relationship fields
  }
},
extendMethods(self) {
  return {
    load(_super, req, widgets) {
      // Call the original, otherwise we get no relationship fields
      await _super(req, widgets);
      for (const widget of widgets) {
        widget._weather = await self.fetchWeather(req, widget);
      }
    }
  }
},
methods(self) {
  return {
    async fetchWeather(req, widget) {
      const result = await fetch('https://query-a-weather-api-somewhere.com?' + new URLSearchParams({
        zip: widget.zip
      });
      return result.json();
    }
  }
}
```

Custom reimplementations that do not have any special optimizations for more than one widget in the array must still take care to loop over `widgets` and load appropriate data for all of them.

There is no return value. The related documents are attached to the widget objects via temporary properties (properties whose names start with `_`, which tells Apostrophe that they should not be stored back to the database at save time).

As an alternative, consider invoking [async components](../../guide/async-components.md) from `widget.html`. Async components are easier to understand and will run only if the template elects to call them in a particular case, which can sometimes be more efficient.

## Module tasks

### `list`

Full command: `node app [widget-type-module-name]:list`

This task generates a list of documents that contain the widget type in question, along with a "dot path" to the widget within the document. It is intended as a debugging tool. For instance:

```bash
node app @apostrophecms/rich-text-widget:list
```

Will list all of the rich text widgets on the site.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types
DOC_PATH: reference/field-types/index.md
URL: https://apostrophecms.com/docs/reference/field-types/
================================================================================
# Schema Field Type Reference

See below for a list of all of the field types available in Apostrophe along with a brief description of their input. Click through to each for a complete description of its function, properties, and reference code to help you use them in your project.

| Field | Input Description |
|-------|-------------|
|[area](/reference/field-types/area.md) | One or more content widgets ([glossary entry](/reference/glossary.md#area))  |
|[array](/reference/field-types/array.md) | An array of structured content using its own [field schema](/reference/glossary.md#schema) |
|[attachment](/reference/field-types/attachment.md) | File upload |
|[boolean](/reference/field-types/boolean.md) | `true` or `false` |
|[box](/reference/field-types/box.md) | Field for authoring CSS box-model values |
|[checkboxes](/reference/field-types/checkboxes.md) | Multi-select checkbox options |
|[color](/reference/field-types/color.md) | Color selection |
|[date](/reference/field-types/date.md) | Date entry, stored in  YYYY-MM-DD format |
|[email](/reference/field-types/email.md) | Email address  |
|[float](/reference/field-types/float.md) | A floating point number |
|[integer](/reference/field-types/integer.md) | A whole number, whether positive or negative |
|[object](/reference/field-types/object.md) | A sub-object of structured content using its own [field schema](/reference/glossary.md#schema) |
|[oembed](/reference/field-types/oembed.md) | Media URL to be embedded via [the oEmbed format](https://oembed.com/) |
|[password](/reference/field-types/password.md) | Text entry that obscures input |
|[radio](/reference/field-types/radio.md) | Single value selection with a radio input interface |
|[range](/reference/field-types/range.md) | A floating point number with a sliding interface |
|[relationship](/reference/field-types/relationship.md) | One or more related content docs (pieces or pages) |
|[relationshipReverse](/reference/field-types/relationship-reverse.md) | Reveals the "other side" of a `relationship` |
|[select](/reference/field-types/select.md) | Single value selection with a dropdown interface |
|[slug](/reference/field-types/slug.md) | Text string value that is converted on save to lowercase and hyphenated |
|[string](/reference/field-types/string.md) | Simple text string |
|[time](/reference/field-types/time.md) | Time entry, stored in HH:MM:SS format |
|[url](/reference/field-types/url.md) | Text input requiring URL structure |
|[dateAndTime](/reference/field-types/dateAndTime.md) | A toggle button and two inputs for date and time, stored in ISO 8601 format `YYYY-MM-DDTHH:MM:SSZ` |

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > area
DOC_PATH: reference/field-types/area.md
URL: https://apostrophecms.com/docs/reference/field-types/area
================================================================================
# `area`

An `area` field allows editors to add, edit, and arrange a series of [widgets](/reference/glossary.md#widget). There are two ways to configure an `area`. The first adds widgets to a pop-up list menu for the editor selection. For this configuration, widgets are added through a `widgets` property in the `options`. Alternatively, the expanded preview menu provides a fly-in menu that allows grouping and a visual preview of widgets. This is configured through a `groups` option in which each individual group takes a `widgets` property. 

## Module field definition

### Configuring an area for the pop-up list menu

```javascript
// Configuring a `main` area field in a `fields.add` subsection of a module:
main: {
  label: 'Main column',
  type: 'area',
  options: {
    widgets: {
      '@apostrophecms/rich-text': {}
    }
  }
}
```
### Configuring an area for the expanded preview menu

```javascript
// Configuring the `main` area field in a `fields.add` subsection of a module:
main: {
  label: 'Main column',
  type: 'area',
  options: {
    expanded: true,
    groups: {
      basics: {
        label: 'Basic Content',
        widgets: {
          '@apostrophecms/rich-text': {},
          '@apostrophecms/image': {}
        },
        columns: 2
      }
    }
  }
}
```
## Settings

### Required

|  Property | Type | Default | Description |
|---|---|---|---|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`area` for this type) |
|`options` | Object | n/a | An object containing widget configuration. Contained within the individual groups for the expanded preview method. |

### Optional

|  Property | Type | Default | Description |
|---|---|---|---|
|`required` | Boolean | `false` | If true, the field is mandatory. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | `boolean` | false | If true, it will prevent the field from appearing in a dialog box | -->
<!-- |readOnly | `boolean` | false | If true, prevents the user from editing the field | | -->

## `options`

Area inputs have additional settings configured in an `options` object.

|  Property | Type | Expanded menu only? | Description |
|---|---|---|---|
|`max`| Integer | No | Sets the maximum number of widgets allowed in the area. |
|`widgets`| Object | No | Takes widget names as keys and associated widget options as values. |
|`expanded`| Boolean | Yes | Activates the expanded widget preview menu. |
|`groups`| Object | Yes | Accepts an object composed of named group objects. |

### `max`

The maximum number of widgets allowed in the area.

**Example using the simple menu**

```javascript
add: {
  main: {
    label: 'Main column',
    type: 'area',
    options: {
      max: 1, // üëà Limits the area to a single image widget.
      widgets: {
        '@apostrophecms/image': {}
      }
    }
  }
}
```

**Example using the expanded preview menu**

```javascript
add: {
  main: {
    label: 'Main column',
    type: 'area',
    options: {
      max: 1, // üëà Limits the area to a single widget.
      expanded: true,
      groups: {
        basics: {
          label: 'Basic Content',
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {}
          },
          columns: 2
        }
      }
    }
  }
}
```

### `widgets`

Widgets names are added as keys to the `widgets` object, with their individual configurations (if needed) as the key value objects. This `widgets` object is added directly to the `options` for the pop-up list menu or within the named group objects in the [`groups` option](#groups) for the expanded preview menu.
**Note:** widget keys in area configuration are their associated module names minus the `-widget` suffix (e.g., `'callout-widget'` is configured as simply `'callout'`). Since all widget module names end with that suffix, it is not required for less repetition.

Configuring a widget type in an area field applies that configuration to the widget type _only in this area's context_. So a rich text widget with configured toolbar and styles in the area field would not automatically apply to a rich text widget in a different area field. (Though some widgets, including the core rich text widget, may support default configurations.)

```javascript
add: {
  main: {
    label: 'Main column',
    type: 'area',
    options: {
      // Configuring four widget types as options in this area,
      // one of which has its own configuration when used in this
      // specific area. ‚¨á
      widgets: {
        '@apostrophecms/image': {},
        '@apostrophecms/rich-text': {
          toolbar: [ 'bold', 'italic' ]
        },
        '@apostrophecms/video': {},
        '@apostrophecms/html': {}
      }
    }
  }
}
```

### `groups`

The `groups` option takes an object and is used to organize widgets in the expanded preview menu. Each group of widgets is passed as a named object in the `groups` object. Each of the groups have three configuration settings - `label`, `widgets` and `columns`.

The `label` property takes a string that is displayed for the widget group in the menu.

The `widgets` property is configured just like the one for the simple pop-up menu. It takes an object containing the widget names as properties and any options as values.

The `columns` property takes an integer from 1-4 and defaults to 3. This determines how many widgets previews will be displayed per line.

**Example**

```javascript
add: {
  main: {
    label: 'Main column',
    type: 'area',
    options: {
      max: 3, // üëà Limits the area to three total widgets.
      expanded: true,
      groups: {
        // Adding two groups of widgets to the menu
        basics: {
          label: 'Basic Content',
          // Configuring five widget types as options in this group,
          // one of which has its own configuration when used in this
          // specific area. ‚¨á
          widgets: {
            '@apostrophecms/image': {},
            '@apostrophecms/rich-text': {
              toolbar: [ 'bold', 'italic' ]
            },
            '@apostrophecms/video': {},
            '@apostrophecms/html': {},
            '@apostrophecms/svg-sprite': {}
          },
          // Configuring for 2 columns of widgets
          // This will result in 3 rows since there are 5 widgets
          columns: 2
        },
        layout: {
          lable: 'Layout Options',
          widgets: {
            'two-column': {},
            'three-column': {},
            'four-column': {}
          },
          // We don't have to add a column property if we want 3 columns
        }
      }
    }
  }
}
```

::: info
If you configure an area to use the expanded preview menu you can further customize how the widget is displayed through options in the individual [widget's configuration](/guide/areas-and-widgets.html). 


## Use in templates

Use the `area` template tag with arguments for the context and the name of the area field in that context:

```
{% area context, area-name %}
```

The "context" may be a page, piece, widget, or [array field](/reference/field-types/array.md) item, as referenced in the template. All configuration from the field definition is applied automatically from the relevant schema configuration.

```nunjucks
<!-- Inserting the `main` area field for a page. -->
<section>
  {% area data.page, 'main' %}
</section>
<!-- Inserting the `photo` area field for array items. -->
<div>
  {% for item in data.page.photos %}
    {% area item, 'photo' %}
  {% endfor %}
</div>
```

::: info
For more information on how areas changed from Apostrophe 2, see the [Coming from 2.x](/guide/migration/upgrading.md#areas-singletons-and-template-macros) guide section on areas.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > array
DOC_PATH: reference/field-types/array.md
URL: https://apostrophecms.com/docs/reference/field-types/array
================================================================================
# `array`

An `array` field has its own [field schema](/reference/glossary.md#schema) and allows the user to add one or more entries that use the fields in that schema. The overall field is stored in the database as an array of an object for each entry.

This is useful for collections of structured data that clearly belong to a parent document but won't have relationships to other documents, such as multiple sets of contact information for business locations or tabs in a widget.

See the [relationship](relationship.md) field if you exclusively, or primarily, need to identify a series of other pieces or pages.

## Module field definition

```javascript
// Configuring the `contactInfo` array field in a module's `fields.add` subsection:
contactInfo: {
  label: 'Contact information',
  type: 'array',
  titleField: 'city',
  fields: {
    add: {
      city: {
        type: 'string',
        label: 'City'
      },
      email: {
        type: 'email',
        label: 'Email address'
      }
    }
  }
}
```

## Settings

### Required

|  Property | Type | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`array` for this type) |
|`fields` | Object | n/a | The field schema for the array items. See below. |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | Array | n/a | The default value for the field. It must comply with the array fields schema. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
| [`inline`](#inline) | Boolean | false | If `true`, array fields are edited inline with others, not in a separate dialog box. |
|`duplicate` | Boolean |  `true` | Only applied to inline arrays. If `true`, array element's context menu has a Duplicate action |
|`style` | String |  n/a | Only if `inline` is true. If set to `table`, the schema will be displayed as an HTML table |
|`min` | Integer |  n/a | The minimum number of entries required in the array |
|`max` | Integer |  n/a | The maximum number of entries allowed in the array |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value
|`titleField` | String |  n/a | The name of one of the array schema fields. If provided, the user interface will use the value of that field as a label for the array tabs. |
|`draggable` | Boolean | true | If `false`, array items cannot be reordered using drag and drop feature. |
|[`whenEmpty`](#whenempty) | Object | Yes | Provide a custom `label` and `icon` to be displayed if an array is empty. |

::: tip NOTE
- If there is no `titleField` value, the items are numbered.
- Setting `titleField` is recommended to improve clarity for content editors.
- `titleField` can access `relationship` sub-field documents by using dot notation (e.g., `_team[0].mascot`).

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | `false` | If `true`, it will prevent the field from appearing in the editor modal | -->

### `inline`

Set `inline: true` on an array field to edit the array inline with the rest of the fields, rather than in a separate dialog box. This works best with a small number of fields in the array.

Care should be taken when using `style: table` along with conditional fields. In general, conditional fields should "switch" between two fields that have the same label in order to maintain the table structure. For example:

<AposCodeBlock>

```javascript
...
  inlineArrayTableField: {
    label: 'Dessert Table',
    itemLabel: 'Dessert Item',
    type: 'array',
    inline: true,
    style: 'table',
    fields: {
    add: {
      brand: {
        type: 'string',
        label: 'Brand',
        required: true
      },
      dessertType: {
        type: 'select',
        label: 'Dessert Type',
        choices: [
          {
            label: 'Ice Cream',
            value: 'iceCream'
          },
          {
            label: 'Sorbet',
            value: 'sorbet'
          }
        ],
        def: 'iceCream'
      },
      iceCream: {
        type: 'select',
        label: 'Flavor',
        choices: [
          {
            label: 'Cherry',
            value: 'cherry'
          },
          {
            label: 'Raspberry',
            value: 'raspberry'
          }
        ],
        if: {
          dessertType: 'iceCream'
        },
        def: 'cherry',
        required: true
      },
      sorbet: {
        type: 'select',
        label: 'Flavor',
        choices: [
          {
            label: 'Orange',
            value: 'orange'
          },
          {
            label: 'Ginger',
            value: 'ginger'
          }
        ],
        if: {
          dessertType: 'sorbet'
        },
        def: 'orange',
        required: true
      }
    }
  }
}
...
```
</AposCodeBlock>

In this example, the third field will "switch" between the ice cream flavors and the sorbet flavors. Not that the label, `Flavor`, is the same for both fields. This means that the label at the top of the table will not change if one item in the array selects ice cream and another selects sorbet.

### `whenEmpty`

If no array items have been added and the array has `inline: true`, the `whenEmpty` setting supplies an object consisting of a `label` and `icon` that are displayed to the editor until items are added. The `label` property takes a localizable string, while the `icon` property takes an icon that has already been [registered](https://github.com/apostrophecms/apostrophe/blob/main/modules/@apostrophecms/asset/lib/globalIcons.js) or is registered through a module [`icons` property](/reference/module-api/module-overview.md#icons).
 
```javascript
{
  whenEmpty: {
    label: 'apostrophe:whemEmpty',
    icon: 'file-document-icon'
  }
}
```

- `label` is the label to display when the inline array is empty.
- `icon` is [configured in the `icons` module setting](/reference/module-api/module-overview.md#icons) in the example.

## Configuring the array field schema

Array field schemas are generally configured the same way as the module's overall field schema is configured. The module's schema is configured in its `fields` section's `add` subsection. Similarly, array field schema are configured in a `fields` property, using its `add` subproperty to configure the actual fields. Both use the field names as keys in the `add` object. Both can contain all field types, including nested `array` fields.

Array schema configuration differs from module schema configuration in that _array schemas_ do not use `group` or `remove` settings.

## Use in templates

Nunjucks provides the [`{% for %}` template tag](https://mozilla.github.io/nunjucks/templating.html#for) to loop over arrays. This is the most common way to traverse the `array` field data and sub-fields.

```nunjucks
<ul>
{% for contact in data.piece.contactInfo %}
  <li>{{ contact.city }}: {{ contact.email }}</li>
{% endfor %}
</ul>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > attachment
DOC_PATH: reference/field-types/attachment.md
URL: https://apostrophecms.com/docs/reference/field-types/attachment
================================================================================
# `attachment`

An `attachment` field allows the user to upload a file to the server, or replace a file which was previously uploaded. Attachments are most often used indirectly through the core image <!-- TODO: link --> and file <!-- TODO: link --> piece types. Each of those piece types contains an attachment field and some metadata fields, making them a convenient way to reuse files.

You may also use attachment fields directly as well, however **doing so means that the uploaded file will not be available in the media library or file manager**. It will only be accessible as a property of the piece or page where it is uploaded. This can be appropriate for files that are only relevant for a single piece of content, such as resumes and job applications for a specific person.

## Module field definition

All fields in a piece or page module use their object key as their database field name (e.g., `resume` below).

```javascript
// Configuring the `resume` field in a module's `fields.add` subsection:
resume: {
  label: 'Resume',
  type: 'attachment',
  fileGroup: 'office'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|------------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`attachment` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`fileGroup` | String | n/a | Can be set to the default `images` or `office` groups, or a custom group, to limit the file types that can be uploaded. See more below. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |`aspectRatio` | Array | n/a | Only applies to image files. If set to an array like `[ 2, 1 ]`, the image must have that aspect ratio and will be autocropped if the user does not manually crop. Only suitable if fileGroup is images. | -->
<!-- |`contextual` | Boolean | `false` | If `true`, it will prevent the field from appearing in the editor modal | -->
<!-- |`crop` | Boolean | `false` | Only applies to image files. If `true`, the user may crop the attachment. Only suitable if fileGroup is images. | -->
<!-- |`minSize` | Array | n/a | Only applies to image files. if set to an array like `[ 640, 480 ]`, the image must have at least the specified minimum width and height. Only suitable if fileGroup is images. | -->

::: warning NOTE
The uploaded files are stored in a web-accessible folder, however their file names are prepended with a randomized ID to avoid naming collisions.

## Custom file groups

Developers can configure file type groups in addition to `office` and `image` using the `fileGroups` or `addFileGroups` options of the [`@apostrophecms/attachment` module](./../modules/attachment.md). Those custom group names can then be used for an attachment field's `fileGroup` setting.

<!-- TODO: Link to the attachment module page for this instead once available. -->

## Use in templates

The `attachment` field value will be an object with various properties, including many metadata properties. They can be accessed directly, but it is more common to use a template helper when working with attachments in templates.

The most common helper method for attachments in templates is `apos.attachments.url`. Once an attachment field has a value, you can obtain the file's public URL with the `apos.attachments.url` template helper.

<!-- TODO: Link to the attachment module for other helpers. -->

```nunjucks
<!-- `data.piece.resume` is an attachment object -->
<a href="{{ apos.attachment.url(data.piece.resume) }}">Download</a>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > boolean
DOC_PATH: reference/field-types/boolean.md
URL: https://apostrophecms.com/docs/reference/field-types/boolean
================================================================================
# `boolean`

A `boolean` field is a simple "True/False" choice. The value stored in the database will be either `true` or `false`.

## Module field definition

```javascript
// Configuring a `isSpecial` field in a module's `fields.add` subsection:
isSpecial: {
  label: 'Is this a special item?',
  type: 'boolean'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`boolean` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | Boolean | n/a | The default value for the field |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |
|`toggle` | Boolean/Object | n/a | If set to `true` or a configuration object, the field will use an alternate "toggle" interface. See below. |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->
<!-- |mandatory | String |  | If set, the string is displayed if the user does not set the field to the `true` choice. This can be used for required confirmation fields. | | -->

## Customizing boolean field labels

We can change labels for the boolean input using a `toggle` object. The user interface will use the values of `true` and `false` properties on the object as labels.

```javascript
showRelatedArticles: {
  label: 'Should the page display related articles?',
  type: 'boolean',
  toggle:{
    true: 'Show related articles',
    false: 'Hide related articles'
  }
}
```

## Use in templates

```nunjucks
<!-- To print the value: -->
{{ data.piece.isSpecial }}
<!-- or use it in a conditional: -->
<button class="{% if data.piece.isSpecial %}is-special{% endif %}">
  Engage
</button>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > box
DOC_PATH: reference/field-types/box.md
URL: https://apostrophecms.com/docs/reference/field-types/box
================================================================================
# `box`

The `box` field is a unique field that provides a tailored UX for defining values associated with the CSS box-model, such as margin, padding, and border-width.

## Module field definition

```javascript
padding: {
  label: 'Container padding',
  type: 'box',
  min: -3,
  max: 50,
  step: 2,
  def: {
    top: 20,
    right: -2,
    bottom: 0
    left: 30
  }
}
```

## Box Field UI
The UI of the box field allows you to edit all values uniformly or each individually.
![Screenshot of the Apostrophe box field UI](/images/apostrophe-box-field-ui.png)

## Use in templates
The value of a box field is always an object with `top`, `right`, `bottom`, `left` properties. All property values are stored as numbers, any omitted values are made  `null`. You can pull out each value in your template like

```nunjucks
<button
  {% if data.piece.margin.left %}
    style="margin-left: {{ data.piece.margin.left }}px;"
  {% endif %}
>
  I might have a left margin
</button>
```

### `toCss` helper function
There is also a helper function that will return a string of CSS rules.

|  Parameter | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`value` | Object | n/a | The box field value |
|`property` | String | n/a | The CSS property to assign values |
|`unit` | String | 'px' | The CSS unit |

```nunjucks
<button style="{{ apos.boxField.toCss( data.piece.margin, 'margin', 'em') }}">
  I might have margins
</button>
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`help` | String | n/a | Help text for the content editor |
|`def` | Object | <pre style='width: 170px; border-radius: 4px; padding: 3px 6px; background-color: var(--vp-code-bg);font-size: var(--vp-code-font-size); color: var(--vp-code-color);'><code>{<br/>&nbsp;top: null,<br />&nbsp;right: null,<br />&nbsp;bottom: null,<br />&nbsp;left: null<br />}</code></pre> | The default value. Must be an object with keys `top`, `right`, `bottom`, `left`. Each value must be a number |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`max` | Number | n/a | The maximum allowable value for any box property |
|`min` | Number | n/a | The minimum allowable value for any box property |
|`step` | Number | n/a | The default increment when using the input's arrow buttons or keyboard |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > checkboxes
DOC_PATH: reference/field-types/checkboxes.md
URL: https://apostrophecms.com/docs/reference/field-types/checkboxes
================================================================================
# `checkboxes`

A `checkboxes` field allows a list of options where a user can select one or more items. Checkbox items can also be deselected, unlike [radio fields](radio.md).

## Module field definition

``` javascript
// Configuring the `genres` field in a module's `fields.add` subsection:
genres: {
  label: 'Select the genres that apply to this book',
  type: 'checkboxes',
  choices: [
    {
      label: 'Romance ü•∞',
      value: 'romance'
    },
    {
      label: 'Comedy ü§£',
      value: 'comedy'
    },
    {
      label: 'Crime üò∞',
      value: 'crime'
    }
  ]
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`choices` | Array/String |  n/a | An array of options that the editor can select from, or a method name that returns them. See below. |
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`checkboxes` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | Array | n/a | The default value for the field. Values must be from the defined choices' values. |
|[`following`](#following) | String/Array | n/a | The name of a field or an array of field names that can be used to generate dynamic `choices` for this field. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |
| `style` | String | n/a | If 'combo', adds a selection choices box and dropdown list of choices |
| `all` | Object | n/a | If `style: 'combo'`, adds a choice to select every option with a label set by the `label` property |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

### `following`
The `following` option is used when adding field choices that depend on the value of another field in the schema by passing a string representing a method name to the [`choices`](#choices) option. It should be set to the name of a field or an array of field names that will be used to dynamically create choices based on the value of those named field(s).

If this field is nested in an `array` or `object` field and is following a field in the parent object, then the name of the field should be prefixed with a `<`, e.g. `following: '<title'`. This hoisting also works if the field is following a field in the parent object from a grand-child `array` or `object` that is nested within a child `array` or `object` using `<<`. This pattern can be extended for additional levels of nesting.

The value(s) of the followed field(s) will be used to create an object with properties composed of the followed schema name for each key, and the current value of that field as value. This object will be passed to the dynamic `choices` method [(see below)](#choices). Note that the property key in the object is the same as the value passed to the `following` field, including any prepended `<`.

## `choices` configuration

The `choices` setting in `checkboxes`, `radio`, or `select` fields configures the options that a user will see in the interface and the values that the server will allow in validation. The `choices` value is an array of objects with `label` and `value` properties, or a string ending with `()` representing a [`method(self)`](../module-api/module-overview#methods) in your module. See below for more [details](#choices).

- `value` is used in the field's database value
- `label` is the more human-readable version used in interfaces

## Populating `choices` dynamically {#choices}

What if the choices aren't known in advance or are dependent on the value of another schema field? Then you can fetch them dynamically.

First, set the `choices` option to the name of a [method in your module](../module-api/module-overview.md#methods). Pass the name of the method you'll implement on the server side as a string ending in `()`. e.g. `choices: 'getChoices()'` ‚Äî **do not** pass a function.

Second, implement that method in your module so that it takes `(req, data, following)` arguments and return an array of choices in the usual format. You may use an async function, or return a promise that will resolve to the array. That means you can reach out to APIs using modules like `axios` or `node-fetch`, or make Apostrophe database queries.

The `data` argument is an object containing the parent's `docId` for further inspection by your function and is falsey if the document hasn't been published.

The `following` argument is an object containing the schema fields being followed as keys and the value of those fields as values. Note that the key will match the field name(s) in the `following` field array exactly. So if you are passing a parental schema field value in an `object` or `array` schema field, you need to include the prefixing `<` along with the name. See the [`following`](#following) property description.

When your `choices` method is async, while calls to the method are debounced to keep the rate of calls reasonable, is usually a good idea to perform at least short-term caching in order to limit the impact on performance when editing.

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Example'
  },
  fields: {
    add: {
      // other schema fields
      region: {
        type: 'select',
        label: 'Region',
        choices: [
          { label: 'North America', value: 'na' },
          { label: 'Europe', value: 'eu' }
        ]
      },
      cities: {
        type: 'checkboxes',
        label: 'Favorite Cities',
        following: [ 'region' ],
        choices: 'getCities()'
      }
    }
  },
  methods(self) {
    return {
      // this method can be async
      getCities(req, { docId }, { region }) {
        // Define city choices based on the selected region
        const cityChoices = {
          na: [
            { label: 'New York', value: 'newYork' },
            { label: 'Los Angeles', value: 'losAngeles' },
            { label: 'Chicago', value: 'chicago' }
          ],
          eu: [
            { label: 'Paris', value: 'paris' },
            { label: 'Berlin', value: 'berlin' },
            { label: 'London', value: 'london' }
          ]
        };
        // Return the array of choices for the selected region
        return cityChoices[region] || [];
      }
    };
  }
};
```
<template v-slot:caption>
</template>
</AposCodeBlock>

## Use in templates

The checkboxes field data value is stored in an array of the selected options' value. Nunjucks provides the [`{% for %}` template tag](https://mozilla.github.io/nunjucks/templating.html#for) that you can use to loop over the array.

```nunjucks
<ul>
  {% for genre in data.piece.genres %}
    <li>{{ genre }}</li>
  {% endfor %}
</ul>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > color
DOC_PATH: reference/field-types/color.md
URL: https://apostrophecms.com/docs/reference/field-types/color
================================================================================
# `color`

`color` fields provides the end user with a color picker interface. They also validate submitted values using [the TinyColor utility](https://github.com/bgrins/TinyColor?tab=readme-ov-file#isvalid). Colors are saved as strings in [8 digit hex code](https://drafts.csswg.org/css-color/#hex-notation), or `#rrggbbaa`, format.

<!-- TODO: Add vue-color options config documentation once supported. -->

## Module field definition

```javascript
// Configuring the `themeColor` field in a module's `fields.add` subsection:
themeColor: {
  type: 'color',
  label: 'Theme color'
}
```

## Color Field UI
You have the ability to control and customize several parts of the color field's UI, as detailed in the `options` section below.
![Screenshot of the Apostrophe color field UI](/images/apostrophe-color-picker-ui.png)

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`color` for this type) |

### Optional

| Property | Type | Default | Description |
|----------|------|---------|-------------|
|`def` | String | n/a | The default value for the field |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |
|`options` | Object | n/a | An object containing color picker configuration. See below. |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

### `options`

Color fields have additional settings configured in an `options` object:

#### `format`

**Type:** String

The color string format saved to the database. Possible options are:

- `rgb`
- `prgb`
- `hex6`
- `hex3`
- `hex8`
- `hsl`
- `hsv`

The default value is [`hex8`](https://www.npmjs.com/package/tinycolor2#hex-8-digit-rgba-hex).

```javascript
backgroundColor: {
  type: 'color',
  label: 'Background color',
  options: {
    format: 'rgb'
  }
}
```
<br/>

#### `presetColors`

An array of color values, used as swatches.

**Type:** Array, Boolean

::: tip
Passing `false` will disable the preset colors UI


**Default Value:**

```javascript
[
  '#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321',
  '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2',
  '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF'
]
```

**Valid Color Strings:**
<br/>Mix and match as you like.

| Format | Example |
|----------|------|
|hex3 | `#f00` |
|hex6 | `#00ff00` |
|hex8 | `#00ff0055` |
|rgb | `rgb(201, 76, 76)` |
|rgba | `rgba(0, 0, 255, 1)` |
|hsl | `hsl(89, 43%, 51%)` |
|hsla | `hsla(89, 43%, 51%, 0.6)` |
|CSS Variable | `--my-primary-color` |

::: warning
When using CSS Variables as presets, Apostrophe will save the CSS Variable **name** as a string, regardless of the `format` option (for example `'--my-primary-color'`).


**Usage**

```javascript
backgroundColor: {
  type: 'color',
  label: 'Background color',
  options: {
    presetColors: ['#ea433a', '#cc9300', '#b327bf', '#66f', '#00bf9a']
  }
}
```
<br/>

##### `disableAlpha`
**Type:** Boolean

Control alpha transparency with a range input.

*Default value*

```javascript
false
```
<br/>

##### `disableFields`
**Type:** Boolean

Disable the inputs for editing the hex & RGBA value of a color. Good for limiting the user's choices.

*Default value*

```javascript
false
```
<br/>

##### `disableSpectrum`
**Type:** Boolean

Disable the full color spectrum UI. Good for limiting the user's choices.

*Default value*

```javascript
false
```

## Use in templates

```nunjucks
<button style="background-color: {{ data.piece.themeColor or '#639' }}">
  Enhance
</button>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > date
DOC_PATH: reference/field-types/date.md
URL: https://apostrophecms.com/docs/reference/field-types/date
================================================================================
# `date`

The `date` field supports saving dates in `YYYY-MM-DD` format. The interface is a [standard date input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date).

## Module field definition

```javascript
// Configuring the `birthday` field in a module's `fields.add` subsection:
birthday: {
  label: 'What is your birthday?',
  type: 'date'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`date` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | String | n/a | The default value for the field. Must be in `YYYY-MM-DD` format. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`max` | String | n/a | The maximum allowed date value for the field. Must be a date format (e.g., `YYYY-MM-DD`) |
|`min` | String | n/a | The minimum allowed date value for the field. Must be a date format (e.g., `YYYY-MM-DD`) |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

## Use in templates

<!-- TODO: Link to the date filter documentation -->
A date value will often be paired with the date template filter.

```nunjucks
Their birthday is {{ data.piece.birthday | date('MMMM D, YYYY') }}.
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > dateAndTime
DOC_PATH: reference/field-types/dateAndTime.md
URL: https://apostrophecms.com/docs/reference/field-types/dateAndTime
================================================================================
# `dateAndTime`

`dateAndTime` fields provide subfields for entering date and time values in a user-friendly way. Dates and times are stored in ISO 8601 format, for example: `2022-01-01T03:00:00Z`.

Note that while dates and times are edited in the individual editor's time zone, they are always saved in UTC (Universal Coordinated Time).

## Module field definition

```javascript
// Configuring the `eventDateAndTime` field in a module's `fields.add` subsection:
eventDateAndTime: {
  label: 'What is the date and time of the event?',
  type: 'dateAndTime'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`string` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

## Use in templates

Times are stored, and will print, in the ISO 8601 format `YYYY-MM-DDTHH:MM:SSZ`.

To print them in the format of your choice pass a [momentjs/datejs compliant format string](https://momentjs.com/docs/#/displaying/) to the date Nunjucks filter, like this:

```nunjucks
{{ data.piece.eventDateAndTime | date("dddd, MMMM Do YYYY, h:mm:ss a") }}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > email
DOC_PATH: reference/field-types/email.md
URL: https://apostrophecms.com/docs/reference/field-types/email
================================================================================
# `email`

`email` fields operate similarly to a normal `string` field, but will only accept a valid email address.

## Module field definition

```javascript
// Configuring the `workEmail` field in a module's `fields.add` subsection:
workEmail: {
  label: 'Work email address',
  type: 'email'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|------------|
|`label` | String | | Sets the visible label for the field in the UI |
|`type` | String | | Specifies the field type (`email` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|------------|
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`required` | Boolean | false | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

## Use in templates

``` nunjucks
Email: {{ data.piece.workEmail }}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > float
DOC_PATH: reference/field-types/float.md
URL: https://apostrophecms.com/docs/reference/field-types/float
================================================================================
# `float`

`float` fields support number input with decimals (floating point numbers). You may set minimum and maximum values using the `min` and `max` options.

## Module field definition

```javascript
// Configuring the `gpa` field in a module's `fields.add` subsection:
gpa: {
  label: 'What was your grade point average (GPA)?',
  type: 'float',
  min: 1.0,
  max: 4.5
}
```

## Settings
### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`float` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | Number | n/a | The default value for the field |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`max` | Number | n/a | The maximum allowed value for the field |
|`min` | Number | n/a | The minimum allowed value for the field |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

## Use in templates

```nunjucks
GPA: {{ data.piece.gpa }}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > integer
DOC_PATH: reference/field-types/integer.md
URL: https://apostrophecms.com/docs/reference/field-types/integer
================================================================================
# `integer`

`integer` fields support whole number input, whether positive or negative. You may set minimum and maximum values using the `min` and `max` options.

## Module field definition

```javascript
// Configuring the `rating` field in a module's `fields.add` subsection:
rating: {
  label: 'Rate the movie from 1-5',
  type: 'integer',
  min: 1,
  max: 5
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`float` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | Number | n/a | The default value for the field |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`max` | Number | n/a | The maximum allowed value for the field |
|`min` | Number | n/a | The minimum allowed value for the field |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

## Use in templates

This example uses a Nunjucks [for tag](https://mozilla.github.io/nunjucks/templating.html#for) and [range function](https://mozilla.github.io/nunjucks/templating.html#range-start-stop-step).

```nunjucks
{{ data.piece.rating }}

{# data.piece.stars is a number #}
Rating:
{% for i in range(1, data.piece.stars) -%}
  ‚≠êÔ∏è
{%- endfor %}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > object
DOC_PATH: reference/field-types/object.md
URL: https://apostrophecms.com/docs/reference/field-types/object
================================================================================
# `object`

An `object` field has its own [field schema](/reference/glossary.md#schema) and allows the user to populate a sub-object containing the fields in that schema. The overall field is stored in the database as a sub-object. If you want support for *one or more* sub-objects, use an [array](/reference/field-types/array.md) field instead.

`object` fields provide a sense of visual hierarchy to distinguish their subfields from other fields when editing, as well as a sub-object to provide clear structure for developers. If you find yourself creating fields named `addressStreet`, `addressCity`, etc. it is usually a better idea to create an `address` field of type `object` with sub-fields named `street`, `city` and so on.

## Module field definition

```javascript
// Configuring the `contactInfo` object field in a module's `fields.add` subsection:
contactInfo: {
  label: 'Address',
  type: 'object',
  fields: {
    add: {
      street: {
        type: 'string',
        label: 'Street'
      },
      city: {
        type: 'string',
        label: 'City'
      },
      state: {
        type: 'string',
        label: 'State'
      }
    }
  }
}
```

## Settings

### Required

|  Property | Type | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`object` for this type) |
|`fields` | Object | n/a | The field schema for the array items. See below. |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | Object | n/a | The default value for the field. It must comply with the fields schema. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | `false` | If `true`, it will prevent the field from appearing in the editor modal | -->

## Configuring the array field schema

`object` field schemas are generally configured the same way as the module's overall field schema is configured. The module's schema is configured in its `fields` section's `add` subsection. Similarly, array field schema are configured in a `fields` property, using its `add` subproperty to configure the actual fields. Both use the field names as keys in the `add` object. Both can contain all field types, including nested `object` fields.

Object schema configuration differs from module schema configuration in that _object schemas_ do not use `group` or `remove` settings.

## Use in templates

You can access the fields of the object as sub-properties.

```nunjucks
<p>
{% set address = data.piece.address %}
{{ address.street }}<br />
{{ address.city }}, {{ address.state }}
</p>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > oembed
DOC_PATH: reference/field-types/oembed.md
URL: https://apostrophecms.com/docs/reference/field-types/oembed
================================================================================
# `oembed`

A `oembed` field supports the user in embedding media hosted by any [oembed‚Äîcompatible hosting site](https://oembed.com/#section7), or any site for which you have provided an [oembetter](https://github.com/apostrophecms/oembetter) filter via the `@apostrophecms/oembed` module. <!-- TODO: document oembetter config for 3.x -->

The field will immediately preview the media embed after entering a valid URL.

The database value of the field will have `url`, `title` and `thumbnail` properties. `title` and `thumbnail` are snapshots from the oembed response at the time the field was saved. `thumbnail` is the URL of a thumbnail image as provided by the oembed response. Developers should retrieve the full embed code in client-side code to get the latest version available.

<!-- TODO: Update following module reference addition. -->
<!-- [apostrophe-oembed](/reference/modules/apostrophe-oembed/README.md) provides browser-side methods to display the video. See the [apostrophe-video-widgets](/reference/modules/apostrophe-video-widgets/README.md) source code for an example of using these methods to play a video in a `div` element. -->

## Module field definition

```javascript
// Configuring the `video` field in a module's `fields.add` subsection:
video: {
  type: 'oembed',
  label: 'Featured video'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`float` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

## Use in templates

Simplest usage could involve simply printing the thumbnail image (if available) and linking to the media:

```nunjucks
{% if data.piece.video and data.piece.video.thumbnail %}
  {% set video = data.piece.video %}
  <a href="{{ video.url }}">
    <img src="{{ video.thumbnail }}" alt="{{ video.title }}">
  </a>
{% endif %}
```

More likely, you will want to add the full embed code from the media source. This should be done in client-side JavaScript. Apostrophe provides an API route to get that.

<!-- TODO: link to the oembed module's API route reference when available. -->
Submit a `GET` request to `/api/v1/@apostrophecms/oembed/query` with the media URL as the `url` query parameter. A successful response will be an object with several properties to help place and style the embed, including an `html` property with the actual HTML markup to embed.

The `@apostrophecms/video-widget` widget provides a full-featured implementation. It includes [a widget player](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/video-widget/ui/src/index.js) that uses that API route to retrieve the full embed code and then replaces a placeholder HTML element with that code. See that widget for a suggested implementation.
<!-- TODO: Update with a link to the main branch once stable -->

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > password
DOC_PATH: reference/field-types/password.md
URL: https://apostrophecms.com/docs/reference/field-types/password
================================================================================
# `password`

`password` fields are identical to `string` fields except that the user's input is visually obscured, they do not support the `textarea` option, and they are not indexed for search.
<!-- TODO: Confirm if they are kept from search indexing automatically. -->

## Module field definition

```javascript
// Configuring the `secret` field in a module's `fields.add` subsection:
secret: {
  label: 'Your secret code',
  type: 'password'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|------------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`password` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|------------|
|[`autocomplete`](#autocomplete) | String | n/a | Sets the value of the `autocomplete` attribute on the field. |
|`def` | String | n/a | The default value for the field |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`min` | Integer | n/a | Sets the minimum number of characters allowed |
|`max` | Integer | n/a | Sets the maximum number of characters allowed |
|`required` | Boolean | false | If `true`, the field is mandatory |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

### autocomplete
The string supplied to the `autocomplete` option is used as the value of the `autocomplete` attribute for the field, as specified in the HTML standards. This feature suggests possible values based on user inputs and previously entered data, streamlining data entry and improving form usability. This also takes a string of `off` to disable autocomplete for sensitive fields. However, most modern browsers ignore this for password fields. In situations where you are implementing a user management page and an administrator will be adding a password for another user pass a string of `new-password` to truly disable auto-complete. For detailed information on how the `autocomplete` attribute works and the values it accepts, refer to the [MDN documentation on autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete).

## Use in templates

You probably do not want to print values from this field in templates, but they can be printed the same way as [string fields](string.md).

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > radio
DOC_PATH: reference/field-types/radio.md
URL: https://apostrophecms.com/docs/reference/field-types/radio
================================================================================
# `radio`

A `radio` field allows a list of options where a user can select one value.

## Module field definition

```javascript

// Configuring the `animalType` field in a module's `fields.add` subsection:
animalType: {
  label: 'Type of animal',
  type: 'radio',
  choices: [
    {
      label: 'Mammals ü¶ß',
      value: 'mammals'
    },
    {
      label: 'Fish üê†',
      value: 'fish'
    },
    {
      label: 'Birds ü¶ú',
      value: 'birds'
    },
    {
      label: 'Reptiles ü¶é',
      value: 'reptiles'
    },
    {
      label: 'Amphibians üê∏',
      value: 'amphibians'
    }
 ]
}
```

```javascript

// Configuring an alignment field using `buttons` presentation and icons
alignment: {
  label: 'Alignment',
  type: 'radio',
  buttons: true,
  choices: [
    {
      tooltip: 'Left',
      value: 'left',
      icon: 'format-align-left-icon'
    },
    {
      tooltip: 'Center',
      value: 'center',
      icon: 'format-align-center-icon'
    },
    {
      tooltip: 'Right',
      value: 'right',
      icon: 'format-align-right-icon'
    }
  ]
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`choices` | Array/String |  n/a | An array of options that the editor can select from, or a method name that returns them. See below. |
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`radio` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | Varies | n/a | The default value for the field. Must be from the defined choices' values. |
|[`following`](#following) | String/Array | n/a | The name of a field or an array of field names that can be used to generate dynamic `choices` for this field. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |
|`buttons` | Boolean | `false` | If `true`, presents the radios as a set of buttons |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->
<!-- |widgetControls | Boolean | false | If `true`, `select` fields can be edited in line on the page if the field is in a widget | | -->

### `following`
The `following` option is used when adding field choices that depend on the value of another field in the schema by passing a string representing a method name to the [`choices`](#choices) option. It should be set to the name of a field or an array of field names that will be used to dynamically create choices based on the value of those named field(s).

If this field is nested in an `array` or `object` field and is following a field in the parent object, then the name of the field should be prefixed with a `<`, e.g. `following: '<title'`. This hoisting also works if the field is following a field in the parent object from a grand-child `array` or `object` that is nested within a child `array` or `object` using `<<`. This pattern can be extended for additional levels of nesting.

The value(s) of the followed field(s) will be used to create an object with properties composed of the followed schema name for each key, and the current value of that field as value. This object will be passed to the dynamic choices method (see below). Note that the property key in the object is the same as the value passed to the `following` field, including any prepended `<`.

## `choices` configuration

The `choices` setting in `checkboxes`, `radio`, or `select` fields configures the options that a user will see in the interface and the values that the server will allow in validation. The `choices` value is an array of objects with `label` and `value` properties, or a string ending with `()` representing a [`method(self)`](../module-api/module-overview#methods) in your module. See below for more [details](#choices).

- `value` is used in the field's database value
- `label` is the more human-readable version used in interfaces. Can be omitted when using the `buttons` presentation
- `icon` (Optional) the name of an icon to pair with the choice
- `tooltip` (Optional) a string that will appear as a tooltip on the choice

## Populating `choices` dynamically {#choices}

What if the choices aren't known in advance or are dependent on the value of another schema field? Then you can fetch them dynamically.

First, set the `choices` option to the name of a [method in your module](../module-api/module-overview.md#methods). Pass the name of the method you'll implement on the server side as a string ending in `()`. e.g. `choices: 'getChoices()'` ‚Äî **do not** pass a function.

Second, implement that method in your module so that it takes `(req, data, following)` arguments and return an array of choices in the usual format. You may use an async function, or return a promise that will resolve to the array. That means you can reach out to APIs using modules like `axios` or `node-fetch`, or make Apostrophe database queries.

The `data` argument is an object containing the parent's `docId` for further inspection by your function and is falsey if the document hasn't been published.

The `following` argument is an object containing the schema fields being followed as keys and the value of those fields as values. Note that the key will match the field name(s) in the `following` field array exactly. So if you are passing a parental schema field value in an `object` or `array` schema field, you need to include the prefixing `<` along with the name. See the [`following`](#following) property description.

When your `choices` method is async, while calls to the method are debounced to keep the rate of calls reasonable, is usually a good idea to perform at least short-term caching in order to limit the impact on performance when editing.

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Example'
  },
  fields: {
    add: {
      // other schema fields
      region: {
        type: 'select',
        label: 'Region',
        choices: [
          { label: 'North America', value: 'na' },
          { label: 'Europe', value: 'eu' }
        ]
      },
      cities: {
        type: 'radio',
        label: 'Favorite City',
        following: [ 'region' ],
        choices: 'getCities()'
      }
    }
  },
  methods(self) {
    return {
      // this method can be async
      getCities(req, { docId }, { region }) {
        // Define city choices based on the selected region
        const cityChoices = {
          na: [
            { label: 'New York', value: 'newYork' },
            { label: 'Los Angeles', value: 'losAngeles' },
            { label: 'Chicago', value: 'chicago' }
          ],
          eu: [
            { label: 'Paris', value: 'paris' },
            { label: 'Berlin', value: 'berlin' },
            { label: 'London', value: 'london' }
          ]
        };
        // Return the array of choices for the selected region
        return cityChoices[region] || [];
      }
    };
  }
};
```
<template v-slot:caption>
</template>
</AposCodeBlock>

## Use in templates

Radio field data is stored as the string `value` property of the selected choice.

```nunjucks
{{ data.piece.animalType }}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > range
DOC_PATH: reference/field-types/range.md
URL: https://apostrophecms.com/docs/reference/field-types/range
================================================================================
# `range`

A `range` field provides [range input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range) interface for selecting a numeric value, typically represented in the browser as a slider. The `step` option may be used along with `min` and `max`, if desired, to effectively limit the results to integers.

## Module field definition

```javascript
// Configuring the `fontSize` field in a module's `fields.add` subsection:
fontSize: {
  type: 'range',
  label: 'Font size',
  min: 14,
  max: 32,
  step: 2
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`range` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | Number | n/a | The default value for the field |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`max` | Number | n/a | The maximum allowed value for the field |
|`min` | Number | n/a | The minimum allowed value for the field |
|`step` | Number | 1 | The interval between numbers (it may be a floating point number) |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

## Use in templates

```nunjucks
{{ data.widget.fontSize }}

{# data.widget.fontSize is a number #}
<h2 style="font-size: {{ data.widget.fontSize }}px;">
  Hello, world
</h2>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > relationshipReverse
DOC_PATH: reference/field-types/relationship-reverse.md
URL: https://apostrophecms.com/docs/reference/field-types/relationship-reverse
================================================================================
# `relationshipReverse`

Adding a `relationshipReverse` field to a doc type schema reveals Apostrophe docs that have established relationships with a given doc. It is a developer convenience, showing the receiving side of a [`relationship` field](/reference/field-types/relationship.md). There is no editing interface for this field type as the relationship is defined in the paired `relationship` field.

Take the example of a website that has a `pizza` piece type with a `relationship` field connecting to its `topping` piece type. Each pizza piece chooses the registered toppings that it has (the relationship is _pizza-to-topping_). The website might also want to list all available toppings on a page and show all pizzas that use each topping (the _topping-to-pizza_ direction). A `relationshipReverse` field could make it easy to find and display that information.

## Module field definition

The field name must begin with an underscore (`_`). This indicates that the ultimate value is not stored in the database, but is populated when needed.

```javascript
// Configuring the `_pizzas` field in a module's `fields.add` subsection:
_pizzas: {
  type: 'relationshipReverse',
  withType: 'pizza',
  reverseOf: '_toppings'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`type` | String | n/a | Specifies the field type (`relationshipReverse` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`reverseOf` | String | n/a | Set to the name of the related `relationship` field. |
|`ifOnlyOne` | Boolean | `false` | If `true`, it will only reveal the relationship data if the doc query returned only one document. [See below](#ifonlyone) for more. |
|`withType` | String | Uses the field name, minus its leading `_` and possible trailing `s` | The name of the related type. |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

::: tip
For relationships with pages, use `withType: '@apostrophecms/any-page-type'`.

If `withType` is not set the name of the field must match the name of the related type, with a leading `_` (underscore), and *optional* trailing `s` added (e.g., `_article` or `_articles` to connect to the `article` piece type).

## `ifOnlyOne`

The `ifOnlyOne` option can provide a performance improvement if the reverse relationship data is only needed when one piece is queried. For example, in the example above, the pizza relationship data may be only needed on a topping [show page](/reference/glossary.md#show-page), where only one topping is displayed; not on the [index page](/reference/glossary.md#index-page), where many toppings are listed.

Setting `ifOnlyOne: true` tells Apostrophe not to look for the extra relationship data in those contexts, such as index pages, where many pieces are queried.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > relationship
DOC_PATH: reference/field-types/relationship.md
URL: https://apostrophecms.com/docs/reference/field-types/relationship
================================================================================
# `relationship`

A `relationship` field expresses a one-to-many connection between an Apostrophe document, a piece or page, and another.

The `_id` values for the related docs are stored in an array. When ready to be used, Apostrophe fetches the full related documents, filtering properties as configured, and attaching them on a property matching the `relationship` field name.

For instance, a website may have `pizza` pieces with a `relationship` field named `_toppings` that relates them to `topping` pieces. The topping `_id` values will be stored on `toppingsIds` in the database. In the template and in API responses, the related topping piece data will be available as the `pizza._toppings` array property of each product.

## Module field definition

The field name must begin with an underscore (`_`). This indicates that the ultimate value is not stored in the database, but is populated when needed.

```javascript
// Configuring the `_toppings` field in a module's `fields.add` subsection:
_toppings: {
  label: 'Toppings',
  type: 'relationship',
  withType: 'topping',
  builders: {
    // Include only the information you need with a projection
    project: {
      title: 1,
      _url: 1
    }
  }
}
```

::: tip
**For better performance, it is strongly recommended that you set a projection filter** via the `builders` option, limiting the amount of information fetched about each related doc. You may also call other query builders by setting subproperties of the `builders` property. This is a useful way to limit the acceptable choices for the join.
<!-- TODO: Link "query builders" to more docs on that feature -->

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`relationship` for this type) |

### Optional

| Property | Type | Default | Description |
|-----------|-----------|-----------|-----------|
|`builders` | Object | n/a | Query builders to limit acceptable options for the join. [See below](#filtering-related-document-properties) for more.|
|`fields` | Object | n/a | A field schema object, allowing editors to [add additional information to most relationships](/guide/relationships.md#providing-context-with-fields). |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`idsStorage` | String | n/a | The name of the property in which to store related document IDs. If not set, the IDs property will be based on the field name. |
|`ifOnlyOne` | Boolean | `false` | If `true`, the related doc data will only be populated if the original document was the only one requested. [See below](#limiting-returned-data-with-ifonlyone) for more. |
|`min` | Integer |  n/a | The minimum number of related docs required |
|`max` | Integer |  n/a | The maximum number of related docs allowed |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |
|`withRelationships` | Array |  n/a | An array of field names representing `relationship` fields you wish to populate with the connected docs. [See below](#populating-nested-relationships-using-withrelationships) for more. |
|`withType` | String | Uses the field name, minus its leading `_` and possible trailing `s` | The name of the related type. |
|`browse` | Boolean | `true` | If `false`, hide the browse button. |
| `suggestionLabel` | String | <div style="word-wrap:break-word;">`apostrophe:`&#8203;`relationshipSuggestionLabel`</div> | The label at the top of the autocomplete suggestions |
|`suggestionHelp` | String | <div style="word-wrap:break-word;">`apostrophe:`&#8203;`relationshipSuggestionHelp`</div> | The text to display next to the autocomplete suggestion label |
|`suggestionLimit` | Number | 25 | How many suggestions should be displayed when you focus the search field |
|`suggestionSort` | Object | `{ updatedAt: -1 }` | How to sort the autocomplete results |
|`suggestionIcon` | String | `text-box-icon` | The icon to display before the autocomplete item. Please refer to the [`icons` module setting](/reference/module-api/module-overview.md#icons) |
|`suggestionFields` | Array | `[ 'slug' ]` | The document properties to display next to the autocomplete label |

::: tip
To create relationships with pages, use `withType: '@apostrophecms/any-page-type'`.

If `withType` is not set the name of the field must match the name of the related type, with a leading `_` (underscore), and *optional* trailing `s` added (e.g., `_article` or `_articles` to connect to the `article` piece type).

## Filtering related document properties

Often when two Apostrophe documents are connected by a `relationship` field, the original doc only needs one or two properties from the connected doc. For example, an `article` piece may connect to an `author` piece, but only need the author's name and portrait photo. That `author` piece may also contain rich text for a biography, an additional set of photos for a slideshow, and a string field with their home town, but we don't want to send all of that to the `article` piece as it is unnecessary and adds to work done by the server.

A `project` query builder limits the properties of the connected doc that are populated on the original doc. The following configuration would limit the author data to only what we need:

```javascript
_author: {
  label: 'Author',
  type: 'relationship',
  max: 1, // There's only one author
  // Limiting our data here üëá
  builders: {
    project: {
      title: 1, // The author's name is entered as its `title`
      photo: 1
    }
  }
}
```

By doing that, we don't get any slideshow, biography, home town, or other data that isn't needed. The projection filter format comes from the similar MongoDB projection operator.

## Limiting returned data with `ifOnlyOne`

The `ifOnlyOne` option was designed to lighten document data in situations where many of that type of document are being displayed. The primary example of this are the index, or listing, pages.

For example, if a `team` piece type has a relationship field that connects it to many `players` (as in baseball "players"), you may want to display all of the players' information on the individual team page (the [show page](/reference/glossary.md#show-page)). However, on the [index page](/reference/glossary.md#index-page) for all teams, you are not displaying all players for every team, so it lightens the server load to ignore the relationship field in that context. So you might configure the field as such:

```javascript
// `_players` will only be populated when only one team document is being fetched
_players: {
  label: 'Players',
  type: 'relationship',
  withType: 'player',
  ifOnlyOne: true
}
```

## Populating nested relationships using `withRelationships`

It is not unusual for one piece type to have situations with "nested relationships" across piece types. For example, `team` may have a relationship field connecting to `player` pieces, then `player` pieces connect to `specialty` pieces. Imagine that the players had multiple relationship fields, and suddenly the data populated two levels up on teams could get very large.

By default, these "nested relationships" are excluded. So on the `team` show page, `data.piece._players` would include only `specialtiesIds` by default. With the following configuration, that same piece data would *also* include `_specialties`, an array of populated specialty objects.

```javascript
// With this configuration, `_players` will include the populated `_specialties` documents rather than only the specialty `_id` values.
_players: {
  label: 'Players',
  type: 'relationship',
  withType: 'player',
  withRelationships: [ '_specialties' ]
}
```

In the case of double nesting e.g., `_specialties` piece has a `_photo` relationship field with another piece `@apostrophecms/image`, then `_photo` can be accessed as `_specialties._photo`.

```javascript
// With this configuration, `_players` will include the populated `_specialties` and `_photo` documents rather than only the specialty and photo `_id` values.
_players: {
  label: 'Players',
  type: 'relationship',
  withType: 'player',
  withRelationships: [ '_specialties._photo' ]
}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > select
DOC_PATH: reference/field-types/select.md
URL: https://apostrophecms.com/docs/reference/field-types/select
================================================================================
# `select`

A `select` field allows a list of options where a user can select one value.

## Module field definition

```javascript
// Configuring the `theme` field in a module's `fields.add` subsection:
theme: {
  label: 'Select a color scheme for this page',
  type: 'select',
  choices: [
    {
      label: 'Dark üåö',
      value: 'dark'
    },
    {
      label: 'Light üí°',
      value: 'light'
    },
    {
      label: 'Dusk üåÜ',
      value: 'dusk'
    }
  ]
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`choices` | Array/String | n/a | An array of options that the editor can select from, or a method name that returns them. See below. |
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`select` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|[`autocomplete`](#autocomplete) | String | n/a | Sets the value of the `autocomplete` attribute on the field. |
|`def` | Varies | n/a | The default value for the field. Must be from the defined choices' values. |
|[`following`](#following) | String/Array | n/a | The name of a field or an array of field names that can be used to generate dynamic `choices` for this field. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->
<!-- |widgetControls | Boolean | false | If `true`, `select` fields can be edited in line on the page if the field is in a widget | | -->

### autocomplete
The string supplied to the `autocomplete` option is used as the value of the `autocomplete` attribute for the field, as specified in the HTML standards. This feature suggests possible values based on user inputs and previously entered data, streamlining data entry and improving form usability. This also takes a string of `off` to disable autocomplete for sensitive fields. For detailed information on how the `autocomplete` attribute works and the values it accepts, refer to the [MDN documentation on autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete).

### `following`
The `following` option is used when adding field choices that depend on the value of another field in the schema by passing a string representing a method name to the [`choices`](#choices) option. It should be set to the name of a field or an array of field names that will be used to dynamically create choices based on the value of those named field(s).

If this field is nested in an `array` or `object` field and is following a field in the parent object, then the name of the field should be prefixed with a `<`, e.g. `following: '<title'`. This hoisting also works if the field is following a field in the parent object from a grand-child `array` or `object` that is nested within a child `array` or `object` using `<<`. This pattern can be extended for additional levels of nesting.

The value(s) of the followed field(s) will be used to create an object with properties composed of the followed schema name for each key, and the current value of that field as value. This object will be passed to the dynamic choices method (see below). Note that the property key in the object is the same as the value passed to the `following` field, including any prepended `<`.

## `choices` configuration

The `choices` setting in `checkboxes`, `radio`, or `select` fields configures the options that a user will see in the interface and the values that the server will allow in validation. The `choices` value is an array of objects with `label` and `value` properties, or a string ending with `()` representing a [`method(self)`](../module-api/module-overview#methods) in your module. See below for more [details](#choices).

- `value` is used in the field's database value
- `label` is the more human-readable version used in interfaces

## Populating `choices` dynamically {#choices}

What if the choices aren't known in advance or are dependent on the value of another schema field? Then you can fetch them dynamically.

First, set the `choices` option to the name of a [method in your module](../module-api/module-overview.md#methods). Pass the name of the method you'll implement on the server side as a string ending in `()`. e.g. `choices: 'getChoices()'` ‚Äî **do not** pass a function.

Second, implement that method in your module so that it takes `(req, data, following)` arguments and return an array of choices in the usual format. You may use an async function, or return a promise that will resolve to the array. That means you can reach out to APIs using modules like `axios` or `node-fetch`, or make Apostrophe database queries.

The `data` argument is an object containing the parent's `docId` for further inspection by your function and is falsey if the document hasn't been published.

The `following` argument is an object containing the schema fields being followed as keys and the value of those fields as values. Note that the key will match the field name(s) in the `following` field array exactly. So if you are passing a parental schema field value in an `object` or `array` schema field, you need to include the prefixing `<` along with the name. See the [`following`](#following) property description.

When your `choices` method is async, while calls to the method are debounced to keep the rate of calls reasonable, is usually a good idea to perform at least short-term caching in order to limit the impact on performance when editing.

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Example'
  },
  fields: {
    add: {
      // other schema fields
      region: {
        type: 'select',
        label: 'Region',
        choices: [
          { label: 'North America', value: 'na' },
          { label: 'Europe', value: 'eu' }
        ]
      },
      cities: {
        type: 'checkboxes',
        label: 'Favorite Cities',
        following: [ 'region' ],
        choices: 'getCities()'
      }
    }
  },
  methods(self) {
    return {
      // this method can be async
      getCities(req, { docId }, { region }) {
        // Define city choices based on the selected region
        const cityChoices = {
          na: [
            { label: 'New York', value: 'newYork' },
            { label: 'Los Angeles', value: 'losAngeles' },
            { label: 'Chicago', value: 'chicago' }
          ],
          eu: [
            { label: 'Paris', value: 'paris' },
            { label: 'Berlin', value: 'berlin' },
            { label: 'London', value: 'london' }
          ]
        };
        // Return the array of choices for the selected region
        return cityChoices[region] || [];
      }
    };
  }
};
```
<template v-slot:caption>
</template>
</AposCodeBlock>

## Use in templates

Select field data is stored as the string `value` property of the selected choice.

```nunjucks
{{ data.page.theme }}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > slug
DOC_PATH: reference/field-types/slug.md
URL: https://apostrophecms.com/docs/reference/field-types/slug
================================================================================
# `slug`

`slug` adds a text field to the schema that is restricted to producing strings strings acceptable as Apostrophe document slugs. All [docs](/reference/glossary.md#doc) already have a slug with with the name "slug," as required by Apostrophe. It is therefore rare that developers have need to create additional fields of this type, but it is allowed.

Text entered in a `slug` field is immediately lower-cased and all spaces and punctuation are replaced by dashes (`-`).

## Module field definition

```javascript
// Configuring the `secondSlug` field in a module's `fields.add` subsection:
projectSlug: {
  label: 'Enter a unique identifier for the project',
  type: 'slug'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`string` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|[`autocomplete`](#autocomplete) | String | n/a | Sets the value of the `autocomplete` attribute on the field. |
|`def` | String | n/a | The default value for the field |
|[`following`](#following) | String/Array | n/a | The name of a field or an array of field names that will be used to automatically generate this field's value. If this field is edited to no longer match the fields it is following, it will stop responding to edits in those fields.|
|[`followingIgnore`](#followingignore) | Boolean/Array | n/a | Controls which `following` values should be ignored when auto-generating field content. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`page` | Boolean | `false` | If `true`, then slashes are allowed since the slug field is describing a page doc |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: 2.x options not yet available -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->
<!-- |pattern | String | | Regular expression to validate entries |
|patternErrorMessage | String | | Error message to display if `pattern` does not match | -->

### autocomplete
The string supplied to the `autocomplete` option is used as the value of the `autocomplete` attribute for the field, as specified in the HTML standards. This feature suggests possible values based on user inputs and previously entered data, streamlining data entry and improving form usability. This also takes a string of `off` to disable autocomplete for sensitive fields. For detailed information on how the `autocomplete` attribute works and the values it accepts, refer to the [MDN documentation on autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete).

### following
This option should be set to the name of a field or an array of field names that will be used to automatically generate this field's value. If this field is edited to no longer match the fields it is following, it will stop responding to edits in those fields.

If an array of fields is passed, the value of each will be concatenated in the order they are passed in the array.

If this field is nested in an `array` or `object` field and is following a field in the parent object, then the name of the field should be prefixed with a `<`, e.g. `following: '<title'`. This hoisting also works if the field is following a field in the parent object from a grand-child `array` or `object` that is nested within a child `array` or `object` using `<<`. This pattern can be extended for additional levels of nesting.

::: tip
If you are overriding a piece type or page type's `slug` field and that doc type uses a [slug prefix](/reference/module-api/module-options.md#slugprefix), the `slug` field should include `'archived'` in the `following` option. It is used by the slug field type to manage prefixes, though its value is not included in the slug name.

```
slug: {
  type: 'slug',
  label: 'Slug',
  following: [ 'title', 'archived' ],
  required: true
}
```

Overriding the `slug` field is typically only necessary if you want to change the `following` string fields.


### followingIgnore
The `followingIgnore` option controls which `following` values should be ignored when auto-generating this field's content. This is useful when you want to follow certain fields for conditional display logic while only using other fields for the actual slug generation.

**Boolean usage:**
- `followingIgnore: true` - Ignores all `following` values. This effectively disables the `following` behavior for content generation.

**Array usage:**
- `followingIgnore: ['fieldName1', 'fieldName2']` - Ignores only the specified field names from the `following` array

```javascript
// Example: Generate slug from title, but only show slug field when article is published
add: {
  title: {
    label: 'Article Title',
    type: 'string'
  },
  status: {
    label: 'Status',
    type: 'select',
    choices: [
      { label: 'Draft', value: 'draft' },
      { label: 'Published', value: 'published' }
    ]
  },
  customSlug: {
    label: 'Custom URL Slug',
    type: 'slug',
    following: ['title', 'archived', 'status'],
    // üëá Only title and archived generate the value, status is just for conditional logic
    followingIgnore: ['status'],
    if: {
      status: 'published'
    }
  }
}
```

In this example, the `customSlug` field will:
- Auto-generate its value from the `title` field (plus `archived` for prefix management)
- Only appear when `status` is "published"
- But changes to `status` won't affect the actual field content

## Use in templates

If adding a new field with the `slug` type, it is most likely not going to be used in templates, but it is allowed as a string value.

```nunjucks
{{ data.piece.projectSlug }}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > string
DOC_PATH: reference/field-types/string.md
URL: https://apostrophecms.com/docs/reference/field-types/string
================================================================================
# `string`

A `string` field is a editable text field with configurable options, including a textarea interface.

## Module field definition

```javascript
// Configuring the `dogName`and `biography` fields in a module's
// `fields.add` subsection:
dogName: {
  label: 'What is your dog\'s name?',
  type: 'string'
},
// Textarea
biography: {
  label: 'Write a short biography for your dog',
  type: 'string',
  textarea: true,
  max: 800
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`string` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|[`autocomplete`](#autocomplete) | String | n/a | Sets the value of the `autocomplete` attribute on the field. |
|`def` | String | n/a | The default value for the field |
|[`following`](#following) | String/Array | n/a | The name of a field or an array of field names that will be used to automatically generate this field's value. If this field is edited to no longer match the fields it is following, it will stop responding to edits in those fields.|
|[`followingIgnore`](#followingignore) | Boolean/Array | n/a | Controls which `following` values should be ignored when auto-generating field content. |
|`help` | String | n/a | Help text for the content editor |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`min` | Integer | n/a | Sets the minimum number of characters allowed |
|`max` | Integer | n/a | Sets the maximum number of characters allowed |
|`pattern` | String | n/a | Accepts a regular expression string to validate the input. Only values matching the pattern are allowed. |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`sortify` |	Boolean |	`false` |	If true, creates "sortified" fields. See below. |
|`textarea` | Boolean | `false` | If `true`, use a textarea interface with multiple lines, which allows line breaks |

<!-- TODO: 2.x options not yet available -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->
<!-- |pattern | String | | Regular expression to validate entries |
|patternErrorMessage | String | | Error message to display if `pattern` does not match | -->
<!-- |searchable | Boolean | true | If false, content from the area will not appear in search results. | -->

### autocomplete
The string supplied to the `autocomplete` option is used as the value of the `autocomplete` attribute for the field, as specified in the HTML standards. This feature suggests possible values based on user inputs and previously entered data, streamlining data entry and improving form usability. This also takes a string of `off` to disable autocomplete for sensitive fields. For detailed information on how the `autocomplete` attribute works and the values it accepts, refer to the [MDN documentation on autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete).

### following
This option should be set to the name of a field or an array of field names that will be used to automatically generate this field's value. If this field is edited to no longer match the fields it is following, it will stop responding to edits in those fields.

If an array of fields is passed, the value of each will be concatenated in the order they are passed in the array.

If this field is nested in an `array` or `object` field and is following a field in the parent object, then the name of the field should be prefixed with a `<`, e.g. `following: '<title'`. This hoisting also works if the field is following a field in the parent object from a grand-child `array` or `object` that is nested within a child `array` or `object` using `<<`. This pattern can be extended for additional levels of nesting.


### followingIgnore
The `followingIgnore` option controls which `following` values should be ignored when auto-generating this field's content. This is useful when you want to follow some fields but exclude others from affecting the field's value.

**Boolean usage:**
- `followingIgnore: true` - Ignores all `following` values. This effectively disables the `following` behavior for generation of field values.

**Array usage:**
- `followingIgnore: ['fieldName1', 'fieldName2']` - Ignores only the specified field names from the `following` array

```javascript
metaDescription: {
  label: 'Meta Description',
  type: 'string',
  following: ['title', 'featured'],
  followingIgnore: ['featured'],
  if: {
    featured: true
  }
}
```

In this example, the `metaDescription` field generates its value from the `title` schema field, but only appears when the `featured` schema field is `true`.

## `sortify`

Setting `sortify: true` creates a parallel version of the field that is more intuitive for sorting purposes. This new, additional property's key will be the string field's name, appended with `Sortified`. Its value will be fully lowercase and have all punctuation removed. Apostrophe will automatically use it if a request is made to sort on the original field.

For instance, if your field's `name` is `lastName` and you set `sortify: true`, `lastNameSortified` will automatically be created and used when sorting on the `lastName` field. This provides case-insensitive sorting that also ignores punctuation differences.

::: tip NOTE
If you add `sortify: true` to an existing field, existing objects will get the sortified version of the field:
- on the next deployment via the `apostrophe-migrations:migrate` command line task,
- when the individual Apostrophe documents are saved, or
- at the next startup when in development.

Migrations like this only need to be run once because on future updates or inserts of a document the sortified property is automatically set.

## Use in templates

The Nunjucks [nl2br](https://mozilla.github.io/nunjucks/templating.html#nl2br) tag can help print textarea strings with line breaks.

```nunjucks
<h2>{{ data.piece.dogName }}</h2>
<p>
  {{ data.piece.biography | striptags(true) | escape | nl2br }}
</p>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > time
DOC_PATH: reference/field-types/time.md
URL: https://apostrophecms.com/docs/reference/field-types/time
================================================================================
# `time`

`time` fields are text field with UI support, and limitation, for saving time values. Times are stored in 24 hour `HH:MM:SS` format.

## Module field definition

```javascript
// Configuring the `eventTime` field in a module's `fields.add` subsection:
eventTime: {
  label: 'What time is the event?',
  type: 'time'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`string` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`def` | String | n/a | The default value for the field. Must be in `HH:MM:SS` format. |
|`help` | String | n/a | Help text for the content editor |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

::: warning NOTE
If you do not set `def: null` or `required: true`, the time defaults to the current time.

## Use in templates

Times are stored, and will print, in the `HH:MM:SS` format.

```nunjucks
{{ data.piece.eventTime }}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Field Types > url
DOC_PATH: reference/field-types/url.md
URL: https://apostrophecms.com/docs/reference/field-types/url
================================================================================
# `url`

`url` adds an editable URL field to the schema.

Apostrophe will detect common mistakes, including leaving off `https://`. Common XSS attack vectors are laundered and discarded. Only "safe" URL schemes, e.g., `http`, `https`, `ftp` and `mailto`, are permitted.

## Module field definition

```javascript
// Configuring the `portfolio` field in a module's `fields.add` subsection:
portfolio: {
  label: 'Portfolio URL',
  type: 'url'
}
```

## Settings

### Required

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|`label` | String | n/a | Sets the visible label for the field in the UI |
|`type` | String | n/a | Specifies the field type (`string` for this type) |

### Optional

|  Property | Type   | Default | Description |
|-----------|-----------|-----------|-----------|
|[`autocomplete`](#autocomplete) | String | n/a | Sets the value of the `autocomplete` attribute on the field. |
|`def` | String | n/a | The default value for the field |
|`help` | String | n/a | Help text for the content editor |
|`hidden` | Boolean | `false` | If `true`, the field is hidden |
|`htmlHelp` | String | n/a | Help text with support for HTML markup |
|`if` | Object | `{}` | Conditions to meet before the field is active. [See the guide for details.](/guide/conditional-fields) |
|`pattern` | String | n/a | Accepts a regular expression string to validate the input. Only values matching the pattern are allowed. |
|`readOnly` | Boolean | `false` | If `true`, prevents the user from editing the field value |
|`required` | Boolean | `false` | If `true`, the field is mandatory |
|`requiredIf` | Object | `{}` | Conditions to meet before the field is required. [See the guide for details.](/guide/conditional-fields) |

<!-- TODO: The following settings are likely to return, but are not yet implemented. -->
<!-- |contextual | Boolean | false | If `true`, it will prevent the field from appearing in the editor modal | -->

### autocomplete
The string supplied to the `autocomplete` option is used as the value of the `autocomplete` attribute for the field, as specified in the HTML standards. This feature suggests possible values based on user inputs and previously entered data, streamlining data entry and improving form usability. This also takes a string of `off` to disable autocomplete for sensitive fields. For detailed information on how the `autocomplete` attribute works and the values it accepts, refer to the [MDN documentation on autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete).

## Use in templates

```nunjucks
<href="{{ data.piece.portfolio }}">My website</a>
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Module Configuration > Module Overview
DOC_PATH: reference/module-api/module-overview.md
URL: https://apostrophecms.com/docs/reference/module-api/module-overview
================================================================================
# Module configuration

Module configuration objects may use the following configuration properties. The overall categories are broadly defined:
- [Configuration settings](#configuration-settings): Static module settings. Once the module is initialized these settings are fixed and can't access the module itself or any other module's settings.
- [Configuration cascades](#configuration-cascades): Settings that merge as a module initializes, first adding properties from parent classes like piece-type and then properties from subclasses like your project-level content type.
- [Initialization function](#initialization-function): A function that runs once during application startup.
- [Customization functions](#customization-functions): Settings via functions that have access to the module itself as an argument and can access other settings.

## Configuration settings

|Setting name | Value type | Description | Module types |
|-------|-------|-------|-------|
| [`extend`](#extend) | String | Identify the base class module | All |
| [`improve`](#improve) | String | Identify a module to enhance | All |
| [`options`](#options) | Object | Configure module options | All |
| [`instantiate`](#instantiate) | Boolean | Prevent a module from being fully instantiated | All |
| [`bundle`](#bundle) | Object | Identify multiple modules to load | All |
| [`icons`](#icons) | Object | Register a Material Design icon for the UI | All |
| [`i18n`](#i18n) | Object | Add translation strings. | All |

### `extend`

Identify a module to use as a base class for your custom module. "Extending" a module this way makes all of the functionality and configuration of the base class available in the new module, other than its `name` property.

The most common base class modules include:

- `@apostrophecms/piece-type` to add a new piece type
- `@apostrophecms/page-type` to add a page type
- `@apostrophecms/piece-page-type` to add an index page and show pages for a piece type
- `@apostrophecms/widget-type` to add a widget type

If this property is not set, the module will implicitly extend the base module, `@apostrophecms/module`.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  // ...
}
```
<template v-slot:caption>
modules/custom-piece/index.js
</template>
</AposCodeBlock>

You can use any existing module as a base class, whether a core module or one built for your project. To do so, make sure the extending module is instantiated _after_ its base class in `app.js`.

In this example, a "Landing page" module uses a "Default page" as its base class.

<AposCodeBlock>

```javascript
require('apostrophe')({
  modules: {
    'default-page': {},
    'landing-page': {}
  }
});
```
<template v-slot:caption>app.js
</template>
</AposCodeBlock>

<AposCodeBlock>

```javascript
// modules/landing-page/index.js
module.exports = {
  extend: 'default-page'
};
```
<template v-slot:caption>
modules/custom-piece/index.js
</template>
</AposCodeBlock>

### `improve`

Similarly to `extend`, `improve` is used to name another existing module. Instead of _inheriting_ the existing module's code and configuration in a new module, using `improve` _enhances_ the existing module's code and configuration.

**This is only valid in modules that are installed into an Apostrophe app**, either on their own or as a part of a bundle, and not in those that are built into the app directly. It is most often used to add functionality to core Apostrophe modules.
<!-- TODO: link to a definition of a bundle when available. -->

::: info
Within an application, you can alter installed or core module behavior by adding an `index.js` file for it in the `module` directory as if it is a new module. Installed modules cannot share their name with an existing module, so they `improve` those existing modules instead.

 You might include this in a stand-alone module that adds functionality to the `@apostrophecms/image` core module:

<AposCodeBlock>

```javascript
module.exports = {
  improve: '@apostrophecms/image'
  // Additional functionality ...
};
```
<template v-slot:caption>
index.js
</template>
</AposCodeBlock>

You should not use both `improve` and `extend` in a single module. If "improving" an existing module, that existing module has already taken care of the "extending."

### `options`

An object used to add additional, often optional, settings to a module. There are many options available depending on the module type. See the [module configuration options page](/reference/module-api/module-options.md) for more information.

### `instantiate`

Set to `false` to prevent the module from being fully instantiated in the application. The primary purpose of this option is to create a base class module that others will [extend](#extend) but that will not be used directly.

### `bundle`

Used to add multiple modules from a single npm module. Takes an object with two properties. The `directory` property takes a relative path to the directory of the modules to be loaded. The `modules` property takes an array of module names. THe original module and bundled modules loaded in this way still need to be added to the `app.js` file, unless they use [`improve`](#improve). Any modules that are to be used only as a base class for other modules should be added to `app.js`, but have their [`instantiate`](#instantiate) property set to `false`.

### `icons`

The icons in Apostrophe come from the `vue-material-design-icons` npm package, version 4.12.1. We have pinned to this version because the names of Material Design icons are not always consistent from version to version. A number of these icons are registered by the [`@apostrophecms/asset/lib/globalicons.js` file](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/asset/lib/globalIcons.js) and can be used directly in your project, for example in the `icon` option of your [widget module](/reference/module-api/module-options.html#options-for-widget-modules) or as a `previewIcon` in your [widget preview](/guide/areas-and-widgets.md#widget-preview-options).

Any of the additional almost 6,000 icons from this package can easily be registered for use through the `icons` setting object. While we have a [list](https://gist.github.com/BoDonkey/a28419ed8954b57931f80061e5e6a3dd) of the currently available icons, this list may grow in the future,  but it won't shrink and no names will change, absent force majeure. To easily confirm that the desired icon is on the list:

``` bash
// in your project, already npm installed

cd node_modules/vue-material-design-icons
ls *.vue
```
Each property key in the `icons` setting object will be the name used to reference the icon in an Apostrophe project. The value will be the Material Design name for the icon, written in PascalCase without the `.vue` ending. The Apostrophe reference name for the icon *does not need to match* the Material Design name.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  icons: {
    airhorn: 'AirHorn',
    expander: 'ArrowUpDownBoldOutline'
  }
};
```
<template v-slot:caption>
index.js
</template>
</AposCodeBlock>

To use an icon that is not included in the `vue-material-design-icons` list, add your icon Vue file to either a relative path in the project or via an `npm` package. Then register the icon with a property name that will be used to reference the icon in the project, and a value that points to the file.

```javascript
icons: {
  // For an icon at ./icons in your project
  'my-icon': '~./icons/MyIconName.vue',
  // For an icon in the their-icon-bundle-package npm module
  'their-icon': '~their-icon-bundle-package/TheirIconName.vue'
}
```
Everything following the `~` becomes part of an `import` statement during the build process.

If you need to convert your icon(s) to Vue components, you can use any of the icons in the `vue-material-design-icons` as a template for constructing a simple wrapper.

At the present time, the same icon cannot be registered under two names (that is, it can't be registered as `my-icon` and as `core-icon` if they both refer to the same icon). Since this can be inconvenient and requires checking the `globalicons.js` file to make sure you are not registering a duplicate, we plan to correct it in an upcoming release.

### `i18n`

An object that configures internationalization behavior for translation namespaces. Most translations in your modules don't require any configuration - they are automatically detected from JSON files in your module's `i18n` directory. This setting is only needed when you want translations to be available in the admin UI.

Each property in the `i18n` object represents a namespace that needs special handling, and its value is an object of configuration options for that namespace. The JSON files for these namespaces should be placed in a subdirectory of your module's `i18n` directory matching the namespace name (e.g., `modules/my-module/i18n/adminStrings/en.json`):

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  i18n: {
    adminStrings: {
      browser: true  // Include this namespace in admin UI
    }
  }
};
```
<template v-slot:caption>
index.js
</template>
</AposCodeBlock>

The `browser: true` option should only be set for namespaces containing translations needed in the admin UI. For translations used only in server-side rendering (e.g., Nunjucks templates like
<span v-pre>`{{ __t('Related articles') }}`</span>
), no configuration is needed - simply place the JSON files in your module's `i18n` directory and Apostrophe will automatically detect and use them. This optimization keeps the admin UI bundle size smaller by only including the translations it needs.

## Configuration cascades

| Setting name | Value type | Description | Module types |
| ------- | ------- | ------- | ------- |
| [`fields`](#fields) | Object/Function | Configure doc type fields | Doc, Widget |
| [`filters`](#filters) | Object/Function | Configure piece type filters | Piece |
| [`columns`](#columns) | Object/Function | Configure piece type manager columns | Piece |
| [`batchOperations`](#batchoperations) | Object/Function | Configure manager batch operations | Doc |

### "Cascading" settings
These settings can either be configured as a static object or through a function that takes `self` and `options` and returns a configuration object.

As detailed for each setting, the configuration objects have `add`, `remove`, `group`, and `order` properties. This pattern allows these settings to "cascade" from the base classes to project-level classes without requiring those settings be declared again.

Use `add` to add additional settings and `remove` to remove existing base class settings. Use `group` to organize user-facing settings in the editing interface. The `order` option allows for the arrangement of added fields in a particular order for `filters`, `columns`, and `batchOperations`.

### `fields`

[Doc type](/reference/glossary.md#doc) modules have some fields configured by default, such as the `title` and `slug` fields. The `fields` setting is used for additional field management.

 The `fields` setting object contains properties of `add`, `remove`, and `group`, which is either provided directly, or via a function that takes `self` and `options` and returns the object.

#### `add`

An object of fields to add to the schema. See the [field type reference](/reference/field-types/index.md) for more on field type configuration.

Adding a field using an object:

<AposCodeBlock>

```javascript
module.exports = {
  fields: {
    add: {
      title: {
        label: 'Title',
        type: 'string'
      },
      subtitle: {
        label: 'Subtitle',
        type: 'string'
      }
    }
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

Adding a field using a function:

<AposCodeBlock>

```javascript
module.exports = {
  fields(self, options) {
    let fields = {
      add: {
        title: {
          label: 'Title',
          type: 'string'
        }
      }
    };

    if (options.subtitle) {
      fields.add.subtitle = {
        label: 'Subtitle',
        type: 'string'
      };
    }

    return fields;
  }
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>


#### `remove`

An array of field names from the base class module to remove. Some default fields cannot be removed since they are required by core functionality (e.g., `title`, `slug`, `visibility`).

Removing a field using an object:

<AposCodeBlock>

```javascript
module.exports = {
  extend: 'article',
  fields: {
    remove: [ 'subtitle' ]
  }
};
```
<template v-slot:caption>
modules/spotlight-article/index.js
</template>
</AposCodeBlock>

Removing a field using a function:

<AposCodeBlock>

```javascript
module.exports = {
  extend: 'article',
  fields(self, options) {
    return {
      remove: !self.options.subtitle ? [ 'subtitle' ] : []
    }
  }
}
```
<template v-slot:caption>
modules/spotlight-article/index.js
</template>
</AposCodeBlock>

#### `group`

An object of field groups. Groupings are used by the editing interface. Note that `group` _does not apply to widget modules_.

`groups` accepts an object composed of named sub-objects. Each sub-object corresponds to a tab in the editing modal, displaying the fields specified within that sub-object. Every sub-object has the following properties:
- `label`: A string used to label the tab for the group.
- `fields`: An array of field names to be included in the group.

The `@apostrophecms/doc-type` module arranges the default fields in two groups: `basics` and `utility`. You can override these groups, but those default fields will become ungrouped unless you arrange them again. Any fields not added to a group will be placed in an "Ungrouped" section in the editing interface.

Grouping fields using an object:

<AposCodeBlock>

```javascript
module.exports = {
  fields: {
    add: {
      // ...
    },
    group: {
      meta: { // üëà The group's identifying name is the object key.
        label: 'Article metadata',
        fields: [
          'subtitle',
          'author',
          '_category'
        ]
      }
    }
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

Grouping fields using a function:

<AposCodeBlock>

```javascript
module.exports = {
  fields(self, options) {
    let groupFields = [ 'author', '_category' ];
    if (options.subtitle) {
      groupFields.push('subtitle');
    }
    return {
      add: {
        // ... 
      },
      group: {
        meta: { // üëà The group's identifying name is the object key.
          label: 'Article metadata',
          fields: groupFields
        }
      }
    }
  }
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `filters`

In piece-type modules, the `filters` setting configures the pieces manager interface by adding and removing filtering fields (to view only certain pieces). `archived` and `visibility` filters are included by default. These settings "cascade" from the base classes to project-level classes without requiring those settings be declared again.

The `filters` object is configured with subsections: `add` and `remove` and can either be added as a static object or a function that takes `self` and `options` and returns an object. Filters must correspond to an existing fields name or custom [query builder](#queries-self-query) on the piece type.

#### `add`

An object of filters or a function that returns an object of filters to add to the piece type. Each filter is an object with its own configuration. If the filter choices are not configured directly, Apostrophe will find and set valid options automatically.

Filter properties include:

| Property | Description |
| ------- | ------- |
| `label` | Recommended, but not required, to customize the human-readable label. |
| `inputType` | Set the an input field type for the filter. Options include `radio`, `checkbox`, or `select`. Defaults to `select`. |
| `choices` | Manually set an array of choices. Choices require `label` and `value` properties. |
| `def` | The default value for the manager filter. |

Add `filters` with object:

<AposCodeBlock>

```javascript
module.exports = {
  filters: {
    add: {
      _category: { // üëà Referencing a relationship field named `_category`
        label: 'Article category'
      },
      featured: { // üëà Referencing a boolean field name `featured`
        labeled: 'Featured',
        inputType: 'checkbox',
        def: true,
        choices: [
          { value: true, label: 'Show featured' },
          { value: false, label: 'Hide featured' }
        ]
      }
    }
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

Add `filters` with function:

<AposCodeBlock>

```javascript
module.exports = {
  filters(self, options) {
    // Check self or options to dynamically add schema fields
    return {
      add: {
        _category: { // üëà Referencing a relationship field named `_category`
          label: 'Article category'
        },
        featured: { // üëà Referencing a boolean field name `featured`
          labeled: 'Featured',
          inputType: 'checkbox',
          def: true,
          choices: [
            { value: true, label: 'Show featured' },
            { value: false, label: 'Hide featured' }
          ]
        }
      }
    }
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

#### `remove`

An array of filter names from the base class module to remove.

<AposCodeBlock>

```javascript
module.exports = {
  extend: 'article',
  filters: {
    remove: [ 'featured' ]
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

#### `order`

An array of field names to sort them in a particular order.

<AposCodeBlock>

```javascript
module.exports = {
  filters(self, options) {
    // Check self or options to dynamically add schema fields
    return {
      add: {
        _category: { // üëà Referencing a relationship field named `_category`
          label: 'Article category'
        },
        featured: { // üëà Referencing a boolean field name `featured`
          labeled: 'Featured',
          inputType: 'checkbox',
          def: true,
          choices: [
            { value: true, label: 'Show featured' },
            { value: false, label: 'Hide featured' }
          ]
        }
      },
      order: [ 'featured', '_category' ]
    }
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `columns`

For piece types, the `columns` setting configures the pieces manager, adding and removing the piece data in the interface. Default columns include `title`, `updatedAt`, and `visibility`. Like the `fields` and `filters` settings, the `add`, `remove`, and `order` properties "cascade" from the base class.

#### `add`

An object of columns or a function that returns an object of columns to add to the piece type manager. Each column is an object with its own configuration. Column properties include:

| Property | Description |
| ------- | ------- |
| `label` | Recommended, but not required, to show a column header label. |
| `component` | An advanced option to use a custom Vue component for table cells in this column. See core components `AposCellBasic` (default) and `AposCellDate` for examples. |
<!-- TODO: Link to a guide on custom cell components when available. -->

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  columns: {
    // üëá Adds a column showing when the article was published.
    add: {
      lastPublishedAt: {
        label: 'Published',
        component: 'AposCellDate'
      }
    }
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

#### `remove`

An array of column names from the base class module to remove.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  columns: {
    // üëá Hides the column showing when the article was last updated.
    remove: [ 'updatedAt' ]
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

#### `order`

An array of column names to sort the columns in a particular order. This will often include default columns.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  columns: {
    add: {
      _topic: {
        label: 'Topic',
        component: 'MyCustomRelationshipCell' // (See components info below)
      }
    }
    // üëá Orders the new `_topic` column among default piece columns.
    order: [ 'title', 'labels', '_topic', 'updatedAt' ]
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `batchOperations`

Page and piece types can offer batch operations (actions editors can take on many selected documents at once) via the `batchOperations` cascade object property. Apostrophe has `archive` and `restore` (from the archive) batch operations by default, for example. New batch operations are added to a series of buttons in the respective manager modal. The `batchOperations` configuration object contains properties of `add` and `order`, which is either provided directly, or via a function that takes `self` and `options` and returns the object.

#### `add`

The `add` property is an object or function returning an object containing batch operation configurations. Each operation is a configuration object. **The operation's key must match an API route defined in `apiRoutes`.** For example, the core piece `archive` batch operation uses the piece type module's `archive` API route.

Each batch operation configuration should include the following properties:

| Property | Description |
| ------- | ------- |
| `label` | A text label used for the batch operation button's readable label. |
| `messages` | An object of notification message strings on `progress` and `completed` sub-properties. These may include `type` and `count` interpolation tags to be replaced by the piece type label and number of affected pieces, respectively. See example below. |
| `icon` | The [name of an icon](#icons) to use for the operation button. |
| `if` | Optionally include a conditional object, similar to [conditional fields](/guide/conditional-fields.md), to hide the operation button based on active [filter values](#filters). |
| `modalOptions` | Options for the confirmation modal. [See below.](#modal-options)  |
| `permission` | Type of user permission needed for the operation. [See below.](#permission) |

The following example uses a hypothetical batch operation that might reset piece fields to default values.

<AposCodeBlock>

```javascript
module.exports = {
  batchOperations: {
    add: {
      // This uses a hypothetical `reset` route added in `apiRoutes`
      reset: {
        label: 'Reset',
        messages: {
          progress: 'Resetting {{ type }}...',
          completed: 'Reset {{ count }} {{ type }}.',
          completedWithFailures: 'Reset {{ count }} {{ type }} ({{ bad }} of {{ total }} failed).',
          failed: 'Resetting {{ type }} failed.'
        },
        // This assumes that the module added this in the `icons` configuration.
        icon: 'recycle-icon',
        // Only display this for non-archived pieces.
        if: {
          archived: false
        },
        modalOptions: {
          title: 'Reset {{ type }}',
          description: 'Are you sure you want to reset {{ count }} {{ type }}?',
          confirmationButton: 'Yes, reset the selected content'
        },
        permission: 'edit'
      },
    }
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

##### Modal options

Batch operation modal options include:

| Option | Description |
| ------- | ------- |
| `title` | The modal heading. |
| `description` | Descriptive text for the confirmation modal. |
| `confirmationButton` | The affirmative confirmation button label (to continue the operation). |

##### `permission`
The `permission` property is used to determine if a particular user is able to perform the batch operation.

Valid values are:
* `edit` : The user has permission to edit the document type.
* `publish` : The user has permission to publish the document type.
* `delete` : The user has permission to delete the document type.

#### `order`

An array of batch operation names to sort them in a particular order within the menu.

<AposCodeBlock>

```javascript
module.exports = {
  batchOperations: {
    add: {
      // This uses a hypothetical `reset` route added in `apiRoutes`
      reset: {
        // ... reset operation configuration object
      },
      rollback: {
        // ...rollback operation configuration object
      },
      update: {
        // ... update operation configuration object
      }
    },
    order: [ 'update', 'reset', 'rollback' ]
  }
};
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>


## Initialization function

### `async init(self)`

This function runs once when the Apostrophe app first starts up. It takes the module, as `self`, as an argument. To run code on every request, or in other situations when the app is running, see the [event handlers documentation](/guide/server-events.md).

While [customization functions](#customization-functions) add functionality for the module in specific ways, `init` provides a space for more open code execution. It is useful for setting properties on the module that could not be set in other sections.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  options: {
    alias: 'product',
    themeColor: 'blue'
  },
  init(self) {
    // üëá Making `self.options.themeColor` available on `apos.product.theme`.
    self.theme = self.options.themeColor;

    // üëá Adding a data migration related to this module using a method from a
    // separate module.
    self.apos.migration.add('blurb', async () => {
      await self.apos.migration.eachDoc({
        type: 'product'
      }, async (doc) => {
        if ((doc.category) === 'old-category') {
          return self.apos.doc.db.updateOne({
            _id: doc._id
          }, {
            $set: { category: 'new-category' }
          });
        }
      });
    });
  }
};
```

  <template v-slot:caption>
    modules/product/index.js
  </template>

</AposCodeBlock>

## Customization functions

Customization function sections all return an object with properties that add functionality related to the module. They may add methods that can be called within the module and elsewhere, event handlers, template helpers, or other features as covered here.

Each of these function sections takes the module, as `self`, as an argument. This provides access to its methods, options, and other properties, as well as those inherited from its base class.

| Function name | Description |
| ------- | ------- |
| [`methods`](#methods) | Add new methods and override base class methods |
| [`extendMethods`](#extendmethods-self) | Extend the functionality of base class methods |
| [`components`](#components-self) | Configure asynchronous template components |
| [`extendComponents`](#extendcomponents-self) | Extend base class template components |
| [`helpers`](#helpers-self) | Add template helper methods |
| [`extendHelpers`](#extendhelpers-self) | Extend base class helper methods |
| [`restApiRoutes`](#restapiroutes-self) | Add custom REST API routes or completely override base class REST API routes |
| [`extendRestApiRoutes`](#extendrestapiroutes-self) | Extend base class REST API routes |
| [`apiRoutes`](#apiroutes-self) | Add custom API routes or completely override base class API routes |
| [`extendApiRoutes`](#extendapiroutes-self) | Extend base class API routes |
| [`renderRoutes`](#renderroutes-self) | Add API routes to return a rendered template |
| [`routes`](#routes-self) | Add standard Express routes |
| [`handlers`](#handlers-self) | Add server-side event handlers |
| [`extendHandlers`](#extendhandlers-self) | Extend base class server-side event handlers |
| [`queries`](#queries-self-query) | Add database query methods |
| [`extendQueries`](#extendqueries-self) | Extend base class database query methods |
| [`middleware`](#middleware-self) | Add standard Express middleware to be called on *every* request. |
| [`tasks`](#tasks-self) | Add task functions that can be run from the CLI. |

### The extension pattern

Several of these sections use an extension pattern. The sections prefixed with `extend` add functionality to base class sections without the prefix. For example:

- functions in `extendMethods` enhance identically named functions in the base class' `methods` section, and
- `extendApiRoutes` enhances API routes from the base class' `apiRoutes`

Each function included in an extension section takes the function it is extending as the first argument (`_super`, below) in addition to the original arguments.

The following example updates the `generate` method in the `extendMethods` section to add a placeholder `price` upon creation.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  extendMethods(self) {
    return {
      // The original `generate` function only takes `index` as an argument.
      generate(_super, index) {
        // Using _super with the original argument to generate a sample piece.
        const product = _super(index);
        // Adding additional functionality.
        product.price = Math.random() * 100;
        // Returning the generated product piece, exactly as the original
        // `generate` method does.
        return product;
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

This example shows another example, extending a [REST API function](#restapiroutes-self):

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  extendRestApiRoutes(self) {
    return {
      // The original function only takes a `req` argument.
      async getAll(_super, req) {
        // Get the original function's response (making sure to `await`).
        const response = await _super(req);

        if (Array.isArray(response.results)) {
          // Adds a `resultLength` property on the response object.
          response.resultLength = response.results.length;
        }
        return response;
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

::: warning
Extension functions should *always* use the `_super` argument to call the original function. If you want to *completely* overwrite the inherited function, add a matching function in the section without the "extend" prefix instead. For example, we could completely overwrite the `insert` method in our piece type by including our own `insert` function in the `methods` section.

### `methods(self)` {#methods}

Add methods that can be invoked on `self` or from another module on `self.apos.modules['module-name']` or the designated module alias. Returns an object of functions.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  methods(self) {
    return {
      async averagePrice(req) {
        let sum = 0;
        const products = await self.find(req).toArray();

        if (!products.length) {
          return 0;
        }

        for (const product of products) {
          sum += product.price;
        }

        return sum / products.length;
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

#### `extendMethods(self)`

<!-- TODO: Link to module reference section to find existing methods. -->
Add to the functionality of a method inherited from the base class. This must return an object of functions, similar to [`methods`](#methods).

Methods included should take a `_super` argument, followed by the normal arguments of the method being extended. If the original method took only a `req` argument, the extending method should take the arguments `_super, req`.

To maintain the same application, they should return the same type of response as the original method. If the original returned an array of docs, the extension method should return an array of docs.

### `components(self)`

`components` returns an object containing functions that power asynchronous template components. Asynchronous template components allow for async data requests in normally synchronous template rendering.

Each template component function should take the arguments:

| Argument | Description |
| ------- | ------- |
| `req` | The request object from the originating template context. |
| `data` | Data passed into the component where the component is used. |

Information returned by the component function will be available in the associated component template as `data`.

See the [async component guide](/guide/async-components.md) for more usage information.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  // ...
  components(self) {
    return {
      // Returning the five most recently created products.
      async latest(req, data) {
        const products = await self.find(req)
          .sort({ createdAt: -1 })
          .limit(data.max || 5)
          .toArray();

        return {
          products
        };
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

#### `extendComponents(self)`

Add functionality to base class async component functions. This must return an object of functions, similar to [`components`](#components-self).

Extension functions should take the following arguments:

| Argument | Description |
| ------- | ------- |
| `_super` | The original component function. See the [extension pattern](#the-extension-pattern). |
| `req` | The request object from the originating template context. |
| `data` | Data passed into the component where the component is used. |

Each should return data in the same form as the original component function.

### `helpers(self)`

`helpers` takes the module as an argument and returns an object of functions that add template utility methods. The individual helper methods may take any arguments that you plan to pass them in templates. Helper functions must run synchronously.

Helpers are called in templates from their module on the `apos` object. See the [`alias`](/reference/module-api/module-options.md#alias) option to make this less verbose.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  options: {
    alias: 'product'
  },
  helpers(self) {
    return {
      formatPrice(product) {
        const price = product.price;
        return `$${floatPrice.toFixed(2)}`;
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

Using in a template:

<AposCodeBlock>

```nunjucks
{{ apos.product.formatPrice(data.piece) }}
```
<template v-slot:caption>
modules/product-page/views/show.html
</template>
</AposCodeBlock>

#### `extendHelpers(self)`

Add to the functionality of a template helper inherited from the base class. This must return an object of functions, similar to [`helpers`](#helpers-self).

Extended helpers should take a `_super` argument, followed by the normal arguments of the helper being extended. If the original helper took only a `price` argument, the extending function should take the arguments `_super, price`.

To maintain the same application, they should return the same type of response as the original helper. If the original returned a string, the extension should return a string.

### `restApiRoutes(self)`

Add a custom REST API for a module. The `restApiRoutes` function takes the module as an argument and returns an object of properties that map to the standard REST API request types.

Each route can be defined as a function or an object. If not using any route options, use a function that accepts a request as its argument. The function should return some value (usually a data object). You should not use Express response methods here.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  restApiRoutes(self) {
    return {
      // GET /api/v1/product
      async getAll(req) {
        const results = [];
        // ... populate `results` with product data.

        return {
          results
        };
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

REST API routes that affect a single, existing document also take the document `_id` property as an argument. These include `getOne`, `patch`, `put`, and `delete`.
```javascript
async getOne(req, _id) {
  // ...
}
```

If specifying any extra options for your route, set the route name to an object. See the [route options](#route-options) section for more.

If you simply wish to add to the existing behavior of the REST API routes, see [`extendRestApiRoutes`](#extendrestapiroutes-self).

::: warning
Apostrophe includes a full REST API for [pieces](/reference/api/pieces.md) and [pages](/reference/api/pages.md). These routes are used by the Apostrophe user interface, so **any change in REST API route handlers for piece types or the `@apostrophecms/page` module could break the UI**. `restApiRoutes` should more likely be used in a project to provide a custom REST API to a database or service not already built into Apostrophe.

`restApiRoutes` is also not for custom route URLs that don't map to one of the standard REST URLs. If you need to add a custom route in addition to the standard REST API for pieces or pages, [you should do that with `apiRoutes`](#apiroutes-self).

Valid names for functions returned by `restApiRoutes` include:
- `getAll`
- `getOne`
- `post`
- `patch`
- `put`
- `delete`

#### `extendRestApiRoutes(self)`

Extend the behavior of existing REST API routes in `extendRestApiRoutes`. This function must return an object of functions. See [`restApiRoutes`](#restapiroutes-self) for the valid function names.

Each extended REST API route function should accept the original function as `_super` and the `req` request object. They should return data in a similar format to the existing [piece](/reference/api/pieces.md) and [page](/reference/api/pages.md) REST API (e.g., single doc `GET` requests should return a single document object and general `GET` requests should return an object including a `result` array of document objects).

### `apiRoutes(self)`

Add custom API routes. The `apiRoutes` function takes takes the module as an argument and must return an object with properties for the relevant [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods), including `get`, `post`, `patch`, and `delete`. Each of those HTTP verb properties should be set to an object of routes.

Each route can be defined as a function or an object. If not using any route options, use a function that accepts a request as its argument. The function should return some value (usually a data object). You should not use Express response methods here.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  apiRoutes(self) {
    return {
      get: {
        // GET /api/v1/product/newest
        async newest(req) {
          const product = await self.find(req).sort({
            createdAt: -1
          }).toObject();
          if (!product) {
            // Browser receives a 404 error
            throw self.apos.error('notfound', 'No products were found.');
          }
          // Response is a JSON object with a `product` property
          return {
            product
          };
        }
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

If specifying any extra options for your route, use an object. See the [route options](#route-options) section for more.

#### Naming routes

If route properties do *not* begin with a forward slash, they can be reached via the pattern: `/api/v1/` followed by the module name, a forward slash, and the API route handler's property name, e.g., `/api/v1/product/newest` for the `newest` route on the `product` module.

Camel-case names will be converted to kebab case names for the URL: `newestThing` becomes `newest-thing` in the route URL.

Beginning the name of a route with a forward slash (`/`) will allow you to create a completely custom URL path. Custom URL paths will not be prefixed or converted to kebab case.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  apiRoutes(self) {
    return {
      get: {
        // GET /api/v1/product/newest-thing
        async newestThing(req) {
          // ...
        },
        // GET /my-api/newest
        '/my-api/newest': async function (req) {
          // ...
        }
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

#### Returning error codes

You can `throw` the `self.apos.error()` method in any route function to return specific error codes and log additional information for developers. Pass in one of several strings to set a specific error response code:

| Error name | HTTP response code |
| ---- | ---- |
| `'invalid'` | 400 |
| `'forbidden'` | 403 |
| `'notfound'` | 404 |
| `'required'` | 422 |
| `'conflict'` | 409 |
| `'locked'` | 409 |
| `'unprocessable'` | 422 |
| `'unimplemented'` | 501 |

Passing a different value as the first argument in `self.apos.error()` will set the response code to 500.
<!-- TODO: Link to the method's own documentation page when available for more. -->

#### `extendApiRoutes(self)`

Extend the behavior of existing API routes (set in `apiRoutes`) in `extendApiRoutes`. This function must return an object as described in [`apiRoutes`](#apiroutes-self).

Each extended API route function should accept the original function as `_super` and the `req` request object. Your extended API route function should return data in a similar format to the existing API route.

### `renderRoutes(self)`

Add custom API routes to return rendered templates. The `renderRoutes` function takes takes the module as an argument and must return an object with properties for the relevant [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods), including `get`, `post`, `patch`, and `delete`. Each of those HTTP verb properties should be set to an object of routes.

The name of the route dictates the template file that will be rendered. For example the `latest` route in the `product` module's `renderRoutes` section will return the template at `/modules/product/views/latest.html`.

**Information returned by the route function will be used in the associated template as `data`.** Each route can be defined as a function or an object. If not using any route options, use a function that accepts a request as its argument. The function should return a data object. You should not use Express response methods here.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  renderRoutes(self) {
    return {
      get: {
        // GET /api/v1/product/latest
        // The route rendered HTML for /modules/product/views/latest.html
        async latest(req) {
          const products = await self.find(req)
            .sort({ createdAt: -1 })
            .limit(req.query.max || 5)
            .toArray();

          return {
            products
          };
        }
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

If specifying any extra options for your route, use an object. See the [route options](#route-options) section for more.

### `routes(self)`

Add standard Express routes. The `routes` function takes takes the module as an argument and must return an object with properties for the relevant [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods), including `get`, `post`, `patch`, and `delete`. Each of those HTTP verb properties should be set to an object of routes.

Each route can be defined as a function or an object. If not using any route options, use a function that accepts a request as its argument:

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  routes(self) {
    return {
      get: {
        // GET /api/v1/product/redirect
        async redirect(req, res) {
          const product = await self.find(req).toObject();

          return res.redirect(product._url);
        }
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

If specifying any extra options for your route, use an object. See the [route options](#route-options) section for more.

Each route function takes the Express arguments `req` (the [request object](https://expressjs.com/en/api.html#req)) and `res` (the [response object](https://expressjs.com/en/api.html#res)). The functions must generate a response via `res` to avoid leaking resources, typically using the `res.redirect` or `res.send` methods.

See [Naming routes](#naming-routes) for more on function names and their route URLs.

::: tip
We recommend using `apiRoutes` or `restApiRoutes` whenever possible before using `routes` as they handle the potential pitfalls of Express routes. There are situations where writing Express routes may be necessary, such as when you need to use `res.redirect` or pipe a stream.

### Route options

A route in the `apiRoutes`, `restApiRoutes`, `renderRoutes`, and `routes` sections (as well as their `extend` variations) may include options to govern particular behavior. If so, it should be configured as an object rather than a function. That object should include a `route` property in addition to the options:

| Property | What is it? |
| -------- | ----------- |
| `route` | A route function that accepts a request as its argument |
| `before` | Identify another module's middleware or routes. Used if the route function should be registered before a particular module's middleware or routes. Format as `middleware:nameOfModule` for middleware or `nameOfModule` for routes. |

### `handlers(self)`

The `handlers` function takes the module as an argument and must return an object. The object keys should be names of existing [server-side events](/reference/server-events.md). The value of those event keys should be an object of functions to execute when those events fire. Event handlers may be asynchronous (async) functions.

Events belonging to the same module where the handlers are defined, or from its base class, can be referenced by name, e.g., `beforeInsert` for any piece type. You may also add handlers in one module that respond to events in other modules. Those event names should be prefixed with the name of the module that emits the event followed by a colon, e.g., `@apostrophecms/page:beforeSend`.

Arguments passed to the event handlers will vary depending on the arguments passed when the event is emitted. See the [events reference](/reference/server-events.md) for details.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  handlers(self) {
    return {
      // Responds to `beforeInsert` when emitted by the `product` module
      beforeInsert: {
        async applyTax(req, piece) {
          piece.totalPrice = piece.price * (1.0 + (piece.tax / 100));
        }
      },
      // Response to `beforeInsert` when emitted by *any* piece type
      '@apostrophecms/piece-type:beforeInsert': {
        async beforeAnyPieceIsInserted(req, piece) {
          console.log('Something is being inserted. üì¨');
        }
      }
    }
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

#### `extendHandlers(self)`

Extend the behavior of existing event handlers (set in `handlers`) in the `extendHandlers` section. This function must return an object as described in [`handlers`](#handlers-self).

Each extended event handler should accept the original function as `_super` followed by its original arguments. Extended handlers will be matched with base class handlers using the same server-side event *and* the same handler name.

### `queries(self, query)`

The `queries` function registers custom query builders and methods. It takes two arguments: the module (`self`) and the query that is being constructed (`query`). It must return an object. That object can have two properties:

| `queries` properties | Description |
| ---- | ---- |
| [`builders`](#builders) | An object of "builders," or chainable methods, that refine the query or otherwise change its behavior prior to execution. |
| [`methods`](#methods) | An object of method functions that execute some action on the query. |

#### `builders`

Query builders are defined as objects with a set of properties available to them. Builders often take an argument or use a default value. Be sure to get to know the [existing query builders](/reference/query-builders.md) before creating new ones.

| Builder properties | Description |
| ---- | ---- |
| `def` | The default value for the builder. |
| `launder` | A function used to validate values passed as arguments when `applyBuildersSafely` is called on the query. Returns `true` if valid.<br />This is required to use the builder in a REST API query string. |
| `choices` | A function returning an array of "choice" objects with `value` and `label` properties. This is returned from the `toChoices` query method if set. |
| `set` | A function called when the builder is invoked instead of the default `query.set` method. The `set` function should include running the `query.set` after other work. |
| `prefinalize` | A function to run before any builder `finalize` steps. Used to alter the query with other builders. |
| `finalize` | A function to run at the end of the query building phase, prior to being processed by the database. Used to alter the query with other builders. |
| `after` | A function run to mutate an array of queried items passed in as an argument. The `after` function should use `query.get` to confirm that the builder was used on the query. |

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  queries(self, query) {
    return {
      builders: {
        // This builder can be used to filter products in a query like this one:
        // await self.apos.product.find(req, {}).belowAverage(true).toArray();
        belowAverage: {
          def: false,
          async finalize() {
            // Make sure this filter was actually invoked first
            if (query.get('belowAverage')) {
              const average = await self.averagePrice(query.req);

              query.and({
                price: { $lt: average }
              });
            }
          },
          // The builder can also be invoked via the module's REST API as a
          // query string parameter, e.g. `?belowAverage=1`. Use the launder
          // utility to ensure the proper data format for the database request.
          launder(value) {
            return self.apos.launder.boolean(value);
          },
          // Always provides these two choices when requested, even if no docs
          // match either value.
          choices() {
            return [
              { value: '0', label: 'No' },
              { value: '1', label: 'Yes' }
            ];
          }
        }
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

#### `methods`

An object of methods that execute queries after any builders have been applied. These functions should use existing [query methods](/guide/database-queries.md#finishing-with-query-methods) or [MongoDB cursor methods](https://docs.mongodb.com/manual/reference/method/js-cursor/) to return documents.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  queries(self, query) {
    return {
      methods: {
        // Adds a query method to deliver a random doc that meets the query
        // criteria.
        async toRandomObject() {
          await query.finalize();

          const pipeline = [
            { $match: query.get('criteria') },
            { $sample: { size: 1 } }
          ];
          const result = await self.apos.doc.db.aggregate(pipeline)
            .toArray();

          return result[0];
        }
      }
    };
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

#### `extendQueries(self)`

Extend the behavior of existing event handlers (set in `queries`) in the `extendQueries` section. This function must return an object as described in `queries`.

Each extended query builder or method should accept the original function as `_super` followed by its original arguments. Extended query builders and methods should be nested in the `builders` or `methods` object, as in [`queries`](#queries-self-query), and are matched with the base class builder or method using the same name. Methods should return data in a similar format to the existing API route.

### `middleware(self)`

Add standard Express middleware to be called on *every* request. The `middleware` function takes the module as an argument and must return an object of [middleware functions](https://expressjs.com/en/guide/using-middleware.html). This is a good place to import third-party middleware if it should be called on every request.

Note that `middleware(self)` is global and runs for every request, not just for requests involving the module containing the middleware. If you are considering authoring your own middleware, it is often better to add an event handler or `await` a method in the appropriate API route instead.

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  middleware(self, options) {
    return {
      checkIp(req, res, next) {
        // Restrict access by IP address, in a crude way.
        const allowlist = [ '127.0.0.1', '::1' ];

        if (!allowlist.includes(req.connection.remoteAddress)) {
          return res.status(403).send('forbidden');
        }
        return next();
      }
    };
  }
};
```
<template v-slot:caption>
modules/limiter/index.js
</template>
</AposCodeBlock>

#### Middleware options

 If including options, set the middleware name to an object with the property `middleware` set to the function. Each option will be a property on the object.

| Option | What is it? |
| -------- | ----------- |
| `before` | The name of another module if *this* middleware must run *before* the named module's middleware. |
| `url` | The URL path that should use this middleware. If none is provided, the middleware applies to all paths. This may be a string, RegEx, or array of paths. [See ExpressJS docs for examples.](https://expressjs.com/en/4x/api.html#path-examples)  |

Example using the `before` option:

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  middleware(self, options) {
    return {
      checkIp: {
        // üëá Same as above, but with `before` and `middleware` properties.
        before: '@apostrophecms/login',
        middleware: function (req, res, next) {
          // Restrict access by IP address, in a crude way.
          const allowlist = [ '127.0.0.1', '::1' ];

          if (!allowlist.includes(req.connection.remoteAddress)) {
            return res.status(403).send('forbidden');
          }
          return next();
        }
      }
    };
  }
};
```
<template v-slot:caption>
modules/limiter/index.js
</template>
</AposCodeBlock>

### `tasks(self)`

`tasks` takes the module as an argument and returns an object of command line task definitions. Task properties include:

| Property | Description |
| ------- | ------- |
| `usage` | A string describing the task and how to use it. It is printed on the command line. |
| `task` | The task function. Can be asynchronous. |
| `afterModuleInit` | Set to `true` to run the task after modules are initiated but *before* they are fully active.
| `exitAfter` | Only relevant if `afterModuleInit` is `true`. Set to `false` to *avoid* exiting the Apostrophe process on completion. Uncommon. |

Task functions takes the object `argv` as an argument, which includes the arguments passed after the task command. As documented by the [Boring](https://www.npmjs.com/package/boring) utility:

> Input:
>
> ```
> node app custom-module:run-it taskOption --foo --bar=baz --use-color=green
> ```
>
> Response:
>
> ```
> {
>   _: [ "custom-module:run-it", "taskOption"],
>   foo: true,
>   bar: "baz",
>   "use-color": "green"
> }
> ```

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  tasks(self, options) {
    return {
      // Since the module is named product, you can run this command line
      // task by typing: `node app product:list` in the CLI.
      list: {
        usage: 'List the titles of each product.',
        async task(argv) {
          // Get an req object with admin privileges. You can also use getAnonReq.
          const req = self.apos.task.getReq();
          const pieces = await self.find(req).toArray();

          for (const piece of pieces) {
            console.log(piece.title);
          }
        }
      }
    }
  }
};
```
<template v-slot:caption>
modules/product/index.js
</template>
</AposCodeBlock>

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Module Configuration > Module Options
DOC_PATH: reference/module-api/module-options.md
URL: https://apostrophecms.com/docs/reference/module-api/module-options
================================================================================
# Module configuration options

Apostrophe modules can be configured with settings that influence functionality without having to write custom JavaScript. The sections below describe the options available in all modules as well as those specific to certain module types.

All settings described here are placed in a module's `options` configuration object. The `options` object can be added in the module's `index.js` file, as well as where the module is instantiated in the `app.js` file.

`index.js` example:

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  // üëá Module configuration options
  options: {
    alias: 'article',
    label: 'Article',
    pluralLabel: 'Articles',
    quickCreate: true
  },
  // Other settings, such as `fields`
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

<AposCodeBlock>

`app.js` example:
```javascript
require('apostrophe')({
  shortName: 'bowling-league-site', // Unique to your project
  modules: {
    article: {
      extend: '@apostrophecms/piece-type',
      // üëá Module configuration options
      options: {
        alias: 'article',
        label: 'Article',
        pluralLabel: 'Articles',
        quickCreate: true
      },
      // Other settings, such as `fields`
    }
  }
});
```
<template v-slot:caption>
app.js
</template>
</AposCodeBlock>

## Using module options

Most module options in Apostrophe core and official extension modules are used automatically for specific purposes. No additional work is needed to use them for their original purposes other than configuring them.

Module options can also be referenced directly in custom module code. Module configuration function sections take a `self` argument, which is the module itself. You can then get the options as `self.options`.

For example, if you had a custom piece type, it might look like this:

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    alias: 'article'
  },
  init (self) {
    const moduleOptions = self.options;
    // ...
  },
  methods (self) {
    return {
      logOptions () {
        console.log('The module alias is ', self.options.alias);
      }
    }
  }
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

## Options for any module

Option settings in this section apply to every module in Apostrophe.

| Option | Value type | Description |
|---------|---------|---------|
| [`alias`](#alias) | String | Configure an alias to more easily reference the module elsewhere. |
| [`components`](#components) | Object | Configure custom UI Vue components to be used for the module. |
| [`csrfExceptions`](#csrfexceptions) | Array | An array of route names in the module, or URLs starting with `/`, that should bypass CSRF protection. |
| [`i18n`](#i18n) | Boolean/Object | Indicate that the module will include localization strings for the i18n module (with optional configuration). |
| [`templateData`](#templatedata) | Object | Set data to be included on `req.data` for requests to this module.  |

### `alias`

<!-- TODO: Link to information about the apos object when available. -->
Set to a string, the `alias` value will be applied to the `apos` object (accessible in many places) as a quick reference to the module.
set an alias to easily reference the module from other modules. There is no default value.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    alias: 'article'
  },
  // ...
}
```
<template v-slot:caption>
modules/news-article/index.js
</template>
</AposCodeBlock>

This `article` module can then be referenced anywhere the `apos` object is present as `apos.article`. Otherwise it would be available via `apos.modules['news-article']`.

With the exception of modules present in Apostrophe core at the time of the 3.x stable release, modules distributed via npm should never set `alias` for themselves or assume that it has been set. This is to avoid conflict when multiple modules attempt to use the same alias.

### `components`

The `components` options is an object identifying Vue components to use for the module's related user interface. The keys of this object, and thus the UI being overridden, will vary based on the module type. For example, piece modules use `managerModal` and `editorModal` components.

This is an advanced option since it can easily break the user interface.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    components: {
      managerModal: 'MyCustomPiecesManager'
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/piece-type/index.js
</template>
</AposCodeBlock>

### `csrfExceptions`

See the [Express module](/reference/modules/express.md#csrf) for more on CSRF protection in Apostrophe. This option can contain an array of route names or relative URLs that should bypass CSRF protection.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    csrfExceptions: [ 'login', '/safe-url' ]
  },
  // ...
}
```
<template v-slot:caption>
modules/access/index.js
</template>
</AposCodeBlock>

### `templateData`

Similar to [`browser`](#browser), the `templateData` module option can be set to an object whose properties will be made available in templates of that module. Properties are attached directly to the `data` object in templates.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    templateData: {
      defaultColor: '#55ff93'
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/heading-widget/index.js
</template>
</AposCodeBlock>

You might use that value as a fallback for user-editable fields.

<AposCodeBlock>

``` nunjucks
{% set bgColor = data.widget.color or data.defaultColor %}
<h2 style="background-color: {{ bgColor }}">
  Title Here
</h2>
```
<template v-slot:caption>
modules/heading-widget/index.js
</template>
</AposCodeBlock>

## Options for all doc type modules

Option settings in this section apply to all modules that extend `@apostrophecms/doc-type` ([doc type](/reference/glossary.md#doc) modules). These include all piece and page types.

| Option | Value type | Description |
|---------|---------|---------|
| [`adminOnly`](#adminonly) | Boolean | Set to `true` to only allow admins to manage the doc type. |
| [`autopublish`](#autopublish) | Boolean | Set to `true` to publish all saved edits immediately. |
| [`label`](#label-for-doc-types) | String | The human-readable label for the doc type. |
| [`localized`](#localized) | Boolean | Set to `false` to exclude the doc type in the locale system. |
| [`sort`](#sort) | Object | Configure sort order for docs of this type. |
| [`slugPrefix`](#slugprefix) | String | Add a prefix to all slugs for this doc type. |
<!-- - [`contextBar`](#contextbar) -->

### `adminOnly`

<!-- TODO: link to permissions docs when available. -->
If `true`, only users with the sitewide admin permission can read or write docs of this type. The `@apostrophecms/user` module uses this setting due to its impact on user access. There is no default value.

#### Example

<AposCodeBlock>
```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    adminOnly: true
  },
  // ...
}
```
<template v-slot:caption>
modules/official-memo/index.js
</template>
</AposCodeBlock>

### `autopublish`

Set `autopublish` to `true` to automatically publish any changes saved to docs of this type. There is then effectively no draft mode for this doc type.

The core image and file modules use this option, for example. It eliminates the need for users to think about the distinction between draft and published content while preserving the possibility of translation for different locales.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    autopublish: true
  },
  // ...
}
```
<template v-slot:caption>
modules/article-category/index.js
</template>
</AposCodeBlock>

<!-- ### `contextBar` -->

<!-- NOTE: Should we keep this on the secrete menu? (not document) -->
<!-- If `true`, the second row of the admin bar, the "context bar," will be disabled.
`true` ~ allows the admin bar context bar row to appear -->

### `label` (for doc types)

`label` should be set to a text string to be used in user interface elements related to this doc type. This includes buttons to open piece manager modals and the page type select field.

If not set, Apostrophe will convert the module `name` meta property to a readable label by splitting the `name` on dashes and underscores, then capitalizing the first letter of each word.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Featured Article'
  },
  // ...
}
```
<template v-slot:caption>
modules/feature/index.js
</template>
</AposCodeBlock>

### `localized`

Defaults to `true`. If set to `false`, this doc type will _not_ be included in the locale system. This means there will be only one version of each doc, regardless of whether multiple locales (e.g., for languages or regions) are active. The "users" piece disables localization in this way.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    localized: false
  },
  // ...
}
```
<template v-slot:caption>
modules/administrative-category/index.js
</template>
</AposCodeBlock>

### `sort`

The `sort` option for a doc type defines a sorting order for requests to the database for that type. The option is set to an object containing field name keys with `1` as a property value for ascending order and `-1` for descending order.

The default sort for all doc types is `{ updatedAt: -1 }`, meaning it returns documents based on the `updatedAt` property (the date and time of the last update) in descending order. The `sort` object can have multiple keys for more specific sorting.

#### Example

This `sort` setting will return articles first based on a custom `priority` field in ascending order, then by the core `updatedAt` property in descending order.

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    sort: {
      priority: 1,
      updatedAt: -1
    }
  },
  fields: {
    add: {
      priority: {
        type: 'integer',
        min: 1,
        max: 5
      },
      // ...
    }
  }
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `slugPrefix`

Set `slugPrefix` to a string to prepend all [slugs](/reference/glossary.md#slug) for docs of this type. This can prevent slugs, which must be unique to each doc, from being reserved in some cases. For example, Apostrophe image docs have the `slugPrefix` value of `'image-'` so images, which do not typically have public pages, do not accidentally reserve a more reader-friendly slug.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    slugPrefix: 'category-'
  },
  // ...
}
```
<template v-slot:caption>
modules/article-category/index.js
</template>
</AposCodeBlock>

## Options for all piece modules

Option settings in this section apply to all piece modules (those that extend `@apostrophecms/piece-type`).

| Option | Value type | Description |
|---------|---------|---------|
| [`pluralLabel`](#plurallabel) | String | The plural readable label for the piece type. |
| [`perPage`](#perpage) | Integer | The number of pieces to include in a set of `GET` request results. |
| [`publicApiProjection`](#publicapiprojection-for-pieces) | Object | Piece fields to make available via a public REST API route. |
| [`quickCreate`](#quickcreate-for-pieces) | Boolean | Set to `true` to add the piece type to the quick create menu. |
| [`searchable`](#searchable) | Boolean | Set to `false` to remove the piece type from search results. |

### `pluralLabel`

Similar to `label` for all doc types, the `pluralLabel` option sets the string the user interface will use to describe a piece type in plural contexts. All page types are referred to as "Pages" in these contexts, but pieces should have unique labels (e.g., "Articles," or "Teams").

If no `pluralLabel` value is provided, Apostrophe will append the `label` (whether set manually or generated [as described](#label)), with "s", as is typical for English words. **Even in English this is often not correct, so `pluralLabel` should usually be defined explicitly.**

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Goose',
    pluralLabel: 'Geese'
  },
  // ...
}
```
<template v-slot:caption>
modules/goose/index.js
</template>
</AposCodeBlock>

### `perPage`

In piece types, the `perPage` option, expressed as an integer, sets the number of pieces that will be returned in each "page" [during `GET` requests](/reference/api/pieces.md#get-api-v1-piece-name) that don't specify an `_id`. This value defaults to 10.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    perPage: 20 // REST `GET` requests will return 20 pieces per page.
  },
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `publicApiProjection` (for pieces)

By default the built-in Apostrophe REST APIs are not accessible without proper [authentication](/reference/api/authentication.md). You can set an exception to this for `GET` requests to return specific document properties with the `publicApiProjection` option.

This should be set to an object containing individual field name keys set to `1` for their values. Those fields names included in the `publicApiProjection` object will be returned when the `GET` API requests are made without authentication.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    publicApiProjection: {
      title: 1,
      authorName: 1,
      _url: 1 // üëà Dynamic properties are allowed
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

Unauthenticated [`GET /api/v1/article`](/reference/api/pieces.md#get-api-v1-piece-name) requests would return each piece with only the `title`, `authorName`, and `_url` properties.

### `quickCreate` (for pieces)

Setting `quickCreate: true` on a piece adds that piece type to the admin bar "quick create" menu. The Apostrophe admin bar user interface includes the quick create menu button to add new pieces without first opening their respective manager modals.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    quickCreate: true
  },
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

### `searchable`

<!-- TODO: link to documentation of Apostrophe search when available. -->
Setting `searchable: false` on a piece type will exclude that piece type from the results in Apostrophe's built-in search.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    searchable: false
  },
  // ...
}
```
<template v-slot:caption>
modules/article/index.js
</template>
</AposCodeBlock>

## Options for the core page module

Option settings in this section apply to the core page module (`@apostrophecms/page`).

| Option | Value type | Description |
|---------|---------|---------|
| [`builders`](#builders) | Object | Set query builder values to be used when pages are served. |
| [`home`](#home) | Boolean/Object | Change how the home page is added to `req.data` when pages are served. |
| [`minimumPark`](#minimumpark) | Array | Override default parked pages, including the home page. |
| [`park`](#park) | Array | Set pages to be created on site start with configuration. |
| [`publicApiProjection`](#publicapiprojection-for-pages) | Object | Set query builder values to be used when pages are served. |
| [`quickCreate`](#quickcreate-for-pages) | Boolean | Set to `false` to remove pages from the quick create menu. |
| [`types`](#types) | Array | Set the page types available for new pages. |

### `builders`

<!-- TODO: Update builders with link to a more detailed explanation of builders when available. -->
The `builders` option can be used to apply any existing query builders when a page is served by its URL. This affects the data available on the page object, `req.data.page` (`data.page` in templates).

The default value is:
```javascript
{
  children: true,
  ancestors: { children: true }
}
```

In this example, page objects are fetched with one level of page tree "children" as `_children` and their "ancestor" pages, each with one level of their child pages, on `_ancestors`.


#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    builders: {
      children: { depth: 2 }
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

In this example, we are not including ancestor pages and are requesting two levels of child pages (direct children and their direct children).

### `home`

The home page document is added to all page requests on `req.data.home` so it can be referenced in all page templates. That home page object also includes a `_children` property containing an array of top level page objects. The `home` option offers minor performance improvements for large sites by setting one of the following values:

| Setting | Description |
|---------|-------------|
| `false` | Disables adding the home page document to the requests. |
| `{ children: false }` | Includes the home page document, but without the child pages array. If the [`builders` option](#builders) has an `ancestors` property, that will take precedence. |

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    home: { children: false }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>


### `minimumPark`

The `minimumPark` option sets the initial defaults for the home page and archive "page" (the page archive). This should normally be left as it is. A possible use case for changing this might be when building an installable module meant to change the defaults for all websites that use it.

::: warning
Configuring this poorly, especially by leaving out one of the two required pages, will break page functionality. In almost every situation it is better to use the [`park`](#park) option instead, including for updating home page properties.

The default is:
```javascript
[
  {
    slug: '/',
    parkedId: 'home',
    _defaults: {
      title: 'Home',
      type: '@apostrophecms/home-page'
    }
  },
  {
    slug: '/archive',
    parkedId: 'archive',
    type: '@apostrophecms/archive-page',
    archived: true,
    orphan: true,
    title: 'Archive'
  }
]
```

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    minimumPark: [
      {
        slug: '/',
        parkedId: 'home',
        _defaults: {
          title: 'Welcome',  // üëà
          type: 'welcome-page' // üëà
        }
      },
      {
        slug: '/archive',
        parkedId: 'archive',
        type: '@apostrophecms/archive-page',
        archived: true,
        orphan: true,
        title: 'Archive'
      }
    ]
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

### `park`

Use the `park` option to add an array of pages that should be created when the app starts up if they do not already exist. Each page is added as an object with initial properties, including the required `parkedId`.

Required and recommended parked page properties include:

| Setting | Requirement | Description |
|---------|-------------|-------------|
| `parkedId` | Required | A unique ID value used to identify it among parked pages. |
| `slug` | Required | The page [slug](/reference/glossary.md#slug). |
| `type` | Required | The page type to be used for the parked page. |
| `title` | Recommended | The page title. If not set, it will be "New Page." |

If added on the top level of the page object, these properties will not be editable through the user interface. Properties other than `parkedId` may be included in a `_defaults` property instead, which will allow them to be edited in the UI.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    park: [
      // The blog page has a permanent slug, title, and type.
      {
        parkedId: 'blogParkedId',
        slug: '/blog',
        title: 'Blog',
        type: 'blog-page'
      },
      // The team page has a permanent type, but editable slug and title.
      {
        parkedId: 'teamParkedId',
        type: 'staff-page',
        _defaults: {
          slug: '/team',
          title: 'Our Team',
        }
      }
    ]
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

### `publicApiProjection` (for pages)

By default the built-in Apostrophe REST APIs are not accessible without proper [authentication](/reference/api/authentication.md). You can set an exception to this for `GET` requests to return specific document properties with the `publicApiProjection` option.

This should be set to an object containing individual field name keys set to `1` for their values. Those fields names included in the `publicApiProjection` object will be returned when the `GET` API requests are made without authentication.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    publicApiProjection: {
      title: 1,
      _url: 1 // üëà Dynamic properties are allowed
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

Unauthenticated [`GET /api/v1/@apostrophecms/page`](/reference/api/pages.md#get-api-v1-apostrophecms-page) requests would return each piece with only the `title` and `_url` properties.

### `quickCreate` (for pages)

Pages are included in the admin bar "quick create" menu by default. Setting `quickCreate: false` on the page module will disable this.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    quickCreate: false
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

### `types`

The `types` array defines the page types available to users when creating or editing pages. Each item in the array should have a `label` property and a `name` property, which matches an active page type. If no `types` array is set, only the core "Home" page type will be available.

[Parked pages](#park) may use page types that are not in the `types` option array. This allows developers to do things such as parking a single search page but not allowing users to create additional search pages.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    types: [
      {
        name: 'default-page',
        label: 'Default'
      },
      {
        name: 'article-page',
        label: 'Article Index'
      }
      {
        name: '@apostrophecms/home-page',
        label: 'Home'
      }
    ]
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

## Options for page type modules

Option settings in this section apply to all page types (modules that extend `@apostrophecms/page-type`).

| Option | Value type | Description |
|---------|---------|---------|
| [`scene`](#scene) | String | Change the "scene" for this page type from the default `'public'`. |

### `scene`

Scenes are contexts in which certain sets of front end assets are delivered. Normally, anonymous site visitors receive only the stylesheets and scripts included in the `'public'` asset scene (those that are placed in the module's `ui/public` directory). If your page will use assets, such as Apostrophe's modals, that are normally reserved for logged-in users you can set `scene: 'apos'` in order to load them with pages of this type.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/page-type',
  options: {
    scene: 'apos'
  },
  // ...
}
```
<template v-slot:caption>
modules/fancy-form-page/index.js
</template>
</AposCodeBlock>

## Options for piece page types

Option settings in this section apply to all piece page types (modules that extend `@apostrophecms/piece-page-type`).

| Option | Value type | Description |
|---------|---------|---------|
| [`perPage`](#perpage) | Integer | Set the number of pieces to display in each set of paginated index page results. |
| [`next`](#next) | Boolean/Object | Enable and optionally configure the `req.data.next` object. |
| [`piecesFilters`](#piecesfilters) | Array | Configure pieces filters for index pages. |
| [`pieceModuleName`](#piecemodulename) | String | Specify the associated piece type if it doesn't match the module name. |
| [`previous`](#previous) | Boolean/Object | Enable and optionally configure the `req.data.previous` object. |

### `perPage`

For piece pages, the `perPage` option, expressed as an integer, defines the number of pieces that will be added to the `req.data.pieces` array when the page is served. The specific pieces in the set will be based on the total number of pieces and the `page` query parameter in the request.

This is, more simply, the number of pieces that will normally be displayed on each page of a [paginated index page](/reference/glossary.md#index-page). This value defaults to 10.
<!-- TODO: Change index page link to a guide on index pages when available. -->

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    perPage: 12
  },
  // ...
}
```
<template v-slot:caption>
modules/article-page/index.js
</template>
</AposCodeBlock>

### `next`

If set to `true`, Apostrophe will include the next piece, based on the [sort option](#sort), on `req.data.next` when serving a [show page](/reference/glossary.md#show-page). This is useful to add links to a show page directing visitors to the next item in a series (e.g., the next oldest blog post). If not set, `req.data.next` will not be available.

`next` can also be set to an object, which will be used as a query builder for retrieving that next piece document.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    next: true
  },
  // ...
}

// OR

module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    // The next article piece would be returned with only the `title`, `_url`,
    // and `publishedAt` properties.
    next: {
      project: {
        title: 1,
        _url: 1,
        publishedAt: 1
      }
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/article-page/index.js
</template>
</AposCodeBlock>

### `piecesFilters`

<!-- TODO: Link to a guide on using piece filters when available. -->
<!-- TODO: Link to a better query builder guide when available. -->
`piecesFilters`, configured as an array of objects, supports filtering pieces on an [index page](/reference/glossary.md#index-page). Each object must have a `name` property associated with a valid [query builder](/reference/module-api/module-overview.md#queries-self-query). These include:

- Custom query builders configured in an app that include a `launder` method
- Field names whose field types automatically get builders:
  - `boolean`
  - `checkboxes`
  - `date`
  - `float`
  - `integer`
  - `relationship`
  - `select`
  - `slug`
  - `string`
  - `url`

When the index page is served, configured filters will be represented on a `req.data.piecesFilters` object (`data.piecesFilters` in the template). If you include `counts: true` in a filter object, the number of pieces matching that filter are included on `req.data.piecesFilters` properties.

#### Example

<AposCodeBlock>

```javascript
// üëÜ
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    piecesFilters: [
      { name: '_author' },
      {
        name: 'category',
        counts: true
      }
    ]
  },
  fields: {
    _author: {
      type: 'relationship',
      label: 'Author'
    },
    category: {
      type: 'select',
      label: 'Category',
      choices: [
        // Category choices here
      ]
    }
    // Other fields...
  },
  // ...
}
```
<template v-slot:caption>
modules/article-page/index.js
</template>
</AposCodeBlock>

### `pieceModuleName`

Piece page types are each associated with a single piece type. If named with the pattern `[piece name]-page`, the associated piece type will be detected automatically. For example, if the `article-page` module extends `@apostrophecms/piece-page-type`, it will automatically be associated with an `article` piece type.

You can override this pattern by explicitly setting `pieceModuleName` to an active piece type name. Ths can be useful if there is more than one piece page type for a single piece type (e.g., to support different functionality in each).

#### Example

<AposCodeBlock>

```javascript
// üëÜ This module name would look for a piece type named `team` if not for
// `pieceModuleName`
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    pieceModuleName: 'person'
  },
  // Maybe there's code here to group people by team.
  // ...
}
```
<template v-slot:caption>
modules/team-page/index.js
</template>
</AposCodeBlock>

### `previous`

If set to `true`, Apostrophe will include the previous piece, based on the [sort option](#sort), on `req.data.previous` when serving a [show page](/reference/glossary.md#show-page). This is useful to add links to a show page directing visitors to the previous item in a series (e.g., the next newest blog post). If not set, `req.data.previous` will not be available.

`previous` can also be set to an object, which will be used as a query builder for retrieving that next piece document.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    previous: true
  },
  // ...
}

// OR

module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    // The previous article piece would be returned with only the `title`,
    // `_url`, and `publishedAt` properties.
    previous: {
      project: {
        title: 1,
        _url: 1,
        publishedAt: 1
      }
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/article-page/index.js
</template>
</AposCodeBlock>


## Options for widget modules

Option settings in this section apply to all widgets (modules that extend `@apostrophecms/widget-type`).


| Option | Value type | Description |
|---------|---------|---------|
| [`className`](#classname) | String | Applies a class to core widget templates. |
| [`icon`](#icon) | String | Select an available icon to include with the label in area menus. |
| [`label`](#label-for-widgets) | String | The human-readable label for the widget type. |

<!-- | [`scene`](#scene) | null | description | -->
<!-- | [`contextual`](#contextual) | Boolean | description | -->

### `className`

Official Apostrophe widget templates support adding an html class from the `className` module option. The class is applied to the outer, wrapping HTML element in the widget template for easy styling.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    className: 'c-image-widget'
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/image-widget/index.js
</template>
</AposCodeBlock>

<!-- NOTE: Not ready to document yet. There are elements to this that need to be worked out. -->
<!--
### `contextual`

Some widgets, including the core rich text widget, should not be edited in a modal. Setting `contextual: true` on a widget module will tell the user interface, when in edit mode, to load the widget immediately using its associated editor component. `@apostrophecms/rich-text-widget` is the best example of this in core. Widgets that only serve to provide layout for nested areas are another possible use case.

**It is important that the widget type has a [configured `widgetEditor` component](#components) that is built for this purpose.** If there is no such component, the widget editor modal will open immediately on load.

#### Example

```javascript
// modules/@apostrophecms/layout-widget/index.js
module.exports = {
  options: {
    contextual: true,
    components: {
      // üëá This refers to a project-level `MyCustomLayoutWidgetEditor.vue`
      // component file.
      widgetEditor: 'MyCustomLayoutWidgetEditor',
      widget: 'AposWidget'
    }
  },
  // ...
}
```
-->

### `icon`

Identify an icon to be used with a widget label in the area menu with the `icon` option. That icon must be included in the [list of globally available UI icons](https://github.com/apostrophecms/apostrophe/blob/main/modules/@apostrophecms/asset/lib/globalIcons.js) or configured on the module in its `icons` section. See the [module settings reference](/reference/module-api/module-overview.md#icons) for how to make new icons available.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    icon: 'pillar'
  },
  icons: {
    pillar: 'Pillar'
  },
  // ...
};

```
<template v-slot:caption>
modules/two-column-widget/index.js
</template>
</AposCodeBlock>

!['Area menu with icons next to widget labels'](/images/area-menu-with-icons.png)

### `label` (for widgets)

`label` should be set to a text string to be used in the area menu. If not set, Apostrophe will convert the module `name` meta property to a readable label by removing `-widget` from the end, splitting the `name` on dashes and underscores, and capitalizing the first letter of each word.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Two Column Layout'
  },
  // ...
};

```
<template v-slot:caption>
modules/two-column-widget/index.js
</template>
</AposCodeBlock>

<!-- TODO: Flesh out once questions around scenes are resolve, or delete. -->
<!-- ### `scene` -->

## Options for the core rich text widget

Option settings in this section apply to the core rich text widget module (`@apostrophecms/rich-text-widget`).

| Option | Value type | Description |
|---------|---------|---------|
| [`defaultData`](#defaultdata) | Object | Define initial default data for rich text content. |
| [`defaultOptions`](#defaultoptions) | Object | Configure the rich text toolbar and styles for rich text widgets. |
| [`editorTools`](#editortools) | Object | Configure rich text tools and their Vue components. |

### `defaultData`

Rich text widgets can start with default content by setting `defaultData` to an object with a `content` property. That value would be a string of text or HTML that all rich text widgets would include when added.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    defaultData: {
      content: '<p>Replace me</p>'
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/rich-text-widget/index.js
</template>
</AposCodeBlock>

### `defaultOptions`

The rich text widget is configured by default with useful [rich text toolbar settings and styles](https://github.com/apostrophecms/apostrophe/blob/main/modules/@apostrophecms/rich-text-widget/index.js#L87). These can be overridden by setting `defaultOptions`. This configuration object can include any of the `toolbar`, `styles`, and `color` sub-options. Sub-options that are not included will fall back to the defaults.

`defaultOptions` can also be overridden in schema configuration where an area configures its rich text widgets. So a project can have site-wide defaults, but a specific area can have its own separate configuration.

#### Example

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    defaultOptions: {
      toolbar: [
        'bold',
        'color',
        'italic',
        'link'
      ],
      styles: [],
      color: {
        presetColors: [ '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff'],
      }
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/rich-text-widget/index.js
</template>
</AposCodeBlock>

<!-- TODO: Link to a guide page about configuring the RTE when available. -->

### `editorTools`

The rich text editor toolbar tools (e.g., "bold," "link," and "underline" buttons) can be reconfigured to have different labels (seen by assistive technologies), different icons, or even new Vue components altogether. `editorTools` can be completely overridden to do this if desired.

::: warning
Using this option takes full responsibility for the configuration of the rich text editor tools. Use this with caution. If overriding, be sure to include _all_ rich text tools that you will use.

If introducing an editor tool that is not included in core, you will need to create both the Vue component and, often, a [tiptap extension](https://tiptap.dev/docs/guide/extensions.html#installation).
<!-- TODO: link to an RTE extension guide when available. -->

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    editorTools: {
      styles: {
        component: 'MyTiptapStyles',
        label: 'Styles'
      },
      '|': { component: 'MyTiptapDivider' },
      bold: {
        component: 'MyTiptapButton',
        label: 'Bold',
        icon: 'format-bold-icon'
      },
      italic: {
        component: 'MyTiptapButton',
        label: 'Italic',
        icon: 'format-italic-icon'
      },
      // Many more tools...
    }
  },
  // ...
}
```
<template v-slot:caption>
modules/@apostrophecms/rich-text-widget/index.js
</template>
</AposCodeBlock>

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Module Configuration > Server Events
DOC_PATH: reference/server-events.md
URL: https://apostrophecms.com/docs/reference/server-events
================================================================================
# Server-side events

Each section below includes server-side events emitted by a particular module *and [modules that extend them](/guide/modules.md#module-inheritance)* (e.g., all piece types emit the events listed for `@apostrophecms/piece-type`). See the [server-side events guide](/guide/server-events.md) for more detail on using events.

Code block examples represent the [`handlers`](/reference/module-api/module-overview.md#handlers-self) section of a module.

::: info
As a reminder, when referencing an event in the `handlers` section *from within the module that emits it* we only need to use the event name. This includes events emitted by functionality that a module inherits (e.g., all piece type modules emit events from `@apostrophecms/piece-type` functionality).

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      // 'beforeSave' is an event the @apostrophecms/user module emits.
      'beforeSave': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/user/index.js
  </template>
</AposCodeBlock>

When naming an event emitted *by a different module*, the event name must be prefixed with the name of the module that emitted it followed by a colon.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      // This team module is specifically listening for 'beforeSave' on
      // the @apostrophecms/user module.
      '@apostrophecms/user:beforeSave': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/team/index.js
  </template>
</AposCodeBlock>

## Core app events

These events are emitted by the primary Apostrophe app. Reference these events with the prefix `apostrophe:` (e.g., `apostrophe:ready`).

### `destroy`

Triggered when the app's `destroy` method is called. Most commonly used in tests. Your handlers should clean up any custom `setTimeout` or `setInterval` timers and/or open socket or database connections you have created. You should not "destroy" your actual website content. Just close any remaining open connections, timeouts, etc.

There is no data included with the event for handlers.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'apostrophe:destroy': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/any-module/index.js
  </template>
</AposCodeBlock>

### `modulesRegistered`

Triggered during startup after all modules are registered and their `init` functions run. This is the last opportunity to adjust module configuration (e.g., field schema) in response to other active modules.

There is no data included with the event for handlers. Previously named `modulesReady`, which still works as an alias.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'apostrophe:modulesRegistered': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/any-module/index.js
  </template>
</AposCodeBlock>

### `ready`

Invoked after all `apostrophe:modulesRegistered` handlers and start up functions have completed. All modules are now completely ready for work.

There is no data included with the event for handlers. Previously named `afterInit`, which still works as an alias.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'apostrophe:ready': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/any-module/index.js
  </template>
</AposCodeBlock>

### `run`

**Not intended for project use.** If Apostrophe was invoked as a command line task, Apostrophe's task module responds to this event by executing the task. Otherwise, Apostrophe's Express module responds to this event by listening for connections. If your goal is to do something just before that happens, you should listen for `apostrophe:ready` instead.

#### Parameters

- `isTask`: A boolean value indicating whether the process was started as an [Apostrophe task](/reference/module-api/module-overview.md#tasks-self).

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'apostrophe:run': {
        async handlerName(isTask) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/any-module/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/db` events

Events emitted by the `@apostrophecms/db` module.

### `reset`

Invoked after all collections are dropped from the database in the `@apostrophecms/db:reset` command line task.

There is no data included with the event for handlers.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'reset': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/db/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/doc` events

Events emitted by the `@apostrophecms/doc` module.

### `fixUniqueError`

Triggered when a unique key error is thrown by MongoDB. Apostrophe uses this to modify the slug property to make it unique.

#### Parameters

- `req`: The active request
- `doc`: The database document that triggered the error

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'fixUniqueError': {
        async handlerName(req, doc) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc/index.js
  </template>
</AposCodeBlock>

### `afterReplicate`

Triggered after Apostrophe automatically replicates certain documents across all locales, including parked pages and piece types with the `replicate: true` option. This runs once during startup.

There is no data included with the event for handlers.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterReplicate': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc/index.js
  </template>
</AposCodeBlock>

### `afterAllModesDeleted`

Triggered after Apostrophe automatically deletes all modes of a certain document. If the doc type module has the `localized: false` setting this event will not be emitted.

#### Parameters

- `req`: The active request
- `doc`: The draft mode data of the document being deleted
- `options`: Any options passed to the `delete` method of the corresponding document type

<AposCodeBlock>

  ```javascript
  handlers(self) {
    return {
      'afterAllModesDeleted': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/doc-type` events

These events are emitted by **all page type and piece type modules** since they extend `@apostrophecms/doc-type`. In most cases it will be best to watch for the event from a piece type or page type module rather than the doc type module.

If specifically watching events on `@apostrophecms/doc-type`, as opposed to modules that extend it, **it will normally be important to check the `type` of the document in question** before proceeding with the handler's work.

### `beforeInsert`

Triggered just *before* Apostrophe inserts a document into the database for the first time.

#### Parameters

- `req`: The active request
- `doc`: The document data being inserted into the database
- `options`: Any options passed from the `insert` method

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeInsert': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `beforeUpdate`

Triggered just *before* Apostrophe updates an existing document in the database.

#### Parameters

- `req`: The active request
- `doc`: The document data being updated in the database
- `options`: Any options passed from the `update` method

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeUpdate': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `beforeSave`

Triggered just *before* Apostrophe either inserts *or* updates a document. Invoked immediately after `beforeInsert` and `beforeUpdate` in their respective cases.

#### Parameters

- `req`: The active request
- `doc`: The document data being saved to the database
- `options`: Any options passed from the saving method

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeSave': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterInsert`

Triggered just *after* Apostrophe inserts a document into the database for the first time. The `doc._id` property is available at this point.

#### Parameters

- `req`: The active request
- `doc`: The document data being inserted into the database
- `options`: Any options passed from the `insert` method

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterInsert': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterUpdate`

Triggered just *after* Apostrophe updates an existing document in the database.

#### Parameters

- `req`: The active request
- `doc`: The document data being updated in the database
- `options`: Any options passed from the `update` method

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterUpdate': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterSave`

Triggered just *after* Apostrophe either inserts *or* updates a document. Invoked immediately after `afterInsert` and `afterUpdate` in their respective cases.

#### Parameters

- `req`: The active request
- `doc`: The document data being saved to the database
- `options`: Any options passed from the saving method

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterSave': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `beforeDelete`

Triggered just *before* Apostrophe permanently deletes an existing document from the database.

#### Parameters

- `req`: The active request
- `doc`: The document being deleted from the database
- `options`: Any options passed from the deleting method

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeDelete': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterDelete`

Triggered just *after* Apostrophe permanently deletes an existing document from the database.

#### Parameters

- `req`: The active request
- `doc`: The document being deleted from the database
- `options`: Any options passed from the deleting method

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterDelete': {
        async handlerName(req, doc, options) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterArchive`

Triggered after a document is archived when saving it.

#### Parameters

- `req`: The active request
- `doc`: The document being archived

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterArchive': {
        async handlerName(req, doc) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterRescue`

Triggered after a document is rescued (the opposite of archiving) when saving it.

#### Parameters

- `req`: The active request
- `doc`: The document being rescued

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterRescue': {
        async handlerName(req, doc) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `beforePublish`

Triggered just *before* a draft document is published.

#### Parameters

- `req`: The active request
- `data`: An object containing the following properties:
  - `draft`: The draft document data
  - `published`: The document data as it will be published
  - `options`: Any options passed from the `publish` method
  - `firstTime`: A boolean value, `true` if the document has never been published before

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforePublish': {
        async handlerName(req, data) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterPublish`

Triggered just *after* a draft document is published.

#### Parameters

- `req`: The active request
- `data`: An object containing the following properties:
  - `draft`: The draft document data
  - `published`: The document data as it will be published
  - `options`: Any options passed from the `publish` method
  - `firstTime`: A boolean value, `true` if the document has never been published before

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterPublish': {
        async handlerName(req, data) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterRevertDraftToPublished`

Triggered after a draft document is reverted to the most recent published state. This is separate from the undo and redo features in the user interface.

#### Parameters

- `req`: The active request
- `result`: An object containing the following property:
  - `draft`: The *new* draft document

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterRevertDraftToPublished': {
        async handlerName(req, result) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

### `afterRevertPublishedToPrevious`

Triggered after a published document is reverted to the most recent "previous" state (the previous published version). This is separate from the undo and redo features in the user interface.

#### Parameters

- `req`: The active request
- `result`: An object containing the following property:
  - `published`: The *new* published document

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterRevertPublishedToPrevious': {
        async handlerName(req, result) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/doc-type/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/express` events

Events emitted by the `@apostrophecms/express` module.

### `afterListen`

Triggered after the Express module begins listening for connections.

There is no data included with the event for handlers.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterListen': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/express/index.js
  </template>
</AposCodeBlock>

### `compileRoutes`

**Not intended for project use.** Triggered prior to middleware and route registration. Used to get all modules to compile their respective routes for registration. To add custom routes, configure the appropriate properties of your module, (e.g., `apiRoutes`, `restApiRoutes`).

There is no data included with the event for handlers.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'compileRoutes': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/express/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/login` events

Events emitted by the `@apostrophecms/login` module.

### `deserialize`

Triggered on every request made when a user is logged in, populating `req.user`.

#### Parameters

- `user`: The user's data from the database

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'deserialize': {
        async handlerName(user) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/login/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/migration` events

Events emitted by the `@apostrophecms/migration` module.

### `after`

Triggered after all data migrations have run. The database is now in a stable state.

There is no data included with the event for handlers.

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'after': {
        async handlerName() { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/migration/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/page` events

Events emitted by the `@apostrophecms/page` module.

### `beforeSend`

Triggered just before a page template is rendered and sent as a response to a request. This can be a good place to adjust the data available to the template  by amending `req.data`. Also see the [async components guide](/guide/async-components.md), as that can be a cleaner way to package code that fetches data during rendering.

#### Parameters

- `req`: The active request

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeSend': {
        async handlerName(req) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

### `serveQuery`

Triggered just before the database query executes to find the best matching page for a request. This can be used to make final adjustments to the query.

#### Parameters

- `req`: The active request
- `query`: The database query that will execute

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'serveQuery': {
        async handlerName(req, query) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

### `serve`

Triggered just before Apostrophe attempts to serve a requested page.

#### Parameters

- `req`: The active request

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'serve': {
        async handlerName(req) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

### `notFound`

Triggered when Apostrophe fails to find a matching page for a request, just before the 404 response. This is a final chance to do extra work to find a matching page and assign the URL to `req.redirect`.

#### Parameters

- `req`: The active request

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'notFound': {
        async handlerName(req) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>


## `@apostrophecms/page-type` events

These events are emitted by **all page type modules** since they extend `@apostrophecms/page-type`. In most cases it will be best to watch for the event from a page type's module rather than the `@apostrophecms/page-type` module.

If specifically watching events on `@apostrophecms/page-type`, as opposed to modules that extend it, **it will normally be important to check the `type` of the page in question** before proceeding with the handler's work.

### `beforeUnpublish`

Triggered just before a page's published document is deleted, leaving only a draft document.

#### Parameters

- `req`: The active request
- `published`: The published document that is about to be unpublished

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeUnpublish': {
        async handlerName(req, published) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

### `beforeMove`

Triggered just *before* a page is moved from one position in the page tree to another.

#### Parameters

- `req`: The active request
- `page`: The page being moved
- `target`: The page used as a target for positioning in the page tree
- `position`: The position to place the page in relation to the target: `before` and `after` insert the new page as a sibling of the target; `firstChild` and `lastChild` insert the new page as a child of the target

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeMove': {
        async handlerName(req, page, target, position) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

### `afterMove`

Triggered just *after* a page is moved from one position in the page tree to another.

#### Parameters

- `req`: The active request
- `page`: The page being moved
- `data`: An object containing the following properties:
  - `originalSlug`: The page's slug prior to moving
  - `originalPath`: The page's path prior to moving
  - `changed`: An array of all pages that were changed by the move, including children of the moved page
  - `target`: The page used as a target for positioning in the page tree
  - `position`: The position to place the page in relation to the target

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterMove': {
        async handlerName(req, page, data) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>


### `afterConvert`

Triggered after page data is run through the schema module's `convert` method, validating its data to the page type's field schema.

#### Parameters

- `req`: The active request
- `data`: The data being saved to the page, prior to schema conversion
- `page`: The page as it will be saved, following schema conversion

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterConvert': {
        async handlerName(req, data, page) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/piece-type` events

These events are emitted by **all piece type modules** since they extend `@apostrophecms/piece-type`. In most cases it will be best to watch for the event from a piece type's module rather than the `@apostrophecms/piece-type` module.

If specifically watching events on `@apostrophecms/piece-type`, as opposed to modules that extend it, **it will normally be important to check the `type` of the piece in question** before proceeding with the handler's work.

### `beforeUnpublish`

Triggered just before a piece's published document is deleted, leaving only a draft document.

#### Parameters

- `req`: The active request
- `published`: The published document that is about to be unpublished

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeUnpublish': {
        async handlerName(req, published) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/piece-type/index.js
  </template>
</AposCodeBlock>

### `afterConvert`

Triggered after piece data is run through the schema module's `convert` method, validating its data to the piece type's field schema.

#### Parameters

- `req`: The active request
- `data`: The data being saved to the piece, prior to schema conversion
- `piece`: The piece as it will be saved, following schema conversion

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'afterConvert': {
        async handlerName(req, data, piece) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/piece-type/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/search` events

Events emitted by the `@apostrophecms/search` module.

### `determineTypes`

Triggered after the search module identifies the document types to include in search results. This is a chance to change the included types.

#### Parameters

- `types`: An array of document type names

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'determineTypes': {
        async handlerName(types) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/search/index.js
  </template>
</AposCodeBlock>

### `beforeIndex`

Triggered just before the search index page is served, after the page's results are stored on `req.data.docs`.

#### Parameters

- `req`: The active request

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'beforeIndex': {
        async handlerName(req) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/search/index.js
  </template>
</AposCodeBlock>

## `@apostrophecms/template` events

Events emitted by the `@apostrophecms/template` module.

### `addBodyData`

**Not intended for project use.**  Triggered just before a body data object is added to a request prior to rendering a page. A module's `getBrowserData` and `enableBrowserData` are better places to work on this data in project code.

#### Parameters

- `bodyData`: The body data object as it has been constructed

<AposCodeBlock>

  ```javascript
  handlers(self, options) {
    return {
      'addBodyData': {
        async handlerName(bodyData) { ... }
      }
    };
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/template/index.js
  </template>
</AposCodeBlock>

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Module Configuration > Query Builders
DOC_PATH: reference/query-builders.md
URL: https://apostrophecms.com/docs/reference/query-builders
================================================================================
# Query builders

Server-side database query builders in Apostrophe help developer refine database document queries or refine the query results in some way. The sections below organize core query builders by the relevant document types.

**See the [database querying guide](/guide/database-queries.md) for general information about using query builders.**

## Builders for all doc types

The following query builders apply to all Apostrophe [doc types](/reference/glossary.md#doc).

### `addUrls()`

```
query.addUrls(false)
```

**Default value:** `true`

The `addUrls` builder controls whether to invoke the `addUrls` method for doc types included in the query results. If set to `false`, `addUrls` methods are not invoked.

This effectively controls whether the query results should include a `_url` property on individual documents, when available. `_url` is a dynamic property (not stored in the database) containing the document's unique URL. Not all documents have a unique URL.

Only piece type modules have an `addUrls` method in Apostrophe core. By default, page documents always include the `_url` property.

### `and()`

```
query.and({ price: { $gte: 0 } })
```

The `and` builder adds additional required criteria to the query. The value should be a MongoDB criteria object (as you would use in the [`find()` operation](https://docs.mongodb.com/v4.4/reference/method/db.collection.find/)). This is the main way to add criteria to a database query. It can be used multiple times to continue adding criteria.

Since this is the main way additional criteria get merged, this method performs a few transformations of the query to make it more readable when `APOS_LOG_ALL_QUERIES=1` is in the environment.

### `archived()`

```
query.archived(false)
```

The `archived` builder tells the query whether or not to include archived documents in the results. It takes boolean value, `undefined`, or `null` (empty).

If the builder value is `false`, `undefined` or this method is never called, the query only returns docs that are *not* in the archive. This is the default behavior for document queries.

If the value is `true` the query returns *only* docs in the archive. Note that permissions would still prevent a typical site visitor from obtaining any results, but an editor might.

If the value is `null` (not `undefined`), the query returns docs regardless of archived status.

### `areas()`

```
query.areas(false)

query.areas([ 'thumbnail' ])
```

**Default value:** `true`

The `areas` builder controls whether to call the `load` methods of widget type managers for widgets in areas. `load` methods are used to do things such as populating relationships in widgets and other asynchronous actions when areas are loaded.

The default value is `true`. Pass `false` to prevent the extra processing for a particular query. This is helpful to make queries faster when detailed area data is not needed.

The value can also be an array containing strings representing area field names or dot paths to nested area fields. For example, with `.areas([ 'thumbnail' ])` you could load only the `'thumbnail'` area for all pages matching the query.

### `attachments()`

```
query.attachments(true)
```

**Default value:** `false`

Passing `true` to the `attachments` builder will annotate all attachment fields in the returned documents with URLs and other metadata (primarily for images). This uses the the `apos.attachment.all` method with the `annotate: true` option.

### `autocomplete()`

```
query.autocomplete('tree')
```

The `autocomplete` builder operates as a sort of fuzzy search for documents. It accepts a string and uses document search text properties to find matches. The string can contain multiple words, but only the final word may be a partial string to find non-exact results. So "tree" will find results with "treehouse," but "treehouses" will not find "treehouse" (it is not meant as an advanced search tool, but can help find similar results).

This will only find partial matches in high-priority properties such as the `title`, or any string, select or checkbox field in the schema of the document.

### `criteria()`

```
query.criteria({ category: { $in: ['animals', 'vegetables'] } })
```

**Default value:** `{}`

The `criteria` builder sets the base MongoDB query criteria, **discarding criteria previously added** using this method or the [`and` builder](#and). The `and` builder is usually better for most cases since it is not destructive. The default value of this builder is an empty object. As with the `and` builder, the criteria format would match that used in the [MongoDB `find` operation](https://docs.mongodb.com/v4.4/reference/method/db.collection.find/).

### `defaultSort()`

```
query.defaultSort({ updatedAt: 1 })
```

The `defaultSort` changes the default value for the [`sort` query builder](#sort).  The argument is the same as for the `sort` query builder: an object like `{ updatedAt: 1 }`, including a field name and `1` for ascending or `-1` for descending. See the [MongoDB `sort` method documentation](https://docs.mongodb.com/manual/reference/method/cursor.sort/) for other options. `false` can be passed as an option as well to clear the default sort.

It is distinct from the `sort` builder to distinguish between cases where a default sort should be ignored (for instance, the `search` query builder is present) and cases where a sort is explicitly requested by the user.

In most custom uses the `sort` builder will likely be a more common option.

### `_ids()`

```
query._ids([
  'ckwxzxdtr000t4v3rivysoari:en:published',
  'ckwxzxdvc001b4v3rhxvxqgg1:en:published'
])
```

The `_ids` builder causes the query to return only the documents with matching `_id` properties and to return them in that order, assuming the documents with the specified IDs exist. All documents are fetched in the locale and mode of the request regardless of the locale suffix of the values. If no locale can be determined via query parameters, the locale is inferred from the first _id in the set.

The query builder can also be called with a string, which is treated as a single document ID.

### `limit()`

```
query.limit(10)
```

The `limit` query builder accepts an integer and limits the number of document results. It returns the first matching documents up to the set limit after taking the [`skip` builder](#skip) into account.

### `locale()`

```
query.locale('es:published')
```

**Default value:** `false`

A valid locale identifier passed to the `locale` builder will tell the query to return results only belonging to that locale, including the mode (`draft` or `published`) after a `:` character. Documents that match the query and have *no locale* (because their doc type is not localized) are also included in the results. Specifically passing `false` (the default value) will use the locale and mode on the `req` request object.

### `log()`

```
query.log(true)
```

**Default value:** `false`

Setting the builder `.log(true)` on a query will log the the query criteria on the server (or the terminal when working on a local machine).

### `next()`

```
query.next({
  _id: 'cgwxzcdvc501b4v3ghxvxqgg1:en:published',
  ...
})
```

**Default value:** `false`

Passing a document object to the `next` builder returns the document that follows it in the current sort order. The document object argument needs to at least include the properties used by the current sort as well as the `_id`. The `_id` is used as a tiebreaker to avoid loops.

### `page()`

```
query.page(5)
```

**Default value:** `1`

The `page` builder is used to request a particular "page," or set, of results when the [`perPage` builder](#perpage) is also used. Page numbers start with `1` (there is no page zero).

### `pageUrl()`

```
query.pageUrl(false)
```

**Default value:** `true`

The `pageUrl` query builder is set to `true` by default and controls whether to add the `._url` property to page documents in the query results. The builder can be set to `false` to disable the `._url` property on a particular query.

The `._url` property will include a site prefix if applicable and is always better to use than the document's `slug` for a URL.

### `permission()`

```
query.permission('edit')
```

The `permission` builder is used to restrict returned documents based on the action name passed as an argument. Only documents on which the `req` object can take the named action are returned. For example, using `.permission('edit')` on the query will only return documents that the requesting user (via `req`) can edit.

Valid action arguments include:
- `'view'`: The `req` has permission to view the documents. This is the default.
- `'edit'`: The `req` has permission to edit the documents.
- `'publish'`: The `req` has permission to publish the documents.
- `false`: Bypass any permission checks. This returns everything regardless of permission level. *Use this with caution.*

In all cases, all of the returned docs are marked with `_edit: true` properties if the user associated with the request is allowed to edit the document and `_published: true` if the user is allowed to publish it. This is useful if you are fetching docs for viewing but also want to know which ones can be edited.

### `perPage()`

```
query.perPage(20)
```

**Default value:** `undefined`

Using the `perPage` builder returns documents in sets of the number passed as an argument. This helps return documents in managable numbers and paginate the results, using the [`page` query builder](#page) to get a specific set of results. This is usually easier than using `skip` and `limit` directly.

After the query completes, with `await query.toArray()` for instance, `query.get('totalPages')` will return the total number of pages.

### `previous()`

```
query.previous({
  _id: 'cgwxzcdvc501b4v3ghxvxqgg1:en:published',
  ...
})
```

**Default value:** `false`

Passing a document object to the `previous` builder returns the document that precedes it in the current sort order. The document object argument needs to at least include the properties used by the current sort as well as the `_id`. The `_id` is used as a tiebreaker to avoid loops.

### `project()`

```
query.project({
  title: 1,
  category: 1,
  updatedAt: 1
})
```

The `project` builders sets the [MongoDB projection](https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/), specifying the document properties to included in the returned documents. The argument should be an object with properties of desired field names set to `1` to include those fields. Negative projections (`category: 0`) are currently not supported.

In addition to database properties, Apostrophe provides two dynamic properties that can be included in the `project` builder object:
- `_url: 1` will include all properties required to generate an accurate `_url` property for each returned document.
- `_relationshipName: 1` will add the properties required to permit a field of type `relationship` to be loaded, even though the related documents are not stored redundantly in the database. In this example, the name of the field is `_relationshipName`. `_articles: 1` could do the same for a relationship to `article` pieces.

### `relationships()`

```
query.relationships(false)

query.relationships(['_author'])
```

**Default value:** `true`

By default, [relationship](/guide/relationships.md) data are fetched for queried documents. The `relationships` builder can prevent or limit this.

Pass `false` to the builder to not retrieve any relationship data. You may also pass an array of relationship names, which will fetch only those relationships and those intermediate to them (using dot notation).

### `sort()`

```
query.sort({ updatedAt: -1, title: 1 })
```

The `sort` builder sets the sorting order for returned documents. If not set, the default is used, from the [`defaultSort` builder](#defaultsort) or module configuration. The sort argument is an object like `{ updatedAt: 1 }`, including a field name and `1` for ascending or `-1` for descending.  See the [MongoDB `sort` method documentation](https://docs.mongodb.com/manual/reference/method/cursor.sort/) for other options.

`false` can be passed as an option to use *no sort definition at all*. This can be helpful when using MongoDB operators like `$near`, which already sort.

If this method is never called or the argument is `undefined`, a case-insensitive sort on the title is normally the default. If `search()` has been called, then a sort by search result quality is the default.

If the query sorts on a field that is defined in a doc type's schema with the `sortify: true` option, then this query builder will automatically substitute a "sortified" version of the field: case-insensitive and ignoring extra whitespace and punctuation. This provides a more natural sort than MongoDB normally does.

### `skip()`

```
query.skip(10)
```

The `skip` builder accepts a number as an argument, then skips that number of documents in a query's results. This affects `toArray` and `toObject`. It does not affect `toDistinct` or `toMongo`.

### `search()`

```
query.search('tree')
```

The `search` builder limits results to those matching the string passed as an argument. Search is implemented using MongoDB's `$text` operator and a full text index. The `search` builder does not support partial matches. For that, see the [`autocomplete` builder](#autocomplete).

If this query builder is set, the `sort` query builder will default to sorting by search quality. This is important because the worst of the full-text search matches will be of very poor quality.

### `type()`

```
query.type('product')
```

The `type` builder can be used to limit a query to only one particular doc type. Pass the doc type name (string) as an argument.

Generally you don't want to call this method directly. It will be better to use a doc type module's `find` method, which limits to that type automatically. You can also include the doc type name as the `type` criteria in a generic `find()` method's arguments.

### `withPublished()`

```
query.withPublished(true)
```

If the `withPublished` builder is set to `true`, then each document in the results will include a `_publishedDoc` property. That property will be set to the published version of that document. This is really only useful when querying for draft documents.

## Page document query builders

The following query builders are only available on query created with the page module's `apos.page.find` method and [page REST API routes](/reference/api/pages.md).

### `ancestors()`

```
query.ancestors(true)

query.ancestors({ children: true })
```

**Default value:** `false`

Setting the `ancestors` builder to `true` retrieves the array of "ancestors" for each returned page and assigns them to the `_ancestors` property. Page ancestors are those that precede a given page in the page tree hierarchy. The home page is `_ancestors[0]`. A returned page is not included in its own `_ancestors` array.

If the builder's argument is an object, the builder does all of the above, and also calls the query builders present in the object *on the query that fetches the ancestors*. For example, you can pass `{ children: true }` to fetch the children of each ancestor as the `_children` property of each ancestor, or pass `{ children: { depth: 2 } }` to get two layers of child pages.

`ancestors` also has its own `depth` option, but it might not do what you think. If the `depth` option is present as a top-level property of the `ancestors` builder argument, then only that number of ancestors are retrieved, counting backwards from the immediate parent of each page. So `{ depth: 2 }` retrieves only the two closest ancestors.

### `children()`

```
query.children(true)

query.children({ depth: 1 })
```

**Default value:** `false`

The `children` builder is used to include the "children" of returned pages in an array on a `_children` property. If `children(true)` is called, it will return all children of a given page. If the argument is an object, it may have a `depth` property to fetch a specific number of child layers. Any
other properties are passed on *as builders for the query that fetches the children*.

### `isPage()`

```
query.isPage(true)
```

**Default value:** `true`

Passing `true` to the `isPage` builder ensures that results will only include documents that are pages.

### `orphan()`

```
query.orphan(true)
```

The `orphan` builder is used to return documents based on their "orphan" status. Orphans are pages that are not returned by the default behavior of the `children` query builder and thus are left out of standard navigation.

If flag is `true`, return only orphan docs. If flag is `false`, return only docs that are not orphans. If `.orphan(null)` or `undefined` is called, or this method is never called, return docs regardless of orphan status.

## Image document query builders

The following query builders are only available on query created with the image module's `apos.image.find` method and [piece REST API routes](/reference/api/pieces.md) when dealing with the `@apostrophecms/image` piece type.


### `minSize()`

```
query.minSize([ 600, 800 ])
```

The `minSize` query builder can be used to set a minimum size for returned image documents. The argument should be an array with two values: the image width and the image height, in that order. The sizes are measured in pixels.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference
DOC_PATH: reference/api/rest-api-reference.md
URL: https://apostrophecms.com/docs/reference/api/rest-api-reference
================================================================================
# ApostropheCMS REST API

ApostropheCMS provides a comprehensive REST API for headless CMS functionality, enabling you to build modern applications with any frontend framework while managing content through Apostrophe's intuitive editing experience.

## Getting Started

The REST API gives you programmatic access to all your content and media:

- **Content Management**: Create, read, update, and delete pages and pieces
- **Media Operations**: Upload, crop, and organize images and files
- **Multilingual Support**: Manage content across multiple locales
- **Flexible Authentication**: API keys for server-to-server, bearer tokens for client apps

### Quick Start

All API endpoints follow RESTful conventions and return JSON responses. Most operations require authentication:

```javascript
// Example: Fetch published articles
const response = await fetch('https://example.net/api/v1/article', {
  headers: {
    'Authorization': 'Bearer your-token-here'
  }
});
const articles = await response.json();
```

## Core API Documentation

<AposTwoColumns>
  <template #leftColumn>
    <AposCtaButton
      detail-heading="API"
      title="Authentication"
      content="Learn about API keys, bearer tokens, and session cookies for authenticating your REST API requests."
      url="/reference/api/authentication"
      hideEffort="true"
    />
  </template>
  <template #rightColumn>
    <AposCtaButton
      detail-heading="API"
      title="Field Formats"
      content="Examples of how each field type appears in API responses, from simple strings to complex areas and relationships."
      url="/reference/api/field-formats"
      hideEffort="true"
    />
  </template>
</AposTwoColumns>

### Content APIs

<AposTwoColumns>
  <template #leftColumn>
    <AposCtaButton
      detail-heading="API"
      title="Piece Type REST API"
      content="Full CRUD operations for piece types with pagination, search, filtering, draft/publish workflows, and relationship queries."
      url="/reference/api/pieces"
      hideEffort="true"
    />
  </template>
  <template #rightColumn>
    <AposCtaButton
      detail-heading="API"
      title="Page Type REST API"
      content="Complete page management including tree navigation, publishing workflows, and page hierarchy operations."
      url="/reference/api/pages"
      hideEffort="true"
    />
  </template>
</AposTwoColumns>

<AposTwoColumns>
  <template #leftColumn>
    <AposCtaButton
      detail-heading="API"
      title="Working with Rich Text"
      content="Handle rich text content including HTML filtering, inline images, and importing external content."
      url="/reference/api/rich-text"
      hideEffort="true"
    />
  </template>
  <template #rightColumn>
    <AposCtaButton
      detail-heading="API"
      title="Media REST Endpoints"
      content="Upload, crop, and manage media files through dedicated endpoints for images, files, and attachments."
      url="/reference/api/media"
      hideEffort="true"
    />
  </template>
</AposTwoColumns>

### Internationalization

<AposTwoColumns>
  <template #leftColumn>
    <AposCtaButton
      detail-heading="API"
      title="i18n REST Endpoints"
      content="Manage multilingual content with endpoints for locale information, cross-locale navigation, and document verification."
      url="/reference/api/i18n"
      hideEffort="true"
    />
  </template>
</AposTwoColumns>

## How to Use This Documentation

This REST API reference provides two complementary ways to work with the ApostropheCMS API:

### Written Documentation (This Section)

The guides on this page and in the navigation are your comprehensive reference for understanding the API:

- **Learn patterns and concepts** with explanations and context
- **Copy production-ready code** examples into your application  
- **Understand field formats** with detailed examples
- **Read offline or on mobile** when you need it

Start here if you're new to the API or building an integration.

### API Explorer (Interactive Testing)

Once you understand the basics, use the API Explorer to test endpoints with your own data:

- **Test live requests** against your local or deployed ApostropheCMS instance
- **Experiment with parameters** and see real-time responses
- **Validate your authentication** setup before writing code
- **Generate curl commands** for quick testing

[Open the API Explorer ‚Üí](api-explorer)

> **Tip**: The written documentation and API Explorer show the same endpoints - use the written docs to learn, then the Explorer to test.

### OpenAPI Specification

For advanced workflows, download our complete OpenAPI 3.0 specification:

- Import into your preferred API client (Insomnia, Bruno, HTTPie, etc.)
- Generate client libraries in any language
- Integrate with AI coding assistants
- Build custom tooling and automation

[Download OpenAPI Spec](docs/apostrophecms-openapi.yaml){download="apostrophecms-openapi.yaml"}

> [!TIP]
> If Postman is your tool of choice, fork our collection to get started quickly with pre-configured requests and authentication.
>
> **Note**: The OpenAPI specification and Postman collection cover the core ApostropheCMS API. As you add custom piece types to your project, you'll need to add corresponding endpoints. See the [Piece Type REST API documentation](/reference/api/pieces) for details on the endpoints available for your custom types.
> [<img src="https://run.pstmn.io/button.svg" alt="Run In Postman" style="width: 128px; height: 32px;">](https://god.gw.postman.com/run-collection/27854768-e9cac689-f449-41e1-96be-cfbd56f418ee?action=collection%2Ffork&source=rip_markdown&collection-url=entityId%3D27854768-e9cac689-f449-41e1-96be-cfbd56f418ee%26entityType%3Dcollection%26workspaceId%3D122a8a50-9d3a-4fd3-8898-298c3cbc4498)

## Common Patterns

### Querying Content

Retrieve published content with pagination and filtering:

```javascript
const response = await fetch(
  'https://example.net/api/v1/article?page=1&perPage=10',
  {
    headers: { 'Authorization': 'Bearer your-token' }
  }
);
```

### Creating Documents

Post new content with required fields:

```javascript
const response = await fetch('https://example.net/api/v1/article', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer your-token'
  },
  body: JSON.stringify({
    title: 'My New Article',
    slug: 'my-new-article'
  })
});
```

### Working with Locales

Access content in specific locales using the `aposLocale` query parameter:

```javascript
const response = await fetch(
  'https://example.net/api/v1/article?aposLocale=fr',
  {
    headers: { 'Authorization': 'Bearer your-token' }
  }
);
```

## Need Help?

- **Stack Overflow**: Tag questions with `apostrophe-cms`
- **Discord**: Join our [community chat](https://chat.apostrophecms.com)
- **GitHub**: Report issues or contribute at [apostrophecms/apostrophe](https://github.com/apostrophecms/apostrophe)

Ready to start building? Check out the [authentication guide](/reference/api/authentication) to set up your first API request.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference > api-explorer
DOC_PATH: reference/api/api-explorer.md
URL: https://apostrophecms.com/docs/reference/api/api-explorer
================================================================================
# API Explorer

The API Explorer lets you test ApostropheCMS REST API endpoints directly in your browser with real authentication. Connect to your local development server or a live instance to experiment with requests and see actual responses.

## When to Use the Explorer vs Documentation

**Use the API Explorer when you want to:**
- Test endpoints with your actual project data
- Experiment with query parameters and request bodies
- Validate authentication configuration
- Generate curl commands for debugging
- Quickly verify an endpoint's behavior

**Use the [written API documentation](rest-api-reference) when you want to:**
- Learn API patterns and best practices
- Understand field formats and data structures
- Copy code examples into your application
- Read detailed explanations of endpoints
- Work offline or on mobile

> **üí° Testing with Localhost**: This explorer can connect to a project running at `localhost:3000` on your workstation to test standard API routes. You can test with API key or bearer token authentication, but not session cookies.

---

## Before you start

To use this page as an interactive testing environment:

1. **Start your Apostrophe project**

   ```bash
   npm run dev
   # or
   node app
   ```

   Make sure it is reachable at:

   - `http://localhost:3000` (default ApostropheCMS dev port)

2. **Scroll to the server URL in the spec**

   In the sidebar, the [`Interactive Explorer`](#üìΩ-interactive-explorer) is marked with an icon. In the Swagger UI, you will find the **Server** dropdown near the top. It should show something like:

   - `http://localhost:3000`

3. **Click the `Authorize` button**
   - See more below about authorization steps.
---

## Step-by-step: Authorize and run your first request

Swagger UI will happily send anonymous requests, but most Apostrophe endpoints require authentication.

Follow these steps carefully:

1. **Click the green "Authorize" button**

2. **Choose an auth method**

   The dialog lists three security schemes.

   - `ApiKeyAuth`
   - `BearerAuth`
   - `SessionAuth`

3. **Recommended: start with API key auth**

   - In your project, typically in the `modules/@apostrophecms/express/index.js` file, add an API key:
   ``` js
   export default {
     options: {
       session: {
         secret: 'myProjectSecret'
       },
       apiKeys: {
         mysecretapikey: {
           role: 'admin'
         }
       }
     }
   };
   ```
   - In the **Authorize** dialog of the explorer, scroll up to find the **API key** entry.
   - Paste your API key into the value field - in this example, `mysecretapikey`.
   - Click **Authorize**.
   - Then click **Close** at the bottom of the dialog.
  > [!NOTE]
  > You will not get any message regarding the validity of the key. If your endpoint requests fail with a `404` error, you likely entered the key wrong. Logout from the API key authorization section and reenter the key.

4. **Try a simple GET request**
   ![The 'Get Users' GET endpoint in the Swagger UI](../../images/swagger-user-endpoint.png)

   - Expand a simple GET endpoint (for example, the first "Users" route).
   - Click the route to expand it
   - Click **Try it out**
   - Change any of the parameters if desired
   - Click **Execute**
   - Check the **Response** section below the request:
     - Status `200` or `201` = success
     - Status `401`, `403` or `404` = auth problem; double-check your API key.

---

## Alternative: Bearer token via login route (more steps)

If you prefer to log in with a username/password instead of using an API key, you can:

1. **Find the login route**
![The Swagger UI POST login route endpoint selector](../../images/swagger-login-route.png)
   - In the explorer, look for the login endpoint (`POST` with `/@apostrophecms/login/login`).
   - Expand that operation.

2. **Send a login request**

   - Click **Try it out**.
   - In the request body, edit the `username` and `password` values.
   - Click **Execute**.

3. **Copy the token from the response**

   - In the **Responses**, scroll down to the `200` response.
   - Manually copy the token value, not including the quotes. The copy button will copy both the key and value.

4. **Configure Bearer auth in Swagger UI**

   - Click the **Authorize** button at the top of the Swagger UI.
   - Find the **BearerAuth** input.
   - Paste **only** the token value into the field (Swagger UI will add `Bearer ` for you).
   - Click **Authorize**, then **Close**.

5. **Try a simple GET request**
   ![The 'Get Users' GET endpoint in the Swagger UI](../../images/swagger-user-endpoint.png)

   - Expand a simple GET endpoint (for example, the first "Users" route).
   - Click the route to expand it
   - Click **Try it out**
   - Change any of the parameters if desired
   - Click **Execute**
   - Check the **Response** section below the request:
     - Status `200` or `201` = success
     - Status `401`, `403` or `404` = auth problem; double-check your token.

---

## Why session cookie auth is not supported here

ApostropheCMS typically uses a session cookie (for example, `project-shortname.sid`) when you log into the admin UI. The online Swagger explorer **cannot** reuse that login, because:

- The in-documentation Swagger UI runs in your browser as a separate web app.
- It cannot safely or portably access cookies from another origin.
- Even if it could, CORS rules usually block cross-site cookie usage.

Because of this, you **cannot** use the "Authorize" dialog to test "I'm logged into the admin UI" style session behavior. For cookie-based flows:

- Download the [OpenAPI spec file repo](https://github.com/apostrophecms/apostrophecms-openapi) and set it up locally
- Use an API client like Postman/Insomnia and configure cookie handling there.

The interactive explorer on this page is intentionally focused on **header-based authentication**: API keys and bearer tokens.

---

## üìΩ Interactive Explorer

Below is the full Swagger UI.
Once your server is running and you follow the authorization instructions, use `Try it out ‚Üí Execute` in each endpoint to test.

<AposApiExplorer />

---

## Need More Detail?

The API Explorer shows you what each endpoint does, but for deeper understanding:

- **[API Documentation Home](/reference/api/rest-api-reference)** - Overview and getting started
- **[Authentication Guide](/reference/api/authentication)** - Detailed auth setup
- **[Piece Type API](/reference/api/pieces)** - Working with content types
- **[Page Type API](/reference/api/pages)** - Managing pages and navigation
- **[Field Formats](/reference/api/field-formats)** - Understanding response structures

---

## Testing Against Your Own Site

For testing against deployed sites or more advanced workflows:

> **Quick Start with Postman**
>
> Fork our pre-configured API collection to get started immediately:
>
> [<img src="https://run.pstmn.io/button.svg" alt="Run In Postman" style="width: 128px; height: 32px;">](https://god.gw.postman.com/run-collection/27854768-e9cac689-f449-41e1-96be-cfbd56f418ee?action=collection%2Ffork&source=rip_markdown&collection-url=entityId%3D27854768-e9cac689-f449-41e1-96be-cfbd56f418ee%26entityType%3Dcollection%26workspaceId%3D122a8a50-9d3a-4fd3-8898-298c3cbc4498)

The Postman collection includes all endpoints with example requests and environment variables for easy configuration.

> [!NOTE]
> This collection covers the core ApostropheCMS API. As you add custom piece types to your project, you'll need to add corresponding endpoints to your forked collection. See the [Piece Type REST API documentation](/reference/api/pieces) for details on the endpoints available for your custom types.

**Manual Setup**

Alternatively, download and configure manually:

1. **Download**: Get our [OpenAPI specification](/openapi.yaml){download="apostrophecms-openapi.yaml"} or the [full repo](https://github.com/apostrophecms/apostrophecms-openapi).
2. **Import**: Load it into your preferred API client (or use the repo locally)
3. **Configure**: Set your server URL and authentication token
    - Server URL (change `https://your-site.com` to your actual domain)
    - Session cookie name (change `project-shortname.sid` to `yourproject.sid`)
4. **Test**: Make live API calls to your ApostropheCMS instance, either locally or your hosted site

## About This Reference

This interactive documentation is generated from our [OpenAPI specification](docs/apostrophecms-openapi.yaml){download="apostrophecms-openapi.yaml"}. You can:

- **Test endpoints live**: Make real API calls to your locally running project (with authentication)
- **View request/response examples**: See exactly what data to send and expect
- **Understand schemas**: Explore all data models and field requirements
- **Copy code samples**: Get ready-to-use code

For more guidance, see our [`apostrophecms-openapi` repo](https://github.com/apostrophecms/apostrophecms-openapi).

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference > authentication
DOC_PATH: reference/api/authentication.md
URL: https://apostrophecms.com/docs/reference/api/authentication
================================================================================
# Authentication

## API keys

API keys are great for server-to-server communication because they don't expire. However, they are unsuitable for client-side requests or use in headless applications because it is possible for end users to determine the API key and use it for their own purposes. For these roles, see the section on [bearer tokens](#bearer-tokens) below.

Configure API keys as an option in the `@apostrophecms/express` module in `app.js`. Alternately, all `@apostrophecms/express` configuration may be added in a separate `modules/@apostrophecms/express/index.js` file.

<AposCodeBlock>

``` javascript
require('apostrophe')({
  modules: {
    '@apostrophecms/express': {
      options: {
        apiKeys: {
          // Use your own key value. Ideally use a strong, randomly generated
          // key.
          'myapikey1029384756': {
            // The user role associated with this key
            role: 'admin'
          }
        }
      }
    },
    // ...
```
<template v-slot:caption>
  app.js
</template>
</AposCodeBlock>

### Usage

Add an `authorization` [HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) to each request:

```
Authorization: ApiKey myapikey1029384756

```

Alternatively, you may pass the api key as the `apikey` or `apiKey` query parameter:

```
http://example.net/api/v1/article?apikey=myapikey1029384756
```

## Bearer tokens

Bearer tokens are more appropriate for browser use and headless applications because they are tied to a single user account. To obtain a bearer token, make a `POST` request to `/api/v1/@apostrophecms/login/login`, with the `username` and `password` body properties:

```javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/login/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    username: 'your-username-here',
    password: 'your-secure-password'
  })
});
const data = await response.json();
```

### Response

A successful response will return a JSON object with a `token` property.

``` json
{
  token: 'random123Token456xyz'
}
```

In case of an error an appropriate HTTP status code is returned.

### Usage

Add this token to all REST API requests that require login by passing an `Authorization` header. This includes `POST`, `PUT`, `PATCH` and `DELETE` operations. Using authorization for `GET` operations will return more complete results, including access to documents with `visibility` set to `loginRequired`.

Your `authorization` HTTP header should look like:

```
Bearer random123Token456xyz
```

Note the need for the word "Bearer" before the key.

To log out and destroy the token, send a `POST` request to `/api/v1/login/logout`, with the same `authorization` header. No body properties are required. After logging out, the token is no longer accepted.
`

## Session cookies

As an alternative to a bearer token, you may request a session cookie. This is the mechanism Apostrophe's admin user interface uses to log in. Session cookies will automatically persist across tabs, but there is slightly more overhead to each request. To use this method, include `session: true` in the `POST` request to `/api/v1/@apostrophecms/login/login`.

``` javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/login/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  credentials:'include',
  body: JSON.stringify({
    username: 'your-username-here',
    password: 'your-secure-password',
    session: true
  })
});
```

### Response

A successful response will return a session cookie via the `Set-Cookie` header, which should be automatically honored in the browser context. In case of an error, an appropriate HTTP status code is returned. For more information about custom log-in requirements, see the documentation [here](/guide/custom-login-requirements.md) in our guide.

### End session

Using the session cookie, send a `POST` request to `/api/v1/@apostrophecms/login/logout` to end the user session.

``` javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/login/logout', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
  },
  credentials: 'include',
  body: JSON.stringify({
    username: 'your-username-here',
    password: 'your-secure-password',
    session: true
  })
});
```

## Allowing public access

All piece types in Apostrophe have a corresponding REST API. By default, this API is only available to authenticated users for security reasons. However, you can enable it for public use via the `publicApiProjection` option, which must be a MongoDB-style projection indicating the fields to include in the response:

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    publicApiProjection: {
      title: 1,
      _url: 1,
      description: 1,
      color: 1
    }
  }
};
```

<template v-slot:caption>
  modules/product/index.js
</template>
</AposCodeBlock>

## Allowing full `GET` access for guest users

By default, even a logged-in user can only see content exposed by the `publicApiProjection`,
unless they have at least some editing privileges.

If your project involves "guest" users who have no editing privileges, or at least none
that are exposed via Apostrophe permissions and roles, but should have full read access
to the REST APIs you can enable this for each relevant piece type:

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  options: {
    guestApiAccess: true
  }
};
```

<template v-slot:caption>
  modules/product/index.js
</template>
</AposCodeBlock>

You can also enable it for pages:

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    guestApiAccess: true
  }
};
```

<template v-slot:caption>
  modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

This does not grant guest users access to anything the public could not see if it
was being accessed as part of an ordinary website page. For instance, this does not
mean that guests can view drafts.

## Getting current user information

After authentication, you can retrieve information about the currently logged-in user by making a request to the `/api/v1/@apostrophecms/login/whoami` endpoint.

### Usage

**With API key (header):**
```javascript
const response = await fetch('http://example.net/api/v1/@apostrophecms/login/whoami', {
  method: 'POST',
  headers: {
    'Authorization': 'ApiKey your-api-key-here',
    'Content-Type': 'application/json'
  }
});
const user = await response.json();
```

**With API key (query parameter):**
```javascript
const response = await fetch('http://example.net/api/v1/@apostrophecms/login/whoami?apikey=your-api-key-here', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  }
});
const user = await response.json();
```

**With bearer token:**
```javascript
const response = await fetch('http://example.net/api/v1/@apostrophecms/login/whoami', {
  method: 'POST', // Recommended
  headers: {
    'Authorization': 'Bearer your-token-here',
    'Content-Type': 'application/json'
  }
});
const user = await response.json();
```

**With session cookie:**
```javascript
const response = await fetch('http://example.net/api/v1/@apostrophecms/login/whoami', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  credentials: 'include' // Include session cookies
});
const user = await response.json();
```

### Response

Returns a JSON object containing user information based on configured fields:

```json
{
  "_id": "user123",
  "username": "john-doe",
  "title": "John Doe",
  "email": "john@example.com"
}
```

### Error handling

- Returns a 404 status code for unauthenticated requests
- No user information is returned if the user is not logged in

The specific fields returned can be configured in the `@apostrophecms/login` module. See the [login module documentation](/reference/modules/login.html) for configuration options.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference > field-formats
DOC_PATH: reference/api/field-formats.md
URL: https://apostrophecms.com/docs/reference/api/field-formats
================================================================================
# API response field examples

Simple examples of how each field type might be returned in a document from the REST APIs.

## area

``` json
// An area with a single rich text widget
{
  "main": {
    "_id": "ckj0k0dy7000i2a68s1z8v4ky",
    "items": [
      {
        "_id": "ckj0k0mox000o2a68oouznar1",
        "metaType": "widget",
        "type": "@apostrophecms/rich-text",
        "content": "<p>Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum <strong>nibh, ut fermentum massa justo sit amet risus.</strong></p><p><br /></p>",
        "_docId": "ckj0k2i45001c7u9kky3tftx2"
      }
    ],
    "metaType": "area",
    "_docId": "ckj0k2i45001c7u9kky3tftx2"
  }
}
```

Each widget is represented by an entry in the `items` array. The `type` property indicates the widget type. The remaining properties depend on the `fields` of that widget, except for the rich text widget which simply has a `content` property containing HTML in a specific format. For more information about how to work with rich text in the API, see [rich text widgets and the REST APIs](rich-text.md).

## array

``` json
{
  "arrayField": [
    // Inner object properties and value types depend on the array's fields
    // definition. They will have the same fields, however.
    // `_id` will be automatically generated and included on every array item.
    {
      "_id" : "ckj0k15x4001h2a68staejzpj",
      "label": "The first one",
      "count": 27
    },
    {
      "_id" : "ckj0k1gy7001j2a68hnlz3d6x",
      "label": "The second item",
      "count": 99
    }
  ]
}
```

## attachment

``` json
{
  "attachment": {
    "_id": "ckhdsopzr0005rt9kn49eyzb5",
    "crop": null,
    "group": "images",
    "createdAt": "2020-11-11T19:27:11.782Z",
    "name": "double-rainbow",
    "title": "double rainbow",
    "extension": "jpg",
    "type": "attachment",
    "docIds": [
      "ckhdsovk40006rt9kdmxp6bhj"
    ],
    "archivedDocIds": [],
    "length": 644584,
    // md5 hash of the original file
    "md5": "f41217031f11e8483ee81e20782f51be",
    "width": 2560,
    "height": 1922,
    "landscape": true,
    "used": true,
    "utilized": true,
    "archived": false,
    // Non-image files will have a single `_url` property.
    "_urls": {
      "max": "https://example.net/uploads/attachments/ckhdsopzr0005rt9kn49eyzb5-double-rainbow.max.jpg",
      "full": "https://example.net/uploads/attachments/ckhdsopzr0005rt9kn49eyzb5-double-rainbow.full.jpg",
      "two-thirds": "https://example.net/uploads/attachments/ckhdsopzr0005rt9kn49eyzb5-double-rainbow.two-thirds.jpg",
      "one-half": "https://example.net/uploads/attachments/ckhdsopzr0005rt9kn49eyzb5-double-rainbow.one-half.jpg",
      "one-third": "https://example.net/uploads/attachments/ckhdsopzr0005rt9kn49eyzb5-double-rainbow.one-third.jpg",
      "one-sixth": "https://example.net/uploads/attachments/ckhdsopzr0005rt9kn49eyzb5-double-rainbow.one-sixth.jpg",
      "original": "https://example.net/uploads/attachments/ckhdsopzr0005rt9kn49eyzb5-double-rainbow.jpg"
    }
  }
}
```

## boolean

``` json
{
  "booleanField": true
}
```

## checkboxes

``` json
{
  "checkFields" : [
    "med",
    "small"
  ]
}
```
## color

``` json
{
  "colorField": "#9013feff"
}
```

## date

``` json
{
  "dateField": "2012-12-21"
}
```

## email

``` json
{
  "emailField": "jon@bonjovi.rocks"
}
```

## float

``` json
{
  "floatField": 8675.309
}
```

## integer

``` json
{
  "integerField": 42
}
```

## password

``` json
{
  "pwField": "don't use this for sensitive passwords"
}
```

## range

``` json
{
  "rangeField": 21
}
```

## relationship

``` json
{
  "_relation": [
    {
      "_id": "ckitdkktu002bu69krdkdu2pj",
      "archived": false,
      "disabled": false,
      "type": "@apostrophecms/user",
      "firstName": "Alexander",
      "lastName": "Hamilton",
      "title": "Alexander Hamilton",
      "slug": "user-alexander-hamilton",
      "username": "adotham",
      "email": "a.ham@treasury.gov",
      "metaType": "doc",
      "createdAt": "2020-12-17T21:47:58.194Z",
      "updatedAt": "2020-12-17T21:47:58.205Z",
      "updatedBy": {
        "_id": "ckhdsd0hk0003509kchzbdl83",
        "firstName": "Super",
        "lastName": "Admin",
        "username": "admin"
      },
      "titleSortified": "alexander hamilton",
      "highSearchText": "alexander hamilton user alexander hamilton",
      "highSearchWords": [
        "alexander",
        "hamilton",
        "user"
      ],
      "lowSearchText": "alexander hamilton user alexander hamilton",
      "searchSummary": ""
    }
  ]
}
```

## select

``` json
{
  "selectField": "selected value"
}
```

## slug

``` json
{
  "slugField": "slugified-string"
}
```

## string

``` json
{
  "stringField": "String value"
}
```

## time

``` json
{
  "timeField": "00:13:22"
}
```

## url

``` json
{
  "urlField": "http://apostrophecms.com"
}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference > i18n
DOC_PATH: reference/api/i18n.md
URL: https://apostrophecms.com/docs/reference/api/i18n
================================================================================
# i18n REST API

There are two i18n API endpoints to facilitate content management in a multilingual ApostropheCMS project.

These APIs are part of the implementation of the built-in admin UI and are generally not necessary if you just want to manipulate documents in a particular locale. For such operations, it's recommended to use the piece and page REST APIs. You can find more information about these APIs and how to use them for document manipulation in different locales [here](/reference/api/pages.md) and [here](/reference/api/pieces.md).

## Endpoints
[Authentication](/reference/api/authentication.md) is required for all REST API requests.

### REST endpoints

| Method | Path | Description |
|---------|---------|---------|
| `GET`  | `/api/v1/@apostrophecms/i18n/locales` | Returns information about all configured locales. |
| `POST` | `/api/v1/@apostrophecms/i18n/locale` | Returns the path to a locale home-page or optional document id and makes the clipboard available in the given locale. |
| `POST` | `/api/v1/@apostrophecms/i18n/exist-in-locale` | Returns arrays of the original document id(s), new locale id(s), and `aposDocId`(s) for an array of document id(s) and a locale. |

## `GET /api/v1/@apostrophecms/i18n/locales`

### Query parameters

None.

### Request example

```javascript
// Request inside an async function.
const response = await fetch('https://example.net/api/v1/@apostrophecms/i18n/locales', {});
const locales = await response.json();
```

### Response

A successful response will contain an object as follows:

```javascript
{
  "en": {
    "label": "English",
    "_edit": true
  },
  "fr": {
    "label": "French",
    "_edit": false
  }
}
```

Note that for each locale the response indicates both the label and whether the current user is permitted to edit content in this locale at all.

This API has been made public in order to facilitate the creation of locale switcher UI in headless applications.

## `POST /api/v1/@apostrophecms/i18n/locale`

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
| `contextDocId` | `?contextDocId=cloydg3ka0005qcls5vmg8sb9` | An optional document id for the path, defaults to the locale home-page. |
| `locale` | `?locale=fr` | Required. The locale for the desired path. |
| `clipboard` | `?clipboard=exampleClipboardContent` | Optional string. Move clipboard contents from localStorage to the cross-domain session cache. |

### Request example

```javascript
// Request inside an async function.
const response = await fetch('https://example.net/api/v1/@apostrophecms/i18n/locale', {
  method: 'POST'
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer your_api_key'
  },
  body: JSON.stringify({
    locale: 'fr',
    clipboard: 'exampleClipboardContent',
    contextDocId: 'cloydg3ka0005qcls5vmg8sb9'
  })
});
const document = await response.json();
```

### Response
A successful `POST` response will return the path to the document in the supplied `locale` with the supplied `contextDocId`, or the home page path if no id is provided.

The `clipboard` content must be a string and only needs to be supplied in cross-domain situations where the target locale's hostname differs from the current locale's hostname. For example, https://fr.example.com/french-example-page versus https://example.com/english-example-page. In this case a `aposCrossDomainSessionToken` key will be supplied as a query parameter on the returned path If the locales share the same hostname but different paths (e.g., https://example.com/fr/french-example-page and https://example.com/en/english-example-page), the `clipboard` content will not be cached.


**Same hostname response:**
``` json
{
  "redirectTo": "/fr/page-slug"
}
```

**Different hostname response**
``` json
{
  "redirectTo": "https://fr.example.com/french-example-page?aposCrossDomainSessionToken=generated_token"
}
```
This token can then be used to retrieve the clipboard contents from the apostrophe cache:
``` javascript
const clipboard = await self.apos.cache.get('@apostrophecms/i18n:cross-domain-sessions', generated_token);
```

### `POST /api/v1/@apostrophecms/i18n/exist-in-locale`

### Query parameters

| Parameter | Example | Description |
|-----------|---------|-------------|
| `ids`     | `?ids=cloydg3ka0005qcls5vmg8sb9,cloydg3ka0005qcls5vmg8sb8` | Required. An array of document IDs to check in the specified locale. |
| `locale`  | `?locale=fr` | Required. The locale in which to check for the document IDs. |
| `mode`    | `?mode=published` | Required. The mode (e.g., draft or published) in which to check for the document IDs. |

### Request example

```javascript
// Request inside an async function.
const response = await fetch('https://example.net/api/v1/@apostrophecms/i18n/exist-in-locale', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer your_api_key'
  },
  body: JSON.stringify({
    ids: ['cloydg3ka0005qcls5vmg8sb9', 'cloydg3ka0005qcls5vmg8sb8'],
    locale: 'fr',
    mode: 'published'
  })
});
const result = await response.json();
```

### Response

A successful `POST` response will return an object with arrays indicating the status of the provided document IDs in the specified locale and mode.

**Response Structure:**
```json
{
  "originalLocaleIds": ["originalLocaleId1", "originalLocaleId2"],
  "newLocaleIds": ["newLocaleId1", "newLocaleId2"],
  "aposDocIds": ["aposDocId1", "aposDocId2"]
}
```

- **`originalLocaleIds`**: Array of document IDs in the original locale and mode.
- **`newLocaleIds`**: Array of document IDs in the new locale.
- **`aposDocIds`**: Array of `aposDocId` values for the documents.

### Example Response

```json
{
  "originalLocaleIds": ["cloydg3ka0005qcls5vmg8sb9:en:published", "cloydg3ka0005qcls5vmg8sb8:en:published"],
  "newLocaleIds": ["cloydg3ka0005qcls5vmg8sb9:fr:published", "cloydg3ka0005qcls5vmg8sb8:fr:published"],
  "aposDocIds": ["cloydg3ka0005qcls5vmg8sb9", "cloydg3ka0005qcls5vmg8sb8"]
}
```

This endpoint is useful for verifying the existence of documents in a given locale and mode.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference > media
DOC_PATH: reference/api/media.md
URL: https://apostrophecms.com/docs/reference/api/media
================================================================================
# Media APIs

The `@apostrophecms/attachment` module manages all media file uploading. Once uploaded, an attachment object should typically be added to an Apostrophe piece or page document (including, but not limited to, `@apostrophecms/image` and `@apostrophecms/file` pieces). It is not common, and not generally recommended, to leave uploaded attachments unconnected from any Apostrophe document.

For attachments meant to be included in the media or file libraries, metadata and organization those media are primarily managed through the respective `@apostrophecms/image` and `@apostrophecms/file` piece types. See the [pieces REST API documentation](./pieces.md) for additional information.

> [!TIP]
> **Handling Large Query Strings**
>
> When working with large sets of media (such as batch operations on hundreds of files), you may encounter query string length limitations. ApostropheCMS 4.x includes middleware that allows you to convert GET requests with large query strings to POST requests using the `__aposGetWithQuery` property. See the [POST-as-GET middleware guide](#post-as-get-middleware) below for details.

## Endpoints

| Method | Path | Description | Auth required |
|---------|---------|---------|---------|
|`POST` | [`/api/v1/@apostrophecms/attachment/upload`](#post-api-v1-apostrophecms-attachment-upload) | Upload a media file | TRUE |
|`POST` | [`/api/v1/@apostrophecms/attachment/crop`](#post-api-v1-apostrophecms-attachment-crop) | Crop an image file | TRUE |
|`GET` | [`/api/v1/@apostrophecms/image`](#media-get-request) | Get an image document with a specified ID | FALSE |
|`POST` | [`/api/v1/@apostrophecms/image`](#media-post-request) | Insert a new image | TRUE |
|`GET` | [`/api/v1/@apostrophecms/file`](#media-get-request) | Get a file document with a specified ID | FALSE |
|`POST` | [`/api/v1/@apostrophecms/file`](#media-post-request) | Insert a new file | TRUE |

## `POST /api/v1/@apostrophecms/attachment/upload`

**Authentication required.**

The `body` of the request should use the `multipart/form-data` encoding, with the file itself uploaded under the name `file`. In a client-side request, the `body` of the request should be a `FormData` object.

### Request example

```javascript
// Create a `FormData` object
const formData = new window.FormData();

// Append a file as per the FormData API:
// https://developer.mozilla.org/en-US/docs/Web/API/FormData/append
formData.append('file', myfile);

// Request inside an async function.
const attachment = await fetch('/api/v1/@apostrophecms/attachment/upload', {
  method: 'POST',
  headers: {
    'Content-Type': 'multipart/form-data'
  },
  body: formData
});
```

### Response

The successful `POST` request returns the newly created attachment. In case of an error an appropriate HTTP status code is returned.

| Property | Format | Description |
|----------|------|-------------|
|`_id` | String | A unique and permanent ID for the attachment |
|`_url` | String | The file URL (the original size, if an image) |
|`_urls` | Object | An object with keys for the generated image size variants, if an image file |
|`archivedDocIds` | Array | An array of string IDs that represent image or file documents using this attachment that are archived |
|`createdAt` | Date | An [ISO date string](https://en.wikipedia.org/wiki/ISO_8601) of the attachment's creation date and time|
|`docIds` | Array | An array of string IDs that represent image or file documents using this attachment (empty at initial upload) |
|`extension` | String | The file's file extension, e.g., `png`, `pdf` |
|`group` | String | The associated file group, including `image` or `office` by default |
|`height` | Number | Height of the image file, if an image |
|`landscape` | Boolean | `true` if an image with landscape aspect ratio |
|`length` | Number | The file size in bytes |
|`md5` | String | MD5 checksum value for the file |
|`name` | String | A "slugified" version of the file name (generally lowercased and joined with dashes) |
|`portrait` | Boolean | `true` if an image with portrait aspect ratio |
|`title` | String | A "sortified" version of the file name (case-insensitive) |
|`type` | String | 'attachment' |
|`updatedAt` | Date | An [ISO date string](https://en.wikipedia.org/wiki/ISO_8601) of the attachment's last update date and time|
|`width` | Number | Width of the image file, if an image |

``` json
// This is a PNG upload with filename `blue-box.png`
{
  "_id": "ckj0akbxa003vp39kfbxgb8zg",
  "group": "images",
  "createdAt": "2020-12-22T17:58:11.314Z",
  "name": "blue-box",
  "title": "blue box",
  "extension": "png",
  "type": "attachment",
  "docIds": [],
  "archivedDocIds": [],
  "length": 10497,
  "md5": "630eeaaecd0bdc07c4a82eeca4c07588",
  "width": 600,
  "height": 106,
  "landscape": true,
  "_urls": {
    "max": "https://example.net/uploads/attachments/ckj0akbxa003vp39kfbxgb8zg-blue-box.max.png",
    "full": "https://example.net/uploads/attachments/ckj0akbxa003vp39kfbxgb8zg-blue-box.full.png",
    "two-thirds": "https://example.net/uploads/attachments/ckj0akbxa003vp39kfbxgb8zg-blue-box.two-thirds.png",
    "one-half": "https://example.net/uploads/attachments/ckj0akbxa003vp39kfbxgb8zg-blue-box.one-half.png",
    "one-third": "https://example.net/uploads/attachments/ckj0akbxa003vp39kfbxgb8zg-blue-box.one-third.png",
    "one-sixth": "https://example.net/uploads/attachments/ckj0akbxa003vp39kfbxgb8zg-blue-box.one-sixth.png",
    "original": "https://example.net/uploads/attachments/ckj0akbxa003vp39kfbxgb8zg-blue-box.png"
  }
}
```

## `POST /api/v1/@apostrophecms/attachment/crop`

**Authentication required.**

This route uploads a new, cropped version of an existing image. The `crop` object is appended to the `crops` array property of the attachment document.

The `body` of the request should include:

| Property | Format | Description |
|----------|------|-------------|
|`_id` | String | The `_id` property of an existing image attachment document |
|`crop` | Object | An object containing `top`, `left`, `width` and `height` properties |

The newly uploaded image file will be stored with a file name using the `crop` properties as well as the `_id`, `name`, and file extension of the original attachment, formatted as `{_id}-{name}.{top}.{left}.{width}.{height}.{extension}`

### Response

The successful `POST` request returns `true`. In case of an error an appropriate HTTP status code is returned.

## Media `GET` request

Endpoints:

- `GET /api/v1/@apostrophecms/image`
- `GET /api/v1/@apostrophecms/file`

A `GET` request for an image or file is generally a normal [piece type `GET` request](./pieces.md#get-api-v1-piece-name-id). In addition to the typical piece document properties, it will also include an `attachment` property, containing an object similar to one returned from [an attachment upload request](#post-api-v1-apostrophecms-attachment-upload).

## Media `POST` request

**Authentication required.**

- `POST /api/v1/@apostrophecms/image`
- `POST /api/v1/@apostrophecms/file`

A `POST` request for an image or file is generally a normal [piece type `POST` request](./pieces.md#get-api-v1-piece-name-id). However, creating a new image or file piece requires a **two-step process**:

1. **Upload the file**: First, use the [`/api/v1/@apostrophecms/attachment/upload`](#post-api-v1-apostrophecms-attachment-upload) endpoint to upload the actual file and receive an attachment object.

2. **Create the piece**: Then, use the image or file `POST` endpoint to create the piece document, including the attachment object in the request body.

The `POST` request body must include an `attachment` property containing the complete attachment object returned from the upload request. In addition to the typical piece document properties, this creates the metadata and organization structure needed for the media library.

### Example: Creating a new image piece

```javascript
// Step 1: Upload the file
const formData = new FormData();
formData.append('file', imageFile);

const attachmentResponse = await fetch('/api/v1/@apostrophecms/attachment/upload', {
  method: 'POST',
  body: formData
});

const attachment = await attachmentResponse.json();

// Step 2: Create the image piece
const imageResponse = await fetch('/api/v1/@apostrophecms/image', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    title: 'My Image',
    alt: 'Description of my image',
    attachment: attachment, // Include the complete attachment object
    // ... other piece properties
  })
});

const imageDocument = await imageResponse.json();
```

## POST-as-GET Middleware

When working with large datasets in the media library (such as batch operations on hundreds of files), you may encounter query string length limitations that prevent standard `GET` requests from working properly. ApostropheCMS 4.x includes middleware that allows you to work around this limitation by converting `GET` requests with large query strings to `POST` requests.

### How it works

The middleware detects `POST` requests that contain a special `__aposGetWithQuery` property in the request body. When found, it:

1. Changes the request method from `POST` to `GET`
2. Moves the contents of `__aposGetWithQuery` to `req.query`
3. Preserves any existing query parameters (like `aposMode` and `aposLocale`)
4. Removes the request body

This allows you to send large amounts of query data through the request body while maintaining the semantic meaning of a `GET` request.

### Usage

Instead of passing large query parameters in the query string:

```javascript
// This might fail with very large query strings
const apiResponse = await apos.http.get('/api/v1/@apostrophecms/image', {
  qs: {
    ids: ['id1', 'id2', 'id3', /* ... hundreds more IDs ... */]
  },
  draft: true
});
```

Use the POST-as-GET pattern:

```javascript
// This will work with large datasets
const apiResponse = await apos.http.post('/api/v1/@apostrophecms/image', {
  body: {
    __aposGetWithQuery: {
      ids: ['id1', 'id2', 'id3', /* ... hundreds more IDs ... */]
    }
  },
  draft: true
});
```

### Important notes

- The original query string parameters are preserved and merged with the `__aposGetWithQuery` content
- Options like `draft: true` passed to `apos.http.post()` are still transformed into query string parameters as normal
- This middleware is particularly useful for batch operations in the media manager, such as applying tags to multiple selected images
- The middleware is transparent to your application logic - the request is processed as a normal GET request after the conversion

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference > pages
DOC_PATH: reference/api/pages.md
URL: https://apostrophecms.com/docs/reference/api/pages
================================================================================
# Page type REST API

All [page types](/reference/glossary.md#page) use a single set of API endpoints, unlike piece types.

## Endpoints

[Authentication](/reference/api/authentication.md) is required for all REST API requests.

### REST endpoints

| Method | Path | Description |
|---------|---------|---------|
|`GET` | [`/api/v1/@apostrophecms/page` ](#get-api-v1-apostrophecms-page)| Fetch the home page and all other pages structured in the home page's `_children` property |
|`GET` | [`/api/v1/@apostrophecms/page/:_id`](#get-api-v1-apostrophecms-page-id) | Fetch a single page with a specified ID |
|`POST` | [`/api/v1/@apostrophecms/page`](#post-api-v1-apostrophecms-page) | Insert a new page |
|`PUT` | [`/api/v1/@apostrophecms/page/:_id`](#put-api-v1-apostrophecms-page-id) | Fully replace a specific page database document |
|`PATCH` | [`/api/v1/@apostrophecms/page/:_id`](#patch-api-v1-apostrophecms-page-id) | Update only certain fields on a specific page |
|`DELETE` | [`/api/v1/@apostrophecms/page/:_id`](#delete-api-v1-apostrophecms-page-id) | **Permanently deletes a page document** |


### Additional page endpoints

| Method | Path | Description |
|---------|---------|---------|
|`GET` | [`/:_url?aposRefresh=1`](#get-url-aposrefresh-1) | Get a page's rendered content |
|`POST` | [`/api/v1/@apostrophecms/page/:_id/publish`](#post-api-v1-apostrophecms-page-id-publish) | Publish the draft version of a page |

<!-- TODO: document -->
<!-- |GET | [`/api/v1/@apostrophecms/page/:_id?locales=1`](#get-api-v1-apostrophecms-page-id-locales-1) | Request the available locales for a specific page |
|POST | [`/api/v1/@apostrophecms/page/:_id/export`](#post-api-v1-apostrophecms-page-id-export) | Copy a page from one locale to another |
|POST | [`/api/v1/@apostrophecms/page/:_id/revert-draft-to-published`](#post-api-v1-apostrophecms-page-id-revert-draft-to-published) | Revert a draft page to the the state of the published version, if available |
|POST | [`/api/v1/@apostrophecms/page/:_id/revert-published-to-previous`](#post-api-v1-apostrophecms-page-id-revert-published-to-previous) | Revert a published page to the previous version, if available |
|POST | [`/api/v1/@apostrophecms/page/:_id/unpublish`](#post-api-v1-apostrophecms-page-id-unpublish) | Unpublish the published version of a page | -->


## `GET /api/v1/@apostrophecms/page`

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`all` | `?all=1` | Set to `1` to include the *entire* page tree, regardless of depth |
|`flat` | `?flat=1` | Set to `1` to [return page results in an flat array](#flat-array-response) instead of the page tree structure |
|`children` | `?children=false` | Set to `false` to exclude the `_children` array` |
|`aposMode` | `?aposMode=draft` | Set to `draft` to request the draft version of page documents instead of the current published versions. Set to `published` or leave it off to get the published version. Authentication is required to get drafts. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to request page document versions for that locale. Defaults to the default locale. |
<!-- TODO: link to docs about locales when available. -->

### Request example

```javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/page?apikey=myapikey', {
  method: 'GET'
});
const document = await response.json();
```

### Page tree response (default)

Pages' relationship to one another is a critical feature. For that reason, by default the `GET` request for multiple pages returns the home page as a JSON object, including a `_children` array property. That array contains the "top level" pages.

``` json
{
    "_id": "ckhdscx5900054z9k88uqs16w",
    "orphan": false,
    "visibility": "public",
    "type": "@apostrophecms/home-page",
    "title": "Home Page",
    "slug": "/",
    "parkedId": "home",
    "rank": 0,
    "level": 0,
    // ... additional properties
    "_url": "http://localhost:3000/",
    "_ancestors": [],
    // Child pages üëá
    "_children": [
        {
            "_id": "ckhfen8ls0005mq9k8p9izkjt",
            "visibility": "public",
            "orphan": false,
            "type": "article-page",
            "title": "Blog",
            "slug": "/blog",
            // ...
            "_url": "http://localhost:3000/blog",
            "_children": []
        },
        {
            "_id": "ckhurshqd00088v9k6pfnqpjz",
            "visibility": "public",
            "orphan": false,
            "type": "default-page",
            "title": "About us",
            "slug": "/about-us",
            // ...
            "_url": "http://localhost:3000/about-us",
            "_children": []
        }
    ]
}
```

### Flat array response

| Property | Type | Description |
|----------|------|-------------|
|`results` | Array | An array of page documents|

Individual page objects will include `_children` and `_ancestor` arrays, as well as the `rank` and `level` properties to indicate position in the page tree.

``` json
{
  "results": [
    {
      "_id": "ckhdscx5900054z9k88uqs16w",
      "orphan": false,
      "visibility": "public",
      "type": "@apostrophecms/home-page",
      "title": "Home Pager",
      "slug": "/",
      "rank": 0,
      "level": 0,
      "path": "ckhdscx5900054z9k88uqs16w",
      // ...
      "_url": "http://localhost:3000/",
      "_ancestors": [],
      "_children": [
        "ckhfen8ls0005mq9k8p9izkjt",
        "ckhurshqd00088v9k6pfnqpjz",
        "ckhdscx6000084z9k56lybljw"
      ]
      },
    {
      "_id": "ckhfen8ls0005mq9k8p9izkjt",
      "visibility": "public",
      "type": "article-page",
      "title": "Blog",
      "slug": "/blog",
      "rank": 0,
      "path": "ckhdscx5900054z9k88uqs16w/ckhfen8ls0005mq9k8p9izkjt",
      "level": 1,
      // ...
      "_url": "http://localhost:3000/blog",
      "_children": []
    },
    {
      "_id": "ckhurshqd00088v9k6pfnqpjz",
      "visibility": "public",
      "type": "default-page",
      "title": "About us",
      "slug": "/about-us",
      "rank": 1,
      "path": "ckhdscx5900054z9k88uqs16w/ckhurshqd00088v9k6pfnqpjz",
      "level": 1,
      // ...
      "_url": "http://localhost:3000/about-us",
      "_children": [
        "ckiz0pmsg006gdr9ker7e99yt",
        "ckiz0pyym0070dr9kv8hzm7y0"
      ]
    },
    {
      "_id": "ckiz0pmsg006gdr9ker7e99yt",
      "visibility": "public",
      "type": "default-page",
      "title": "Our history",
      "slug": "/about-us/our-history",
      "rank": 0,
      "path": "ckhdscx5900054z9k88uqs16w/ckhurshqd00088v9k6pfnqpjz/ckiz0pmsg006gdr9ker7e99yt",
      "level": 2,
      // ...
      "_url": "http://localhost:3000/about-us/our-history",
      "_children": []
    },
    {
      "_id": "ckiz0pyym0070dr9kv8hzm7y0",
      "visibility": "public",
      "type": "default-page",
      "title": "Leadership and staff",
      "slug": "/about-us/leadership-and-staff",
      "rank": 1,
      "path": "ckhdscx5900054z9k88uqs16w/ckhurshqd00088v9k6pfnqpjz/ckiz0pyym0070dr9kv8hzm7y0",
      "level": 2,
      // ...
      "_url": "http://localhost:3000/about-us/leadership-and-staff",
      "_children": []
    },
    {
      "_id": "ckhdscx6000084z9k56lybljw",
      "visibility": "public",
      "type": "@apostrophecms/archive-page",
      "title": "Archive",
      "slug": "/archive",
      // ...
      "rank": 3,
      "path": "ckhdscx5900054z9k88uqs16w/ckhdscx6000084z9k56lybljw",
      "level": 1,
      "_children": []
    }
  ]
}
```

## `GET /api/v1/@apostrophecms/page/:_id`

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` or `published` to request a specific mode version of the page. Authentication is required to get drafts. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to request the page document version for that locale. |
|`render-areas` | `?render-areas=true` | Replaces area `items` data with a `_rendered` property set to a string of HTML based on widget templates. |

<!-- TODO: link to docs about locales and modes when available. -->
<!-- Read more about [mode and locale parameters on single-document requests](/guide/rest-apis#locale-and-mode-in-single-document-requests). -->
::: info
Query parameters will override the locale and mode present in the `_id`. So, if the `aposLocale=es` parameter is supplied, a `GET` request to the `_id` `###:en:published` will return the Spanish, not English, locale.
You can also elect to use the `aposDocId` instead of the `_id` and use the query parameters to pass in the locale and mode parameters found in the `_id`.
### Request example

```javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/page/ckitdo5oq004pu69kr6oxo6fr:en:published?apikey=myapikey', {
  method: 'GET'
});
const document = await response.json();
```

### Response

The successful `GET` request returns the matching document. See the [page document response example](#page-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

## `POST /api/v1/@apostrophecms/page`

### Required properties

| Property | Type | Description |
|----------|------|-------------|
|`_targetId` | String | The `_id` of an existing page to use as a target when inserting the new page. `_home` and `_archive` are optional conveniences for the home page and [archived section](#moving-pages-to-the-archive), respectively. |
|`_position` | String, Number | A numeric value will represent the zero-based child index under the `_targetId` page. `before`, `after`, `firstChild`, or `lastChild` values set the position within the page tree for the new page in relation to the target page (see `_targetId`). `before` and `after` insert the new page as a sibling of the target. `firstChild` and `lastChild` insert the new page as a child of the target. |

The `_position` property uses specific string values rather than index numbers to better support the draft review workflow.

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` to insert a page as a draft instead of immediately published. Set to `published` or leave it off to insert a published page. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to request page document versions for that locale. Defaults to the default locale. |
<!-- TODO: link to docs about locales when available. -->

### Request example

```javascript
// Object with, at a minimum, properties for each required piece field.
const data = {
  title: 'My great new article',
  // Content properties, e.g., `category`, `mainContent`
  _targetId: 'ckhdscx5900054z9k88uqs16w',
  _position: 'firstChild'
};
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/page?apikey=myapikey', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
const document = await response.json();
```

### Response

The successful `POST` request returns the newly created document. See the [page document response example](#page-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

### Duplicating existing pages

The optional `_copyingId` property may be added to the **body** of the
request, e.g. included in the `data` object shown above.
If this property contains the `_id` of an existing page,
the properties of that page will be applied first as
defaults, and then overridden by any properties present in the body.

In addition, this value becomes the `copyOfId` property of the new page.
[`beforeInsert` handlers](/reference/server-events.md#beforeinsert)
at the application level can access this property
to duplicate additional application-specific resources as needed.

## `PUT /api/v1/@apostrophecms/page/:_id`

### Required properties

| Property | Type | Description |
|----------|------|-------------|
|`_targetId` | String | The `_id` of an existing page to use as a target when inserting the new page|
|`_position` | String | `before`, `after`, `firstChild`, or `lastChild`. This sets the position within the page tree for the new page in relation to the target page (see `_targetId`). `before` and `after` insert the new page as a sibling of the target. `firstChild` and `lastChild` insert the new page as a child of the target.|

The `_position` property uses specific string values rather than index numbers to better support the draft review workflow.

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` or `published` to replace a specific mode version of the page. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to replace the page document version for that locale. |
|`render-areas` | `?render-areas=true` | Replaces area `items` data with a `_rendered` property set to a string of HTML based on widget templates. |

<!-- TODO: link to docs about locales and modes when available. -->
<!-- Read more about [mode and locale parameters on single-document requests](/guide/rest-apis#locale-and-mode-in-single-document-requests). -->

### Request example

```javascript
// Object with, at a minimum, properties for each required piece field.
const data = {
  title: 'My great new article',
  // Content properties, e.g., `category`, `mainContent`
  _targetId: 'ckhdscx5900054z9k88uqs16w',
  _position: 'lastChild'
};
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/page/ckitdo5oq004pu69kr6oxo6fr:fr:published?apikey=myapikey', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
const document = await response.json();
```

### Response

The successful `PUT` request returns the newly created document. See the [page document response example](#page-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

## `PATCH /api/v1/@apostrophecms/page/:_id`

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` or `published` to update a specific mode version of the page. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to update the page document version for that locale. |

If moving a page within the page tree, the `PATCH`request must include *both* `_targetId` and `_position` as described in the [POST request description](#post-api-v1-apostrophecms-page).

If a `PATCH` operation is attempted in the published mode, the changes in the patch are applied to both the draft and the current document, but properties of the draft not mentioned in the patch are not published. This is to prevent unexpected outcomes.

<!-- TODO: link to docs about locales and modes when available. -->
<!-- Read more about [mode and locale parameters on single-document requests](/guide/rest-apis#locale-and-mode-in-single-document-requests). -->

### Request example

```javascript
// Object with *only* the document fields to overwrite.
// This example only changes the page's title to "Organization history."
const data = {
  title: 'Organization history'
};
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/page/ckitdo5oq004pu69kr6oxo6fr?apikey=myapikey&aposMode=published&aposLocale=fr', {
  method: 'PATCH',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
const document = await response.json();
```

### MongoDB-style requests

The `PATCH` request body may use MongoDB-style operators. For example, you may use dot or "at" notation to update a nested property:

``` json
{
  // Via "dot notation"
  "description.items.0.content": "<p>Update only the rich text.</p>",
  // Same thing via "@ notation," which finds the nested item with that _id
  "@ckgwegpfw00033h5xqlfb74nk.content": "<p>Update only the rich text.</p>"
}
```

### Response

The successful `PATCH` request returns the complete patched document. See the [page document response example](#page-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

### Moving pages to the archive

The archive is part of the overall page tree in order to maintain the nesting structure. As such, there is not only a simple `archived` property to set `true`. Instead, set `_targetId` to `_archive` and `_position` to `lastChild` (or another position within the archive). You may similarly move pages out of the archive by moving them to a position relative to another page that is not in the archive.

## `DELETE /api/v1/@apostrophecms/page/:_id`


**Authentication required.**

This API route **Permanently deletes the page database document**. Moving pieces to the archive in the Apostrophe user interface or [using a `PATCH` request](#moving-pages-to-the-archive) do not permanently delete database documents and should be considered.

`DELETE` requests will be rejected if:
- the `_id` matches the draft mode of a page that has an existing published mode document
- the `_id` matches the home page (`slug: '/'`)
- the `_id` matches a page that has sub-pages, or "children," in the page tree structure. You must delete child pages first

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` or `published` to delete a specific mode version of the piece. |
|`aposLocale` | `?aposLocale=fr` | Set to [a valid locale](#TODO) to delete the piece document version for that locale. |

<!-- TODO: link to docs about locales and modes when available. -->
<!-- Read more about [mode and locale parameters on single-document requests](/guide/rest-apis#locale-and-mode-in-single-document-requests). -->

### Request example

```javascript
// Request inside an async function.
await fetch('http://example.net/api/v1/@apostrophecms/page/ckitdo5oq004pu69kr6oxo6fr:en:published?apikey=myapikey', {
  method: 'DELETE'
});
```

### Response

The successful `DELETE` request simply responds with a `200` HTTP response status code. In case of an error an appropriate HTTP status code is returned. If the error is due to one of the rejection cases documented above, a message will be included to that effect, such as:

```
{
  "name": "invalid",
  "data": {},
  "message": "You must delete the children of this page first."
}
```

## `GET /:_url?aposRefresh=1`

Including the `aposRefresh=1` query parameter value on an Apostrophe page URL returns the rendered HTML from the `refreshLayout.html` template, which excludes the wrapping markup from the `outerLayoutBase.html` template file outside of the `[data-apos-refreshable]` element. Apostrophe UI uses this parameter to refresh content during editing.

Authentication is not required for this API route if `:_url` is a public URL.

**We do not recommend making edits to `refreshLayout.html` for the sake of API requests as this template is critical to normal content editing.**
<!-- TODO: Add and link to a how-to/guide/recipe about an alternative way to
customize the response template (e.g., using a custom query param and looking
for that on `data.query` in the template. We're not documenting alternative
options to customizing the response template here since this is the reference
section, not a how-to. -->

Specifically, the Nunjucks template blocks included in this rendered markup by default include:
-  the `beforeMain`, `mainAnchor`, `main`
, `afterMain` template blocks
<!-- TODO: Document the insertion mechanism in the component section. -->
- [template components](/guide/async-components) prepended and appended to the `main` block

The most critical element that is *excluded* is the `head` tag, with all of its stylesheet and script tags.

### Request example

```javascript
// Request inside an async function.
const response = await fetch('http://example.net/some-page?aposRefresh=1', {
  method: 'GET'
});
const document = await response.text();
```

### Response

Returns the a string of rendered HTML for the requested page.

## `POST /api/v1/@apostrophecms/page/:_id/publish`

Publish an existing `draft` mode document in a document set.

The `:_id` segement of the route should be one of the following:
- The `_id` property of the draft page document to be published
- The `_id` property of the published page document to be replaced by the current `draft` version
- The `aposDocId` property of the pages in the document set

The `body` of the request is ignored.

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposLocale` | `?aposLocale=fr` | Identify a valid locale to publish the draft for that locale. Defaults to the locale of the `_id` in the request or the default locale. |
<!-- TODO: link to docs about locales when available. -->

### Request example

```javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/@apostrophecms/page/ckhdscx5900054z9k88uqs16w:en:draft/publish?apikey=myapikey&aposLocale=fr', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  }
});
const document = await response.json();
```

### Response

The successful `POST` request returns the newly published document. See the [page document response example](#page-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

## Page document response example

### Common properties

| Property | Format | Description |
|----------|------|-------------|
|`_ancestors` | Array | An array of `_id` strings for the page's ancestors in the page tree |
|`_children` | Array | An array of `_id` strings for the page's children in the page tree |
|`_id` | String | A unique and permanent ID for the document|
|`_url` | String | The page's URL, including the domain if a `baseUrl` is set on the site |
|`createdAt` | Date | An [ISO date string](https://en.wikipedia.org/wiki/ISO_8601) of the document's creation date and time|
|`historicUrls` | Array | An array of former `_url` values for the page. These will redirect to the page. URLs will be removed as other pages claim them. |
|`level` | Number | The page tree tier for the page. The home page is `0`, its children are `1`, and so on.  |
|`orphan` | Boolean | `true` if the page has been configured to not be included in standard `_children` properties (usually to exclude from navigation)  |
|`path` | String | A string of page `_id` values, separated by forward slashes (`/`), representing the page's ancestor path |
|`slug`| String | A unique, but changeable, identifier for the page|
|`rank` | Number | The order in which the page appears in the page tree under its parent. The first child page among its siblings will be `0`. |
|`title` | String | The entered title, or name, of the *document*|
|`archived` | Boolean | Whether the document is archived|
|`type` | String | The piece type name|
|`updatedAt` | Date | An [ISO date string](https://en.wikipedia.org/wiki/ISO_8601) of the document's last update date and time|
|`visibility` | String | The visibility setting, controlling public availability|
|Content properties | Variable | Additional properties specific to the piece type and its fields|

**TODO:** Link to examples of each field's response format.

### Example

``` json
{
    "_id": "ckhurshqd00088v9k6pfnqpjz",
    "visibility": "public",
    "orphan": false,
    "type": "default-page",
    "title": "About us",
    "slug": "/about-us",
    "rank": 1,
    "path": "ckhdscx5900054z9k88uqs16w/ckhurshqd00088v9k6pfnqpjz",
    "level": 1,
    "metaType": "doc",
    "createdAt": "2020-11-23T16:34:05.894Z",
    "archived": false,
    "titleSortified": "about us",
    "updatedAt": "2020-12-21T20:34:02.636Z",
    "historicUrls": [
        "/tags"
    ],
    "intro": {
        "metaType": "area",
        "_id": "ckhurshsn000b8v9kxhnnsrof",
        "items": [],
        "_edit": true,
        "_docId": "ckhurshqd00088v9k6pfnqpjz"
    },
    "main": {
        "_id": "ckhuu2q2w00012a69tk7hw9m6",
        "items": [
            {
                "_id": "ckiz0oqln000i2a68sr1liirc",
                "metaType": "widget",
                "type": "@apostrophecms/rich-text",
                "content": "<p>Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Integer posuere erat a ante venenatis dapibus posuere velit aliquet.</p><p><br /></p>",
                "_edit": true,
                "_docId": "ckhurshqd00088v9k6pfnqpjz"
            }
        ],
        "metaType": "area",
        "_edit": true,
        "_docId": "ckhurshqd00088v9k6pfnqpjz"
    },
    "updatedBy": {
        "_id": "ckhdsd0hk0003509kchzbdl83",
        "firstName": "Super",
        "lastName": "Admin",
        "username": "admin"
    },
    "_edit": true,
    "_url": "https://example.net/about-us",
    "_ancestors": [
        {
            "_id": "ckhdscx5900054z9k88uqs16w",
            "orphan": false,
            "visibility": "public",
            "type": "@apostrophecms/home-page",
            "title": "Home Pager",
            "slug": "/",
            "parkedId": "home",
            "parked": [
                "slug",
                "parkedId",
                "_children"
            ],
            "rank": 0,
            "level": 0,
            "path": "ckhdscx5900054z9k88uqs16w",
            "metaType": "doc",
            "createdAt": "2020-11-11T19:17:53.998Z",
            "archived": false,
            "titleSortified": "home pager",
            "updatedAt": "2020-12-21T20:37:56.066Z",
            "historicUrls": [
                "/"
            ],
            "main": {
                "_id": "ckhdsdhlk0005fv9k2a865nnh",
                "items": [
                    {
                        "_id": "cki7skym100052a69651avehi",
                        "metaType": "widget",
                        "type": "@apostrophecms/rich-text",
                        "content": "<p>Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Praesent commodo cursus magna, vel scelerisque nisl consectetur et. Etiam porta sem malesuada magna mollis euismod. Fusce dapidbus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.asdf</p><p>Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus. Donec id elit non mi porta gravida at eget metus. Donec ullamcorpesadfasdfr nulla non metus auctor fringilla. Donec ullamcorper nulla non metus auctor fringilla. Donec id elit non mi porta gravida at eget metus. Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit.</p>"
                    }
                ],
                "metaType": "area"
            },
            "published": true,
            "updatedBy": {
                "_id": "ckhdsd0hk0003509kchzbdl83",
                "firstName": "Super",
                "lastName": "Admin",
                "username": "admin"
            },
            "_edit": true,
            "_url": "https://example.net/"
        }
    ],
    "_children": [
        {
            "_id": "ckiz0pmsg006gdr9ker7e99yt",
            "visibility": "public",
            "orphan": false,
            "type": "default-page",
            "title": "Our history",
            "slug": "/about-us/our-history",
            "rank": 0,
            "path": "ckhdscx5900054z9k88uqs16w/ckhurshqd00088v9k6pfnqpjz/ckiz0pmsg006gdr9ker7e99yt",
            "level": 2,
            "metaType": "doc",
            "createdAt": "2020-12-21T20:34:36.065Z",
            "titleSortified": "our history",
            "updatedAt": "2020-12-21T20:34:42.605Z",
            "updatedBy": {
                "_id": "ckhdsd0hk0003509kchzbdl83",
                "firstName": "Super",
                "lastName": "Admin",
                "username": "admin"
            },

            "historicUrls": [
                "/our-history",
                "/about-us/our-history"
            ],
            "_edit": true,
            "_url": "https://example.net/about-us/our-history",
            "_children": []
        },
        {
            "_id": "ckiz0pyym0070dr9kv8hzm7y0",
            "visibility": "public",
            "orphan": false,
            "type": "default-page",
            "title": "Leadership and staff",
            "slug": "/about-us/leadership-and-staff",
            "main": {
                "_id": "ckiz0py60000f2a68mizfqogd",
                "items": [],
                "metaType": "area"
            },
            "rank": 1,
            "path": "ckhdscx5900054z9k88uqs16w/ckhurshqd00088v9k6pfnqpjz/ckiz0pyym0070dr9kv8hzm7y0",
            "level": 2,
            "metaType": "doc",
            "createdAt": "2020-12-21T20:34:51.838Z",
            "titleSortified": "leadership and staff",
            "updatedAt": "2020-12-21T20:35:53.239Z",
            "updatedBy": {
                "_id": "ckhdsd0hk0003509kchzbdl83",
                "firstName": "Super",
                "lastName": "Admin",
                "username": "admin"
            },
            "historicUrls": [
                "/about-us/our-history/new-page"
            ],
            "_edit": true,
            "_url": "https://example.net/about-us/leadership-and-staff",
            "_children": []
        }
    ]
}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference > pieces
DOC_PATH: reference/api/pieces.md
URL: https://apostrophecms.com/docs/reference/api/pieces
================================================================================
# Piece type REST API

Apostrophe provides built-in REST end points for all [piece types](/reference/glossary.md#piece). The exact document properties returned will depend on the piece type's fields.

## Endpoints

**Note:** `:piece-name` represents the name of a piece type module. For example, you would request all pieces of an `article` piece type with `/api/v1/article`.

### REST endpoints

[Authentication](/reference/api/authentication.md) is required for all requests other than `GET` requests for pieces with defined [`publicApiProjection`](/reference/module-api/module-options.md#publicapiprojection).

| Method | Path | Description |
|---------|---------|---------|
|`GET` | [`/api/v1/:piece-name`](#get-api-v1-piece-name)| Get all pieces of a given type, paginated|
|`GET` | [`/api/v1/:piece-name/:_id`](#get-api-v1-piece-name-id)| Get a single piece with a specified ID |
|`POST` | [`/api/v1/:piece-name`](#post-api-v1-piece-name)| Insert a new piece of the specified type |
|`PUT` | [`/api/v1/:piece-name/:_id`](#put-api-v1-piece-name-id)| Fully replace a specific piece document |
|`PATCH` | [`/api/v1/:piece-name/:_id`](#patch-api-v1-piece-name-id)| Update only certain fields on a specific document |
|`DELETE` | [`/api/v1/:piece-name/:_id`](#delete-api-v1-piece-name-id) | **Permanently deletes a piece document** |

### Additional piece endpoints

| Method | Path | Description |
|---------|---------|---------|
|`POST` | [`/api/v1/:piece-name/:_id/publish`](#post-api-v1-piece-name-id-publish) | Publish the draft version of a piece |

**This guide will use an `article` piece type as an example.** In addition to standard piece fields, this hypothetical piece type has the following fields (for the sake of illustration):
- `author`: a `relationship` field connected to the `user` piece type
- `category`: a String field
- `body`: an `area` field using the rich text widget.

## `GET /api/v1/:piece-name`

### Basic query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`page` | `?page=2` | The page of results to return |
|`perPage` | `?perPage=20` | Number of pieces to return on each page |
|`search` | `?search=shoes` | A search query to filter the response |
|`autocomplete` | `?autocomplete=sho` | A partial word to filter the response |
|`aposMode` | `?aposMode=draft` | Set to `draft` to request the draft version of piece documents instead of the current published versions. Set to `published` or leave it off to get the published version. Authentication is required to get drafts. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to request piece document versions for that locale. Defaults to the default locale. |
|`render-areas` | `?render-areas=true` | Replaces area `items` data with a `_rendered` property set to a string of HTML based on widget templates. |
<!-- TODO: link to docs about locales when available. -->

#### More about pagination

Apostrophe REST APIs are paginated. Use `page` and `perPage`, not `skip` and `limit`. For best performance, load content when you need it and avoid large values for `perPage`.

#### More about search

`search` produces the most complete search results, while `autocomplete` supports an incomplete final word in the query, so it is better suited to "search as you type" interfaces. Since the results are more complete with `search` (as long as the user has finished typing the last word), providing a way to trigger a full `search` is still recommended when using `autocomplete`.

#### Querying on individual fields

You can also query based on the value of most top level [schema fields](/reference/field-types/index.md) present in the document, including fields you add yourself. For example, you can query on slugs, string fields, and relationships:

| Parameter | Example | Description |
|----------|------|-------------|
|`_ids[]` | `?_ids[]=firstidhere:en:published&_ids[]=secondidhere:en:published` | One or more piece `_id` properties |
|`slug` | `?slug=friday-gathering` | The value of the slug field |
|`title` | `?title=Friday%20Gathering` | The value of the title field |
|`_topic` | `?_topic=idOfTopicGoesHere` | The `_id` property of a related piece |
|`topic` | `?topic=cheese` | The `slug` property of a related piece |
|`_topic[]` | `?_topic[]=cheese&_topic[]=bread` | An "OR" search on multiple related pieces |
|`_topicAnd[]` | `?_topicAnd[]=cheese&_topicAnd[]=bread` | An "AND" search on multiple related pieces |

`_ids[]`, `slug` and `title` exist in all piece types. For the `_topic` and `topic` examples, your piece type must have a [relationship field](../field-types/relationship.md) by that name permitting the user to select related topics, for instance:

```javascript
fields: {
  add: {
    _topic: {
      relationship: {
        withType: 'topic'
      }
    }
  }
}
```

Note that `title` is not intended as a general-purpose search and titles might not be unique.

#### `_ids` preserves order

For convenience, when `_ids` is used the results are sorted in the order specified. For instance, the above example, `firstidhere:en:published` is guaranteed to be returned before `secondidhere:en:published` in the `results` array.

#### Relationship searches on `_id` versus `slug`

Leaving the `_` off the query parameter for a relationship field causes it to match on the slug rather than the `_id` of the related document. This is useful for public-facing URLs.

#### Relationship searches for multiple related documents

Multiple values can be passed for the same relationship field using the `[]` suffix on each one. This creates an "OR" search. In the example above, you'll receive all pieces that have a relationship to cheese OR bread.

To perform an "AND" search, add `And` to the end of the query parameter name as shown in the last example above.

#### Querying on custom query builders

It is possible to create your own custom query builders that receive query parameters and customize the search results. For discussion and an example, see the [queries](../module-api/module-overview.md#queries-self-query) module configuration function.

### Request example

```javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/article?apikey=myapikey&aposMode=draft', {
  method: 'GET'
});
const document = await response.json();
```

### Response

By default, `GET` requests return the published and default locale version of each piece.

| Property | Type | Description |
|----------|------|-------------|
|`pages` | Number | The total number of pages of results |
|`currentPage` | Number | The current page of results |
|`results` | Array | An array of individual piece objects. See the [getOne](#get-api-v1-piece-name-id) response for the document structure.|


``` json
  {
    // Total number of pages of results (10 per page by default)
    "pages": 4,
    // The returned page of results
    "currentPage": 1,
    // Piece document results
    "results": [
      {
        "_id": "ckitdo5oq004pu69kr6oxo6fr",
        "archived": false,
        "visibility": "public",
        "type": "article",
        "title": "ES6 and Beyond: modern JavaScript is so worth it",
        "slug": "es6-and-beyond-modern-javascript-is-so-worth-it",
        // ... additional properties
      },
      // ... up to nine additional documents, by default
    ]
  }
```

In case of an error an appropriate HTTP status code is returned.

## `GET /api/v1/:piece-name/:_id`

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` or `published` to request a specific mode version of the piece. Authentication is required to get drafts. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to request the piece document version for that locale. |
|`render-areas` | `?render-areas=true` | Replaces area `items` data with a `_rendered` property set to a string of HTML based on widget templates. |

<!-- TODO: link to docs about locales and modes when available. -->
<!-- Read more about [mode and locale parameters on single-document requests](/guide/rest-apis#locale-and-mode-in-single-document-requests). -->
::: info
Query parameters will override the locale and mode present in the `_id`. So, if the `aposLocale=es` parameter is supplied, a `GET` request to the `_id` `###:en:published` will return the Spanish, not English, locale.
You can also elect to use the `aposDocId` instead of the `_id` and use the query parameters to pass in the locale and mode parameters found in the `_id`.

### Request example

```javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/article/ckitdo5oq004pu69kr6oxo6fr?apikey=myapikey&aposMode=draft&aposLocale=en', {
  method: 'GET'
});
const document = await response.json();
```

### Response

The successful `GET` request returns the matching document. See the [piece document response example](#piece-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

## `POST /api/v1/:piece-name`

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` to insert a piece as a draft instead of immediately published. Set to `published` or leave it off to insert a published piece. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to request piece document versions for that locale. Defaults to the default locale. |
<!-- TODO: link to docs about locales when available. -->

### Request example

```javascript
// Object with, at a minimum, properties for each required piece field.
const data = { ... };
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/article?apikey=myapikey', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
const document = await response.json();
```

### Response

The successful `POST` request returns the newly created document. See the [piece document response example](#piece-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

### Duplicating existing pieces

The optional `_copyingId` property may be added to the **body** of the
request, e.g. included in the `data` object passed to `JSON.stringify`
above. If this property contains the `_id` of an existing piece of the
same type, the properties of that piece will be applied first as
defaults, and then overridden by any properties present in the body.

In addition, this value becomes the `copyOfId` property of the new piece.
[`beforeInsert` handlers](/reference/server-events.md#beforeinsert) of individual piece types can access this property
to duplicate additional application-specific resources as needed.

## `PUT /api/v1/:piece-name/:_id`

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` or `published` to replace a specific mode version of the piece. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to replace the piece document version for that locale. |

<!-- TODO: link to docs about locales and modes when available. -->
<!-- Read more about [mode and locale parameters on single-document requests](/guide/rest-apis#locale-and-mode-in-single-document-requests). -->

### Request example

```javascript
// Object with, at a minimum, properties for each required piece field.
const data = { ... };
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/article/ckitdo5oq004pu69kr6oxo6fr:fr:published?apikey=myapikey', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
const document = await response.json();
```

### Response

The successful `PUT` request returns the newly created document. See the [piece document response example](#piece-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

## `PATCH /api/v1/:piece-name/:_id`

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` or `published` to update a specific mode version of the piece. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to update the piece document version for that locale. |

If a `PATCH` operation is attempted in the published mode, the changes in the patch are applied to both the draft and the current document, but properties of the draft not mentioned in the patch are not published. This is to prevent unexpected outcomes.

<!-- TODO: link to docs about locales and modes when available. -->
<!-- Read more about [mode and locale parameters on single-document requests](/guide/rest-apis#locale-and-mode-in-single-document-requests). -->

### Request example

```javascript
// Object with *only* the document fields to overwrite.
// This example only changes the article's category to "Nerd Post."
const data = {
  category: 'Nerd Post'
};
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/article/ckitdo5oq004pu69kr6oxo6fr?apikey=myapikey&aposMode=published&aposLocale=en', {
  method: 'PATCH',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
const document = await response.json();
```

### MongoDB-style requests

The `PATCH` request body may use MongoDB-style operators. For example, you may use dot or "at" notation to update a nested property:

```javascript
{
  // Via "dot notation"
  "description.items.0.content": "<p>Update only the rich text.</p>",
  // Same thing via "@ notation," which finds the nested item with that _id
  "@ckgwegpfw00033h5xqlfb74nk.content": "<p>Update only the rich text.</p>"
}
```

### Response

The successful `PATCH` request returns the complete patched document. See the [piece document response example](#piece-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

## `DELETE /api/v1/:piece-name/:_id`

**Authentication required.**

This API route **permanently deletes the piece database document**. Moving pieces to the archive in the Apostrophe user interface or using a `PATCH` request to set `archived: true` do not permanently delete database documents and should be considered.

`DELETE` requests will be rejected if the `_id` matches the draft mode of a page that has an existing published mode document.

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposMode` | `?aposMode=draft` | Set to `draft` or `published` to delete a specific mode version of the piece. |
|`aposLocale` | `?aposLocale=fr` | Set to a valid locale to delete the piece document version for that locale. |

<!-- TODO: link to docs about locales and modes when available. -->
<!-- Read more about [mode and locale parameters on single-document requests](/guide/rest-apis#locale-and-mode-in-single-document-requests). -->

### Request example

```javascript
// Request inside an async function.
await fetch('http://example.net/api/v1/article/ckitdo5oq004pu69kr6oxo6fr:en:published?apikey=myapikey', {
  method: 'DELETE'
});
```

### Response

The successful `DELETE` request simply responds with a `200` HTTP response status code. In case of an error an appropriate HTTP status code is returned.

## `POST /api/v1/:piece-name/:_id/publish`

**Authentication required.**

Publish an existing `draft` mode document in a document set.

The `:_id` segment of the route should be one of the following:
- The `_id` property of the draft piece to be published
- The `_id` property of the published piece to be replaced by the current `draft` version
- The `aposDocId` property of the pieces in the document set

The `body` of the request is ignored.

### Query parameters

| Parameter | Example | Description |
|----------|------|-------------|
|`aposLocale` | `?aposLocale=fr` | Identify a valid locale to publish the draft for that locale. Defaults to the locale of the `_id` in the request or the default locale. |
<!-- TODO: link to docs about locales when available. -->

### Request example

```javascript
// Request inside an async function.
const response = await fetch('http://example.net/api/v1/article/ckhdscx5900054z9k88uqs16w:en:draft/publish?apikey=myapikey', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  }
});
const article = await response.json();
```

### Response

The successful `POST` request returns the newly published piece. See the [piece document response example](#piece-document-response-example) below for a sample response body. In case of an error an appropriate HTTP status code is returned.

## Piece document response example

### Common properties

| Property | Format | Description |
|----------|------|-------------|
|`_id` | String | A unique and permanent ID for the document|
|`visibility` | String | The visibility setting, controlling public availability|
|`archived` | Boolean | Whether the document is archived |
|`type` | String | The piece type name|
|`title` | String | The entered title, or name, of the *document*|
|`slug`| String | A unique, but changeable, identifier for the piece|
|`createdAt` | Date | An [ISO date string](https://en.wikipedia.org/wiki/ISO_8601) of the document's creation date and time|
|`updatedAt` | Date | An [ISO date string](https://en.wikipedia.org/wiki/ISO_8601) of the document's last update date and time|
|Content properties | Variable | Additional properties specific to the piece type and its fields|

<!-- **TODO:** Link to examples of each field's response format. -->

### Example

``` json
{
  "_id": "ckitdo5oq004pu69kr6oxo6fr",
  "archive": false,
  "visibility": "public",
  "type": "article",
  "title": "ES6 and Beyond: modern JavaScript is so worth it",
  "category": "Tech Tips",
  "slug": "es6-and-beyond-modern-javascript-is-so-worth-it",
  "main": {
    "_id": "ckitdnl9l005t2a681hdgry8r",
    "items": [
      {
        "_id": "ckitdo2fl005x2a68ibiv795n",
        "metaType": "widget",
        "type": "@apostrophecms/rich-text",
        "content": "<p>I'm an old dog. I've been coding the web since 1993. So why do I want to teach you new tricks?</p><p>In 1993¬†I hopped an Amtrak train from Connecticut to Seattle. Three days of the same designated vegetarian meal.¬†Hoo boy. But the scenery was worth the food.</p><p>And on arrival I discovered two beautiful things: coffee, and¬†Seattle's spoken word scene. Yes, I read slam poetry in dive bars. Very punk rock.</p><p>How did that turn out? Well I¬†was, uh, popular with the critics. Audiences, not so much. Hey, I had fun.</p><p>There was one small problem: I didn't yet have a job.</p><p>Fortunately my former employer at Cold Spring Harbor Laboratory on Long Island called me up one day to ask: \"hey, when you said you could rebuild our cell biology visualization software for this new World Wide Web thing... were you joking?\"</p><p>I quickly decided I wasn't joking. And so¬†I worked remotely from Seattle.¬†Over a 14.4kbps modem. That's <em>way slower than bad 3G</em>¬†for you youngins.</p><p>And so I helped take¬†an application that was limited to a handful of researchers with access to high-end workstations (think \"Unix! I know this\" in Jurassic Park) and bring it to anyone with a decent PC and a modem. <em>Slowly</em>. <em>Barely</em>. But still.</p><p>That was a \"new tricks\" moment. And¬†also a punk rock moment. Something that was difficult and reserved for a priesthood with the relevant skills became that much more accessible.</p><p>&hellip;</p>",
        "_edit": true,
        "_docId": "ckitdo5oq004pu69kr6oxo6fr"
      }
    ],
    "metaType": "area",
    "_edit": true,
    "_docId": "ckitdo5oq004pu69kr6oxo6fr"
  },
  "metaType": "doc",
  "createdAt": "2020-12-17T21:50:45.195Z",
  "updatedAt": "2020-12-21T17:25:34.339Z",
  "updatedBy": {
    "_id": "ckhdsd0hk0003509kchzbdl83",
    "firstName": "Super",
    "lastName": "Admin",
    "username": "admin"
  },
  "authorIds": [
    "ckitdleax002tu69kejca3ho0"
  ],
  "_edit": true,
  "_author": [
    {
      "_id": "ckitdleax002tu69kejca3ho0",
      "archive": false,
      "disabled": false,
      "type": "@apostrophecms/user",
      "firstName": "Tom",
      "lastName": "Boutell",
      "title": "Tom Boutell",
      "slug": "user-tom-boutell",
      "username": "tom",
      "email": "tboutell@example.net",
      "metaType": "doc",
      "createdAt": "2020-12-17T21:48:36.393Z",
      "updatedAt": "2020-12-21T17:25:13.940Z",
      "updatedBy": {
        "_id": "ckhdsd0hk0003509kchzbdl83",
        "firstName": "Super",
        "lastName": "Admin",
        "username": "admin"
      },
      "_edit": true
    }
  ],
  "_url": "http://example.net/blog/es6-and-beyond-modern-javascript-is-so-worth-it",
  "_parentUrl": "http://example.net/blog"
}
```

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > REST API Reference > rich-text
DOC_PATH: reference/api/rich-text.md
URL: https://apostrophecms.com/docs/reference/api/rich-text
================================================================================
# rich text widgets in the REST API

### A simple example of what to expect

In the REST APIs of piece types and pages, and also in the database, an area containing a simple rich text widget looks like this:

```json
{
  "main": {
    "_id": "ckj0k0dy7000i2a68s1z8v4ky",
    "items": [
      {
        "_id": "ckj0k0mox000o2a68oouznar1",
        "metaType": "widget",
        "type": "@apostrophecms/rich-text",
        "content": "<p>Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum <strong>nibh, ut fermentum massa justo sit amet risus.</strong></p><p><br /></p>",
        "_docId": "ckj0k2i45001c7u9kky3tftx2"
      }
    ],
    "metaType": "area",
    "_docId": "ckj0k2i45001c7u9kky3tftx2"
  }
}
```

### Adding and updating rich text widgets

If creating a new document with `POST`, or updating a document with `PUT` or `PATCH`, you can add new rich text widgets to the `items` array or update the `content` of existing ones.

When adding a new widget via the REST API, you are not required to pass `_id`, `_docId` or `metaType`. These are supplied automatically for you.

### Rich text is filtered

Note that the HTML must specifically match what is allowed by the set of features enabled in that particular rich text widget, for instance via the `insert`, `toolbar`, `styles` and `colors` options given when configuring the widget. Anything else sent in a `POST`, `PATCH` or `PUT` request will be filtered out. This feature is designed to prevent users from carrying out cross-site scripting attacks or simply breaking the entire layout of your website with unexpected CSS.

### Importing inline images

Inline images are only permitted if the rich text widget has the `image` control in its `toolbar` and/or `insert` option.

When using the `content` property, inline images are only permitted via a specifically formatted `figure` tag, based on `@apostrophecms/image` pieces already uploaded to the system. However, there is a simple way to import external images.

Just use the following format when making a `POST`, `PUT` or `PATCH` REST API call for a page or piece type:

```javascript
{
  // Other properties of the page
  "slug": "/about",
  "type": "default-page",
  "title": "About",
  // The area field we are interested in, within the page
  "main": {
    "metaType": "area",
    // The array of widgets
    "items": [
      // A rich text widget
      {
        "type": "@apostrophecms/rich-text",
        // Use import rather than content to trigger
        // the image-importing behavior
        "import": {
          "baseUrl": "https://myoldsite.com",
          "html": "<p>Here is some text.</p>\n<img src=\"/my-image.jpg\" />",
          "imageTags": ["tag-piece-id-1", "tag-piece-id-2"]
        }
      }
    ]
  }
}
```

Note that:

* We are using an `import` property, not a `content` property. This triggers special behavior for importing external images.

* The `baseUrl` sub-property has been set to point to another site. This optional sub-property is used to resolve `img src` URLs with no protocol, like the one in this example.

* The actual markup is passed in the `html` sub-property.

* Any images found during import are imported into the system as Apostrophe image pieces and automatically converted to the proper figure format with optional captions. This means they will appear in the media library alongside images added to Apostrophe in the usual way.

* Any `alt` attributes found are also imported.

* The optional `imageTags` sub-property accepts an array `_id`s from existing `@apostrophecms/image-tag` pieces that will be applied to any image(s) imported during the process. These tags will be added to the imported images in the media library.

* The rich text widget still must specify the `image` control in its `toolbar` and/or `insert` options or the images will be filtered out.

================================================================================
COLLECTION: guides
NAV_PATH: Config & API Reference > Glossary
DOC_PATH: reference/glossary.md
URL: https://apostrophecms.com/docs/reference/glossary
================================================================================
# Glossary

While these terms have more common definitions, these descriptions focus on each term's use in the context of Apostrophe.

## General terms

### Core

The term "Apostrophe core," or simply "core," is used frequently throughout this documentation. "Core" refers to the foundational software for all Apostrophe projects. It is the package that a developer would get when installing with `npm i apostrophe` or `yarn add apostrophe`. This documentation focuses on the features in Apostrophe core since those are the features that all Apostrophe projects have in common.

### Module

Apostrophe sites are powered by Apostrophe modules. Each module is responsible for providing one feature, such as a type of widget, a type of customized page, or a service like pushing assets to the browser. Apostrophe has many standard modules which provide its core features.

A module can extend, or "subclass", another module, and most of the modules you create at "project level" (in your project code) will. All modules implicitly extend `@apostrophecms/module`, which provides a rich set of conveniences, like rendering templates or pushing assets relative to your module's folder.

<!-- TODO: Move this description of module directories to a guide page and link there instead. This goes beyond definition. -->

Modules created at project level live in subdirectories of `/modules`. For example, an `article` module would be managed in the `/modules/article` directory. Code and configuration for a module lives in it's `index.js` file (`/modules/article/index.js`, in the example).

### Doc

A "doc" refers to a content-related document in Apostrophe's database. They are in the `aposDocs` MongoDB collection.

Docs contain various properties, including [areas](#area), as described by a schema configured for their **document types** (or "doc type"). Each doc type will extend `@apostrophecms/piece-type`, `@apostrophecms/page-type`, `@apostrophecms/piece-page-type`, or another doc type that itself extends one of those core modules.

At a minimum, a doc has unique `_id` and `slug` properties. The `type` property identifies the doc type and determines what other behaviors it might have. The `@apostrophecms/doc` module provides methods for working with docs, including the `apos.docs.getManager(doc.type)` method, which returns a reference to the module suited to working with that type of document.

### Piece

A "piece" is a unit of standalone, structured, non-page content in Apostrophe. A piece module extends `@apostrophecms/piece-type`. These include core elements such as images and users, as well as project-specific content, such as events or products.

They are not pages themselves, but can be displayed at individual page URLs if there is a matching pieces page type (extending the `@apostrophecms/piece-page-type` module). They could then have individual [show pages](#show-page) once an [index page](#index-page) (an often-paginated listing page) of that type is created.

### Page

A doc that is part of the page tree and is designed to be viewed like any traditional web page. It can potentially have "child" pages via the page tree hierarchy. Pages belong to particular "page types," and may have custom fields based on their type, but are not displayed in an index listing as pieces are.

Their `slug` property begins with `/`, which is only true for pages. A page also has `path`, `rank` and `depth` properties that help make its relationship to other pages in the tree clear.

`path` differs from `slug` in that it always reflects the true parent-child relationships between pages in the tree, while `slug` can be edited and shortened if desired so that URLs don't have to contain a lot of slashes to reach a deep page.

### Index page

An index page, is a special [page](#page) that is built to display a listing of [pieces](#piece). Index pages extend the `@apostrophecms/piece-page-type` module. In addition to data available to all pages, index page templates have access to a `data.pieces` array, which contains objects representing individual pieces, limited by the pieces page `perPage` option and the state of pagination. Index pages also have `data.currentPage` and `data.totalPages` number values available to support pagination.

### Show page

Despite their name, these are not [pages](#page) in the sense of extending the `@apostrophecms/page-type` module. They therefore do not have individual representation in the page tree. They are a feature, enabled by creating an [index page](#index-page), providing individual URLs that display a rendered template for individual [pieces](#piece). **A blog listing is an "index page" and the individual blog post is a "show page."**

Show page templates (`show.html`), do have access to their parent index page's `data.page` object, but they also have access to `data.piece`, which contains all of the data for a particular piece.

### Global doc

There is a single doc with the slug, `global`, which is always loaded and available to page templates as `data.global`. This is useful for shared, site-wide headers and footers that are editable, etc. It is managed by the `@apostrophecms/global` module.

### Slug

The slug of an Apostrophe doc is a string that uniquely identifies that doc within the database. Apostrophe will enforce that no two docs have the same slug. Slugs _can_ be changed, unlike the `_id` property of the database document. The Apostrophe user interface and REST API will suggest slugs automatically based on the document's title on creation.

If the doc is a page, or a piece with a [show page](#show-page), the slug is used as a component of the page URL. This works differently for pages and pieces.

- [Page](#page) slugs begin with a forward slash and, by default, include sections for their parent pages, e.g., `/previous-page/new-page` for a page titled "New Page" with a parent page of "Previous Page." Editing a page slug will not effect the actual page tree structure.
- [Piece](#piece) slugs do not begin with a forward slash nor do they include reference to an [index page](#index-page). A piece titled "New Piece" will get the suggested slug of `new-piece` if no other doc has that slug already.

### Widget

A widget is a single section of content in an [area](#area) that can usually be edited, such as a block of rich text, an image slideshow, or a callout block. You can create entirely new types of widgets by extending the `@apostrophecms/widget-type` module.

### Area

An area is a special field in a piece or page where you can add any number of widgets of any type, as configured for that piece or page type. Editors can add, edit, move, and remove widgets within the area. Widgets in the area maintain their order for consistent displaying.

Areas are inserted into your templates using the [`area` template tag](/guide/areas-and-widgets.md). They are implemented by the `@apostrophecms/area` module.

### Template

Apostrophe uses the [Nunjucks template language](https://mozilla.github.io/nunjucks/) to render webpages and components of pages, such as widgets and [blocks](#block). Nunjucks shares a syntax with the Jinja and Twig languages which are popular in the Python and PHP worlds, respectively.

### Block

In Nunjucks templates, [a block is a section of a template that can be overridden in a template that extends it](https://mozilla.github.io/nunjucks/templating.html#block). This is a useful technique in page templates when paired with [template inheritance](https://mozilla.github.io/nunjucks/templating.html#template-inheritance).

### Schema

A piece, page, or widget type's schema is the definition of its fields. Apostrophe's schemas are used both to create an editing interface and to sanitize and save data on the server side. Commonly used field types include strings, integers, floats, select elements and "relationship" fields, which allow editors to define connections to other docs.

Schemas are built by using the `add`, `remove`, and `group` properites of the `fields` option when configuring any module that extends `@apostrophecms/piece-type`, `@apostrophecms/page-type`, or `@apostrophecms/widget-type`.

Here is a simple example in which we add a required "author" string field to the schema for "story," a custom piece type:

```javascript
// modules/story/index.js in our project
module.exports = {
  extend: 'apostrophe-pieces',
  name: 'story',
  fields: {
    add: {
      author: {
        type: 'string',
        required: true
      }
    }
  }
}
```

<!-- TODO: Return when module reference is available. -->
<!-- See the [apostrophe-schemas](/reference/modules/apostrophe-schemas/README.md) module documentation for more information. -->

### Relationship

In [Apostrophe schemas](#schema), a "relationship" field describes a connection with another doc. A development agency might want to connect "services" to "projects," or you might want to select "office" pieces for display in the website footer.

In that second case, the schema containing the relationship field might look like this:

```javascript
fields: {
  add: {
    _offices: {
      label: 'Offices',
      type: 'relationship',
      withType: 'office'
    }
  }
}
```

The editing interface for this join allows the user to pick offices to associate with this service. When writing templates, the developer is then able to access a `._offices` array as a property of each service.

<!-- TODO: Return when module reference is available. -->
<!-- See the [apostrophe-schemas](/reference/modules/apostrophe-schemas/README.md) module documentation for more information about joins. -->

<!-- TODO: Display this when other locale information is added. -->
<!-- ### Document set

The database documents that exist as mode and locale versions of one another. For example, in a project with an English and a French locale, the home page would be managed in the database by six documents: 1) the draft English, 2) published English, 3) previous English, 4) draft French, 5) published French, and 6) previously published French. These six database documents make up the document set. -->


### Shortname

An Apostrophe website's shortname is used as the primary identifier for the application. It is used as the Express session name and by default is the database name and part of the CSRF cookie name. It is a top-level property of the application object we [configure in a project's `app.js` file](/guide/development-setup.md#creating-a-project) as `shortName`.

## User interface terms

### Manager

The manager, or manager modal, is a UI modal that displays a table or list of pages or pieces of a particular doc type. Pages are displayed in one manager and every piece type is displayed in their own manager modals. This UI is usually opened by clicking or triggering the doc type's button in the admin bar. The manager is also used as a "chooser" when browsing pages or pieces for a relationship field.

### Editor

The editor modal is a traditional interface with [discrete fields](/reference/field-types/index.md) to add or update a document's content. This is distinct from the "in-context" editing experience where editors update content in the page as any visitor would see it.

## Localization terms

Apostrophe generally subscribes to [the W3C definitions](https://www.w3.org/International/questions/qa-i18n.en) of the following terms. These definitions borrow from their descriptions with a focus on use with Apostrophe.

### Localization

"Localization," often abbreviated as **l10n**, is the process of adapting the Apostrophe user interface and Apostrophe website content for different groups of people (usually based on language and country). This can include text translation, date formats, content variation, and much more.

### Locale

A locale is a content classification used to associate certain content and l10n settings with a group of people. Locales may be languages (e.g., English, Spanish), countries (e.g., Canada, France), combinations of the two (e.g., Canadian French, Canadian English), or really any significant group of website visitors.

### Internationalization

"Internationalization," often abbreviated as **i18n**, refers to the whole system that supports localization. This is why the primary core Apostrophe module related to these topics is `@apostrophecms/i18n`. We can think of i18n as the tools and l10n as how people use them to make content more accessible to different peoples.

================================================================================
COLLECTION: guides
NAV_PATH: Starter Kits > Essentials Starter Kit
DOC_PATH: starters/essentials.md
URL: https://apostrophecms.com/docs/starters/essentials
================================================================================
# Apostrophe Essentials Starter Kit

## Requirements For Development On Your Computer

### Operating System: Mac, Linux, or Virtual Linux

**Your local development environment must be either MacOS or Linux.** If your development computer runs Windows, we recommend development on
Windows Subsystem for Linux (WSL). Microsoft recommends WSL for Node.js development.

### Software Installation Requirements

To test-drive the project in development, make sure you have Apostrophe's usual dependencies on your local machine:

* MongoDB (5.x or better, we recommend 6.x or better) or an Atlas account
* NodeJS (18.x or better)

For more information see the Apostrophe [Getting Started Tutorial](/guide/development-setup.md).
## Getting started

This Starter Kit, also known as a boilerplate project, serves as a template for initiating new projects and can be installed in two main ways:

1. **Using Our CLI Tool**: Run our [CLI tool](https://github.com/apostrophecms/cli) to clone this template locally, install its dependencies, and set up an initial admin user. You accomplish this using:
   
   `apos create <my-project-name>`
> Note that if you are connecting to an MongoDB Atlas instance you should add your connection string to the `APOS_MONGODB_URI` environment variable first. Use:

  ``` sh
  export APOS_MONGODB_URI="mongodb+srv://username:pa%24%24word@mycluster.1234x.mongodb.net/YOUR-PROJECT-NAME?retryWrites=true&w=majority"
  ```

2. **Manual Setup**: Manually `git clone` this repository and install its dependencies using `npm install`. Then add an initial admin user with `node app @apostrophecms/user:add admin admin`. Again, if using a MongoDB Atlas instance set the `APOS_MONGODB_URI` environment variable first using:

``` sh
export APOS_MONGODB_URI="mongodb+srv://username:pa%24%24word@mycluster.1234x.mongodb.net/YOUR-PROJECT-NAME?retryWrites=true&w=majority"
```

For those who need to create multiple projects with additional base modules, consider [forking this repository](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/about-forks) into your organizational or personal GitHub account. Customize it to fit your needs. To use your customized template, run the following CLI command:

  `apos create <project-name> --starter=<repo-name>`

Here, `<repo-name>` should be the URL of your forked repository, excluding the `https://github.com/` part.

**Note: This template is NOT designed to be installed into an existing project.**

## Running the project

Run `npm run dev` to build the Apostrophe UI and start the site up. Remember, this is during alpha development, so we're all in "dev mode." The `dev` script will watch for saves in client-side CSS and JavaScript and trigger a build and page refresh if they are detected. It will also restart the app when server-side code is saved.

## Making it your own

This boilerplate is designed so you can install and start running it right away. If you are starting a project that will go into production one day, there are a few things you should be sure to check:

- [ ] **Update the shortname.** You don't need to perform this step if you created your project using the CLI tool. The `shortname` option in `app.js` is used for the database name (unless another is given in the `@apostrophecms/db` module). You should change this to an appropriate project name before you start adding any users or content you would like to keep.
- [ ] **Update the Express.js session secret.** The secret is set to `undefined` initially in the `modules/@apostrophecms/express/index.js` file. You should update this to a unique string.
- [ ] **Decide if you want hot reloading on.** This boilerplate uses nodemon to restart the app when files are changed. In `modules/@apostrophecms/asset/index.js` there is an option enabled to refresh the browser on restart. If you like this, do nothing. If you don't, remove the option or set it to `false`. The option has no effect when the app is in production.
- [ ] **Update the `className` options in `app.js`.** This option is set for core widget types to provide CSS styling hooks. It is namespaced with `bp-` for "boilerplate." You will likely want to update that to match your general CSS class naming practices.

## You really want the docs

Right now, [all the juicy info is in the ApostropheCMS docs](https://apostrophecms.com/docs), so head over there and start reading! This boilerplate project is a fun introduction to the UI, but you'll want to know more to really try it out.

================================================================================
COLLECTION: guides
NAV_PATH: Starter Kits > Pro Essentials Starter Kit
DOC_PATH: starters/pro-essentials.md
URL: https://apostrophecms.com/docs/starters/pro-essentials
================================================================================
---
prev: false
next: false
---
# Apostrophe Pro Essentials Starter Kit

::: info
This page provides detailed information about a Pro module, accessible with an Apostrophe Pro subscription. If you haven't subscribed yet, explore our [Apostrophe Workspaces](https://app.apostrophecms.com/login) to discover the benefits of a subscription. For further details or inquiries, feel free to [contact us](https://apostrophecms.com/contact-us) or visit our [pricing page](https://apostrophecms.com/pricing).

## Purpose
The purpose of the Pro Essentials Starter Kit is to serve as a quick start for single-site Apostrophe Pro projects.
As such, it includes several Pro modules, pre-configured, although it does not include all, as developer needs vary. Subscribers will have access to additionally `npm install` and configure any of the Pro modules listed on our website.

It also serves as example code for creating your own custom modules and organizing your files in an ApostropheCMS project. The [section describing the widgets](#provided-widgets) outlines some code practices and features that can be used in your own custom modules.

This Starter Kit includes:

* The `@apostrophecms-pro/document-versions` module.
* Example configuration of the `@apostrophecms-pro/palette` module.
* Basic Apostrophe Widgets, including an Accordion, Card, Column, Hero, Link, and Slideshow Widget located in `modules/widgets`.
* Basic examples of theme specific front-end code.

## Requirements For Development On Your Computer

### Operating System: Mac, Linux, or Virtual Linux

**Your local development environment must be either MacOS or Linux.** If your development computer runs Windows, we recommend development on
Windows Subsystem for Linux (WSL). Microsoft recommends WSL for Node.js development.

### Software Installation Requirements

To test-drive the project in development, make sure you have Apostrophe's usual dependencies on your local machine:

* MongoDB (5.x or better, we recommend 6.x or better)
* NodeJS (18.x or better)

For more information see the Apostrophe [Getting Started Tutorial](/guide/development-setup.md).

## Getting Started
The Pro Essentials starter kit can either be installed using the [Apostrophe CLI tool](https://apostrophecms.com/extensions/apos-cli) or you can navigate to the [official GitHub repository](https://github.com/apostrophecms/starter-kit-pro-essentials), fork the template into your own account, and clone it locally.

---
### Installing with the CLI tool

To install with the [CLI tool](https://apostrophecms.com/extensions/apos-cli), use the `--starter` flag to specify this kit:

```sh
apos create my-project --starter=pro-essentials
```
---
### To install from GitHub:

1) `git clone` the [Starter Kit](https://github.com/apostrophecms/starter-kit-pro-essentials) and push it up to your own git repository under an appropriate name, matching your choice of `shortName`, for ongoing work.

2) Install dependencies:

``` sh
npm install
```

3) Add an admin user:

``` sh
node app @apostrophecms/user:add admin admin
```

Enter a password when prompted.

## Before you begin

This document assumes familiarity with Apostrophe concepts. If you are not already familiar with
single-site Apostrophe development, you should pause here and familiarize yourself with the
[ApostropheCMS documentation](https://apostrophecms.com/docs/) as a starting point.

## First Steps: required before project startup

### Setting your shortName

**Don't leave this setting in `app.js`, or anything else, set to `CHANGEME`.** The `shortName` should usually be the same
as your repository name, which should usually be the same as the name of your project folder. It will also be the name of
your MongoDB database by default in local development. Do not use punctuation other than hyphens. Good examples include
`smithco-marketing`, to distinguish from other sites built for that company, or just `smithco`.

This name should be unique among your projects.

Note that the CLI tool will automatically change this to the project name you used for installation.

### Disabled File Key

In `app.js`, locate `disabledFileKey` and change `CHANGEME` to a random string of your choosing. This is used when disabling access to files in the local backend. Do not leave it set to `CHANGEME`.

### Session Secret

In `app.js`, locate `secret` and change `CHANGEME` to a random string of your choosing. This is used for login session encryption. Do not
leave it set to `CHANGEME`.


After following all the steps above you can start your project in development mode:

``` sh
npm run dev
```

Once the project has finished starting up you can visit:

``` sh
http://localhost:3000/login
```

And log in with the admin account you created for the site. Then make some simple edits to the homepage.


## Site Development

Right now we have basic example templates in place. Let's look at where to put our code to customize the experience.

> Again, if you are not already familiar with single-site Apostrophe development, you should pause here and
[review the ApostropheCMS documentation](https://apostrophecms.com/docs) as a starting point.

Just like in any single-site Apostrophe project, modules are configured in `app.js`, and module code lives
in subdirectories of `modules/`.

Feel free to add page templates and modules as you would with an ordinary open-source Apostrophe project. You can `npm install` modules
like `@apostrophecms/blog` and configure them in a normal way. You can also install additional Pro modules like
`@apostrophecms-pro/advanced-permission` if they are necessary to your plans.

### The `theme-default` module

Apostrophe allows frontend assets to be placed in any module, but as a suggested
code organization, this project contains a `theme-default` module with a sample
`ui/src/index.js` and `ui/src/index.scss` as described further below. This approach
simplifies later migration to an Assembly multisite project especially if you anticipate
implementing a choice of themes at that time.

The `theme-default` module also modifies the base webpack build to incorporate SCSS variables for colors and fonts. This is included to demonstrate how to set up centralized theme management with global variables in one place. It also adds a function for converting font sizes from `px` to `rem`. While this is a useful function that is used in several of the `theme-default` stylesheets, it primarily serves to illustrate how SCSS functions can be added to your project. A similar approach would be used to add in any SCSS mixins that subsequent stylesheets utilize.

The `views` folder of the `theme-default` module has two markup files that provide the HTML for the `@apostrophecms/home-page`. The main `welcome.html` file contains a conditional block for displaying different content based on whether there is a user is logged in or not. It has a second conditional block for displaying markup from the `placeholder.html` file if no content has been added to the page. You can choose to maintain this structure and modify the `welcome.html` file, or change the `modules/@apostrophecms/home-page/views/page.html` to contain your own markup.

#### Modern Frontend Assets Without A Custom Build Process

There is no need for a custom Webpack configuration in most cases. Specifically, you can follow our documentation and place your modern
JavaScript code in the `ui/src/index.js` file of any module, or use `import` statements in that file to import it there. As noted in
our documentation, it is **important for `ui/src/index.js` to export a function as its default export.** This function will be invoked
to initialize your module at a safe time when `apos.http`, `apos.util`, etc. are already available.

You may also place Sass SCSS code in the `ui/src/index.scss` file of any module, and use `import` statements in that file to bring in
more Sass SCSS code.

#### Frontend Assets With Your Own Build Process

A sample webpack build is not included as standard equipment, as `ui/src` suffices for most needs, and the built-in, automatic Webpack configuration
can be extended, per our public documentation and as illustrated. However, if you prefer to create your own webpack configuration, the typical pattern
is to configure the output of your build process to be a `ui/public/something.js` file in any module in your Apostrophe project.

#### Serving Static Files: Fonts and Static Images

If you need to serve static files, you can do this much as you would in standalone Apostrophe development.

The folder `public` maps to `/` in the URL space of a site. For instance, `public/fonts/myfile.ttf` maps to the URL `/fonts/myfile.ttf`.
For assets like favicons and fonts, you can add `link` tags to the `standardHead` block already present in
`modules/@apostrophecms/template/views/outerLayout.html`.

### Palette Configuration

The palette module allows styles to be edited visually on the site. It is configured in `modules/@apostrophecms-pro/palette/index.js`.
There you can specify the selectors, CSS properties, and field types to be used to manipulate color, font size, font family
and other aspects of the site as a whole.

For complete information and a sample configuration, see the [@apostrophecms-pro/palette module documentation](https://apostrophecms.com/extensions/palette-3).

> Note that like all other changes, palette changes do not take place for logged-out users until the editor clicks "Publish."

## Hosting and Deployment

### If we are your host

If we are hosting Apostrophe for you, then you can deploy updates to your staging and production environments by pushing to your
`staging` and `production` git branches, respectively. You will receive notifications in our shared Slack channel, including links to
access the deployment progress logs.

Apostrophe will complete the build steps listed in the `build` npm command provided in `package.json` and also execute any
database migrations before restarting with your newest code.

### Self-hosting

Self-hosting is also an option if you have not chosen to host with us. We offer several how-to guides on this, such as
[Ubuntu hosting setup](/cookbook/ubuntu-hosting.md) and
[deploying Apostrophe in the cloud with Heroku](/cookbook/deploying-to-heroku.md). The main new element
with Apostrophe Pro is making sure that the `npm install` command has access to the `@apostrophecms-pro` modules during installation.

Here is the simplest recipe to achieve that:

1. Make sure you have been granted access to install our pro modules (that is, make sure `npm install` works for you in this project). If
not, reach out to our support team.
2. [Log into the npm website](https://www.npmjs.com/) using the account that has been granted access.
3. Pull down the personal menu and select "Access Tokens."
4. Select "Classic Token" from the "Generate Tokens" dropdown.
5. Give the token a name, such as "ops-deployment".
6. Select "Read-Only."
7. **Immediately** copy and paste the token that is displayed. It will not be shown again.
8. Create a `.npmrc` file in the root of your project, like this:

```
//registry.npmjs.org/:_authToken=YOUR-TOKEN-HERE
```

It is also possible to use an environment variable for additional security, depending on your preferred deployment and hosting
solution. Please see the npm documentation for more information on that option.

## Provided widgets
There are six basic widget modules located in the `modules/widgets` folder of this starter kit. This supplements the core `rich-text`, `image`, `video`, and `html` widgets. They can be altered to fit the design and functionality of your project or act as a blueprint to build your own custom widgets. Both the `hero` and `column` widgets have been added to the `main` area of the `@apostrophecms/home-page`. The remainder of the basic widgets have been added to the areas of the `column` widget as described below.

If you look at the `app.js` file you won't see these widget modules in the `modules` object. Instead, they are being registered using the `nestedModuleSubdirs` property. Setting this property to `true` will cause Apostrophe to register all the modules listed in the `modules.js` file of any subfolder in the project-level `modules` folder. You can choose to organize any custom modules, such as grouping all of your piece-types, to keep your `modules` folder and the `app.js` file less cluttered. Note that if you choose to move any of the provided widgets out of the current folder you will need to add them to the `app.js` and remove them from the `modules/widgets/modules.js` file. If you choose to keep this structure, any custom widgets you add to the folder need to be listed in the `modules.js` file.

All the styling for the supplied widgets, except for the partials added in the custom webpack extensions added in the `theme-default` module, is located in the `ui/src/index.scss` file of each module. You can choose to maintain this structure, move the styling to the `theme-default/ui/src/scss` folder, or organize them in a different project-specific manner. Note that for them to be included in the standard webpack build, they need to be imported into a `<module>/ui/src/index.scss` file.

### `accordion-widget`
The `accordion-widget` implements an accordion element powered by the [`accordion-js` npm package](https://www.npmjs.com/package/accordion-js). You can read about additional configuration options in the documentation of that package. The module consists of a main `index.js` file with the content schema fields, plus a `views` folder that contains a `widget.html` file with the Nunjucks markup for the accordion.

Finally, there is the `ui/src` folder that contains the `index.scss` stylesheet and the `index.js` file that contains the JavaScript that is delivered to the frontend and powers the accordion using a [widget player](/guide/custom-widgets.md#client-side-javascript-for-widgets). Any custom widgets that require client-side code should be structured in this same way. Data is passed from the schema fields to the browser for use in the player script by adding it to a data attributes in the template.

### `card-widget`
The `card-widget` creates a simple card with optional image and text. The card can be made directly clickable, or can have links and buttons added. The schema fields for these elements are provided by the `lib/schema/link.js` file, which serves as a model for implementing reusable parts of widgets. These same schema fields are reused in the `hero` and `link` widgets and can be used in your custom project widgets. The markup for the links is imported into the `card-widget` template from the `views/fragments/link.html` file using the [`rendercall` helper](/guide/fragments.md#inserting-markup-with-rendercall). This is present in a simpler form in the `links-widget`. Again, all your custom modules (not just widgets) can utilize fragments to replicate similar areas of markup in this same way.

### `column-widget`
The `column-widget` implements one method of adding a user-selected number of columns to a page. It uses a select field and conditional fields that restrict the number of columns based on the value of the select. Each column has an area with widgets for the `link`, `card`, and `accordion` basic widgets, plus the core `rich-text`, `image`, and `video` widgets. These are added through a shared configuration object that defines the available widgets for each column. The first column additionally adds the basic `slideshow` widget.

The widget also provides a `helper(self)` customization function that is used in the Nunjucks template. Depending on the value of the select field it returns the correct number of columns. The `helper(self)` functions can be used in your custom modules to provide computed values from data passed back from the markup.

### `hero-widget`
The `hero-widget` implements a hero element with image or color background, text and links. As stated above, this module reuses the `links.js` helper file. It also demonstrates how to use `relationship` schema fields to add an image or video for the background.

### `link-widget`
This simple widget adds either a button or inline-link. As described for the `card-widget`, It utilizes the `lib/schema/link.js` helper file and the `views/fragments/link.html` fragment. Within the widget template there is a `rendercall` that passes data from the widget schema fields to the fragment.

### `slideshow-widget`
The `slideshow-widget`, much like the `accordion-widget`, utilizes client-side JavaScript. For this widget the `ui/src/index.js` is adding the [`swiper.js` package](https://swiperjs.com/) to the player.

================================================================================
COLLECTION: guides
NAV_PATH: Starter Kits > Pro Assembly Starter Kit
DOC_PATH: starters/assembly.md
URL: https://apostrophecms.com/docs/starters/assembly
================================================================================
# Apostrophe Assembly Essentials Starter Kit

::: info
This page provides detailed information about a Pro module, accessible with an Apostrophe Pro subscription. If you haven't subscribed yet, explore our [Apostrophe Workspaces](https://app.apostrophecms.com/login) to discover the benefits of a subscription. For further details or inquiries, feel free to [contact us](https://apostrophecms.com/contact-us) or visit our [pricing page](https://apostrophecms.com/pricing).

## Purpose

The purpose of the [Assembly Essentials starter kit](https://github.com/apostrophecms/starter-kit-assembly-essentials) is to serve as a quick start for multisite-enabled, cloud-hosted projects based on and hosted via Apostrophe Assembly. Technically speaking, it serves as a working example of a project built on the [`@apostrophecms-pro/multisite` module](https://apostrophecms.com/extensions/multisite-apostrophe-assembly).

It also serves as example code for creating your own custom modules and organizing your files in an ApostropheCMS project. The [section describing the widgets](#provided-widgets) outlines some code practices and features that can be used in your own custom modules.

This starter kit includes:

* An example of project-level code for your customer-facing sites.
* An example of project-level code for the dashboard site that manages the rest.
* An example of project-level frontend asset generation via a modern webpack build.
* Best practices for easy hostname configuration in dev, staging and prod environments.
* Support for multiple themes.

## Requirements For Development On Your Computer

### Operating System: Mac, Linux, or Virtual Linux

**Your local development environment must be either MacOS or Linux.** If your development computer runs Windows, we recommend development on Ubuntu Linux in a full virtual Linux machine, via [VirtualBox](https://www.virtualbox.org/).

Another option is to use the Windows Subsystem for Linux, which is also an Ubuntu Linux-based environment. However this option has not been extensively tested with Assembly.

### Software Installation Requirements

To test-drive the project in development, make sure you have Apostrophe's usual dependencies on your local machine:

* MongoDB (5.0 or better, we recommend 6.0)
* NodeJS (18.x or better, latest long term support release recommended)

For more information see the Apostrophe [Getting Started Tutorial](/guide/development-setup.md).

## Getting started

**We recommend installing this project by cloning it locally and then pushing it to a repository in your own account. The Apostrophe CLI is not currently intended for multisite projects**

1) Navigate to the [Starter Kit](https://github.com/apostrophecms/starter-kit-pro-essentials) repository and clone it locally, or navigate to the directory where you want your project installed and type:

```sh
git clone https://github.com/apostrophecms/starter-kit-assembly-essentials.git your-new-project-name
```
2) In the root directory of your project initialize version tracking with your preferred tool (GitHub, BitBucket, SourceForge, etc...) and create the base repo for your project.

3) Install dependencies:

``` sh
npm install
```

3) After installation, add an admin user to the dashboard site, which manages all other sites:

```sh
node app @apostrophecms/user:add admin admin --site=dashboard
```

Enter a password when prompted.

> When running command line tasks in a multisite environment you must always specify which site you are referring to. For the dashboard, use `--site=dashboard`. For other sites, you can use any of their valid hostnames, or `--all-sites` which runs the task on every site except the dashboard.

## First Steps: required before project startup

### Setting your shortname prefix

Before you do anything else, set the fallback value for the `shortnamePrefix` option in `app.js` to a unique string for your project, replacing `a3ab-`. This should match your repo name followed by a `-` character. This should be distinct from any other Assembly projects you have, to ensure their MongoDB databases do not conflict in a dev environment.

> MongoDB Atlas note: if you are self-hosting and you plan to use a low-end MongoDB Atlas cluster (below M10), you must use a unique prefix less than 12 characters (before the `-`), even if your repo name is longer. This is not an issue with hosting provided by the Apostrophe Assembly team.

### Configuring your domains

After cloning this project, be sure to edit the `domains.js` file in the root directory and update the list to match your actual project's domains, typically for development, staging, and production. The `@apostrophecms-pro/multisite-dashboard` extension's `site` module requires an object with URL strings for the `baseUrlDomains` option, and this file provides those values. While `dev`, `staging`, and `prod` are common domain names, you can use other names, but the first one defined in the object will be considered the development environment.

If you are doing local development on your own computer, leave the `dev` domain set to `localhost:3000`. For staging and production, the Apostrophe Assembly team will typically preconfigure this for you and you won't need to worry about DNS or certificates.

If you are rolling your own hosting, the recommended approach is to create a DNS "wildcard" `A` record for a subdomain of your actual domain name, like `*.staging.example.com`, and configure `staging.example.com` as the `staging` value in `domains.js`. You'll also need a wildcard SSL certificate for each of staging and production.

You will later be able to set a "shortname" for each site and it will automatically work as a subdomain of all three domains. This saves a lot of configuration effort.

> In the case of production, you will of course also be able to add a final production domain name for *each* site via the user interface. But you will need a "pre-production" hostname for early content creation. That is where `baseUrlDomains` comes into play even for production.
>
> You are not restricted to the environment names `dev`, `staging` and `prod`. However, the first environment configured is assumed to be a local debugging environment for programmers (typically `dev`), and the environment named `prod` is the only one that attempts to serve a site under its `prodHostname`. If you are working with the Apostrophe Assembly team for hosting, ask us for an additional cloud instance for each environment.

### Adding a suffix to your subdomains (optional)

The `shortNameSuffix` configuration option, which defaults to an empty string, allows you to add additional suffix string to every site short name. For example, for a site with short name `cars` and the following configuration:
```js
multisite({
  // ...
  shortNameSuffix: '-assembly',
});
```
The resulting base URL for this site will be `http://cars-assembly.localhost:3000`, `https://cars-assembly.staging.your-domain.com`, etc.

These options apply only when the hostname is determined in part by the `shortName` field for the site, so if a production hostname is configured, it will be used exactly as given.

> Note that your dashboard will also be affected, the base URL would become `https://dashboard-assembly.staging.your-domain.com`

> **Note:** This option is not currently supported by Apostrophe Assembly Hosting, as we apply the naming convention for you when hosting for you. It's there for self-hosted customers with different needs.

### Changing the locale separator of your subdomains (optional)

The `localeSeparator` configuration option, which defaults to `.`, allows you to change how the subdomains for localized sites (if chosen so) will be built. By default a dot separator will be used. For example, if "Separate Host" is enabled for a particular locale, `fr.cars.your-domain.com` will be the URL of a site with the short name `cars` and the `fr` locale.
If you apply the following configuration:
```js
multisite({
  // ...
  localeSeparator: '-',
});
```
The hostname above will become `fr-cars.your-domain.com`.

This option applies only when the hostname is determined in part by the `shortName` field for the site, so if a production hostname is configured for the locale it will be used exactly as given.

> **Note:** Your configuration won't be applied immediately on the existing sites. You need to update ("touch") your site records in order to apply the changes. You can do that for all existing sites via the CLI command `node app site:touch --site=dashboard`. If you do not have the `touch` task, update the apostrophe module to the latest 3.x version.

> **Note:** This option is not currently supported by Apostrophe Assembly Hosting, as we apply the naming convention for you when hosting for you. It's there for self-hosted customers with different needs.

### Setting your Dashboard shortname (optional)

By default, your dashboard will be available on a `dashboard` subdomain - `http://dashboard.localhost:3000`, `https://dashboard.staging.your-domain.com`, etc. You can change that with the configuration option `dashboardShortName` in your `app.js`. For example:
```js
multisite({
  // ...
  dashboardShortName: 'admin',
});
```
With the setting above, the Dashboard application will be available at `http://admin.localhost:3000`, `https://admin.staging.your-domain.com`, etc.

Note that if `shortNameSuffix` is also set, the two options are combined to arrive at the complete dashboard subdomain.

> **Note:** This option is not currently supported by Apostrophe Assembly Hosting. Contact us if this is a concern for your project.

### Disabled File Key

In `sites/index.js`, locate `disabledFileKey` and change `CHANGEME` to a random string of your choosing. This is used when disabling access to files in the local backend.

### Session Secret

In `sites/index.js`, locate `secret` and change `CHANGEME` to a random string of your choosing. This is used for login session encryption.


### `/etc/hosts` File Configuration Requirements

Because this project serves multiple websites, certain hostnames must point directly to your own computer for local testing.

**If you will only be testing in Chrome at first,** you do not have to edit your hosts file right away. That's because in Chrome, all subdomains of `localhost` resolve to your own computer.

However, in other browsers this is not true and you must add the following lines to `/etc/hosts` before proceeding:

```
127.0.0.1 dashboard.localhost company1.localhost
```

**You will need a subdomain for each test site you plan to add to the multisite platform.** See the example below, where a site called `company` is added to the platform via the dashboard. You can always add more of these entries later.

## Starting Up In Development
Once you have followed the steps above you are ready to start your project up in development mode.

Type
```
npm run dev
```

When ready, visit:

```
http://dashboard.localhost:3000/login
```

> If you are on a Mac this will work without extra configuration. If you are on Linux you may need to edit `/etc/hosts` and add an entry for `dashboard.localhost`, pointing to 127.0.0.1 just like plain `localhost` does. You'll do this for each site you test locally.

You can now log into the admin account and view the basic dashboard.

To create a site, access "Sites" on the admin bar and add a new site. Notice that sites are Apostrophe "pieces" in the dashboard.

Be sure to give your first site a "shortname" which is distinct from other sites, like `company1`. Also fill out the admin password field for the site.

After you successfully save the site, you can access:

```
http://company1.localhost:3000/login
```

And log in with the admin account you created for the site. Then make some simple edits to the homepage.

Now try creating `company2` and `company3`. Notice that while the code is the same, the databases and content are separate.

> If you access these sites while logged out, you won't see your content edits unless you have used the "Commit" button to make them live.

## Scheduling tasks with Apostrophe Assembly hosting

To schedule tasks much like you would with `cron` in a single-server environment, add a new `tasks` option to `app.js` when configuring `@apostrophecms/multisite`. This option is top-level, it's a peer of the `sites` and `dashboard` options.

```javascript
tasks: {
  // These tasks are run for all sites, i.e. like the `--all-sites` option
  'all-sites': {
    hourly: [
      // Run this task hourly but only on the server that
      // happens to grab the lock first
      'products:sync'
    ],
    daily: [ ... also supported, same syntax ]
  },
  // These tasks are run for the dashboard site, i.e. like `--site=dashboard`
  dashboard: {
    hourly: [
      'some-module-name:some-task-name'
    ],
    daily: [ ... also supported, same syntax ]
  }
}
```

Note that the individual tasks are configured as strings. These strings start with the Apostrophe task name, like `product:sync`, and can optionally also include additional parameters to the task exactly as they would if you invoked it directly at the command line. You should **not** include `node app` in these strings.

Then, to test your hourly tasks in a local environment:

```javascript
node app tasks --frequency=daily
```

> ‚ö†Ô∏è VERY IMPORTANT NOTE: this will intentionally **not** run the job more than once in an hour, even if you try to test it twice in an hour. That's normal. This is a guard so that tasks scheduled on more than one of our workers actually run just once as intended.

If you need to skip that check for testing purposes, you can clear the `aposTaskLog` mongodb collection in your dashboard database. If your `shortName` is `companyname`, then your dashboard database name is `companyname-dashboard`.

## Site Development

Right now we have a bare-bones example. Let's look at where to put our code to customize the experience.

### Where Does My Apostrophe Project Code Go?

> If you are not already familiar with single-site Apostrophe development, we strongly recommend that you [read the ApostropheCMS documentation](https://apostrophecms.com/docs) as a starting point.

In a typical single-site Apostrophe project, modules are configured in `app.js`. In a multisite project, you'll find that `app.js` is instead reserved for top-level configuration that applies to all sites.

The code you're used to seeing in `app.js` can instead be found in `sites/index.js`. And, the code you're used to seeing in `modules` can be found in `sites/modules`.

In all other respects, development is just like normal ApostropheCMS single-site development. Feel free to add page templates and modules. You can `npm install` modules like `@apostrophecms/blog` and configure them in a normal way; just do it in `sites/index.js` rather than `app.js`.

If you have already started a single-site project, you can move your modules directly from `modules` to `sites/modules`, and move the `modules` section of your `app.js` file to the corresponding section of `sites/index.js`. However, take note of the existing settings we provide and merge accordingly.

> **If you are hosting your project with us, or using tools provided by us, you should remove any legacy app.js or module code that configures UploadFS cloud storage or mongodb database hosts.** Such settings are handled automatically and the configuration is set behind the scenes by `@apostrophecms-pro/multisite` and the provided logic in the starter kit.

### Themes

Apostrophe Assembly and the multisite module are designed to accommodate hundreds of websites, or more, running on a single codebase. But, you may need some differences in appearance and behavior that go beyond what the palette editor can provide. For that you can create multiple themes. Each site is set via the dashboard UI to use a single theme and will typically stay with that theme throughout its lifetime.

You might not need more than one theme. If that's the case, just build out the `default` theme to suit your needs, and remove the `demo` theme from `themes.js`. You can also remove the `sites/modules/theme-demo` module and `sites/lib/theme-demo.js`.

#### Adding a New Theme

To configure your list of themes, edit `themes.js`. Right now it looks like:

```javascript
module.exports = [
  {
    value: 'default',
    label: 'Default'
  },
  {
    value: 'demo',
    label: 'Demo'
  }
];
```

You can add additional themes as needed. Your `value` should be a shortname like `default` or `arts`. The `value` must not be changed later.

#### Custom Module Configuration for Themes

If your theme is named `default`, then you must have a `sites/lib/theme-default.js` file, like this:

```javascript
module.exports = function(site, config) {
  config.modules = {
    ...config.modules,
    'theme-default': {}
  };
};
```

The `config` object already contains what was configured in `sites/index.js`. Here we can modify the configuration by adding extra modules only for this theme, or changing the configuration of a module specifically for this theme.

In this case we add one custom module, `theme-default`, when the default theme is active. **It is a best practice to push your theme's frontend assets to Apostrophe in a module like this,** named after the theme. If your themes share any assets, then they should be imported into the appropriate `.js` or `.scss` master file by each theme.

#### Modern Frontend Assets Without A Custom Build Process

Beginning with the 1.1.0 release, there is no need for Webpack for simpler cases. Specifically, you can follow our documentation and place your modern JavaScript code in the `ui/src/index.js` file of any module, or use `import` statements in that file to import it there. As noted in our documentation, it is **important for `ui/src/index.js` to export a function as its default export.** This function will be invoked to initialize your module at a safe time when `apos.http`, `apos.util`, etc. are already available.

You may also place Sass SCSS code in the `ui/src/index.scss` file of any module, and use `import` statements in that file to bring in more Sass SCSS code.

To include theme-specific code, place it in the `ui/src/index.scss` or `ui/src/index.js` file of the appropriate theme module. The provided example theme modules are `theme-default` and `theme-alternate`.

For example:
- The default theme's SASS stylesheet entrypoint is located at `sites/modules/theme-default/ui/src/index.scss`
- The default theme's JavaScript browser-side entry point is located at: `sites/modules/theme-default/ui/src/index.js`

#### Example webpack extensions

The `theme-default` and `theme-demo` modules modify the base webpack build using the [`webpack` property](/guide/webpack.md#extending-webpack-configuration) to incorporate SCSS variables for colors and fonts. This is included to demonstrate how to set up centralized theme management with global variables in one place. They also both add a function for converting font sizes from `px` to `rem`. While this is a useful function that is used in several of the `theme-default` stylesheets, it primarily serves to illustrate how SCSS functions can be added to your project. A similar approach would be used to add in any SCSS mixins that subsequent stylesheets utilize.

The two theme modules accomplish this extension in slightly different ways. The `theme-default` extension adds all the variables and the function into a template literal block within the `additionalData` property. If you continue to use the `theme-default` module in your project and want to use the included project-level widgets, you need to keep and potentially edit this template literal block since the styling of the widgets depends on them.

The `theme-demo` module includes the variables and function by importing files from the `sites/modules/theme-demo/ui/src/scss/settings/` folder. Note that these files also need to be imported into the `sites/modules/theme-demo/ui/src/index.scss` file. This is necessary for the main webpack build to include them. If your project includes additional [SASS "partials"](https://sass-lang.com/guide/#partials) files that other stylesheets access through `@use` you will need to add them to both the `index.scss` file and in the extended webpack configuration. Again, the project-level widgets included in this starter-kit depend on the styling included in these files.

The `theme-default` module depends on only the `sites/layout.html` file to provide markup for the `@apostrophecms/home-page` page type. In contrast, the `views` folder of the `theme-demo` module has two markup files that provide additional HTML markup. The main `welcome.html` file contains a conditional block for displaying different content based on whether there is a user is logged in or not. It has a second conditional block for displaying markup from the `placeholder.html` file if no content has been added to the page. The Nunjucks template in the `sites/modules/@apostophecms/home-page/views/page.html` file conditionally adds this markup if `demo` is the selected theme. You can choose to maintain this structure and modify the `welcome.html` file, or change the `modules/@apostrophecms/home-page/views/page.html` to contain your own markup.

#### Frontend Assets With Your Own Build Process

Beginning with the 1.1.0 release, a sample webpack build is not included as standard equipment, as `ui/src` suffices for most needs. However, if you need to use webpack or another custom build process, the solution is to configure the output of your build process to be a `ui/public/something.js` file in any module in your Apostrophe project. As above you can create a build that is included in only one theme by writing its output to the `ui/src` subdirectory of that theme module.

#### Developing For IE11

With Microsoft ending Internet Explorer 11 support in 2022, we no longer enable IE11 support by default. However you can enable IE11 support by setting the `es5: true` option to the `@apostrophecms/asset` module. This will create a compatibility build of your `ui/src` JavaScript. Please note that editing is never supported in IE11. See the Apostrophe documentation for more information.

#### Serving Static Files: Fonts and Static Images

If you need to serve static files, you can do this much as you would in standalone A3 development.

The folder `sites/public` maps to `/` in the URL space of a site. For instance, `sites/public/fonts/myfile.ttf` maps to `/fonts/myfile.ttf`. For assets like favicons and fonts, you can add `link` tags to the `standardHead` block already present in `sites/modules/@apostrophecms/template/views/outerLayout.html`.

### Palette Configuration

The palette allows styles to be edited visually on the site. It is configured in `sites/modules/@apostrophecms-pro/palette/index.js`. There you can specify the selectors, CSS properties, and field types to be used to manipulate color, font size, font family and other aspects of the site as a whole.

For complete information and a sample configuration, see the [@apostrophecms-pro/palette module documentation](https://npmjs.org/package/@apostrophecms-pro/palette). *You will need to be logged into an npm account that has been granted access, such as the one you used to npm install this project.*

> Note that like all other changes, palette changes do not take place for logged-out users until the user clicks "Publish."

## Provided widgets
There are six basic widget modules located in the `sites/modules/widgets` folder of this starter kit. This supplements the core `rich-text`, `image`, `video`, and `html` widgets. They can be altered to fit the design and functionality of your project or act as a blueprint to build your own custom widgets. Both the `hero` and `column` widgets have been added to the `main` area of the `@apostrophecms/home-page`. The remainder of the basic widgets have been added to the areas of the `column` widget as described below.

If you look at the `sites/index.js` file you won't see these widget modules in the `modules` object. Instead, they are being registered using the `nestedModuleSubdirs` property. Setting this property to `true` will cause Apostrophe to register all the modules listed in the `modules.js` file of any subfolder in the project-level `sites/modules` folder. You can choose to organize any custom modules, such as grouping all of your piece-types, to keep your `modules` folder and the `index.js` file less cluttered. Note that if you choose to move any of the provided widgets out of the current folder you will need to add them to the `sites/index.js` file and remove them from the `sites/modules/widgets/modules.js` file. If you choose to keep this structure, any custom widgets you add to the folder need to be listed in the `modules.js` file.

All the styling for the supplied widgets, except for the partials added in the custom webpack extensions added in the theme modules, is located in the `ui/src/index.scss` file of each module. You can choose to maintain this structure, move the styling to another project-level module like a `sites/modules/asset/ui/src/` folder, or organize them in a different project-specific manner. Note that for them to be included in the standard webpack build, they need to be imported into a `<module>/ui/src/index.scss` file.

### `accordion-widget`
The `accordion-widget` implements an accordion element powered by the [`accordion-js` npm package](https://www.npmjs.com/package/accordion-js). You can read about additional configuration options in the documentation of that package. The module consists of a main `index.js` file with the content schema fields, plus a `views` folder that contains a `widget.html` file with the Nunjucks markup for the accordion.

Finally, there is the `ui/src` folder that contains the `index.scss` stylesheet and the `index.js` file that contains the JavaScript that is delivered to the frontend and powers the accordion using a [widget player](/guide/custom-widgets.md#client-side-javascript-for-widgets). Any custom widgets that require client-side code should be structured in this same way. Data is passed from the schema fields to the browser for use in the player script by adding it to a data attributes in the template.

### `card-widget`
The `card-widget` creates a simple card with optional image and text. The card can be made directly clickable, or can have links and buttons added. The schema fields for these elements are provided by the `lib/schema/link.js` file, which serves as a model for implementing reusable parts of widgets. These same schema fields are reused in the `hero` and `link` widgets and can be used in your custom project widgets. The markup for the links is imported into the `card-widget` template from the `sites/views/fragments/link.html` file using the [`rendercall` helper](/guide/fragments.md#inserting-markup-with-rendercall). This is present in a simpler form in the `links-widget`. Again, all your custom modules (not just widgets) can utilize fragments to replicate similar areas of markup in this same way.

### `column-widget`
The `column-widget` implements one method of adding a user-selected number of columns to a page. It uses a select field and conditional fields that restrict the number of columns based on the value of the select. Each column has an area with widgets for the `link`, `card`, and `accordion` basic widgets, plus the core `rich-text`, `image`, and `video` widgets. These are added through a shared configuration object that defines the available widgets for each column. The first column additionally adds the basic `slideshow` widget.

The widget also provides a `helper(self)` customization function that is used in the Nunjucks template. Depending on the value of the select field it returns the correct number of columns. The `helper(self)` functions can be used in your custom modules to provide computed values from data passed back from the markup.

### `hero-widget`
The `hero-widget` implements a hero element with image or color background, text and links. As stated above, this module reuses the `links.js` helper file. It also demonstrates how to use `relationship` schema fields to add an image or video for the background.

### `link-widget`
This simple widget adds either a button or inline-link. As described for the `card-widget`, It utilizes the `lib/schema/link.js` helper file and the `sites/views/fragments/link.html` fragment. Within the widget template there is a `rendercall` that passes data from the widget schema fields to the fragment.

### `slideshow-widget`
The `slideshow-widget`, much like the `accordion-widget`, utilizes client-side JavaScript. For this widget the `ui/src/index.js` is adding the [`swiper.js` package](https://swiperjs.com/) to the player.

## Dashboard Development

**The dashboard site has one job: managing the other sites.** As such you don't need to worry about making this site a pretty experience for the general public, because they won't have access to it. However you may want to dress up this experience and add extra functionality for your own customer admin team (the people who add and remove sites from the platform).

This starter kit has the `@apostrophecms-pro/multisite-dashboard` extension installed. This converts the dashboard from sites being presented as individual cards to a scrollable list. Each site now has a link for login to the site, as well as navigation to the home-page. This extension also creates a search box that makes finding sites easier. Finally, this extension also adds a template tab to the site creation modal. When creating or editing a site you can select to make it a template by clicking on "Template" control in the "Basics" tab. This will still be an active site, but it will be moved to the template tab. Sites in the template tab can be duplicated by selection that option in the context menu to the far right.

The dashboard site can be extended much like the regular sites. Dashboard development is very similar to regular site development, except that modules live in `dashboard/modules`, what normally resides in `app.js` lives in `dashboard/index.js`, and so on.

The most important module is the `site` module. The `site` module is a piece type, with a piece to represent each site that your dashboard admins choose to create. This module is registered through the `@apostrophecms-pro/multisite-dashboard` extension and can be extended at the project level by creating a `dashboard/modules/@apostrophecms-pro/site` folder and placing your code there. This is the [standard method](/guide/modules.md) for extending any package at project level.

The `site` schema field values get passed to the individual sites in the `site` object. This is what is used to set the theme configuration in the `sites/index.js` file. The starter kit is also adding the value of the `theme` schema field to the `apos.options` object.

```
// sites/index.js
module.exports = function (site) {
  const config = {
    // Theme name is globally available as apos.options.theme
    theme: site.theme,
    ...
```

If you have additional values being passed from the `site` piece schema that you want to make available to your modules you have several choices. The value can be added in the modules config options in the `sites/index.js` file.

```javascript
// sites/index.js
module.exports = function (site) {
  const config = {
    // Theme name is globally available as apos.options.theme
    theme: site.theme,
    nestedModuleSubdirs: true,
    modules: {
      'commerce-page': {
        options: {
          apiKey: site.apiKey,
        }
      },
      ...
```
You can also elect to add them to the `apos.options` object, as is shown above example for the `site.theme`. This can then be accessed in any module function with access to `self` using `self.apos.options.<property>`. If you need that value in your templates you can use the [`templateData` module option](/reference/module-api/module-options.md#templatedata).
### Allowing dashboard admins to pass configuration to sites

You can add custom schema fields to `sites` and those fields are available on the `site` object passed to `sites/index.js`, and so they can be passed on as part of the configuration of modules.

However, there is one important restriction: you **must not decide to completely enable or disable a module that pushes assets on any basis other than the theme name.** This is because Apostrophe builds only one asset bundle per theme.

**"Should I add a field to the `site` piece in the dashboard, or just add it to `@apostrophecms/global` for sites?"** Good question! Here's a checklist for you:

* **If single-site admins who cannot edit the dashboard should be able to edit it,** you should put it in `sites/modules/@apostrophecms/global`.
* **If only dashboard admins who create and remove sites should be able to make this decision,** it belongs in `dashboard/modules/site/index.js`. You can then pass it on as module configuration in `sites/lib/index.js`.

## Accessing the MongoDB utilities for a specific site

The database name for a site is the prefix, followed by the `_id` of the site piece. However this is awkward to look up on your own, so we have provided utility tasks to access the MongoDB utilities:

```
# Mongo shell for the dashboard site
node app mongo:mongo --site=dashboard
# Mongo shell for an individual site; use its hostname
# in the appropriate environment
node app mongo:mongo --site=test1.localhost
# mongodump
node app mongo:mongodump --site=test1.localhost
# mongorestore, with the --drop option to prevent
# doubled content
node app mongo:mongorestore --site=test1.localhost -- --drop
```

Note the use of `--` by itself as an end marker for the options to Apostrophe, allowing the `--drop` option to be passed on to `mongodump`.

## Hosting

Hosting for staging and production clouds is typically provided by the Apostrophe Assembly team.

Self-hosted arrangements can also be made. For more information contact the Apostrophe Assembly team.

## Deployment

If we are hosting Apostrophe Assembly for you, then you can deploy updates to your staging cloud by pushing to your `staging` git branch, and deploy updates to your production cloud by pushing to your `production` git branch. You will receive notifications in our shared Slack channel, including links to access the deployment progress logs.

Apostrophe will complete asset builds for each theme, as well as running any necessary new database migrations for each site, before switching to the newly deployed version of the code.

## Profiling with OpenTelemetry

ApostropheCMS supports profiling with OpenTelemetry. There is an [article in the documentation](/cookbook/opentelemetry.md) covering the use of OpenTelemetry in general. Launching Apostrophe Assembly with OpenTelemetry support is slightly different. However for your convenience, `app.js` and `telemetry.js` are already set up appropriately in this project.

To launch in your local development environment with OpenTelemetry logging to Jaeger, first [launch Jaeger according to the instructions in our documentation](/cookbook/opentelemetry.md). Then start your Apostrophe Assembly project like this:

```
APOS_OPENTELEMETRY=1 npm run dev
```

This provides a great deal of visibility into where the time is going when Apostrophe responds to a request. Note that separate hosts can be distinguished via the `http.host` tag attached to each request in Jaeger.

Using OpenTelemetry in a staging environment provided by the Apostrophe team is possible. This involves modifying the provided `telemetry.js` file to log to a hosted backend such as [New Relic](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-introduction/) using an appropriate Open Telemetry exporter module. `process.env.ENV` can be used to distinguish between `dev` or no setting (usually local development), `staging` and `prod` when decidig whether to enable an OpenTelemetry backend.

We do not recommend enabling OpenTelemetry in production, at least not permanently, because of the performance impact of the techniques OpenTelemetry uses to obtain the necessary visibility into async calls.

## Self-hosting and the sample Dockerfile

A sample `Dockerfile` is provided with this project and can be used for self-hosting. See also the provided `.dockerignore` file.

Typical `build` and `run` commands look like:

```bash
# build command
docker build -t apostrophe-assembly . \
  --build-arg="NPMRC=//registry.npmjs.org/:_authToken=YOUR_NPM_TOKEN_GOES_HERE" \
  --build-arg="ENV=prod" --build-arg="APOS_PREFIX=YOUR-PREFIX-GOES-HERE-" \
  --build-arg="DASHBOARD_HOSTNAME=dashboard.YOUR-DOMAIN-NAME-GOES-HERE.com" \
  --build-arg="PLATFORM_BALANCER_API_KEY=YOUR-STRING-GOES-HERE" \
  --build-arg="APOS_S3_REGION=YOURS-GOES-HERE" \
  --build-arg="APOS_S3_BUCKET=YOURS-GOES-HERE" \
  --build-arg="APOS_S3_KEY=YOURS-GOES-HERE" \
  --build-arg="APOS_S3_SECRET=YOURS-GOES-HERE"

# run command
docker run -it --env MONGODB_URL=YOUR-MONGODB-ATLAS-URL-GOES-HERE apostrophe-assembly
```

To avoid passing the real MongoDB URL to the build task, currently the provided Dockerfile uses a
temporary instance of `mongod` to satisfy a requirement that it be present for the build task.

An npm token is required to successfully `npm install` the private packages inside the
image during the build.

S3 credentials are passed to the build so that the static assets can be mirrored to S3, however
at a cost in performance this can be avoided by removing `APOS_UPLOADFS_ASSETS=1` from
the `Dockerfile` and removing the references to these environment variables as well. Note
that you will still need S3 credentials in the `run` command, unless you arrange for
`dashboard/public/uploads` and `sites/public/uploads` to be persistent volumes on a
filesystem shared by all instances. This is slow, so we recommend using S3 or configuring
a different [uploadfs backend](https://github.com/apostrophecms/uploadfs) such as
Azure Blob Storage or Google Cloud Storage.

## Localized domain names

Dashboard administrators can define the locales for each site from the `locales` tab of the site editor modal. This is turned on by default with the `localizedSites` option of the `site` module set to `true`.

You can add as many locales as you want via the `locales` tab, and for each of them you can give it a name, label, prefix, choose if you want a separate host, and if so, set a separate production hostname.

If the separate host is set to `true`, the locale will be used as a subdomain of the domain name
in addition to the separate production hostname if that field has been filled out and DNS has been configured for it.
There is now also `stagingSubdomain` to allow a free choice of staging subdomain name,
for those who want to test the effects of `separateProductionHostname` being set the same for any group of sites in advance.

Let's say we have a French locale with these options:

| Fields                       | Values               |
|------------------------------|----------------------|
| Label                        | `French`             |
| Prefix                       |                      |
| Separate Host                | `true`               |
| Separate Production Hostname | `my-french-site.com` |


And our site piece `shortName` is set to `site`.

In this case, if the environment variable `ENV` is set to `staging`, we will have `fr.site.staging.com` as the hostname.
If we are in production, so `ENV` is set to `prod`, we will have `fr.site.production.com` and `my-french-site.com` (only in production) as hostnames.

If we set a prefix, such as `/fr`, then only URLs in which the path part begins with `/fr` will display content from that locale. This way some locales can share the same `separateProductionHostname` being differentiated by the prefix.

If `separateHost` is set to `false` and `prefix` is `/fr`, we simply use the latter to differentiate locales: `site.localhost:3000/fr`, `site.staging.com/fr`, `site.production.com/fr`.

Note that you can have only one locale with no prefix _and_ no separate host, that would be the default one.

## Private locales

You can make a locale `private`, meaning that this locale is only visible for logged in users.

There is a new `boolean` field with the label `Private Locale` for each configured locale in your dashboard.

When adding the option `localizedSites` to the `site` module of your project, instead of `true` you can pass an object and specify the option `privateByDefault`.
If this sub-option is set to `true`, every new locale created will have its `private` property set to `true` by default, otherwise they will be public by default.

```javascript
// in dashboard/index.js
const themes = require('../themes');
const baseUrlDomains = require('../domains');

module.exports = {
  privateDashboards: true,
  modules: {
    // other dashboard modules
    '@apostrophecms-pro/multisite-dashboard': {},
    site: {
      options: {
        themes,
        baseUrlDomains,
        localizedSites: {
          privateByDefault: true
        }
      }
    },
    'site-page': {},
  }
};

```

The `private` option will be editable from the dashboard when editing your site locales.

================================================================================
COLLECTION: tutorials
NAV_PATH: Tutorials Home
DOC_PATH: tutorials/index.md
URL: https://apostrophecms.com/docs/tutorials/
================================================================================
# Tutorials

Step-by-step tutorials that go beyond the technical explanations in our Guide or Reference sections. Explore real-world implementations, from full project builds to focused how-tos, designed to help you get hands-on with ApostropheCMS.

<AposTwoColumns>
  <template #leftColumn>
    <AposCtaButton
      detail-heading="Series"
      title="Intro to ApostropheCMS"
      content="Dive into ApostropheCMS with a hands-on tutorial series. We'll guide you step-by-step through crafting your first website, exploring fundamental concepts and practical implementations."
      url="/docs/tutorials/introduction.html"
      hideEffort="true"
    />
  </template>
  <template #rightColumn>
    <AposCtaButton
      detail-heading="Astro"
      title="ApostropheCMS & Astro"
      content="ApostropheCMS and Astro work seamlessly together through the `apostrophe-astro` extension. Learn who this integration is for and what makes it a powerful choice for building modern websites."
      url="/docs/tutorials/astro/introducing-apollo.html"
      hideEffort="true"
    />
  </template>
</AposTwoColumns>
<AposTwoColumns>
  <template #leftColumn>
    <AposCtaButton
      detail-heading="Collection"
      title="Recipes"
      content="Practical, standalone tutorials for solving specific challenges in ApostropheCMS. These recipes range from simple tips to advanced patterns and can be filtered by topic to match your needs."
      url="/docs/tutorials/recipes.html"
      hideEffort="true"
    />
  </template>
  <template #rightColumn>
    <AposCtaButton
      detail-heading="Collection"
      title="Pro Topics"
      content="In-depth tutorials for teams using ApostropheCMS‚Äôs commercial modules and advanced capabilities. These guides support complex implementations, from multisite setups to enterprise-grade integrations and workflows."
      url="/docs/tutorials/pro.html"
      hideEffort="true"
    />
  </template>
</AposTwoColumns>

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS
DOC_PATH: tutorials/introduction.md
URL: https://apostrophecms.com/docs/tutorials/introduction
================================================================================
# Welcome to our ApostropheCMS Web Development Series

<iframe src="https://www.youtube.com/embed/WaA-3zwKO0Y?si=bKzaJx2xUGsFM8z2" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the video and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

We're thrilled to guide you on this explorative journey through the ApostropheCMS ecosystem. Our goal with this series of tutorials is to provide a robust foundation to comprehend and harness the power of ApostropheCMS effectively.

Throughout this tutorial, we will incrementally construct a sample website using the Apostrophe  Essentials starter kit. This website will be similar to the [Consumer Reports](https://www.consumerreports.org/) site and provide a wealth of opportunities to learn about the essential elements of ApostropheCMS pages, pieces, templates, and components. Please note that this project is designed as a learning tool, rather than a ready-to-use template for your individual projects.

We have structured this project into distinct sections, each focusing on a specific building block of ApostropheCMS. These sections are interdependent, often expanding or refining the code from the preceding ones. However, the code from each tutorial can act as the basis for custom modules in your own project and be used as practical examples alongside our guide and reference material.

To help guide you along your development journey, the finalized code for this project can be found on the `main` branch of our [GitHub project repository](https://github.com/apostrophecms/apostrophe-onboarding-project). The repository also includes a database with sample content and images. You'll find the repo is organized into branches that correspond to specific tutorials. For a smoother experience and additional details on how to use the project repository, please take a look at the [README](https://github.com/apostrophecms/apostrophe-onboarding-project?tab=readme-ov-file#readme) file for that repository. While you can certainly refer to the completed code, we encourage you to try building the project yourself for a more valuable learning experience.

## **Summary of what we are covering per section**

### Code Overview

Before digging into custom code creation, we are going to spin up a new project using the Essentials starter kit and take a look at code organization in Apostrophe. We'll examine how core modules are improved and organized, but also how to organize project-specific modules and extend the core modules in your custom code. This section will also touch briefly on some of the initialization and customization functions that are available to us to help build a custom web experience.

### Pages

![Screenshot of the index.js and view.html code of the home page](../images/sec2-1-pages-comp.jpg)

Our journey begins with a key component of any website, pages. As we start building our product review site, we'll develop a landing page, category-specific pages, and individual product pages. One of the standout features of ApostropheCMS is its ability to programmatically generate a multitude of sub-pages from a single template. This means you can focus on crafting one exemplary template, and ApostropheCMS will do the heavy lifting of creating numerous sub-pages, eliminating the need to write additional code for each page.

Now, let's delve into the specific topics from the ApostropheCMS documentation that we'll be addressing in this section:

- **Introduction to the Module Schema:** We'll start with an overview of schema fields. [Schemas](/guide/core-concepts.html#schemas) in Apostrophe are a powerful tool to structure your data, allowing you to specify the types of content your users can add or edit. 

- **Incorporating Areas and Built-in Widgets:** Next, we'll introduce you to 'areas', a flexible content container that can include various types of widgets. We will start by utilizing several of the widgets that come built-in with Apostrophe and understanding how we can pass them per-page options.

- **Mastering the Main Layout Template:** As we dive deeper, you'll get acquainted with the main layout template in ApostropheCMS, which provides the structure for your site's appearance. We will look at how we can add content and extend common areas, such as the page head and main body.

- **Per-Page Templates:** Moving further, you'll learn about per-page templates that allow for more customization and flexibility in managing the layout and content of individual pages.

- **Exploring Nunjucks Filters:** We'll introduce you to Nunjucks filters, a versatile tool to manipulate, sanitize, and display data on the front end. 

- **Understanding Localization:** Even though we'll take a deeper dive into localization later in the tutorial, we'll touch on it in this section. We'll discuss how to manage both static strings and dynamic content for multi-language support.

- **Getting Started with Fragments:** Last but not least, we'll cover fragments and the use of global settings, which can be used to populate commonly used elements like footers or headers across your website. 

As we journey through these topics, you'll gain a solid understanding of how ApostropheCMS handles pages, preparing you for more complex topics in the tutorials ahead.

## Adding project assets

![screenshot of the project asset folder and files](../images/sec2-1-assets.jpg)

Diving deeper into our journey with ApostropheCMS, we now arrive at a critical aspect of web development - incorporating CSS, font files and JavaScript assets. This process is crucial to both the look and functionality of your website, so it's essential to understand how ApostropheCMS version 3 manages these assets.

Let's unpack the specific topics we'll cover in this section:

- **Location of Asset Files:** First, we'll explain where to place your CSS and JavaScript files that will be used site-wide, or on a per-module basis. This is handy for adding site-wide styling, fonts, and analytics scripts.

- **Webpack Options:** We'll discuss how ApostropheCMS leverages Webpack, a powerful module bundler. We will also cover adding assets to your page that will not be processed by the normal Webpack build process.

- **Understanding the 'public' Folder and Relative URLs:** Finally, we'll delve into the role of the `public` folder and how it plays a part in the deployment of your website. We will touch on the topic of adding static assets, like logo images, and accessing these assets from your ApostropheCMS templates using relative URLs.

By the end of this section, you will be adept at handling CSS and JavaScript assets in the ApostropheCMS ecosystem.

## Crafting Widgets

![screenshot of row widget index.js and widget.html files](../images/sec2-1-widget-comp.jpg)

As we continue to deepen our understanding of ApostropheCMS, our next venture is into the realm of widget creation. In this tutorial, we will breathe life into our website by developing several custom widgets that will revamp our page layouts and offer new avenues for content management.

Let's look at the exciting array of widgets we'll be creating:

- **Row Widget:** This handy widget will empower editors to insert rows with varying column structures on the page, adding a new layer of flexibility to your layout design.

- **Deal Widget:** This versatile widget will allow editors to insert links to special pages such as e-commerce pages or affiliate links, creating an opportunity to generate additional revenue and promote strategic partnerships.

- **Rating Widget:** Last but not least, our rating widget will let editors incorporate the overall ratings for a product from the review site, providing a quick, at-a-glance summary for your visitors. This widget will also allow readers to provide their own feedback and will introduce database manipulation.

Now, let's examine the specific topics from the ApostropheCMS documentation that we'll cover in this section:

- **Frontend and Backend Code in Modules:** We'll kick things off by outlining where to place the frontend and backend code within our modules, helping you maintain an organized codebase.

- **Using Attributes to Pass Data to JavaScript "Players":** We'll explore how you can pass data into JavaScript "players" using attributes. This technique is invaluable when you need to access server-side data within your client-side code.

- **Adding User Input to the Database:** We'll look at how you can listen for User submissions from front-end code using `apiRoutes()` and save those submissions to the database.

By the end of this tutorial, you'll have the skills to create a range of dynamic widgets, transforming your website into an interactive and engaging platform.

## Crafting Pieces

![screenshot of piece index.js and widget html files](../images/sec2-1-pieces-comp.jpg)

As we proceed with our ApostropheCMS journey, our next pit-stop is the creation of 'Pieces', flexible and powerful building blocks for content in ApostropheCMS. In this tutorial, we will create a 'review' piece that Editors can use to add their review articles. As covered in the [core concepts](/guide/core-concepts.html#pieces) section of our documentation, pieces are used for any content that can be potentially used in multiple places on a website, like blog articles. Our review piece will include an image attachment, a space to write the review, and a rating widget for input from both the content creators and the content consumers.

Once we've built our review piece, we will explore how to generate pages to display all or selected reviews, and learn how to feature chosen reviews on our home page using widgets and relationships.

Here's what we'll unpack from the ApostropheCMS documentation in this section:

- **Expanding Knowledge of the Content Field Schema:** We'll delve deeper into the content field schema. You'll learn about using the attachment field to allow users to upload files or images directly to your pieces.

- **Reusable Content with Pieces:** We will highlight the power of pieces in creating reusable content, allowing you to maintain consistency while saving time and effort in managing your site's content.

- **Understanding Show and Index.html Pages:** You'll learn about the role of `show.html` and `index.html` pages in rendering individual pieces and a directory of pieces, respectively.

- **Introduction to Pagination / Browsing a Directory of Pieces:** We'll explore how ApostropheCMS handles pagination, enabling users to conveniently browse through a directory of pieces.

- **Displaying Pieces with Widgets:** We will cover how to showcase the pieces you've created on your website with widgets, allowing for dynamically updating content across your site.

- **Using Relationships to Display Pieces:** We'll modify our footer to display links to specific reviews leveraging the `relationship` field, and further exploring the use of fragments.


By mastering the creation of pieces and their applications, you'll gain more control and flexibility in managing and displaying content on your website.

## Implementing Navigation

![screenshot of pagetree generated navigation](../images/sec2-6-pagetree-nav.png)

As we continue our ApostropheCMS journey, our next milestone is adding navigation to our site. In this tutorial, we'll explore various strategies for creating navigation and select one to implement on our pages. We'll delve into the data that's automatically available to templates, provide an introduction to the page tree concept, and revisit how to add data to the global module. Additionally, we'll touch on `array` and `relationship` schemas, and their application in creating dynamic navigation.

Here's a glimpse of the specific topics from the ApostropheCMS documentation we'll cover in this section:

- **Understanding 'Array' Schema and 'Relationship' Fields:** We'll delve into the `array` schema and `relationship` fields, both crucial tools in ApostropheCMS for managing collections of data. We'll discuss the various options available in the `array` schema and how `relationship` fields can be used to establish connections between pieces of content.

- **Data Available to Every Page:** We'll discuss the data variables that are available to all page templates in ApostropheCMS. These include:
  - `data.home`: This variable holds the home page document, allowing you to access its properties.
  - `data.home._children`: This gives you an array of the home page's immediate child pages, useful for creating top-level navigation.
  - `data.page._ancestors`: This array includes the current page's ancestor pages, useful for breadcrumbs and hierarchical navigation.
  - `data.page._children`: Similar to `data.home._children`, this variable gives you the current page's immediate child pages.

By mastering navigation, you'll empower users to explore your site with ease, improving their experience and engagement.

## Refining the Admin Bar

![Screenshot of the admin bar with the 'Personal Settings' modal open](../images/sec2-1-navigation-comp.png)
In the next leg of our ApostropheCMS journey, we'll focus on modifying the admin bar. The admin bar in ApostropheCMS serves as the primary interface for editors, enabling them to create new pieces and pages, manage media files, and handle user roles and permissions. Additionally, it offers access to global configuration settings, locale selection and the personal settings menu. One of its crucial functions is managing the document publication workflow, providing notifications to users with appropriate permissions about documents awaiting approval.

In this tutorial, our aim is to streamline the admin bar to enhance the process of adding content to pages. We'll also touch on the process of adding custom buttons to further customize your ApostropheCMS experience.

Let's delve into the specific topics we'll cover from the ApostropheCMS documentation:

- **Grouping Items:** We'll begin by organizing the admin bar items into logical groups. This can enhance usability and navigation, making it easier for editors to find the tools they need.

- **Adding to the Context Menu:** We'll explore how to add new items to the context menu, allowing you to customize the options available to your editors based on your specific project requirements.

- **Adding a Button:** We'll walk you through the process of adding a custom button to the admin bar and setting up listeners. This can be used to create dynamic responses to user actions, enhancing the interactivity of your CMS.

- **Customizing the Personal Settings Menu:** Finally, we will take a look at customizing the personal settings menu. This menu can be set-up to allow editors to change their password and language preferences. We will also look at how to add additional functionality to this menu.

By the end of this tutorial, you'll be adept at modifying the admin bar, tailoring it to best suit the needs of your editors.

## Adding Optional Extensions

![Adding and using the SEO extension](../images/sec2-1-extensions-comp.jpg)

In our continuing journey to unlock the full potential of ApostropheCMS, the next step involves incorporating optional extensions into our project. In this tutorial, we'll add two incredibly useful extensions ‚Äî `SEO` and `Blog`. We will demonstrate the steps for integration, and we'll also dissect the structure of these extensions, shedding light on the `bundle` option. Gaining an understanding of this concept is useful for creating and publishing reusable modules that can be used for multiple projects.

Let's highlight the specific topics we'll unpack from the ApostropheCMS documentation in this tutorial:

- **Exploring the Extensions Section:** We'll kick off by introducing you to the extensions section of ApostropheCMS.com. This part of the site is a treasure trove of functionalities that can greatly enhance your project.

- **Understanding 'Bundle' and 'Bundles' Options:** We'll delve into the 'bundle' and 'bundles' options, which allow you to group related modules. Bundles make it easier to maintain, share, and reuse collections of modules across multiple projects.

- **Leveraging Module Options:** Lastly, we'll explore module options, which allow you to configure the behavior of your modules. Understanding these options is critical to building powerful, customized experiences with ApostropheCMS.

By the end of this tutorial, you'll be adept at incorporating and understanding the structure of extensions, taking another significant step in mastering ApostropheCMS.

## Next Steps
Having introduced you to the foundational building blocks of an ApostropheCMS project in this tutorial, we're primed to delve deeper into how to effectively organize your code. Understanding how to properly structure your code is essential for both the development process and for the ongoing management of your project. Additionally, it is important to understand how to configure and modify modules from the core Apostrophe package at project-level, and where code for your project-specific modules should be placed. In the upcoming tutorial, we will explore the recommended practices and structures for organizing code in ApostropheCMS. Let's get started!

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS > Organizing Your Code
DOC_PATH: tutorials/code-organization.md
URL: https://apostrophecms.com/docs/tutorials/code-organization
================================================================================
# Overview of Apostrophe code organization

<iframe src="https://www.youtube.com/embed/yd9HV5JNqLw?si=kCgnQ6cV4noHzJJV" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This video is available in textual and video forms. Watch the video and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

In this tutorial, we'll initialize our project with the Apostrophe Command Line Interface (CLI) tool. After creating our project we'll delve into its organization, focusing on the fundamental modules and files that comprise the Essentials starter kit project. We'll also revisit the concept of module inheritance, which was introduced in the first section. Lastly, we'll explore the application of `nestedModuleSubdirs` as an optional approach to reorganizing our project. While you will be creating this project locally using the CLI tool, you can also clone the [GitHub repo](https://github.com/apostrophecms/apostrophe-onboarding-project) and checkout branch `sec2-1b`.

## Creating our project

We're going to assume that you have already set your development environment up and installed the CLI tool. To create a new project, simply open your terminal (for Windows, make sure to open the terminal in WSL) and navigate to the location where you want to install your project. Then issue the command:

```sh
apos create onboarding-project --starter=essentials
```

You can give the project whatever name you desire in place of 'onboarding-project', just make sure that all projects using the same MongoDB instance have a unique name, as this will also be used as the database name where all of our project collections will be stored. With this command, we are specifying the `essentials` starter kit by using the optional `--starter` flag. If this flag is left off, the Essentials starter kit will be installed by default. You can explore our [website](https://apostrophecms.com/starter-kits) for additional starter kits.

The CLI tool will create a new folder with the name of the project containing a number of files and folders, including an `app.js` file with the name of the project added as the `shortName`, and a `package.json` file for installing all the project dependencies. Then it will perform a package install.

After installation is complete, it will issue a command line task to add a user with `admin` permissions and ask for a password.

```sh
node app @apostrophecms/user:add admin admin
```

This command is running the `add` task of the `@apostrophecms/user` module. Many of the core Apostrophe modules have tasks that you can run from the command line. You can use this same task to add users with permissions of 'editor', 'contributor', or 'guest', in addition to 'admin'.

```sh
node app @apostrophecms/user:add <user-name> <user-role>
```

## Essentials starter kit organization

![screenshot of the Apostrophe boilerplate directory structure](../images/sec2-1b-directory.png)

### `app.js`
At the root level of your project is the `app.js` file. This file is used to register any modules that are being used in the project. It can also be used to initialize other services that should be started when the project spins up, for example, [site telemetry](/cookbook/opentelemetry.html). You can pass some configuration options, like class names for core widgets, but most options should be passed in the individual module files. At the top of the file there is a `shortname` property. Again, this determines the database name that will be used and should be unique within a MongoDB instance to avoid overwriting another project's content. If you use our CLI this shortname is automatically set to the name you pass as an argument to the `apos create` command. If you elect to clone a project from a repo, you will need to change this manually.

### `views`
Also at the root of your project is the `views` folder. This folder contains the main page layout file, `layout.html`, that you extend within your other page modules. We will get into the details of this in the ["Creating Pages"](/tutorials/pages.html) tutorial. This folder can also be used for project-wide template "fragments". We will be using fragments to construct both the header and footer sections of our page.

### `modules`
The modules folder is where you will add all of your project-specific modules. Within the `modules` folder, there are three additional folders in the essentials project.

![screenshot of the open modules folder](../images/sec2-1b-modules-folder.png)

The topmost of these is the `@apostrophecms` folder. Any modules in this folder will implicitly `improve` the core Apostrophe module of the same name. Any module which then uses `extend` with that core module will also have access to these improvements. We will come back to `improve` and `extend` later in this tutorial and you can read more in our [documentation section](/guide/module-configuration-patterns.html). From within your project, you can see what modules are part of core by navigating to the `node_modules/apostrophe/modules/@apostrophecms` folder. *Note*: there can be a `node_modules/@apostrophecms` folder. This is used for additional extensions (like the `@apostrophecms/blog` extension) added from your package manager, not for the core modules. As a rule, you should never touch anything in `node_modules`, unless your goal is to publish your own module to npm to share it with the world. Typically, your workflow in that circumstance would be to work on your module in a separate repository that is either symlinked or installed into the `node_modules` folder, rather than working on the code within your ApostropheCMS project.

Drilling down in the `@apostrophecms` folder we can see that there are four modules. We will cover the `home-page` and `page` module folders in the next tutorial. In the `express` folder, you should now set the session secret to a unique, random string. This is required by Express.js to sign the session ID cookie.

We will touch on the other two folders within `modules/`, `asset` and `default-page` in later tutorials.

### `package.json`

![boilerplate package.json code](../images/sec2-1b-package.png)
As with all Node.js apps, the `package.json` file plays a vital role in managing Apostrophe projects. It allows developers to define and control project dependencies, set up custom scripts for various tasks, and provide essential information about the project. In the case of the Apostrophe essentials starter kit, it sets up several useful scripts that we use to build and run our project. You will end up using `npm run dev` quite a bit during local development!

### `public`
The `public` folder can be used for static assets, although this isn't always the best solution because using cloud storage for other assets will break relative URLs and updating the asset won't cause a cache refresh. However, this folder is used by the Apostrophe default build process to store the various CSS and JS bundles.

### `data`
To decrease build time webpack creates a cache file that is stored within the data folder. When customizing the admin UI, this caching behavior can cause problems. If you find that elements aren't updating after code changes as expected you can try eliminating the `data` folder using `rm -rf data`. You can try eliminating the `apos-build` folder that is generated during the build step, as well. These folders will regenerate the next time you bring the project up.

### `lib`
The 'lib' folder is completely optional but typically contains code that is shared across different parts of the project or provides functionality that is not directly related to the main application logic. These files often consist of utility functions, helper classes, or custom modules that encapsulate reusable code. In the essentials project it contains a single file, `area.js`, that can be used for configuring page areas. We will revisit this in the ["Creating Pages"](/tutorials/pages.html) tutorial.

### `deployment` and `scripts`
The `deployment` and `scripts` folders house bash scripts that are primarily used internally by the Apostrophe team for the deployment of sites and cloning of the project's database for local development. In most cases, you are going to want to eliminate these folders and implement your own solutions, but they provide good examples of how to accomplish these tasks.

## Module basics

As introduced in the [Core Concepts](/guide/core-concepts.html#modules) section of the documentation, in Apostrophe each module is responsible for providing one feature, such as a type of widget, a type of customized page, or a service. All the modules use the same API. This means that they all have access to a number of core features.

### Creation

``` javascript
// modules/blog-post/index.js
module.exports = {
  // ...
}
```

The CLI tool provides an easy way to make piece, widget, and generic modules for your project.

``` sh
apos add widget article
```

The `add` command takes the type of module to be created (`piece`, `widget`, or `module`) and a name for the module. For a widget module, it will automatically add the correct ending. So for this example it would create a folder named `article-widget`. You can also pass an optional flag of `--page` when creating a `piece`. This will set up the folder and files for your views that we will be talking about in the [Creating Pieces](/tutorials/pieces.html) tutorial. When adding a `widget` you can pass the optional `--player` flag. This will create the folder and file structure for adding browser-side JavaScript to your widget that we will talk about in the [Creating Widgets](/tutorials/widgets.html) tutorial.

Making a new module from scratch is fairly easy. A basic module in Apostrophe consists of a folder that is named for the module being created, so `default-page`, or `column-widget`. Modules that create pages are typically appended with `-page` and those that create widgets with `-widget`. Within that folder, at minimum, there needs to be an `index.js` file that has a `module.exports` object. That object will contain code to configure and power the functionality of that module. As we will cover in additional tutorials, the module folder can also contain additional folders that can be used to deliver style sheets and JavaScript to the front end, create new Admin UI components, and more.

```javascript
// app.js
require('apostrophe')({
  shortname: 'onboarding-project',
  modules: {
    // ...
    'blog-post': {}
  }
})
```
In addition to adding this folder to your project `modules` folder, the new module must also be registered in the `app.js` file. To do this you just add a new property to the `modules` object, with the module name as a key and configuration object as value. For most modules, all the configuration takes place in the actual module, so an empty object is passed. Order is important here. Modules will be instantiated in the order they are added in the `modules` object. Assets included with each module will be bundled according to this order.

### Inheritance

```javascript
// modules/blog-post/index.js
module.exports = {
  extend: `@apostrophecms/piece-type`
  // ...
}
```

Module inheritance is an important concept in Apostrophe. Most of the modules in your project will `extend` a core Apostrophe module. For example, a module to create a new piece type will extend the `@apostrophecms/piece-type` module. Your custom piece module creates a new instance of the core module with a different name, inheriting all the methods and tasks of the original. You can also extend any custom module in your project. Just make sure that the new custom module is instantiated in the `app.js` file *after* the base module you are extending.


You might also have modules in your project that `improve` the core modules. Unlike extending a module, when you improve another module, you are not creating a module with a new name, but rather adding some functionality to the original. Any module that then extends the original will also have access to any improvements from the custom module. It is important to note that only modules installed into your project as packages, either through symlinking a local repo or installing from a package repository, can be improved.

### Configuration

```javascript
// modules/blog-post/index.js
module.exports = {
  extend: `@apostrophecms/piece-type`
  options: {
    alias: 'blog',
    label: 'Blog Article'
  }
  fields: {
    add: {
      blogTitle: {
        type: 'string',
        label: 'Enter your blog title'
      }
    },
    group: {
      blogFields: {
        label: 'Blog',
        fields: [ 'blogTitle' ]
      }
    }
  }
}
```

Depending on the type of module you can add a variety of `options` and `fields`. The `options` configuration object can allow you to set a label for your module that is shown to the editor or turn on localization. We will be covering these options as we dive into further tutorials.

The `fields` configuration option lets you add and group schema fields that determine what content an editor can add in your piece or page. In the ["Creating Pages"](/tutorials/pages.html) tutorial, we will begin to look at schema fields in more detail. In this code example, we are passing an object to the `fields` key, however this key can also take a function with `self` and `options` as arguments that returns the object. This is covered in our [documentation](/reference/module-api/module-overview.html#fields). This allows you to further customize what content can be added and will be covered further in the [Adding Extensions](/tutorials/adding-extensions.html) tutorial.

### Customization

Each module can take multiple initialization and configuration functions. We will just cover a couple of the most essential ones in this tutorial. Some of the other functions will be touched on during this tutorial series, but to see the full list take a look at the [documentation](/reference/module-api/module-overview.html).

### `async init(self)`

This function runs only once during application startup. You can access any options or methods that are defined in the module through `self`. You can also run functions that are defined in other modules using `self.apos.modules['abc'].function()` where `abc` is the name of the other module. Note that we can add an `alias` option to the `abc` module to shorten this to `self.apos.abc`.

### `methods(self)`

This adds methods that can be invoked within the module or from other modules. It returns an object of functions. We will be utilizing this in several areas of our on-boarding project.

### `components(self)`

You can use this function to power asynchronous template components. This allows for making async data requests at the time of template rendering. We will make use of it in our project to query the database for the most recently published review article.

### `handlers(self)`

This function allows you to listen for events emitted by core Apostrophe and custom modules and then trigger an action based on that event. For example, you could send an [outgoing webhook](/cookbook/creating-webhooks.html#outgoing-webhooks) anytime a new article is published.

## Next steps
In this tutorial, you learned a little more about the basics of Apostrophe code organization. We will apply this knowledge throughout the rest of this tutorial series. Next, we will begin constructing our review site homepage.

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS > Creating Pages
DOC_PATH: tutorials/pages.md
URL: https://apostrophecms.com/docs/tutorials/pages
================================================================================
# Page Creation

<iframe src="https://www.youtube.com/embed/3Ojv9v36zfk?si=X7ZVJ7RzK5v1TTit" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the videos and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

In an Apostrophe project, pages provide a way to show static content, as well as dynamic content delivered by both widgets and pieces. The `@apostrophecms/page-type` module allows for the creation of page types. The selection of these page types by a user tells Apostrophe what template to use to render the page, what content types can be added to a page by the editor through the field schema, as well as what additional dynamic content should be added. You can have as many or as few page types as needed for your site. You can either elect to make code changes as you follow along with the tutorial, or you can switch to branch `sec2-2-pages` of the [repo](https://github.com/apostrophecms/apostrophe-onboarding-project).

While the focus of this tutorial is demonstrating how to add pages to your project, we will also be diving a little deeper into some key concepts. These concepts apply universally in Apostrophe projects. As a result, this tutorial won't be code-heavy but is crucial in fully understanding how to develop with Apostrophe.

## Getting Started
In our project, we are first going to create our home page by modifying the Essentials starter kit `home-page` module. At this point, you should already have created a new project using the Apostrophe CLI tool as outlined in the [Code Organization](/tutorials/code-organization.html) tutorial. As a reminder, if you have the CLI tool installed, navigate in your terminal to the directory where you want to create your new project. Then issue the command:

`apos create onboarding-project --starter=essentials`

This will create a new directory named `onboarding-project` and clone the files from the `starter-kit-essentials` repo. It will also run `npm install`, add your project name to the `package.json` file, and register a new user with the username `admin` and the password of your choice.

## Adding a page module
![screenshot of the folder structure of a typical page](../images/sec2-2-page-structure.png)

The Apostrophe Essentials starter kit already has a `home-page` module that we will modify for our purposes, but creating a new page from scratch is easy. It is essentially a two-step process. First, you create a folder in the `modules` folder. This folder is conventionally given a suffix of `-page`. Within that folder, you need to add an `index.js` file and another folder named `views` with a `page.html` file. Second, you need to register that page so that it is available for the editor to select. This is accomplished by adding it to the `types` array of the `@apostrophecms/page` module.

The `home-page` module of the starter kit improves the core module of the same name, so it resides in the `modules/@apostrophecms/home-page` folder. We are going to alter the field schema of this page to create our custom homepage layout. This page has also already been added to the project-level `@apostrophecms/page` module. Let's look at how that file is set-up.

![Code of the boilerplate project-level `@apostrophecms/page` module](../images/sec2-2-page-module.png)

In the starter, there are two pages that are registered in the `types` array of the module `options`. For each page, there is an object that has a `name` property set to the name of the module that should be used for that page type. Note the name structure - the `home-page` module is located inside the `modules/@apostrophecms` folder, so that needs to be prefixed before the name. The second property is the `label` that will be shown in the dropdown menu in the new page creation modal. There are a number of other options for the `@apostrophecms/page` module that we will touch on briefly in other tutorials.

![Code of the boilerplate project `@apostrophecms/home-page` module](../images/sec2-2-home-page.png)

Focusing back on the `modules/@apostrophecms/home-page/index.js` file,
it only has a single option, `label: 'Home Page'`. There are additional options that we could add you can read about in the [documentation](/reference/module-api/module-options.md#options-for-all-doc-type-modules). An interesting option, that applies to all doc types not just pages, is `autopublish`.

![Screenshot of Apostrophe page publishing button with selection dropdown open](../images/sec2-2-publish-button.png)

When an editor that has the correct permissions creates a new page, they can decide to publish it immediately or save it as a draft. Setting `autopublish:true` in the `options` object will take this choice away and cause the document to be published whenever changes are made.

### Content field schema

``` javascript
// modules/blog-post/index.js
module.exports = {
  extend: '@apostrophecms/piece-type',
  // üëá The field schema
  fields: {
    add: {
      authorName: {
        label: 'Author name',
        type: 'string',
        required: true
      },
      blogTitle
      body: {
        label: 'Blog post body',
        // The `area` field type supports dynamic content widgets. It is
        // covered in the "Areas and widgets" guide section.
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {}
          }
        }
      }
    },
    group: {
      blogFields: {
        label: 'Blog fields',
        fields: [ 'authorName', 'body' ]
      }
    }
  }
};
```

The content field schema is simply a collection of fields for the input of content. For pages, the `field` property takes an `add` property composed of all the input fields and an optional `group` property that organizes those fields.

The `add` key takes an object of named objects. The name of each object is used for the retrieval of content added by the user in the template or from other fields. Within each object, you need at minimum a `label` that is displayed to the user and a `type`, that specifies what type of content is being added to the field, and also provides validation and sanitization of the input.

There are 23 basic field types [available](/reference/field-types/), all with additional options that modify or restrict the content that can be added. As we will touch on in a later tutorial, you can also create [custom input fields](/guide/custom-schema-field-types.md) for specialized content.

In the example above, we are adding two field types. The first is a field type of `string` within an object named `authorName`. This object has another optional property, `required`, set to `true`. This will force the user to add a string to this field before it is valid and can be saved.

The second field, `body` has a field type of `area`. This is a special type that can be used to add widgets to the page. As [covered](/guide/core-concepts.html#widgets) in our documentation and the [Code Organization](/tutorials/code-organization.html) tutorial, a widget is a section of structured content. Apostrophe comes with four core widgets for adding rich text, images, video, and raw HTML. As we will cover, you can also make [custom widgets](/tutorials/widgets.html). Each area can contain as many types of widgets as you wish. In the above example, the `area` has a single widget, the core `@apostrophecms/rich-text` widget. It is added to the area by passing the name of the widget as a property key and an empty configuration object as a value. Note that the names of the core widgets are prefixed with `@apostrophecms` and you can leave off the `widget` suffix since all items added to an `area` should be widgets.

## Modifying the homepage index.js file
Looking at the final project, the main area of the homepage is split into a top "Featured" section, and a bottom "Latest" section. So, we will start by creating one area that will take the content from the user for the top section and a separate one for the bottom section.

### Creating the top section schema fields
Open the `modules/@apostrophecms/home-page/index.js` file. Start by deleting the `main` field from the `add` object and replace it with the following:

<AposCodeBlock>

``` javascript
topArea: {
  type: 'area',
  label: 'Top Area',
  options: {
    widgets: {
      '@apostrophecms/image': {
        // This option will add these classes to any image
        className: 'img-fluid image-fit-center-center'
      },
      '@apostrophecms/video': {},
      '@apostrophecms/html': {},
      '@apostrophecms/rich-text': {
        toolbar: [
          'styles',
          '|',
          'bold',
          'italic',
          'strike',
          'link',
          '|',
          'bulletList',
          'orderedList',
          '|',
          'blockquote',
          'codeBlock',
          '|',
          'undo',
          'redo'
        ],
        styles: [
          {
            tag: 'p',
            label: 'Paragraph (P)'
          },
          {
            tag: 'h2',
            label: 'Heading 2 (H2)'
          },
          {
            tag: 'h2',
            label: 'Special underline',
            class: 'custom-underline display-6 ps-2'
          },
          {
            tag: 'h3',
            label: 'Heading 3 (H3)'
          },
          {
            tag: 'h4',
            label: 'Heading 4 (H4)'
          }
        ],
        insert: [
          'table',
          'image',
          'horizontalRule'
        ]
      }
    }
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>

</AposCodeBlock>

This will create a menu that will allow for the selection of these widgets when a content editor is adding to the top area of the home-page.

![Screenshot of the widget selection dropdown menu](../images/sec2-2-on-page.png)

Right now, bringing the project up would result in an error because we haven't modified our template. However, this screenshot gives a preview of what our new top area will look like. Walking through the code. We are naming the first section object `topArea` and adding a single field of `type: 'area'`. That field is getting a `label` of `Top Area`, then within the `options` we are passing the `widgets` object with all four core widgets. This will create an area where we can add additional widgets by selecting them from a dropdown menu either on the page or in the editor modal. In this case, we are also passing some in-context options to several of the widgets.

The first widget, `@apostrophecms/image`, will allow the user to add as many images as they want to the top area. Within the configuration object, we are adding the `className` property. This will cause the value string to be added to the `class` attribute of the wrapper element for each image. This property can be used with any of the core widgets. Remember, for this project, we are using the Bootstrap framework, so these classes provide styling from that framework. You can add any classes you would like, but the styling for them either needs to come from a framework, a custom style sheet, or from styles added to your template. We will cover this further in the [Adding Assets](/tutorials/assets.html) tutorial.

The image widget can also take several other parameters that control the sizes and aspect ratios of the image that can be added that you can review in the [documentation](/guide/core-widgets.md#image-widget). In this way, you can make sure that a user added image doesn't cause layout issues.

The next two widgets, to add videos hosted by a 3rd party and HTML, are added without additional configuration. While the `@apostrophecms/html` widget allows the user a lot of freedom to add code to the page, it also has the drawback that malformed code can break page rendering. Therefore, it should always be used carefully and you might want to try and implement other ways of allowing the user to add their specialized content to the page. Again, we will cover the creation of a customized widget, as well as pieces and async components as alternative methods. Luckily, Apostrophe [provides a way](/guide/core-widgets.html#html-widget) to still access a page with malformed code. Appending `safe-mode=1` to your page URL as a query parameter will allow you to bypass the html widget output and fix your page.

![Screenshot of the rich text widget toolbar](../images/sec2-2-rich-text-toolbar.png)

The final widget is the `@apostrophecms/rich-text` widget. In this case, we are adding a large amount of configuration. The first property, `toolbar` takes an array of all the items that you want to be added to the toolbar that appears when you highlight some text. The first item is the `styles` dropdown that adds the items passed in through the `styles` property array. By default, the `toolbar` array has 'styles', 'bold', 'italic', 'strike', 'link', 'anchor', 'bulletList', 'orderedList', and 'blockquote'. If you supply a `toolbar` array in the area configuration, it overrides the default values. You can read about the other possible toolbar items in the [documentation](/guide/core-widgets.md#configuring-the-toolbar).

The `styles` array is used to indicate what types of HTML tags can be added to the text in the rich text input box. The only tags that will be allowed are those passed in through the styles array. By default the style array is set to pass the 'p', 'h2', 'h3', and 'h4' tags. If you add a styles array to the widget configuration for the area, it overrides the default values. In addition to adding the tag through the `tag` property, each object in the `styles` array should also have a label that is displayed in the dropdown menu. Finally, you can optionally pass a string of classes. Note that you can have the same tag used multiple times with different `class` strings. This is exactly what we are doing with the `h2` tag.

Depending on what items are added to the `toolbar` and `styles` arrays, different Markdown shortcuts will be automatically enabled. For example, if the `h2` tag is allowed, you can type `##` in the editor to add that styling to the text you type afterward. You can read more in the [documentation](/guide/core-widgets.md#using-markdown-in-the-rich-text-widget).

The final configuration option for the rich text widget is the `insert` array. This creates an additional method for adding items without having to highlight any text first by making the pop-up appear by typing `/`. There is currently built-in support for adding a table or adding an inline image. There is also an add-on extension that enables the AI-assisted addition of text in the editor. We will cover installing and using extensions in the [Adding Extensions](/tutorials/adding-extensions.html) tutorial.

### Creating the bottom section schema fields

Next, we will add the bottom section.

<AposCodeBlock>

``` javascript
bottomArea: {
  type: 'area',
  label: 'Bottom Area',
  options: {
    expanded: true,
    groups: {
      core: {
        label: 'Core Widgets',
        widgets: {
          '@apostrophecms/image': {
            // This option will add these classes to any image
            className: 'img-fluid image-fit-center-center'
          },
          '@apostrophecms/video': {},
          '@apostrophecms/html': {},
          '@apostrophecms/rich-text': {
            toolbar: [
              'styles',
              '|',
              'bold',
              'italic',
              'strike',
              'link',
              '|',
              'bullet_list',
              'ordered_list',
              '|',
              'blockquote',
              'code_block',
              '|',
              'horizontal_rule',
              '|',
              'undo',
              'redo'
            ],
            styles: [
              {
                tag: 'p',
                label: 'Paragraph (P)'
              },
              {
                tag: 'h2',
                label: 'Heading 2 (H2)'
              },
              {
                tag: 'h2',
                label: 'Special underline',
                class: 'custom-underline display-6 ps-2'
              },
              {
                tag: 'h3',
                label: 'Heading 3 (H3)'
              },
              {
                tag: 'h4',
                label: 'Heading 4 (H4)'
              }
            ]
          }
        },
        columns: 2
      }
    }
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>

</AposCodeBlock>

![Screenshot of the bottom area expanded widget preview menu](../images/sec2-2-expanded-menu.png)

The code for the bottom section is largely the same as the top section. However, instead of the `widgets` being a top-level option, it is now moved inside the `groups` option. Additionally, the `expanded: true` option has been added. Together, these cause the widgets to be presented as a graphical selection in a fly-out menu.

Looking at the `groups` option, it takes an object of named objects. In this case, we are only passing a single object named `core`. Within this object, we are passing a label for that "group" of widgets that will be displayed above their cards in the fly-out. The `widgets` property is configured the same as it was for the top section. The only other property in the `core` object is `columns`. This takes an integer from 1-4, with a default of 3, that determines how many cards there should be for each row in the group. The cards display either an icon or preview image that is configured within the widget itself.

### Organizing the fields

The last thing we need to add to our custom homepage, for now, is the optional `groups` property. This code should be added after the `add` property within the `fields` object.

<AposCodeBlock>

```javascript
group: {
  basics: {
    label: 'Basics',
    fields: [ 'topArea', 'bottomArea' ]
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>

</AposCodeBlock>

The `group` property takes an object of named objects. Each of these named objects will create a tab in the editor modal. By default, Apostrophe creates two tabs in the editor modal. The first is a 'Basics' tab that contains the `title` field. You can choose to move that field into a new group to no longer have a 'Basics' tab. The second is named `utility` and is always visible along the right side of the modal. You can add additional fields in this tab, or you can elect to move the `slug` and `type` fields in this tab to other tabs. With the group object above, we are moving our two areas into the 'Basics' tab along with the default `title` field.

## Introducing templates

At this point, if we were to try spinning our site up we would get a 500 error. This is because our template file expects the `main` field that we deleted. So we need to replace to code within the `modules/@apostrophecms/home-page/views/page.html` file to output our new areas. Before we do this, let's take a look at some features we can use in templates.

As we covered in the [Technical Overview](/guide/technical-overview.html) page in the guide, Apostrophe uses the Nunjucks templating language, which mixes HTML markup with a variety of different features. One feature that is used in most page-type templates for an Apostrophe project is template inheritance. This allows one template to extend another, much like most modules in Apostrophe extend a parent module. In the boilerplate project, templates at the project level typically extend the `views/layout.html` file.

### The "outerLayoutBase.html" file
If you were to open the `views/layout.html` file, you would see that it extends another core file of Apostrophe, `outerLayout` that comes from the `@apostrophecms/template` module. That file in turn extends the `outerLayoutBase.html` file. Let's open that file, `node_modules/apostrophe/modules/@apostrophecms/template/views/outerLayoutBase.html`

<AposCodeBlock>

``` nunjucks
<!DOCTYPE html>
<html lang="{% block locale %}en{% endblock %}" {% block extraHtml %}{% endblock %}>
  <head>
    {% block startHead %}
    {% endblock %}
    {% component '@apostrophecms/template:inject' with { where: 'head', end: 'prepend' } %}
    <title>{% block title %}{{ data.piece.title or data.page.title }}{% endblock %}</title>

    {# This call is still here for backwards compatibility, but does nothing #}
    {{ apos.asset.stylesheets(data.scene) }}

    {% block standardHead %}
    <meta name="viewport" content="width=device-width, initial-scale=1">
    {% endblock %}
    {% component '@apostrophecms/template:inject' with { where: 'head', end: 'append' } %}
    {% block extraHead %}
    {% endblock %}
  </head>
  <body class="{{ data.aposBodyClasses }} {% block bodyClass %}{% endblock %}"{{ data.aposBodyDataAttributes | safe }}>
    {% component '@apostrophecms/template:inject' with { where: 'body', end: 'prepend' } %}
    {% block apostropheMenu %}
      {% if data.scene == 'apos' %}
        <div id="apos-busy"></div>
        <div id="apos-admin-bar"></div>
      {% endif %}
    {% endblock %}
    {% block apostropheUserInterface %}
      {% if data.scene == 'apos' %}
        <div id="apos-notification"></div>
      {% endif %}
    {% endblock %}
    <div data-apos-refreshable>
      {% block beforeMain %}{% endblock %}
      {% block mainAnchor %}<a name="main"></a>{% endblock %}
      {% component '@apostrophecms/template:inject' with { where: 'main', end: 'prepend' } %}
      {% block main %}{% endblock %}
      {% component '@apostrophecms/template:inject' with { where: 'main', end: 'append' } %}
      {% block afterMain %}{% endblock %}
    </div>
    {% component '@apostrophecms/template:inject' with { where: 'body', end: 'append' } %}
    {% block extraBody %}{% endblock %}
    {% if data.scene == 'apos' %}
      <div id="apos-modals"></div>
      <div id="apos-command-menu"></div>
    {% endif %}
    {# Scripts must load after apos-modal in the DOM #}

    {# This call is still here for backwards compatibility, but does nothing #}
    {{ apos.asset.scripts(data.scene) }}

    {# For project-level webpack injection in dev environments #}
    {% block afterAposScripts %}{% endblock %}
    {# Automatically does nothing in production #}
    {{ apos.asset.refreshOnRestart() }}
  </body>
</html>
```

</AposCodeBlock>

This file is a bit complicated, but largely repetitive once you understand the structure. The file creates a standard web page but adds `block` directives to areas of the page where you can inject custom values from your project-level templates.

For example,
``` nunjucks
<html lang="{% block locale %}en{% endblock %}" {% block extraHtml %}{% endblock %}>
```

This line adds an `html` tag with the default language set to `en`. But, the value of the `lang` attribute is surrounded by `{% block locale %}` and `{% endblock %}` tags. This means that in our project level template we can set the page language by passing a different value in through these same block tags.

``` nunjucks
{% block locale %}fr{% endblock %}
```
Looking through this file, we can see that there are multiple areas of the page where we can add or change content, like the `extraHead` block at the end of the page `head` tag, and the `main` block within the body tag. Sometimes, we don't want to eliminate code that may already exist in a parent template block. For example, looking at the `standardHead` block code: 

``` nunjucks
{% block standardHead %}
  <meta name="viewport" content="width=device-width, initial-scale=1">
{% endblock %}
```
The `meta` tag in this block has reasonable attributes that we may want to keep, but we may want to add additional meta tags. In this case, we can tell our project-level template to keep any content that is already in the block and simply append the new markup that we pass it using the `super()` render tag.

``` nunjucks
{% block standardHead %}
  {{ super() }}
  <meta property="og:title" content="{{ data.page.title }}">
{% endblock %}
```

The current contents of the block will be added wherever in your template block you use this renderer. So, you could put new content before or after the parent template content.

## Adding the homepage template

Let's create a basic template that simply displays the two areas that we added. In most cases, a page type module requires a template for rendering when there is a request for the page. It will look for a `page.html` file in the module `views` folder. The only exception to that rule is if the module extends a page type for which there is already a template. To add our new homepage template, open the `modules/@apostrophecms/home-page/views/page.html` file and delete all the content. Add this code in its place.

<AposCodeBlock>

``` nunjucks
{% extends "layout.html" %}

{% block main %}
<section class="d-flex justify-content-center me-auto me-md-5 ms-auto ms-md-5">
  <container class="articles container">
    {% area data.page, 'topArea' %}
  </container>
</section>
<section class="d-flex justify-content-center me-auto me-md-5 ms-auto ms-md-5">
  <container class="articles container">
    {% area data.page, 'bottomArea' %}
  </container>
</section>
{% endblock %}
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/views/page.html
  </template>

</AposCodeBlock>

This template extends the `view/layout.html` file and replaces the content of the `main` block. All the other blocks in the layout are left untouched. The majority of the content here just sets up sections and adds Bootstrap styling.

The only other lines of special note in this file are the two that render the widgets that were added into each area by our content field schema: `{% area data.page, 'topArea' %}` and `{% area data.page, 'bottomArea' %}`. These `{% area %}` template tags are provided by the `@apostrophecms/area` core module and take a context, in this case `data.page`, and an area schema field name. This helper will parse through all the widget data added to our area and render that data into HTML, without us having to parse each widget.

### Page data
Pages, pieces, and widget templates each get data from the field schema of the corresponding document provided to them through the `data` object. For pages, this is through `data.page`. This provides an object with the names and values of each schema field as properties. For pages, this also provides a wealth of additional information about the document, including the time the document was created or updated, the document id for accessing it in the database, and publication status.

Depending on the document type of the module, the template has a lot of additional data available through the `data` object. We will be using one of the `data` properties in the fragments section, but you can see the larger list of them in the [documentation](/guide/template-data.md).

::: v-pre
 When creating a new template, sometimes it is handy to see exactly what is being passed to the template for debugging purposes. Apostrophe exposes several helpers, including `apos.log`. In this case, you could use it to output the `data.page` object to the console, using `{{ apos.log('this is the page data', data.page)}}`. This is essentially like using `console.log('message', variable)` in JavaScript. This information will show up in the server console, not the browser console, since the page is rendered server-side.
 
 An alternative to this is using `<script> console.log({{ page.data | json}})</script>`. This will pipe the log output to the browser console since the script will be run on the client-side. This is useful for parsing through large objects or using other console methods. Note the use of `| json` within the interpreted expression. This is saying that the `page.data` should be piped to the Nunjucks `json` filter. Filters in Nunjucks apply a function to any template data and are used to sanitize or modify the input that is piped to them. In this case, the `json` filter will properly escape data into a json string for output in a script tag. There are several [Nunjucks-](https://mozilla.github.io/nunjucks/templating.html#filters) and [Apostrophe-supplied](/guide/template-filters.html#apostrophe-supplied-filters) filters, plus you can create [custom filters](https://docs.apostrophecms.org/guide/template-filters.md#custom-template-filters). We will explore this further in a future tutorial.

## Using fragments

<iframe src="https://www.youtube.com/embed/j0Shrq6xjC0?si=IOQUtQnwdxHePFC4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Another tool we have to help us in constructing pages is fragments. Fragments can be used in templates for pages, pieces, and widgets. They are useful for template code that is reused across multiple files, but also to organize complicated layouts by splitting the code into smaller, more manageable pieces. Fragments are very similar to Nunjucks macros, but they support fetching data to add to the fragment asynchronously. We will revisit this in the [Creating Pieces](/tutorials/pieces.html) tutorial.

Looking back at the project overview in the tutorial [Introduction](/tutorials/introduction.html), we can see that all the pages are going to have a top bar with our branding, a navbar, and a footer. We could elect to directly add this markup to our `views/layout.html` file, but instead, we are going to use fragments for each.

### Top bar fragment
![Screenshot of the topbar of the POC site](../images/sec2-2-topbar-frag.png)

Create a `views/fragments/topbar.html` and add the following code:

<AposCodeBlock>

``` nunjucks
{% fragment mainArea() %}
  <section class="bg-dark text-white topbar">
    <div class="align-items-center container-fluid d-flex justify-content-evenly logo-block" style="min-height: 100%; height: 100%;">
      <div class="align-items-center d-flex justify-content-between mb-auto mt-3 row" style="width: 100%;">
        <div class="col-md-3 mb-3 ps-2 text-center">
          <div class="lh-1 logo-block">
            <a href="{{ data.home._url }}" class="text-decoration-none"><span class="tight">{{ __t('apostropheProductReviews') }}</span></a>
          </div>
        </div>
        <div class="col-md-3 mb-3 text-center">
          <div class="input-group me-1 ms-1 w-100">
            <div class="input-group-text">üîé</div>
            <input class="form-control" placeholder="{{ __t('findTheBest') }}...">
          </div>
        </div>
        <div class="col-md-3 mb-3 text-center">
          <button type="button" class="btn btn-info text-white">{{ __t('becomeAMember') }}</button>
        </div>
      </div>
    </div>
  </section>
{% endfragment %}
```
  <template v-slot:caption>
    views/fragments/topbar.html
  </template>

</AposCodeBlock>

There are three things of note within this file. First, all the code is surrounded with `fragment` tags. The top tag has a fragment name that looks a bit like a function name. That is because we can pass arguments in from our templates to be used within our fragments. We will look at this when we add the navigation fragment in the [Building Navigation](/tutorials/navigation.html) tutorial.
::: v-pre
Second, our logo link uses the data object to set the URL for the home page using `{{ data.home._url }}`. All pages and widgets can access the `data.home` property. While there is a `slug` property within `data.home`, we don't want to use this in case our user wants to localize the page. Instead, we are using the computed `_url` property value. Looking into the database at the homepage, we won't see the `_url` property. Instead, this value is computed when the user requests the page.

Lastly, the logo text and two placeholder texts look a little odd -  
`<a href="{{ data.home._url }}" class="text-decoration-none"><span class="tight">{{ __t('apostropheProductReviews') }}</span></a>`
**Adding static translation to the topbar**

The text for all three is computed using the `__t()` template helper. Adding our text in using this helper allows us to perform static localization of our text strings. We will circle back to "static" versus "dynamic" localization in a later tutorial. For now, in order for our site to work, we need to create a new folder to contain our string translation files.

There are multiple places we could store our translation strings, but in this case, the topbar is going to be used globally throughout our site, so it makes sense to put them in a project-level `@apostrophecms/global` module folder. When we create our navigation fragment we will come back to the `@apostrophecms/global` module and [global settings](/guide/global.md). This module provides a useful place for allowing the user to enter content or alter settings that are used across your project. Create a `modules/@apostrophecms/global/i18n` folder. Within that folder create an `en.json` file and add the following code:

<AposCodeBlock>

``` json
{
  "apostropheProductReviews": "Apostrophe Product Reviews",
  "findTheBest": "Find the best",
  "becomeAMember": "Become a member"
}
```
  <template v-slot:caption>
    modules/@apostrophecms/global/i18n/en.json
  </template>

</AposCodeBlock>

For each of the strings we are passing to the `__t()` helper, we have a corresponding string that we want to add to the page.

#### Configuring project locales

Now that we have localization strings added to our project, we need to provide locales for the project. These locales are most often different languages, countries, or combinations of the two. In some cases, it may also be appropriate to establish locales for people based on topical interests, professional categories, or cultural identities.

Locales are configured through the `@apostrophecms/i18n` module. Open the `modules/@apostrophecms` folder and create an `i18n` folder with an `index.js` file inside. Add the following code:

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    locales: {
      en: {
        label: 'English'
      },
      de: {
        label: 'Deutsch',
        prefix: '/de'
      }
    }
  }
};

```
  <template v-slot:caption>
    modules/@apostrophecms/i18n/index.js
  </template>

</AposCodeBlock>

This code is passing the `locales` property to the module `options`. That property should contain a named object for each locale we want to add to our project. The name for each object is a short identifier, typically a two-letter language code, country code, or one of each with a dash separating them. For example, you might want one locale for French-speaking Canadians (`fr-CA`) and another for English-speaking Canadians (`en-CA`). In the code we added to our project we are creating two locales, a base English locale with the short identifier `en`, and a German ("Deutsch") locale with the short identifier `de`. For the German locale, we are passing a `prefix` property. This prefix will be appended to the base hostname before the page path. For example, 'www.myProjectSite.com/de/'. We can also elect to use a different hostname for our localized content using the `hostname` property. Each locale except for the base locale must have a prefix, a hostname, or both.

Now that we have a second locale added, we need to add an additional JSON file containing the string translations. Open the `modules/@apostrophecms/global/i18n` folder and add a `de.json` file. Add the following code:

<AposCodeBlock>

``` json
{
  "apostropheProductReviews": "Apostrophe Produktbewertungen",
  "findTheBest": "Finden Sie das Beste",
  "becomeAMember": "Werden Sie Mitglied"
}
```
  <template v-slot:caption>
    modules/@apostrophecms/global/i18n/de.json
  </template>

</AposCodeBlock>

Again, our JSON file contains each of the translation strings as keys and their translations as values. We will circle back to look at our translations at the end of this tutorial when we can see both our topbar and footer.

### Creating the footer fragment

![Screenshot of the footer of the POC project](../images/sec2-2-footer-frag.png)

We will place our `footer.html` fragment in the same folder as our `topbar.html`. Create the `views/fragments/footer.html` file and add the following code:

<AposCodeBlock>

``` nunjucks
{% fragment mainArea() %}
  <footer class="bg-info bg-opacity-10 pt-5 text-secondary"> 
      <div class="container"> 
          <div class="row"> 
              <div class="col-lg-4 py-3">
                  <h2 class="fw-bold h5 mb-4 text-primary text-uppercase">Quick Links</h2>
                  <div class="row">
                      <div class="col-sm-6">
                          <ul class="list-unstyled"> 
                              <li class="mb-3"><a href="#" class="text-secondary">Get Quote</a>
                              </li>
                              <li class="mb-3"><a href="#" class="text-secondary">Enterprise Plan</a>
                              </li>
                              <li class="mb-3"><a href="#" class="text-secondary">Become an Affiliate</a>
                              </li>
                              <li class="mb-3"><a href="#" class="text-secondary">Our Portfolio</a>
                              </li>
                          </ul>
                      </div>
                      <div class="col-sm-6">
                          <ul class="list-unstyled"> 
                              <li class="mb-3"><a href="#" class="text-secondary">Web Design</a>
                              </li>
                              <li class="mb-3"><a href="#" class="text-secondary">Web Development</a>
                              </li>
                              <li class="mb-3"><a href="#" class="text-secondary">WordPress</a>
                              </li>
                              <li class="mb-3"><a href="#" class="text-secondary">Digital Marketing</a>
                              </li>
                              <li class="mb-3"><a href="#" class="text-secondary">Content Writing</a>
                              </li>
                          </ul>
                      </div>
                  </div>
              </div>
              <div class="col-lg-4 py-3">
                  <h2 class="fw-bold h5 mb-4 text-primary text-uppercase">Latest Posts</h2>
                  <p class="mb-3">
                         Duis pharetra venenatis felis, ut tincidunt ipsum consequat nec. Fusce et porttitor libero, eu aliquam nisi. Nam finibus ullamcorper semper.</p>
              </div>
              <div class="col-lg-4 py-3"> 
                  <h2 class="fw-bold h5 mb-4 text-primary text-uppercase">Other</h2>
                  <p class="mb-3">Subscribe to our newsletter and get exclusive updates directly in your inbox.</p>
                  <form class="mb-4">
                      <div class="bg-white border input-group overflow-hidden p-1 rounded-pill">
                          <input type="email" class="border-0 form-control pe-3 ps-3" placeholder="Enter email..." aria-label="Recipient's email" aria-describedby="button-addon2" required>
                          <button class="btn btn-primary pb-2 pe-4 ps-4 pt-2 rounded-pill" type="submit" id="button-addon2" aria-label="submit">
                              <svg viewBox="0 0 24 24" fill="currentColor" class="d-inline-block" height="16" width="16">
                                  <path d="M1.946 9.315c-.522-.174-.527-.455.01-.634l19.087-6.362c.529-.176.832.12.684.638l-5.454 19.086c-.15.529-.455.547-.679.045L12 14l6-8-8 6-8.054-2.685z"></path>
                              </svg>
                          </button>
                      </div>
                  </form>
                  <h2 class="fw-bold h5 mb-2 text-primary text-uppercase">Get Social</h2>
                  <div class="d-inline-flex flex-wrap"> <a href="#" class="p-1 text-secondary" aria-label="facebook"> <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                              <path d="M14 13.5h2.5l1-4H14v-2c0-1.03 0-2 2-2h1.5V2.14c-.326-.043-1.557-.14-2.857-.14C11.928 2 10 3.657 10 6.7v2.8H7v4h3V22h4v-8.5z"/>
                          </svg> </a> <a href="#" class="p-1 text-secondary" aria-label="twitter"> <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                              <path d="M22.162 5.656a8.384 8.384 0 0 1-2.402.658A4.196 4.196 0 0 0 21.6 4c-.82.488-1.719.83-2.656 1.015a4.182 4.182 0 0 0-7.126 3.814 11.874 11.874 0 0 1-8.62-4.37 4.168 4.168 0 0 0-.566 2.103c0 1.45.738 2.731 1.86 3.481a4.168 4.168 0 0 1-1.894-.523v.052a4.185 4.185 0 0 0 3.355 4.101 4.21 4.21 0 0 1-1.89.072A4.185 4.185 0 0 0 7.97 16.65a8.394 8.394 0 0 1-6.191 1.732 11.83 11.83 0 0 0 6.41 1.88c7.693 0 11.9-6.373 11.9-11.9 0-.18-.005-.362-.013-.54a8.496 8.496 0 0 0 2.087-2.165z"/>
                          </svg> </a> <a href="#" class="p-1 text-secondary" aria-label="instagram"> <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                              <path d="M12 2c2.717 0 3.056.01 4.122.06 1.065.05 1.79.217 2.428.465.66.254 1.216.598 1.772 1.153a4.908 4.908 0 0 1 1.153 1.772c.247.637.415 1.363.465 2.428.047 1.066.06 1.405.06 4.122 0 2.717-.01 3.056-.06 4.122-.05 1.065-.218 1.79-.465 2.428a4.883 4.883 0 0 1-1.153 1.772 4.915 4.915 0 0 1-1.772 1.153c-.637.247-1.363.415-2.428.465-1.066.047-1.405.06-4.122.06-2.717 0-3.056-.01-4.122-.06-1.065-.05-1.79-.218-2.428-.465a4.89 4.89 0 0 1-1.772-1.153 4.904 4.904 0 0 1-1.153-1.772c-.248-.637-.415-1.363-.465-2.428C2.013 15.056 2 14.717 2 12c0-2.717.01-3.056.06-4.122.05-1.066.217-1.79.465-2.428a4.88 4.88 0 0 1 1.153-1.772A4.897 4.897 0 0 1 5.45 2.525c.638-.248 1.362-.415 2.428-.465C8.944 2.013 9.283 2 12 2zm0 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm6.5-.25a1.25 1.25 0 0 0-2.5 0 1.25 1.25 0 0 0 2.5 0zM12 9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/>
                          </svg> </a> <a href="#" class="p-1 text-secondary" aria-label="linkedin"> <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                              <path d="M6.94 5a2 2 0 1 1-4-.002 2 2 0 0 1 4 .002zM7 8.48H3V21h4V8.48zm6.32 0H9.34V21h3.94v-6.57c0-3.66 4.77-4 4.77 0V21H22v-7.93c0-6.17-7.06-5.94-8.72-2.91l.04-1.68z"/>
                          </svg> </a> <a href="#" class="p-1 text-secondary" aria-label="youtube"> <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                              <path d="M21.543 6.498C22 8.28 22 12 22 12s0 3.72-.457 5.502c-.254.985-.997 1.76-1.938 2.022C17.896 20 12 20 12 20s-5.893 0-7.605-.476c-.945-.266-1.687-1.04-1.938-2.022C2 15.72 2 12 2 12s0-3.72.457-5.502c.254-.985.997-1.76 1.938-2.022C6.107 4 12 4 12 4s5.896 0 7.605.476c.945.266 1.687 1.04 1.938 2.022zM10 15.5l6-3.5-6-3.5v7z"/>
                          </svg> </a> 
                  </div>
              </div>
          </div>
          <div class="pb-3 pt-3 small">
              <hr class="mt-0 ">
              <div class="align-items-center row">
                  <div class="col-md pb-2 pt-2">
                      <p class="mb-0">&copy; 2002 - 2020. All Rights Reserved - Company Name</p>
                  </div>
                  <div class="col-md-auto pb-2 pt-2"><a href="#" class="text-secondary">Privacy Policy</a> | <a href="#" class="text-secondary">Terms of Use</a>
                  </div>
              </div>
          </div>
      </div>
  </footer>
{% endfragment %}
```
  <template v-slot:caption>
     views/fragments/footer.html
  </template>

</AposCodeBlock>

For now, we are just creating a static footer. As we add our pieces and widgets, plus talk more about the global module, we will update this file.

### Modification of the master template

Now that we have created our fragments, we could use them in our `modules/@apostrophecms/home-page/views/page.html` file. However, since they are being used for the majority of our pages, we can add them to our project-level `views/layout.html` file. Open up this file, remove the existing content, and add the following code:

<AposCodeBlock>

``` nunjucks
{% extends data.outerLayout %}

{% import 'fragments/topbar.html' as topbar %}
{% import 'fragments/footer.html' as footer %}

{% set title = data.piece.title or data.page.title %}
{% block title %}
  {{ title }}
  {% if not title %}
    {{ apos.log('Looks like you forgot to override the title block in a template that does not have access to an Apostrophe page or piece.') }}
  {% endif %}
{% endblock %}

{% block beforeMain %}
  <header>
    {% render topbar.mainArea() %}
  </header>
  <main class="pr-main">
{% endblock %}

{% block afterMain %}
  </main>
  <footer>
    {% render footer.mainArea() %}
  </footer>
{% endblock %}
```
  <template v-slot:caption>
    views/layout.html
  </template>

</AposCodeBlock>

As before, we are using `data.outerLayout` to extend the `outerLayout.html` file of the `@apostrophecms/template` core module. Next, we are using two import statements to import our fragments. Since these files are located in the project-level `views` folder, we can reference them by passing in the subfolder and file name. If they are located elsewhere in your project you would have to reference them using a relative path.

The next section of code adds the content of the page `title` tag using the `data` object for either the piece or the page. The `set` tag is used to assign the value the `title` variable using the `or` logic operator. This works like a JavaScript `or`, returning the value of the first true operand. This is all enclosed in `title` block tags.

Next, we add are using a `beforeMain` block to add our topbar fragment within `header` tags. To accomplish this we use the `render` tag and pass it the name of the fragment file and the name of the fragment macro within the file. As we will see with the navigation fragment, we can include several fragments in the same file. We are also adding the opening of the `main` HTML element. Adding it here means that we reduce the need for `super()` within templates that are adding content to the `main` block.

Lastly, we close out the `main` markup element and add our footer fragment to the `afterMain` block.

## Alternative module schema configuration

This project won't be utilizing the `modules/default-page` module that is created in the boilerplate. But we can use it to show an additional way to configure your schema fields for cases where there are a large number of schema with similar configurations.

As pointed out in the code overview tutorial, the boilerplate project contains a `lib/` folder with an `area.js` file that isn't utilized in the project.

<AposCodeBlock>

``` javascript
// lib/area.js
module.exports = {
  '@apostrophecms/image': {},
  '@apostrophecms/video': {},
  '@apostrophecms/html': {},
  '@apostrophecms/rich-text': {
    toolbar: [
      'styles',
      '|',
      'bold',
      'italic',
      'strike',
      'link',
      '|',
      'bulletList',
      'orderedList',
      '|',
      'blockquote',
      'codeBlock',
      '|',
      'undo',
      'redo'
    ],
    styles: [
      {
        tag: 'p',
        label: 'Paragraph (P)'
      },
      {
        tag: 'h3',
        label: 'Heading 3 (H3)'
      },
      {
        tag: 'h4',
        label: 'Heading 4 (H4)'
      }
    ],
    insert: [
      'table',
      'image',
      'horizontalRule'
    ]
  }
};

```
  <template v-slot:caption>
    lib/area.js
  </template>

</AposCodeBlock>

This file exports an area content field schema with each of the four core widgets added and some configuration of the rich text widget. This is a simple default export, but we will return to this in a later tutorial to see how we can use named exports to add a centralized library of schema fields. So how would this be used?

Opening the `modules/default-page/index.js` we can delete the existing `fields.add.main.options.widgets` object and instead, use our exported schema. In addition, we need to require the `lib/area.js` file.

<AposCodeBlock>

``` javascript
const { fullConfig } = require('../../lib/area');

module.exports = {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Default Page'
  },
  fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: fullConfig
        }
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [ 'main' ]
      }
    }
  }
};

```
  <template v-slot:caption>
    modules/default-page/index.js
  </template>

</AposCodeBlock>

You can see that this would provide considerable utility if we had a page with multiple areas.

## Summary and next steps

In this tutorial, we've navigated through the process of adding a page in an Apostrophe project. This was achieved by modifying the existing `@apostrophecms/home-page` module, but in future tutorials, we will add pages through the creation of a new module and incorporation of the fresh type into the `@apostrophecms/page` module.

We also took an initial look at how to add and organize content schema fields. This is crucial because it's how you'll allow users to enter content onto your pages. We primarily concentrated on the `area` schema field and core Apostrophe widgets when creating our two content areas. Moving forward we will look at other schema field types, as well as conditionals and other options that regulate the content users can add to the page.

While creating the main page layout template for our project, we also got an overview of template inheritance by looking at the core base layout file. This also gave us the opportunity to create reusable sections of code through fragments. We will look in future tutorials at using async components as an alternative. Finally, we created the template for our displaying the content our users entered on the homepage.

![Screenshot of the topbar localization](../images/sec2-2-localization.png)

We also learned about localization when creating our topbar fragment. If we bring our site up (using `npm run dev`) it won't look that great because we don't have any styling added, yet. However, if we log in, by navigating to `http://localhost:3000/login and entering our credentials, we can still see the top 'admin bar' and the content of our topbar. If we open the localization dropdown menu to the left of our login menu we can see both of our locales listed. Selecting the 'Deutsch' local, we can see that the strings for our topbar and our admin UI change from English to German.

At this point, we could add content to our site, but the majority of the homepage would look horrible. In the next tutorial, we are going to look at how to add assets like fonts and styling frameworks to our pages to begin to make them look like the completed project.

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS > Adding CSS and JS Assets
DOC_PATH: tutorials/assets.md
URL: https://apostrophecms.com/docs/tutorials/assets
================================================================================
# Assets

<iframe src="https://www.youtube.com/embed/qrQUlcDPFg8?si=z_6MKL8BfiGclGiN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the video and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

In an Apostrophe project, you have multiple options for where to add assets. It is all dependent on how you feel most comfortable organizing your codebase. 

Apostrophe automatically provides a [webpack](https://webpack.js.org/)-powered process for bundling project frontend JavaScript and stylesheets. You can elect to use SCSS or CSS in your styling and Apostrophe will compile and bundle it for delivery to the front end. The webpack configuration can be altered to include additional file types, additional processing steps, or aid in codebase organization. You can also elect to use your own build process or opt resources out of the built-in build process.

In this tutorial, we are going to cover where assets can be added to your project. We will also look at how we can exempt files from being processed by webpack, plus how to extend webpack. Finally, we will touch on the topic of adding static assets, like logo images, where they can be accessed using relative URLs. You can copy the code from this tutorial into your project, or switch to the `sec2-3-assets` branch of the [repo](https://github.com/apostrophecms/apostrophe-onboarding-project). In this tutorial we will be installing the `Bootstrap` package, so you should run `npm update` after switching branches.

## The boilerplate `asset` folder

![Screenshot of the folder structure of the Apostrophe boilerplate asset folder](../images/sec2-3-asset-folder.png)

The boilerplate project has a `modules/asset` folder. This module extends the `@apostrophecms/module` and not the `@apostrophecms/asset` module - note that this folder is located in the top-level modules folder. This gives this module access to some core configuration settings and functions, as well as exposing it to the webpack build process. In a later tutorial, we will cover configuring the `@apostrophecms/uploadfs` module through the project-level `modules/@apostrophecms/asset` module. The `modules/asset` folder can be renamed if you are worried that the similarity in names will prove confusing or if you prefer that the core assets of your project be stored in a different folder. Please note that if you elect to change the name of the module you will also have to change the `app.js` file to register the new name.

We aren't going to alter the `index.js` file of this module, but it is worth opening it and taking a look to revisit a key customization function.

``` javascript
// modules/asset/index.js
module.exports = {
  handlers(self) {
    return {
      '@apostrophecms/page:beforeSend': {
        webpack(req) {
          req.data.isDev = (process.env.NODE_ENV !== 'production');
        }
      }
    };
  }
};
```

This module has a single [`handler(self)` configuration function](/reference/module-api/module-overview.md#handlers-self). Remember that handlers listen for Apostrophe modules, both core and custom, to emit a named signal. This handler listens for the `@apostrophecms/page` module to emit the `beforeSend` server event. This event is triggered just before a requested page is rendered and sent as a response. It is a good time in the request cycle to adjust the data available to the template by amending any information to the `data.req` object. In this case, the handler is checking the `NODE_ENV` environment variable. If it is set to `production` then the `isDev` property will be set to `false`. This will be available in the template as `data.isDev`. This can be useful for only outputting debugging info if the project is in development.

Our main interest in this module for this tutorial is the `ui/src` folder. Any number of modules can have this folder, and any JavaScript or styling assets put into this folder will be auto-discovered during the webpack build and added to the front-end asset bundles. The assets will be added to the bundle in the order that the modules are registered in the `app.js` file. This can be important for correct cascading of styles. It is also of note that if you have JavaScript in two different module `ui/src` folders that import the same dependencies, the Apostrophe webpack build is smart enough to only include that resource once.

In the boilerplate project, the `ui/src` folder contains two files, `index.js` and `index.scss`. Any front-end assets that need to be bundled either need to be added to these files, or imported by these files. We are going to start by modifying the `index.scss` file to bring our Bootstrap framework CSS into the project. Bootstrap can be installed as an npm package. Start by navigating to the root directory of your project and running `npm install bootstrap`.

![Screenshot of the essentials starter kit 'modules/asset/ui/src/index.scss` file contents](../images/sec2-3-ui-src-folder.png)

Next, open up the `modules/asset/ui/src/index.scss` file. Inside are a series of import statements. The topmost one imports the popular `normalize.css` CSS resets file. The remainder of the import statements bring in starter kit-specific styling from the `scss` folder in the same directory. The Bootstrap project brings in its own CSS resets, so we can delete all the contents of this file. Add in Bootstrap using `@import 'bootstrap';`. This will bring the bootstrap CSS from the node package. All of our other styling will be imported before this so that any variables we add will be brought properly into the Bootstrap framework. At this point, you can delete the contents of the `scss` folder in this directory. We will begin adding back some custom styling next.

Although this project won't be using any Bootstrap components, only styling, we can also import the Bootstrap JavaScript. Open the `ui/src/index.js` file. You can elect to get rid of the `console.log('Hello World');` that is in the `export default()` function, but don't delete the function itself. At the top of the file, before the `export`, add in `const bootstrap = require('bootstrap');`. Your code linter may complain that you are creating a constant, but never using it. This is fine, the Apostrophe webpack will still import the bootstrap JavaScript and make it available on the front end for use.

![Screenshot of our page after addition of the Bootstrap CSS framework](../images/sec2-3-styled.png)

If we spin our project up now using `npm run dev`, both the topbar and footer should look much more reasonably styled. We still need to start adding some specific styling to make it look like our final site, but Bootstrap is doing a lot of the heavy lifting for us.

I'm not going to explain the styling of this page in-depth as it is project-specific and not specific to Apostrophe. I'm going to create three files within the `modules/asset/ui/src/scss` folder. You can delete the files that are already in this folder, as we won't be using them. You can get the content of each of these files from the GitHub repo links. The [`_theme-settings.scss`](https://github.com/apostrophecms/apostrophe-onboarding-project/blob/main/modules/asset/ui/src/scss/_theme-settings.scss) file contains all the project-wide variables for brand colors and look. The [`_theme-main.scss`](https://github.com/apostrophecms/apostrophe-onboarding-project/blob/main/modules/asset/ui/src/scss/_theme-main.scss) file contains some project wide settings, like font-family and sizes for heading, plus it imports two fonts from Google fonts. Finally, the [`_theme-topbar.scss`](https://github.com/apostrophecms/apostrophe-onboarding-project/blob/main/modules/asset/ui/src/scss/_theme-topbar.scss) file contains styling specific to our header fragment topbar. To bring these stylesheets into our project, we also need to add them in our `index.scss` file.

<AposCodeBlock>

```scss
/*
Anything in this file will be compiled into the final CSS file.
Apostrophe automatically includes the index.scss file from any
module that has a ui/src directory.
*/

// Add theme SASS variables
@import './scss/_theme-settings';
// Add theme fonts and base styles
@import './scss/_theme-main';
// Add styling for theme components
@import './scss/_theme-topbar';

// Add theme framework styles
@import 'bootstrap';
```
  <template v-slot:caption>
    modules/asset/ui/src/index.scss
  </template>

</AposCodeBlock>

![Screenshot of the topbar and footer after application of custom styling](../images/sec2-3-custom-styles.png)

Now our topbar and footer look a lot more like our final project. Just to underscore, the file naming conventions that have been used for this project are a personal choice. All that you need to remember is that all of your stylesheets, however they are named, should be imported into the `index.scss` file of the `ui/src` folder for inclusion in the final front-end bundle.

## Static module assets
Within your project, you can store static assets - the ones hard-coded onto the page, not user-uploaded ones - in several different locations. Where you store them depends a bit on how those assets will be used. The first location is within the project-level `public` folder. Assets in this folder will be available within your templates via URL. For example, an image file placed into `public/images/logo.png` will be available at `https://my-project.com/images/logo.png`. Any assets shared this way will not trigger a cache reload if they are edited, so it should be used for assets that are very rarely updated, like a brand logo or favicons. A second potential drawback of this mechanism of adding assets is that relative links like `url("/images/logo.png")` will not work if the CSS and JS are being served from an S3 bucket or CDN which will no longer have the public folder in their directory structure.

To allow the use of relative URLs and to add cache busting, Apostrophe allows you to add static assets into a `public` folder placed into any module. We will use this method to add favicons to our project. Again, open the `modules/assets` folder and create a `public/favicon` folder. We will copy all of our `favicon` images from this same folder in the [`main` GitHub branch](https://github.com/apostrophecms/apostrophe-onboarding-project/tree/main/modules/asset/public/favicon) of the project. Now that we have the assets available, we need to add them to our pages. Since these favicons will be on every page of our website, we will add links into the `views/layout.html` file.

Opening this file, we will add the favicons in the head of our pages, following the `title`. The `@apostrophecms/template/outerLayoutBase.html` file offers two additional blocks in the `head` section. The `standardHead` block contains the `viewport` meta information. If we choose to add our favicons in this section we would need to use `super()` so that we don't lose this information. Instead, we can add it to the second block, `extraHead`. Opening the `views/layout.html` file we need to add the following code after the `title` block:

<AposCodeBlock>

``` nunjucks
{% block extraHead %}
<link rel="icon" sizes="16x16" href="{{ apos.asset.url('/modules/asset/favicon/favicon-16.png')}}">
<link rel="icon" sizes="32x32" href="{{ apos.asset.url('/modules/asset/favicon/favicon-32.png')}}">
<link rel="icon" sizes="96x96" href="{{ apos.asset.url('/modules/asset/favicon/favicon-96.png')}}">
<link rel="icon" sizes="180x180" href="{{ apos.asset.url('/modules/asset/favicon/favicon-180.png')}}">
<link rel="icon" sizes="512x512" href="{{ apos.asset.url('/modules/asset/favicon/favicon-512.png')}}">
{% endblock %}
```
  <template v-slot:caption>
    views/layout.html
  </template>

</AposCodeBlock>

We are adding favicons of 5 different sizes. To get the URL of each asset, we are using the `apos.asset.url()` helper. This will resolve to a relative URL pointing at the `modules/asset/favicon` folder within the `apos-frontend` release folder. We will come back to this folder later in the tutorial when we touch on customizing your project webpack build.

## Using a customized build process
You may choose to use a customized build process powered by another bundler, like [Gulp.js](https://gulpjs.com/). In this case, you can use the `modules/custom-module/ui/public` folder. Much like the `modules/custom-module/public` folder, files added to this folder will be brought into the corresponding JavaScript or CSS asset bundle that is added to the front end. The files in this folder will not be compiled or interpreted prior to adding to the asset bundle. Any files that depend on `import` or `require`, or stylesheets that need a preprocessor must be put through a build process before they are added into this folder.

## Modifying the webpack build configuration
There are cases where your project may use a different CSS pre-processor or need to use file types that the standard Apostrophe webpack process doesn't support. You can modify the configuration of the process through the top-level `webpack` property from any project module. There are three different properties that `webpack` accepts. For the moment, we will only cover `extensions`. You can read about [`extensionOptions`](/reference/modules/asset.md#extensionoptions) in the documentation, and we will cover the third, `bundles` in the tutorial on widgets.

The `extensions` property takes an object of named objects. Each of these named objects should be set to an object that will be merged into the existing webpack configuration. The structure of this configuration comes from the [webpack configuration specs](https://webpack.js.org/configuration/). For example:

```javascript
module.exports = {
  webpack: {
    extensions: {
      extensionName: {
        // webpack configuration
        resolve: {
          alias: {
            'Utilities': path.join(process.cwd(), 'lib/utils')
          }
        }
      }
    }
  }
};
```

This would create an alias that you could then use within files in the `modules/custom-module/ui/src/` folder.

```javascript
import { customMethod } from ('Uilities/methods.js');

export default () => {
  // Code utilizing customMethod()
};
```

Because the extensions are named, you can elect to override the extension of one module in another module by passing an extension of the same name. The webpack config will be merged with the extension that is loaded last. As you may have guessed, the [`extensionOptions`](/reference/modules/asset.md#extensionoptions) allows you to extend, rather than override a previously defined extension.

## Summary and next steps

In this tutorial, the focus was on handling assets in an Apostrophe project. Multiple choices were covered regarding where assets can be placed based on codebase organization preferences. You can either add your styling and code on a per-module basis or consolidate it in a single module. Special attention was given to the `ui/src` folder, the role of the `index.js` and `index.scss` files, and the addition of the Bootstrap framework to the project. The tutorial also explored managing static assets, detailing two methods: either through the project-level `public` folder or a `modules/custom-module/public` folder in any module. Advantages of adding at the module level were also discussed, including relative URLs and cache busting. This allowed us to include favicons in our project.

Additionally, the tutorial explained that Apostrophe, with its built-in webpack-powered process, can manage project frontend JavaScript and stylesheets, compiling and bundling them for frontend delivery. Tips on modifying the project's webpack configuration were also provided. The example in this tutorial illustrates how you could add an alias to further assist with project codebase organization. Of course, modifications to the webpack configuration for other JS and CSS processing are also possible.

Looking ahead, the next focus will be on widgets. These tools enable editors to add layout and content to page and piece areas. Several widgets will be created, ranging from a basic column layout widget to a more complex ratings widget. This will offer insights into adding icons to projects, provide a deeper understanding of field schema conditionals and template helper functions, and introduce async components.

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS > Creating Widgets
DOC_PATH: tutorials/widgets.md
URL: https://apostrophecms.com/docs/tutorials/widgets
================================================================================
# Widget Creation
<iframe src="https://www.youtube.com/embed/KS4o4IUmSGE?si=W6vCP5pZfleMtVUg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the videos and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

In our tutorial on [Creating Pages](/tutorials/pages.html) in our Apostrophe project, we made use of the core widgets for adding content to our home page areas. In this tutorial, we shift focus towards custom widget development, aiming to furnish our editors with unique tools to augment the site's aesthetics.

We will create a basic layout widget, a pivotal step toward accomplishing our final project's envisioned appearance. This will introduce template helper functions, schema field conditionals, and introduce how we register icons for use in our project.

Next we will formulate a CTA 'deal widget', designed to empower editors with the capability of presenting links, garnished with images and headings, in a singular or multiple format. This will introduce some additional options and methods for working with images in schemas and templates.

Finally, we will create a 'rating widget' that allows the editors to add ratings to the different products using a star system. In the creation of this widget, we will also begin to learn about async components, a powerful way to add dynamic content to pages asynchronously, giving your widgets access to site settings and data supplied by APIs, plus we will revisit adding module styling.

Again, you can follow along with the tutorial to modify your own project, or to see the progress of the project while following this tutorial switch to the `sec2-4-widgets` branch of the [apostrophe-onboarding-project](https://github.com/apostrophecms/apostrophe-onboarding-project) repo on GitHub.

## Widget Overview

Creating a new widget is much like creating a new page. A widget module extends the core `@apostrophecms/widget-type` module and requires two files, an `index.js` file, and a `views/widget.html` file. The index file contains the content schema fields for collecting content from the users, as well as helper methods that can extend or alter that content. The `widget.html` file provides a template for generating the markup to display the content. This is like the page module `index.js` and `views/page.html` files.

While widgets and pages have some similarities, there are some key differences. As with pages, the content schema fields of widgets are added through the `fields` property. Unlike page modules, where the `fields` property takes both `add` and `group` properties, widgets take only the `add` property. Fields are not currently grouped by tabs and are added into the modal according to their order in the `add` object.

Another key difference occurs behind the scenes in how Apostrophe handles content added through a page versus a widget. When you save a page, Apostrophe creates a new document in the database. That document and the content within it can be retrieved from the database with a unique id. This isn't true of widgets. They don't exist as documents within the database outside the page where they are added. However, as we will cover when we create the `rating-widget` in this tutorial, each widget gets a unique id that we can use to retrieve content.

Because widgets aren't meant to be stand-alone documents, the markup file that you add to the module is different also. Rather than creating markup for a whole page, you only create a block of HTML code that can be slotted into any page. This means that generally, you aren't going to have a template that you are extending. Although if you have a series of interrelated widgets, you can certainly opt to create a template or fragments to be used within each.

## Creating a layout widget

![Screenshot of the POC home page with the first column of the top area highlighted](../images/sec2-4-top-area-columns.png)
Our home page areas are currently limited to adding widgets that span the whole width of the page. Looking at the final layout of our example project, we can see that the content on the home page is split into columns of different widths. For example, the top area of the homepage is two columns, with the left column taking 33%, and the right 66%.

In the Bootstrap framework, you create rows that are then split up into multiple columns, so we will create a `row-widget`. This `row-widget` can then be added to the homepage areas and will expose new areas corresponding to the number of columns that the user selects

To simplify widget creation, we will use the CLI tool:

`apos add widget row`

This will create a new module with the name `row-widget` in our `modules` folder. Within our new module folder, the CLI tool will create a basic `index.js` file extending the core `@apostrophecms/widget-type` module. It will also provide a `views` folder containing a `widget.html` page. Much like the page-type module will serve HTML from the `modules/custom-page/views/page.html`, for a widget the HTML should be located at `modules/custom-widget/views/widget.html`.

Before this widget will function, we need to add it to the project `app.js` file. You can add `'row-widget': {}` at the end of the `modules` property object. Make sure to separate your new module from the previous one with a comma.

Opening the `modules/row-widget` folder, let's dig into the `index.js` file. Right now our `options` section contains the `label` for the widget that will be displayed to the user for selection within an area. We are going to add two additional options:

<AposCodeBlock>

``` javascript
  options: {
    label: 'Row Widget',
    icon: 'view-column-outline',
    previewIcon: 'view-column-outline'
  },
```
  <template v-slot:caption>
    modules/row-widget/index.js
  </template>

</AposCodeBlock>

We are setting both the `icon` and optional `previewIcon` to the same icon. The `icon` will be shown in the dropdown menu when people select icons during in-context editing on the page. The `previewIcon` will be displayed in the fly-out menu if the area that the `row-widget` is added into has the `expanded: true` option. Remember, in our pages creation tutorial the top area used the in-context dropdown, and the bottom area used the flyout. If we didn't add a `previewIcon` option, the value of the `icon` option would be used instead.

### Registering an icon

The icon being used in this module isn't currently registered by Apostrophe in the [`globalIcons.js`](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/asset/lib/globalIcons.js) file. The icon is available within the [`vue-material-design-icons` v4.12.1 package](https://gist.github.com/BoDonkey/a28419ed8954b57931f80061e5e6a3dd), which is installed in our project. In order to use this icon within our module we need to add a new configuration property to our module's `index.js` file.

``` javascript
// ...
icons: {
  'view-column-outline': 'ViewColumnOutline'
},
// ...
```

Note that `icons` is a top-level property, not within the `options` object. Within the `icons` object we are using a property to define the name that we want to use in our project, `'view-column-outline'`. For value, we are adding the name of the Vue component from the package, leaving the `.vue` suffix off. We could use this same method to install other custom icons. If we added an icon file in our widget module, we would provide a relative path to that file to register it for use. Note, any icon we bring in needs to be a Vue component. Icons can typically be converted to Vue components by copying the wrappers added to the `vue-material-design-icons` package icons.

### Adding fields programmatically

There are a number of different ways that we could add a row with different numbers of columns and will depend on the design system you select. In the end, we want to give the user a choice of one to four columns per row. We also want to allow them to select variants of two columns, where the individual columns take up different widths, like '25%' and '75%'. Each of the columns requires an `area` schema field that is populated with widgets for the user to add content. So, we need to solve two problems. First, we need to display the number of areas that correlates with the value the user selects. Second, we need to add styling to make each column the correct width.

#### Displaying the correct number of areas

``` javascript
area3: {
  label: 'Area 3',
  type: 'area',
  contextual: true,
  options: {
    widgets: fullConfig
  },
  if: {
    $or: [
      { columns: 3 },
      { columns: 4 }
    ]
  }
}
```
To solve the first problem we are going to use conditionals. These optional configuration fields allow you to determine if a schema field is presented to the user based on one or more values. These values can be based on the value of other fields within the same schema, or the results returned by an asynchronous function. Conditionals are created by adding the `if` property to the schema field. That property receives an object that at the simplest, contains one or more `key:value` properties, where the key is equal to the name of another field in the schema, and the value is the exact (`===`) value desired for that field. This can be a string, boolean, or number, but it must match exactly. If there is more than one property in the object, then **all** conditions must match in order for the field to be presented.

The `if` property object can also contain an `$or` property that takes an array of objects. Each of the objects in the array contains a schema field name as a property and the desired match for a value. However, this will evaluate as true if **any** of the fields evaluates as true.

In the example above, we are adding a schema field named `area3`. Most of the other properties being added match what we saw in the earlier tutorial on creating a page, except for the `if` we just discussed. This property is taking an object with an `$or` property with an array of two objects. These objects are telling Apostrophe to show this field if another field in the schema named `columns` has a value of either `3` or `4`.

We could hard code each of the four different areas, as shown in this example, but this wouldn't help with setting the desired styling. Instead, we will create the area schema using a loop. We will also move this code out into a separate file. This isn't required, it is simply a choice to keep the codebase more organized. Create a `modules/row-widget/lib/fields.js` file and add the following code:

<AposCodeBlock>

```javascript
const fullConfig = require('../../../lib/area');
const fields = {
  columns: {
    label: 'Column layout',
    type: 'select',
    help: 'How many columns should this row have?',
    choices: [
      {
        label: 'One full-width column',
        value: 1
      },
      {
        label: 'Two equal-width columns',
        value: 2
      },
      {
        label: 'Three equal-width columns',
        value: 3
      },
      {
        label: 'Four equal-width columns',
        value: 4
      },
      {
        label: 'Two columns, 33% and 66%',
        value: '4-8'
      },
      {
        label: 'Two columns, 66% and 33%',
        value: '8-4'
      },
      {
        label: 'Two columns, 25% and 75%',
        value: '3-9'
      },
      {
        label: 'Two columns, 75% and 25%',
        value: '9-3'
      }
    ]
  }
};

const colsIf = [ null, false, [ 2, 3, 4, '4-8', '8-4', '3-9', '9-3' ], [ 3, 4 ], [ 4 ] ];

for (let i = 1; i <= 4; i++) {
  fields[`area${i}`] = {
    label: `Area ${i}`,
    type: 'area',
    contextual: true,
    options: {
      widgets: fullConfig
    },
    ...(colsIf[i] && {
      if: {
        $or: colsIf[i].map((colName) => {
          return {
            columns: colName
          };
        })
      }
    })
  };
  // uncomment to see the full output for each area
  // console.log(`Output for i = ${i}:`, fields);
}

module.exports = {
  fields
};
```
Walking through each line,
``` javascript
const fullConfig = require('../../../lib/area');
```
  <template v-slot:caption>
    modules/row-widget/lib/fields.js
  </template>

</AposCodeBlock>

First, we are importing the area widget configuration from the project-level `lib` folder. Remember we used this when we were creating the `default-page` page type. As we add our next widgets, we will alter the `area.js` file to export additional configurations, and we will return to alter this `fields.js` file.

``` javascript
const fields = {
  columns: {
    label: 'Column layout',
    type: 'select',
    help: 'How many columns should this row have?',
    def: 1,
    choices: [
      {
        label: 'One full-width column',
        value: 1
      },
      {
        label: 'Two equal-width columns',
        value: 2
      },
      {
        label: 'Three equal-width columns',
        value: 3
      },
      {
        label: 'Four equal-width columns',
        value: 4
      },
      {
        label: 'Two columns, 33% and 66%',
        value: '4-8'
      },
      {
        label: 'Two columns, 66% and 33%',
        value: '8-4'
      },
      {
        label: 'Two columns, 25% and 75%',
        value: '3-9'
      },
      {
        label: 'Two columns, 75% and 25%',
        value: '9-3'
      }
    ]
  }
}
```
Next, we are creating the first schema field for our widget. In this case, it is named `columns` and has a field type of `select` and some help text that will be presented to the user. Our select is getting a default value of `1` using the optional `def` property. The `choices` property receives an array of objects that are each composed of a label that is presented in the dropdown to the user, and the corresponding value for that selection. For the equal-width columns, we are just passing the number of columns desired. For the columns that require different widths, we are passing a string that has the width of each column. Full-width in Bootstrap is `12` columns, 50% width would be `6`, 25% would be `3`, etc... This is idiosyncratic to Bootstrap and will be different with other frameworks.

``` javascript
const colsIf = [ null, false, [ 2, 3, 4, '4-8', '8-4', '3-9', '9-3' ], [ 3, 4 ], [ 4 ] ];
```
The `colsIf` variable gives an array we can use to determine our conditional depending on the selected value. We are padding it with `null` at the beginning to make looping easier.

``` javascript
for (let i = 1; i <= 4; i++) {
  fields[`area${i}`] = {
    label: `Area ${i}`,
    type: 'area',
    contextual: true,
    options: {
      widgets: fullConfig
    },
    ...(colsIf[i] && {
      if: {
        $or: colsIf[i].map((colName) => {
          return {
            columns: colName
          };
        })
      }
    })
  };
  // uncomment to see the full output for each area
  // console.log(`Output for i = ${i}:`, fields);
}
```

Next, we set up a loop to add from 1 to 4 columns. For each iteration, we add an area object to the existing `fields` variable and give that area a name and label based on the counter value. We use the imported configuration to add the same set of widgets to each area. Finally, we use the spread operator to add our conditional field based on the values provided by the `colsIf` array. So, `array1` won't have a conditional since the value is `false`, but `array3` will have a conditional field with an `$or` that will return true only if the user selects either `3` or `4` in the dropdown.

Finally, at the end of this file we have:
```javascript
module.exports = {
  fields
};
```
This will export our newly populated `fields` variable. So, how do we use it?

Open the `modules/row-widget/index.js` file and add:

<AposCodeBlock>

``` javascript
const { fields } = require('./lib/fields');
```
  <template v-slot:caption>
    modules/row-widget/index.js
  </template>

</AposCodeBlock>

This will bring our exported variable into the main file. We can then add:

<AposCodeBlock>

``` javascript
fields: {
  add: fields
},
```
  <template v-slot:caption>
    modules/row-widget/index.js
  </template>

</AposCodeBlock>

This will add all of our schema fields for our widget. While we aren't quite finished with the changes that we need to make to our `index.js` file, let's shift over to creating the templating needed to display our content.

### Templating our layout

In the [Creating Pages](/tutorials/pages.html) tutorial, we touched on the basic usage of Nunjucks. Within these templates, plain HTML markup can be intermixed with tags that are interpreted and utilized during rendering. These include conditional tags that selectively display content and others that provide loops to add repetitive items, like list items. 

If you open the `widget.html` file of our module you will see that a section with an attribute of `data-row-widget` has been added. You can elect to place your code inside this section or eliminate it within your project. In this case, I'm going to eliminate the section because it makes the Bootstrap styling more difficult.

We are going to start with a simplified, non-working version of our final template and modify it. Add the following code to the `modules/row-widget/views/widget.html` file, replacing all of the content:

<AposCodeBlock>

``` nunjucks
<div class="row mb-5">
  {% for column in data.widget.columns %}
    <div class="col-md-{{column}}">
      {% area data.widget, 'area'+loop.index %}
    </div>
  {% endfor %}
</div>
```
  <template v-slot:caption>
    modules/row-widget/views/widget.html
  </template>

</AposCodeBlock>

This markup starts by adding a `div` with Bootstrap classes for margin, `mb-5`, and another class called `row`. The `row` class tells our styling framework that we want this content to be the full width of the container. Using additional Bootstrap classes, we can split the width into multiple columns.

Next, we have a for loop within our `{% %}` tags. In Nunjucks templates, a `for...in` loop takes an array of values. The array items can be simple numbers, strings, or they can be objects. Each array item is passed individually to the code within the loop and the HTML rendered, before progressing to the next array item. In this case, the `for` loop would iterate over an array supplied by the `columns` schema field. The value of this schema field, and any others, is supplied to the template within the `data.widget` object. Directly looping over the array items might work well if we had only allowed the user to specify the number of columns (although a [`range` tag](https://mozilla.github.io/nunjucks/templating.html#range-start-stop-step) would work better in that case), but we also allowed them to specify custom widths. Additionally, our `columns` schema doesn't return an array, only a single value. We will fix this in a moment.

Inside the for loop, we are adding a `div` with a Bootstrap class to specify how much width the column should take. Again, right now this is just for illustration. We are going to need to modify the value of the users choice so that it works in both the `for` loop to add the correct number of columns, and for adding our column class.

Within our column div, we are once again using the `area` template helper. We are passing it the widget data object and asking it to process the area named `'area'+loop.index`. This final portion, `loop.index`, is a special variable that is inside of Nunjucks loops. It provides the current iteration of the loop, starting at 1, and we are concatenating that value onto the `area` string. There are other variables that allow you to easily change markup output for the first item (`loop.first`) or last item (`loop.last`), or perform other operations within the loop.

As written, this code will not function because of the value being returned by the `columns` schema field. We have two requirements, that the value delivered to the template be an array that will work with the `for` loop. Secondly, the array contains a value for each column that reflects the width of the column. This will cause the for loop to iterate over the markup the correct number of times and add the correct width classes. To accomplish this we are going to use a [`helper(self)` configuration function](/reference/module-api/module-overview.md#helpers-self) in our `index.js` file.

#### Creating a Nunjucks helper

The [`helpers(self)` customization function](/reference/module-api/module-overview.md#helpers-self) takes the module as an argument and returns an object of functions that add template utility methods. We have already utilized one helper, `area` to display the content added into our pages area schema fields. In this case we will create a custom helper that will convert the values coming for the `columns` select field into an array. Open the `modules/row-widget/index.js` file and add the following code after the fields object:

<AposCodeBlock>

``` javascript
helpers(self) {
  return {
    layoutToColumns(layout) {
      const layoutMap = {
        1: [ 12 ],
        2: [ 6, 6 ],
        3: [ 4, 4, 4 ],
        4: [ 3, 3, 3, 3 ],
        '4-8': [ 4, 8 ],
        '8-4': [ 8, 4 ],
        '3-9': [ 3, 9 ],
        '9-3': [ 9, 3 ]
      };
      return layoutMap[layout] || [ 12 ];
    }
  };
}
```
  <template v-slot:caption>
    modules/row-widget/index.js
  </template>

</AposCodeBlock>

This code declares a new helper function called `layoutToColumns(layout)` that takes the `columns` value and converts it to an array of values that correspond to the number and width of the columns to be added. This array is then returned. Now we need to add it to our template.

Open the `modules/row-widget/views/widget.html` file and add the following at the top of the file.

<AposCodeBlock>

``` nunjucks
{% set cols = apos.modules['row-widget'].layoutToColumns(data.widget.columns) %}
```
  <template v-slot:caption>
    modules/row-widget/views/widget.html
  </template>

</AposCodeBlock>

This line calls the new helper function using `apos.modules['row-widget'].layoutToColumns(data.widget.columns)`, passing in the value of the `columns` schema field as an argument. We could simplify this call by adding an `alias` option to our module. For example, adding `alias: 'row'`, would shorten this to `apos.row.layoutToColumns(data.widget.columns)`. The returned value of our helper function is assigned to the `cols` variable using the Nunjucks `{% set %}` tag. Now we can alter the for loop to:

<AposCodeBlock>

``` nunjucks
{% for column in cols %}
```
  <template v-slot:caption>
    modules/row-widget/views/widget.html
  </template>

</AposCodeBlock>

#### Using the row widget

Now that we have a functional row widget, we need to add it to the areas where we want to utilize it. For our tutorial project, I added it to the homepage `topArea` and `bottomArea` widget lists. To accomplish this, open the `modules/@apostrophecms/home-page/index.js` file and add `row: {}` to the `widgets` object of both areas. At this point, you could spin your project up and take the new row widget for a spin!

Remember, to edit a page you need to be logged in, then just navigate to the page and click the edit button at the upper right. If you don't see the new row widget in your areas when you open the drop-down or flyout menus, you may need to clear your former builds first before bringing the project up, making sure to pass the `APOS_DEV=1` flag. So: `rm -rf apos-build data && APOS_DEV=1 npm run dev`.

## Creating a CTA widget

<iframe src="https://www.youtube.com/embed/TZzXsBNWGbQ?si=gJKZsNhnOSxxi858" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

![Screenshot of the deal widget from the proof-of-concept site](../images/sec2-4-deal-widget.png)

As practice and to reiterate the key concepts in creating a widget, we are next going to make a simple widget that will allow the user to set up a call-to-action area on the page that includes an image and URL link. This widget is used on the right side of the bottom area of the tutorial project homepage.

Again, by convention, a widget module folder is named with a `-widget` suffix and contains `index.js` and `views/widget.html` files. We can use the CLI tool to create this basic structure using:

``` sh
apos add widget deal
```
> ‚ö†Ô∏è Remember to add the new widget into the `app.js` after creation.

### Adding the schema fields

Open the newly-created `module/deal-widget/index.js` file and add the following code:

<AposCodeBlock>

``` javascript
module.exports = {
  // extending a core module creates a new instance of that module type
  // with a new name, but all the same functions
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Deal Widget'
  },
  fields: {
    add: {
      title: {
        type: 'string',
        label: 'Deal Title',
        required: true
      },
      link: {
        type: 'url',
        label: 'Deal Link',
        required: true
      },
      image: {
        type: 'area',
        label: 'Deal Image',
        max: 1,
        required: true,
        options: {
          widgets: {
            '@apostrophecms/image': {
              aspectRatio: [ 16, 9 ],
              minSize: [ 1200, 675 ]
            }
          }
        }
      }
    }
  }
};

```
  <template v-slot:caption>
    module/deal-widget/index.js
  </template>

</AposCodeBlock>

We are adding three required schema fields. A `title` field of the `string` type, a `link` field of the `url` type, and finally, we are adding an image using an `area` field with an `@apostrophecms/image` core widget. In this final `image` field, we are specifying that the user can only add a single image using the `max: 1` property.

Within the image widget we are limiting the image to an aspect ratio of `16:9` with a minimum horizontal resolution of `1200px` and a minimum vertical resolution of `675px`. In this way, you can ensure that any images added by the user won't break the design. If the user adds an image that has a different aspect ratio, Apostrophe will apply an automatic crop to the image. The user can adjust how the image is cropped using the editing tools, but will still be restrained to the 16:9 aspect ratio. Any images not meeting the resolution minimums won't be presented to the user as a choice.

### Creating the template
Add the following to the `modules/deal-widget/views/widget.html` file:

<AposCodeBlock>

``` nunjucks
<!-- Use a helper to get the image. Use the Nunjucks `set` to create a variable -->
{% set image = apos.image.first(data.widget.image) %}

<!-- Even though the image field is required, it's possible that the image
  has been deleted. So we need to check for that. -->
{% if image %}
  <!-- Uncomment the line below to see other available data -->
  {# {{ apos.log('image data', image) }} #}
  {% set imageUrl = apos.attachment.url(image, {size: 'one-sixth' }) %}
  {% set altText = image.alt %}
{% else %}
  {% set imageUrl = 'https://picsum.photos/200' %}
{% endif %}

<section data-deal-card-widget class="align-items-center mb-2 border-2 border-bottom border-info row">
  <div class="col-12 col-md-6 order-last order-md-first">
    <p class="lead"><a href="{{ data.widget.url }}" class="text-decoration-none">{{ data.widget.title }}</a></p>
  </div>
  <div class="col-12 col-md-6">
    <img class="image-fit-center-center img-fluid" src="{{ imageUrl }}" alt="{{ altText }}">
  </div>
</section>
```
  <template v-slot:caption>
    modules/deal-widget/views/widget.html
  </template>

</AposCodeBlock>

In the first line of this template, we are setting the value of the `image` variable to the object added to our `image` schema field. We are using a built-in method, `apos.image.first()`. This allows us to get the first image added to an area. While we are passing in the `image` schema field as an argument, this same helper can be used to get the first image on a page or within any other document. You can also add an optional object to return the first image of a certain type - `apos.image.first( page.body, { extension: 'gif'} )`. You might be able to guess from the name that this is a method defined in the `@apostrophecms/image` module.

::: v-pre
The next block of code makes sure that the image object exists and if not, loads in a holder image. If it does exist another built-in method is used to get the URL of a specific size image. In this case, we are getting the `one-sixth` size. By default, when you upload an image using the media library [there are six resized images saved](/reference/modules/attachment.md#imagesizes) in addition to the original - 'max', 'full', 'two-thirds', 'one-half', 'one-third', and 'one-sixth'. These default sizes can be changed through configuration of the `@apostrophecms/attachment` module. We are also setting the alt text for the image from the `image` variable. You can use `{{ apos.log('image data', image) }}` to see what other info is available.

Finally, we are using standard markup and Nunjucks tags to construct our final deal card HTML.

### Using the deal widget
Like the `row-widget`, we will be using the `deal-widget` on the home page. Once again, we could add it to the top and bottom areas of the homepage. However, since we added the area configuration for our rows from the `lib/area.js` file, let's instead add it there. Open the file and modify the code to look like the following:

<AposCodeBlock>

``` javascript
/*
This file provides an easy way to populate any areas in the project with widgets.
*/
const basicConfig = {
  '@apostrophecms/image': {
    // This option will add these classes to any image
    className: 'img-fluid image-fit-center-center'
  },
  '@apostrophecms/video': {},
  '@apostrophecms/html': {},
  '@apostrophecms/rich-text': {
    toolbar: [
      'styles',
      '|',
      'bold',
      'italic',
      'strike',
      'link',
      '|',
      'bulletList',
      'orderedList',
      '|',
      'blockquote',
      'codeBlock',
      '|',
      'undo',
      'redo'
    ],
    styles: [
      {
        tag: 'p',
        label: 'Paragraph (P)'
      },
      {
        tag: 'h2',
        label: 'Heading 2 (H2)'
      },
      {
        tag: 'h2',
        label: 'Special underline',
        class: 'custom-underline display-6 ps-2'
      },
      {
        tag: 'h3',
        label: 'Heading 3 (H3)'
      },
      {
        tag: 'h4',
        label: 'Heading 4 (H4)'
      }
    ],
    insert: [
      'table',
      'image',
      'horizontalRule'
    ]
  }
};

const fullConfig = {
  ...basicConfig,
  deal: {}
};

module.exports = {
  basicConfig,
  fullConfig
};

```
  <template v-slot:caption>
    lib/area.js
  </template>

</AposCodeBlock>

By altering the file in this way we are creating two named exports and eliminating the default export. This means that we need to alter the import in the `modules/row-widget/lib/fields.js` file to:

<AposCodeBlock>

``` javascript
const { fullConfig } = require('../../../lib/area');
```
  <template v-slot:caption>
    modules/row-widget/lib/fields.js
  </template>

</AposCodeBlock>

You can now spin up your site and add a deal widget. First, add a row widget to either the top or bottom area and select a column size. Second, add a deal widget and populate the fields with title, link, and image. In a real production site it would probably be better to modify the link field to give the user a choice between an existing page or an outside URL. We will build this when we are creating our site navigation.

## Creating the rating widget

<iframe src="https://www.youtube.com/embed/x2tHUIvJr9w?si=nrrAisMGN64cuA-S" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

What is a review site without the ability of the authors and readers to submit ratings!? To wrap up our tutorial on widgets we will take a look at another way to deliver template content and begin the creation of our ratings widget. We will create a section for editors to add their product ratings from a set of schema fields, and a way for reader's to submit their ratings on the front end. This will highlight an important aspect of widget creation, adding a 'player' for front-end JavaScript.

### Adding the async component method

Again, we will start with the CLI tool to create the base files: `apos add widget rating --player`. We are using the `--player` flag to have the tool create the folder and file structure for adding our JavaScript. Don't forget to add the new `rating-widget` to the `app.js` file to register it after creation.

We will start by adding the ability for the editor to add a rating to the product review. Open up the `index.js` file and add the following code:

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Rating Widget',
  },
  fields: {
    add: {
      productQuality: {
        type: 'range',
        label: 'Product Quality',
        min: 1,
        max: 5,
        step: 1,
        def: 1
      },
      productSafety: {
        type: 'range',
        label: 'Product Safety',
        min: 1,
        max: 5,
        step: 1,
        def: 1
      },
      productValue: {
        type: 'range',
        label: 'Product Value',
        min: 1,
        max: 5,
        step: 1,
        def: 1
      }
    }
  },
  components(self) {
    return {
      async stars(req, data) {
        // Performs any data manipulation or retrieval
        // before it is passed to the component template
        // In this case, we are just passing the starsData from the widget
        return {
          starsData: data.starsData
        };
      }
    };
  }
};

```
  <template v-slot:caption>
    modules/rating-widget/index.js
  </template>

</AposCodeBlock>

While the schema fields in this code are of a new type, the majority of the code should look familiar. The `range` field type allows the developer to specify a range of numbers from `min` to `max` that the user can enter using a slider. You can optionally add a `step` size that determines the interval between each value. This code adds three different schema fields to collect quality, safety, and value ratings, all added to the `basics` tab. 

The last section of code is the novel part. In our template, we want to convert the number entered by the user into stars displayed on the front end. We could use a loop directly in the template, but we would have to add the loop code to the template three times, one for each schema field. Instead, we will use an `async components()` customization function. Components are a little like fragments. Unlike fragments, however, you can run a database query or fetch information from a 3rd party API to populate it. You can also access site information to further customize your widget to things like locale.

At the moment, this component is very simple. We will expand on it when we add the reader section of the widget to collect information on the frontend. A component function takes the module as an argument and returns an object of functions that can be used within templates. There are two differences from the `helper()` functions that we have already learned about. First, `helpers` must be synchronous, `components` can be asynchronous. Second, `components` return markup to the template, rather than a value or object.

![Component request cycle](../images/sec2-4-components.png)

In the code for the `components(self)` configuration method we are returning a single function named `stars()`. This function takes two arguments - `req`, the request object from the originating template and `data`, an object with the data payload passed from the template where the component is used. Our component method is then returning an object with a `starsData` property set to the `starsData` value sent from our template. This data payload is then sent to our component template, `stars.html`. As covered, `components` return markup to the originating template. The markup being returned here is derived from another template, `stars.html`, named with the same file name as the component method name. This template has access to the data returned by our component method on the `data` object.

### Creating the component template

Create the `modules/rating-widget/views/stars.html` file and add the following code:

<AposCodeBlock>

``` nunjucks
{% set stars = data.starsData %}
{% for x in range(1, 6) %}
  {% if x <= stars %}
    <i class="fas fa-star"></i>
  {% else %}
    <i class="far fa-star"></i>
  {% endif %}
{% endfor %}
```
  <template v-slot:caption>
    modules/rating-widget/views/stars.html
  </template>

</AposCodeBlock>

This template contains a simple `for...range` loop that will increment a counter from 1 to 5 (not including the stop value of 6) and compare that value to the star value entered by the author. If the counter value is less than or equal to the entered value, a filled star from the font-awesome library is added. Otherwise, an empty star from the same library is added to the markup. I can hear those in the back mumbling - "Don't we already have an icon library, why don't we register a new one from there?" While it is true that we have a library of icons, they are all Vue components for use in the admin UI, we need a different set of icons for the front end.

### Creating the widget template

Open the `modules/rating-widget/views/widget.html` file and replace the existing content with the following code

<AposCodeBlock>

``` nunjucks
<section class="container" data-rating-widget>
  <div class="row">
    <div class="card mb-3 col-md-6">
      <div class="card-body">
        <h5 class="card-title">Apostrophe Product Ratings</h5>
        <div class="card-text">
          <div class="row mb-3">
            <p class="mb-1">Quality:</p>
            <div class="fontawesome-rating">
              {% component 'rating-widget:stars' with { starsData: data.widget.productQuality } %}
            </div>
          </div>
          <div class="row mb-3">
            <p class="mb-1">Safety:</p>
            <div class="fontawesome-rating">
              {% component 'rating-widget:stars' with { starsData: data.widget.productSafety } %}
            </div>
          </div>
          <div class="row mb-3">
            <p class="mb-1">Value:</p>
            <div class="fontawesome-rating">
              {% component 'rating-widget:stars' with { starsData: data.widget.productValue } %}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
```
  <template v-slot:caption>
    modules/rating-widget/views/widget.html
  </template>

</AposCodeBlock>

Our template for this widget is almost all straight HTML markup except for three calls to our component function. Within each `<div class="fontawesome-rating">` we have a Nunjucks tag, `{% component 'rating-widget:stars' with { starsData: data.widget.XXX } %}`. This is saying that we want to use the component function named `stars` defined in the `rating-widget`. To call a component method defined in a different module it would be changed to `{% component 'custom-module:methodName' %}`. We are passing an object to our function using `with`. In this case, it is an object with a single property, `starsData`, that will be available in the `data` object passed to our method. In each component call, we are passing in the schema field value for that category, whether quality, safety, or value. You can pass any data available in the template to the component method in this manner, although passing in the entire template data object can cause performance issues.

### Adding the widget styling and font-awesome

The last step we need to perform to get our rating-widget ready to add to pages is to add the font-awesome font that we used for displaying the rating. Font-awesome is available as a CDN-delivered resource, so we are going to add it to our project this way. There are a number of areas where we could elect to add this resource. If we plan on using the font in other areas of the site, it might make sense to add it to a stylesheet loaded in the `modules/asset/ui/src` folder. In this case, we are only going to be using it in the `rating-widget` module, so instead we will create a `modules/rating-widget/ui/src/index.scss` file and add the following:

<AposCodeBlock>

``` scss
@import url("https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.8.2/css/all.min.css");
@import './scss/_font-awesome-stars';
```
  <template v-slot:caption>
    modules/rating-widget/ui/src/index.scss
  </template>

</AposCodeBlock>

Here we are importing the font-awesome font and also a file for the additional widget styling. The additional styling is going to be very simple, but I like to mainly use the index file to import other files, not directly add style rules. Create the `modules/rating-widget/ui/src/scss/_font-awesome-stars.scss` file and add the following:

<AposCodeBlock>

``` scss
.fa-star:before {
  color: var(--bs-info);
  font-size: 20px;
}
```
  <template v-slot:caption>
    modules/rating-widget/ui/src/scss/_font-awesome-stars.scss
  </template>

</AposCodeBlock>

![Screenshot of the rating widget](../images/sec2-4-final-ratings-widget.png)
The only other thing we need to do to is add our new widget and spin the project up to see what it looks like. In the end, we are going to add it into our review piece, but for now, you can add it to the area in the `default-page` module and the `lib/area.js` file in the `fullConfig` section to be able to use it on the homepage. Once again, you may need to remove the `apos-build` and `data` folders, plus start-up with the `APOS_DEV=1` variable set.

## Adding the reader feedback to the rating-widget

![Screenshot of the user rating submission section added to the rating-widget](../images/sec2-4-user-rating-input.png)

Now we have built an area where our editors can give their ratings on the products being reviewed. Now we need to implement a way for the readers of the site to provide feedback on the products. Extending the rating-widget will accomplish two goals, in terms of this tutorial series.
1) It will introduce us to "players", a way to add custom browser-side JavaScript for powering our widget.
2) We need to capture the reader response in the database, so we will get to learn about the `apiRoute(self)` configuration function and can begin to explore how we can interact with the database.

### Creating the markup

We want to duplicate our existing widget layout in order to add a section where readers can add a rating to a product review. To accomplish this first step we will update the markup for the widget.

At the top of the `modules/rating-widget/views/widget.html` file add:

<AposCodeBlock>

``` nunjucks
{% set widgetId=data.widget._id %}
```

<template v-slot:caption>
  modules/rating-widget/views/widget.html
</template>

</AposCodeBlock>

This code will set a variable, `widgetId` for use in our markup. We are getting this value from the `data.widget` object that is available in every widget. This is just like the `data.piece` object available on pages. This value will be used to link a database record containing the data that the reader submits to the corresponding rating widget.

Next, add the following code after the markup for the first column with a class of `card` that we added previously, inside the div with a class of `row`:

<AposCodeBlock>

``` nunjucks
<div class="card mb-3 col-md-6">
  <div class="card-body" data-reader-card data-widget-id={{widgetId}}>
    <h5 class="card-title">Submit your rating</h5>
    <div class="card-text">
      <div class="row mb-3">
        <p class="mb-1">Quality:</p>
        <div class="rating">
          <span class="simple-rating" data-category="quality" data-default-rating="3"></span>
        </div>
      </div>
      <div class="row mb-3">
        <p class="mb-1">Safety:</p>
        <div class="rating">
          <span class="simple-rating" data-category="safety" data-default-rating="3"></span>
        </div>
      </div>
      <div class="row mb-3">
        <p class="mb-1">Value:</p>
        <div class="rating">
          <span class="simple-rating" data-category="value" data-default-rating="3"></span>
        </div>
      </div>
      <div class="row">
        <button class="btn btn-primary" data-submit-rating>Submit</button>
      </div>
    </div>
  </div>
</div>
```

<template v-slot:caption>
  modules/rating-widget/views/widget.html
</template>

</AposCodeBlock>

This markup adds the same three fields for 'Quality', 'Safety', and 'Value' that we added for displaying the values selected by the editor. We will circle back to how to use various data attributes when we add our player code. The important thing to understand at this point is that the player code can't access the widget or page data. Instead, any data to be used in a player should be added as data attributes to the markup which can later be retrieved browser-side by the player code.

### Adding the widget player
While we could add an inline script to our widget for browser-side JavaScript, it makes more sense to add a "player". Code added this way will be run when the editable area of the page is refreshed during editing. This isn't guaranteed with inline scripts, which can lead to a loss of dynamic content and event listeners.

Player code can be added in the `ui/src/index.js` file of any module, or a file imported by it. Open the `modules/rating-widget/ui/src` folder and create an index.js file. Paste the following code:

<AposCodeBlock>

``` javascript
// Export the main anonymous function
export default () => {
  // Define SimpleStarRating constructor function that takes a target element as argument
  const SimpleStarRating = function (targetElement) {
    // Helper function to get attribute from the target element
    function fetchAttribute(attributeName, defaultValue) {
      return targetElement.getAttribute(attributeName) || defaultValue;
    }

    // Initialize variables
    const maximumStars = parseInt(fetchAttribute('data-stars', 5));
    let defaultStarRating = parseFloat(fetchAttribute('data-default-rating', 0));
    let currentStarRating = -1;
    const starElements = [];

    // Style the target element
    targetElement.style.display = 'inline-block';

    // Create star elements
    for (let index = 0; index < maximumStars; index++) {
      const star = document.createElement('span');
      star.className = 'far fa-star';
      star.addEventListener('click', handleStarClick);
      if (index > 0) {
        starElements[index - 1].appendChild(star);
      } else {
        targetElement.appendChild(star);
      }
      starElements.push(star);
    }

    // Function to set the current rating
    function setCurrentRating(rating) {
      currentStarRating = rating;
      targetElement.setAttribute('data-rating', currentStarRating);
      displayCurrentRating();
    }

    // Event listeners for mouse events
    targetElement.addEventListener('mouseout', function () {
      displayCurrentRating();
    });

    targetElement.addEventListener('mouseover', function () {
      clearStarRating();
    });

    // Show the default rating initially
    displayDefaultRating();

    // Helper function to display rating
    function displayRating(rating) {
      clearStarRating();
      for (let i = 0; i < starElements.length; i++) {
        if (i >= rating) break;
        starElements[i].classList.replace('far', 'fas');
      }
    }

    // Function to display the current rating
    function displayCurrentRating() {
      const ratingAttribute = parseFloat(fetchAttribute('data-rating', 0));
      if (ratingAttribute) {
        currentStarRating = ratingAttribute;
        displayRating(currentStarRating);
      } else {
        displayDefaultRating();
      }
    }

    // Function to display the default rating
    function displayDefaultRating() {
      defaultStarRating = parseFloat(fetchAttribute('data-default-rating', 0));
      displayRating(defaultStarRating);
    }

    // Function to clear the star rating display
    function clearStarRating() {
      for (let i = 0; i < starElements.length; i++) {
        starElements[i].classList.replace('fas', 'far');
      }
    }

    // Function to handle clicking on a star
    function handleStarClick(event) {
      if (this === event.target) {
        const clickedStarIndex = starElements.indexOf(event.target);
        if (clickedStarIndex !== -1) {
          const newRating = clickedStarIndex + 1;
          setCurrentRating(newRating);
        }
      }
    }
  };

  // Register the SimpleStarRating as a widget player for ApostropheCMS
  apos.util.widgetPlayers.rating = {
    selector: '[data-rating-widget]',
    player: function (element) {
      const ratingElements = element.getElementsByClassName('simple-rating');
      for (let i = 0; i < ratingElements.length; i++) {
        const ratingElement = ratingElements[i];
        // Remove existing child spans
        while (ratingElement.firstChild) {
          ratingElement.removeChild(ratingElement.firstChild);
        }
        const _simpleStarRating = new SimpleStarRating(ratingElement);
      }

      const submitButton = element.querySelector('[data-submit-rating]');
      const ratingCard = element.querySelector('[data-reader-card]');
      const widgetId = ratingCard.getAttribute('data-widget-id');

      // Attach click event to the submit button
      submitButton.addEventListener('click', async () => {
        // Collect ratings
        const ratings = {};
        Array.from(ratingElements).forEach((el) => {
          const category = el.getAttribute('data-category');
          const rating =
            el.getAttribute('data-rating') ||
            el.getAttribute('data-default-rating');
          ratings[category] = Number(rating);
        });

        const averageRatings = await sendRatingsToServer(
          ratings,
          widgetId
        );
        // Remove the submit button
        submitButton.remove();

        // Replace the rating elements with a thank you message and average ratings
        ratingCard.innerHTML = `
            <h5 class="card-title">Thank you for your ratings!</h5>
            <div class="card-text">
              <p>Average Ratings from ${averageRatings.ratingsCount} reviews</p>
              <div>
                <p class="mb-1">Quality:</p>
                <div class="rating">${generateStars(
                  averageRatings.averageQuality
                )}</div>
              </div>
              <div>
                <p class="mb-1">Safety:</p>
                <div class="rating">${generateStars(
                  averageRatings.averageSafety
                )}</div>
              </div>
              <div>
                <p class="mb-1">Value:</p>
                <div class="rating">${generateStars(
                  averageRatings.averageValue
                )}</div>
              </div>
            </div>
          `;
      });
    }
  };

  async function sendRatingsToServer(ratings, widgetId) {
    const baseURL = window.location.origin;
    const endpoint = `${baseURL}/api/v1/rating-widget/submit`;
    const data = {
      ratings: ratings,
      widgetId: widgetId
    };

    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const responseData = await response.json();
      console.log('Success:', responseData);
      return responseData;
    } catch (error) {
      console.error('Error:', error);
      return null;
    }
  }

  function generateStars(rating, maxStars = 5) {
    let starsHTML = '';
    for (let i = 1; i <= maxStars; i++) {
      if (i <= rating) {
        starsHTML += '<span class="fas fa-star"></span>';
      } else if (i === Math.ceil(rating) && i !== rating) {
        starsHTML += '<span class="fas fa-star-half-alt"></span>';
      } else {
        starsHTML += '<span class="far fa-star"></span>';
      }
    }
    return starsHTML;
  }
};

```

<template v-slot:caption>
 modules/rating-widget/ui/src/index.js
</template>

</AposCodeBlock>

This is a lot of code, and we aren't going to cover it all. We will go through the sections that are generally applicable to Apostrophe, not the code associated with the behavior of the UI that is common JavaScript. Let's start by looking at the overall structure of the code.

``` javascript
export default () => {
  const SimpleStarRating = function (targetElement) {
    ...
  }

  apos.util.widgetPlayers.rating = {
    ...
  }

  async function sendRatingsToServer(ratings, widgetId, docId) {
    ...
  }

  function generateStars(rating, maxStars = 5) {
    ...
  }
};
```

The player file must export a default function. In this case, within that exported function we are defining a constructor, `SimpleStarRating`.  It initializes a new `SimpleStarRating` object, sets up its properties and methods, and performs some initial actions like setting up the star elements for the default rating and adding event listeners. This constructor function encapsulates all the behavior and properties needed for the star rating functionality. We will only look at the code for this constructor briefly.

The `apos.util.widgetPlayers.rating` adds the player code to an object of widget players, `apos.util.widgetPlayers` using the widget name, excluding the `-widget` suffix. We will take a deeper dive into how this is structured.

There are two additional helper functions included in the export. The first asynchronous function, `sendRatingsToServer()` is responsible for initiating the database connection and transferring the data. We will also look at this in depth. The second method, `generateStars()` is used for UI behavior and will only be mentioned when looking at the main player code.

### The `SimpleStarRating` constructor

``` javascript
const SimpleStarRating = function (targetElement) {
  // Helper function to get attribute from the target element
  function fetchAttribute(attributeName, defaultValue) {
    return targetElement.getAttribute(attributeName) || defaultValue;
  }
  ...
};
```

Starting at the beginning of the constructor, we define a helper function called `fetchAttribute()` since we will be accessing markup attributes repeatedly to gather data passed from the `data.widget` object into the front-end markup. This function will get the specified attribute from the `targetElement` and if it doesn't exist it will pass back the `defaultValue`.

``` javascript
 // Initialize variables
    const maximumStars = parseInt(fetchAttribute('data-max-stars', 5));
    let defaultStarRating = parseFloat(fetchAttribute('data-default-rating', 0));
    let currentStarRating = -1;
    const starElements = [];
```
Next we are initializing some variables. The most important one for this tutorial is `defaultStarRating`. Remember that in the markup, each of our three sections had a `data-default-rating` attribute.

``` nunjucks
<span class="simple-rating" data-category="quality" data-default-rating="3"></span>
```
Our target element doesn't have a `data-max-stars` attribute, but this would give us the ability to change the number of stars from a slight change to the markup and a schema field asking the editor to assign a maximum number.

``` javascript
// Create star elements
for (let index = 0; index < maximumStars; index++) {
  const star = document.createElement('span');
  star.className = 'far fa-star';
  star.addEventListener('click', handleStarClick);
  if (index > 0) {
    starElements[index - 1].appendChild(star);
  } else {
    targetElement.appendChild(star);
  }
  starElements.push(star);
}
```
Skipping slightly down in the code there is a loop that adds all the stars into our target element. While this isn't specific to Apostrophe, I'm pointing it out to remind you that our stars are being added using font-awesome, just like in the editor card.

``` javascript
// Function to set the current rating
function setCurrentRating(rating) {
  currentStarRating = rating;
  targetElement.setAttribute('data-rating', currentStarRating);
  displayCurrentRating();
}
```
The last method we are going to look at in our constructor is `setCurrentRating`. This method is called on a click of one of the rating stars and sets an attribute of `data-rating` equal to the value of the star on the parent span before updating the display. This isn't an Apostrophe-specific method, just a valuable pattern to use for widget players.

### The `apos.util.widgetPlayers.rating` object

``` javascript
apos.util.widgetPlayers.rating = {
   selector: '[data-rating-widget]',
   player: function (element) {
     ...
   }
}
```

The `apos.util.widgetPlayers.rating` object takes two properties. The `selector` property takes a value that identifies the widget HTML in the page.

``` nunjucks
<section class="container" data-rating-widget>
```

This selector was added when we first initiated construction of this widget. This selector does not need to be unique on the page. This is important because a user can add several of the same widget to the page. Apostrophe is smart enough to hook a specific player instance to a specific widget.

The second property is `player` and takes a function with the DOM element matching the selector as argument. This is where you are going to add the code that manipulates and takes input from your widget. This is the code that should update the widget or add event listeners upon page load or refresh. As shown in this example, you can export additional helper functions that are used in the player. They will still be exposed on the front-end, they just won't be refreshed with the rest of the code in the `apos.util.widgetPlayers` object.

``` javascript
player: function (element) {
  const ratingElements = element.getElementsByClassName('simple-rating');
  for (let i = 0; i < ratingElements.length; i++) {
    const ratingElement = ratingElements[i];
    // Remove existing child spans
    while (ratingElement.firstChild) {
      ratingElement.removeChild(ratingElement.firstChild);
    }
    const _simpleStarRating = new SimpleStarRating(ratingElement);
  }
...
```
The code for the player begins by getting all the elements in our widget with a class name of `simple-rating`. Looking back at our markup, each of the three sections - 'quality', 'safety', and 'value' - all have a span with this class.
``` nunjucks
<p class="mb-1">Quality:</p>
<div class="rating">
  <span class="simple-rating" data-category="quality" data-default-rating="3"></span>
</div>
```
The array of these elements is passed into a for loop, any existing star element arrays are removed and each gets a new `SimpleStarRating` constructor instantiated that adds the correct stars based on the `data-default-rating`.

``` javascript
const submitButton = element.querySelector('[data-submit-rating]');
const ratingCard = element.querySelector('[data-reader-card]');
const widgetId = ratingCard.getAttribute('data-widget-id');
```

Next, we are selecting the submission button within the DOM so that we can add an event listener. We are also selecting the reader input card added by the new markup, both to allow us to get the `widgetId` value passed from the `data.widget` object through the attribute added to the markup, and to later change the HTML after the user makes a submission.

``` javascript
submitButton.addEventListener('click', async () => {
  // Collect ratings
  const ratings = {};
  Array.from(ratingElements).forEach((el) => {
    const category = el.getAttribute('data-category');
    const rating =
      el.getAttribute('data-rating') ||
      el.getAttribute('data-default-rating');
    ratings[category] = Number(rating);
  }
  ...
```
The remainder of the `player` function adds an event listener to the submission button. Upon click it first collects the ratings from each of the sections. It uses the `data-category` and either `data-rating` or `data-default-rating` attributes, depending on whether the reader has selected a rating star. These ratings then get pushed to an array. The data attributes we are getting back are strings, so we are coercing them to numbers before storing them.

``` javascript
const averageRatings = await sendRatingsToServer(
    ratings,
    widgetId
  );
```
Those ratings, along with identifiers for the specific widget and the document to which the widget has been added, are passed to the `sendRatingsToServer` method. The values returned from that function are assigned to the `averageRatings` variable for later use.

``` javascript
// Remove the submit button
  submitButton.remove();
```
Next, to make sure the user doesn't submit again (until page refresh), the submission button is removed. Obviously in production code you would want a better methodology, like storing a cookie, to additionally prevent this type of behavior.

``` javascript
// Replace the rating elements with a thank you message and average ratings
ratingCard.innerHTML = `
  <h5 class="card-title">Thank you for your ratings!</h5>
  <div class="card-text">
    <p>Average Ratings from ${averageRatings.ratingsCount} reviews</p>
    <div>
      <p class="mb-1">Quality:</p>
      <div class="rating">${generateStars(
        averageRatings.averageQuality
      )}</div>
    </div>
    <div>
      <p class="mb-1">Safety:</p>
      <div class="rating">${generateStars(
        averageRatings.averageSafety
      )}</div>
    </div>
    <div>
      <p class="mb-1">Value:</p>
      <div class="rating">${generateStars(
        averageRatings.averageValue
      )}</div>
    </div>
  </div>
`;
```
Finally, we are replacing the existing markup for the reader submission section to reflect the running average rating in each category and the total number of reviews. The data returned from the server by the `sendRatingsToServer()` function is used to populate the markup with the total number of reviews and stars representing the running average for each section using the `generateStars()` helper function. Feel free to examine the `generateStars()` function on your own.

### The `sendRatingsToServer` method

``` javascript
async function sendRatingsToServer(ratings, widgetId) {
  const baseURL = window.location.origin;
  const endpoint = `${baseURL}/api/v1/rating-widget/submit`;
  const data = {
    ratings: ratings,
    widgetId: widgetId
  };

  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const responseData = await response.json();
    console.log('Success:', responseData);
    return responseData;
  } catch (error) {
    console.error('Error:', error);
    return null;
  }
}
```
There are different methods for updating the database from a user submission. For the `@apostrophecms/form` extension, an `$emit` is used that has the form document. The module has a `handler(self)` that listens for that signal and saves the form to the database. In this case, we are going to use HTTP `POST` and a `routeAPI(self)` configuration function in our module.

This method starts by setting the `baseURL` value to the base URL of the site and then constructing the endpoint for our POST. In this case we are going to create a route named `submit`. All the data for the body of the POST is added to the `data` variable.

Next, we set up a try/catch block to initiate the fetch and get back either response data or an error from the route. Again, any returned data is passed back to the click listener to repopulate the HTML displayed to the user.

### Adding the `apiRoutes(self)` configuration method

Except for a tiny bit of styling, setting up the `apiRoutes(self)` configuration method in the parent `rating-widget/index.js` file is the last step. Open the `modules/rating-widget/index.js` file and add the following code after the `components(self)` configuration method:

<AposCodeBlock>

``` javascript
apiRoutes(self) {
  return {
    post: {
      async submit(req) {
        // Destructure input ratings and identifiers from the request body
        const { quality = 3, safety = 3, value = 3 } = req.body.ratings;
        const { widgetId } = req.body;

        const ratingDocument =
          (await fetchRatingDocument(req, widgetId)) ?? {};

        // Calculate new average ratings
        const newAverages = calculateNewAverages(
          ratingDocument,
          quality,
          safety,
          value
        );

        // Update the document with new average ratings
        await updateDocument(widgetId, newAverages);

        return newAverages;
      }
    }
  };
  // Fetches the rating document from the database
  async function fetchRatingDocument(req, widgetId) {
    const criteria = { _id: widgetId };
    return await self.apos.db.collection('reviewRatings').findOne(criteria);
  }

  // Calculate new average ratings
  function calculateNewAverages(ratingDocument, quality, safety, value) {
    // Destructure existing averages and count, using -1 as a fallback for missing averages
    const {
      averageQuality = -1,
      averageSafety = -1,
      averageValue = -1,
      ratingsCount = 0
    } = ratingDocument;

    // Function to update the average, includes formula explanation
    const updateAverage = (oldAverage, newValue, count) => {
      // If there were no reviews yet, the new value becomes the average
      if (oldAverage === -1) return newValue;
      // Formula to update the running average
      return parseFloat(
        ((oldAverage * (count - 1) + newValue) / count).toFixed(1)
      );
    };

    return {
      // Update each average using the helper function
      averageQuality: updateAverage(averageQuality,quality,ratingsCount + 1),
      averageSafety: updateAverage(averageSafety, safety, ratingsCount + 1),
      averageValue: updateAverage(averageValue, value, ratingsCount + 1),
      // Increment the ratings count
      ratingsCount: ratingsCount + 1
    };
  }

  // Updates the document in the database
  async function updateDocument(widgetId, newAverages) {
    try {
      const { averageQuality, averageSafety, averageValue, ratingsCount } =
        newAverages;
      const criteria = {
        _id: widgetId
      };
      const updateQuery = {
        $set: {
          averageQuality: averageQuality,
          averageSafety: averageSafety,
          averageValue: averageValue,
          ratingsCount: ratingsCount
        }
      };
      await self.apos.db
        .collection('reviewRatings')
        .updateOne(criteria, updateQuery, { upsert: true });
    } catch (e) {
      console.log('error', e);
    }
  }
}
```

  <template v-slot:caption>
    modules/rating-widget/index.js
  </template>

</AposCodeBlock>

This configuration method returns an object with the main POST route method called `submit(req)`, but also four other helper functions. While these helper functions are fairly specific to the POST route function, our `apiRoutes(self)` method could expose multiple POST routes, or routes for other HTTP verbs that could all utilize the helper functions. How you structure your code is up to you.

``` javascript
post: {
  async submit(req) {
    // Destructure input ratings and identifiers from the request body
    const { quality = 3, safety = 3, value = 3 } = req.body.ratings;
    const { widgetId } = req.body;

    const ratingDocument =
      (await fetchRatingDocument(req, widgetId)) ?? {};

    // Calculate new average ratings
    const newAverages = calculateNewAverages(
      ratingDocument,
      quality,
      safety,
      value
    );

    // Update the document with new average ratings
    await updateDocument(widgetId, newAverages);

    return newAverages;
  }
}
```

This object starts by declaring a `post` property that will take an object of all of POST methods. The `submit` method starts by getting values from the `req` object. It then uses the `widgetId` that came originally from the `data.widget` object to retrieve a record from the database using that ID and the `fetchRatingDocument()` helper method. We are using the nullish coalescing operator to set `ratingDocument` to an empty object if the record doesn't exist in the database, indicating it hasn't been created, yet.

The values the user selected, along with the values from the rating document object are next used to calculate what the new average should be with the `calculateNewAverages()` helper method. After updating the document using the `updateDocument()` helper method, the new averages are passed back as a response to the fetch request made by the player script.

### The `fetchRatingDocument()` method

``` javascript
async function fetchRatingDocument(req, widgetId) {
  const criteria = { _id: widgetId };
  return await self.apos.db.collection('reviewRatings').findOne(criteria);
}
```
The `fetchRatingDocument()` method makes a simple database query. First we set the `criteria` variable to an object with a key of `_id` set to the `widgetId`. Every MongoDB record needs a unique `_id` property. It is normally set automatically by MongoDB when you create a record, but we are going to create a record for every rating-widget added and use their unique ID as the record `_id`. To find the desired record, we will specify the collection where we will be saving our rating documents, `reviewRatings`. To specify this collection we are using `self.apos.db.collection()`. This can be used to specify any collection, but many of the core Apostrophe collections have shortcuts. For example, to access `self.apos.db.collection('aposDocs')` we can use `self.apos.doc.db`.

### The `calculateNewAverage()` function

``` javascript
function calculateNewAverages(ratingDocument, quality, safety, value) {
  // Destructure existing averages and count, using -1 as a fallback for missing averages
  const {
    averageQuality = -1,
    averageSafety = -1,
    averageValue = -1,
    ratingsCount = 0
  } = ratingDocument;

  // Function to update the average
  const updateAverage = (oldAverage, newValue, count) => {
    // If there were no reviews yet, the new value becomes the average
    if (oldAverage === -1) return newValue;
    // Formula to update the running average
    return parseFloat(
      ((oldAverage * (count - 1) + newValue) / count).toFixed(1)
    );
  };

  return {
    // Update each average using the helper function
    averageQuality: updateAverage(averageQuality, quality,ratingsCount + 1),
    averageSafety: updateAverage(averageSafety, safety, ratingsCount + 1),
    averageValue: updateAverage(averageValue, value, ratingsCount + 1),
    // Increment the ratings count
    ratingsCount: ratingsCount + 1
  };
}
```
Within the `calculateNewAverages()` method we first get the averages for each section from the widget object. If they don't already exist we set them to `-1`. We also get the current number of ratings that have been submitted and default to `0` if the field doesn't exist. Next we create a helper function, `updateAverage` to calculate the running average from passed values. Finally, we return new averages for each of the sections and an incremented count of submitted ratings.

### The `updateDocument()` function

``` javascript
async function updateDocument(widgetId, newAverages) {
  try {
    const { averageQuality, averageSafety, averageValue, ratingsCount } =
      newAverages;
    const criteria = {
      _id: widgetId
    };
    const updateQuery = {
      $set: {
        averageQuality: averageQuality,
        averageSafety: averageSafety,
        averageValue: averageValue,
        ratingsCount: ratingsCount
      }
    };
    await self.apos.db
      .collection('reviewRatings')
      .updateOne(criteria, updateQuery, { upsert: true });
  } catch (e) {
    console.log('error', e);
  }
}
```
Finally, we get to the last helper function that updates the database with our new values. It begins by destructuring the `newAverages` object to extract the fields we will use to update the database - `averageQuality`, `averageSafety`, `averageValue`, and `ratingsCount`. Subsequently, it creates a criteria object that identifies the database document to be updated based on its `_id`, which should match the supplied `widgetId`.

The core of the function is the MongoDB `$set` operation encapsulated in the `updateQuery` object. This query method is designed to update or create specific fields. If we were only increasing the `ratingsCount`, much like we would do when creating a widget that keeps track of "likes", we could use the [`$inc` method](https://www.mongodb.com/docs/v7.0/reference/operator/update-field/).

The newly created `criteria` and `updateQuery` variables are passed as arguments to an `updateOne` MongoDB method. In this case, we are specifying that the record to be updated should exist in the `reviewRatings` collection of the database. We are adding an object with a property of `upsert: true` as the third argument to indicate that if the document isn't found, it should be created and given the `_id` specified in the `criteria` object, and the values from the `$set` object.

While this function is tailored for our specific POST method, it's worth noting that its structure could be adapted to serve as a more generalized utility function. By doing so, it could execute MongoDB `$set` operations with arbitrary sets of key-value pairs.

### Final steps

If you were to spin the site up now, everything would be functional (as long as you had reviews with the `rating-widget` on page). You should be able to select your rating as a logged-out reader and have those ratings saved to the database. The reader card markup should then change to reflect the number of reviews submitted and the new averages. The only small thing we need to do is add some styling. We didn't have fractional ratings for the editors (although the `range` schema field would [allow that](/reference/field-types/range.md)). So, we need to slightly modify our `modules/rating-widget/ui/src/scss/_fontAwesomeStars.scss` file. Open that file and modify it:

<AposCodeBlock>

``` scss
.fa-star:before, .fa-star-half-alt:before {
  color: var(--bs-info);
  font-size: 20px;
}
```

<template v-slot:caption>
  modules/rating-widget/ui/src/scss/_fontAwesomeStars.scss
</template>

</AposCodeBlock>

## Summary and next steps

In this tutorial, we walked through the creation of three different widgets. During creation of the `row-widget`, we learned about using conditionals to display schema fields, creating template helpers to help format template data, and registering new icons to be used in our project.

While creating the `deal-widget`, we learned more about how to work with the image widget to make sure that images added by the user don't break our layout by specifying the aspect ratio and resolution. We also learned about how to use images outside an area using built-in Apostrophe helpers. 

Finally, the construction of the `rating-widget` introduced us to async components in Apostrophe. We also got a chance to review how styling is added at the module level. For all of these widgets, we also covered and reviewed some aspects of Nunjuck templating, looking at two different loops and how to set variables. Creation of this widget finished off our tutorial with an introduction to widget "players". A way to add front-end JavaScript to power our widgets. We also covered haw data from the back-end can be passed into front-end code using data attributes. Lastly, we got a chance to start to play with Apostrophe and MongoDB queries, query builders, and modifying database records. We will have more in-depth coverage in the "Pieces" tutorial.

Moving forward into the next tutorial, we will look at the Apostrophe `piece-type` through the creation of a `review` piece. This will also cover the creation of special page-types to display single reviews or a filtered list. We will also revisit widgets, looking at using a widget to display a specific piece or list of pieces. Along the way, we will also talk about additional schema field types and options, as well as taking a look at how Apostrophe handles pagination.

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS > Creating Pieces
DOC_PATH: tutorials/pieces.md
URL: https://apostrophecms.com/docs/tutorials/pieces
================================================================================
# Piece Creation

<iframe src="https://www.youtube.com/embed/jsJqO9K14dc?si=8VT5i7ms0jcSUvX2" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the videos and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

Pieces are stand-alone documents containing structured content. This content can be material that is presented on a page, like a blog article, or a team roster. However, pieces can also be used for storing other types of data. For example, the `@apostrophecms/user` module extends the `@apostrophecms/piece-type` module and stores each project user as a piece. Because pieces are stand-alone documents, they can easily be retrieved from the database.

In this tutorial, we are going to create a review piece-type and accompanying pages for showing individual pieces, as well as all the pieces belonging to a specific category. This will introduce us to filtering and query builders. We will also dive further into localizing our user interface. Finally, we will create several additional widgets to allow the display of editor-specified pieces in page areas.

You can follow along and create the new modules for our project, or switch to the `sec2-5-pieces` branch of the [GitHub repo](https://github.com/apostrophecms/apostrophe-onboarding-project).

## Creating the review piece

We are once again going to use the CLI tool for the creation of our `review-piece`. We are also going to take advantage of an additional flag, `--page`, to create an optional set of `piece-type-pages` for the display of our pieces.

```sh
apos add piece review --page
```

> ‚ö†Ô∏è Remember to add both of the newly created modules to the `app.js` file.

### The `piece-type` module

We will start by opening the `modules/review/index.js` file that extends the `@apostrophecms/piece-type` core module. Add the following code:

<AposCodeBlock>

``` javascript
module.exports = {
  // extending a core module creates a new instance of that module type
  // with a new name, but all the same functions
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Review',
    pluralLabel: 'Reviews',
    i18n: {
      browser: true
    }
  },
  fields: {
    add: {
      author: {
        type: 'string',
        label: 'Author',
        required: true
      },
      featuredImage: {
        type: 'area',
        label: 'Featured Image',
        max: 1,
        options: {
          widgets: {
            '@apostrophecms/image': {}
          }
        }
      },
      content: {
        type: 'area',
        label: 'Content',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {},
            rating: {}
          }
        }
      },
      category: {
        type: 'select',
        label: 'Category',
        required: true,
        choices: [
          {
            label: 'Vehicle',
            value: 'vehicle'
          },
          {
            label: 'Home & Garden',
            value: 'home-garden'
          },
          {
            label: 'Appliances',
            value: 'appliances'
          },
          {
            label: 'Electronics',
            value: 'electronics'
          },
          {
            label: 'Toys',
            value: 'toys'
          }
        ]
      },
      isFeatured: {
        type: 'boolean',
        label: 'Featured',
        def: false
      }
    },
    group: {
      content: {
        label: 'Content',
        fields: [ 'title', 'author', 'featuredImage', 'content' ]
      },
      meta: {
        label: 'Meta',
        fields: [ 'category', 'isFeatured' ]
      }
    }
  },
  filters: {
    add: {
      isFeatured: {
        label: 'featured'
      },
      category: {
        label: 'category'
      }
    }
  },
  columns: {
    add: {
      category: {
        label: 'Category'
      }
    }
  }
};

```
<template v-slot:caption>
  modules/review/index.js
</template>

</AposCodeBlock>

The `fields` object of this code adds five input schema fields and groups them into two tabs, `content` and `meta`. The three fields on the content tab are what you would expect for a review article. First the `author` of the piece, next, a single image from the article that can be featured in any markup as `featuredImage`, and finally the actual `content`, with the rich-text and image widgets, along with our custom ratings widget for the author to rate the product.

::: info
The `featuredImage` has an `area` schema field type that we are adding an image-widget into for the editor to add a single image. In this case it might have been preferable to use a [`relationship`](/guide/media.html#the-relationship-field-option), instead.
``` nunjucks
_featuredImage: {
  label: 'Image',
  type: 'relationship',
  withType: '@apostrophecms/image',
  max: 1
}
```

In the meta tab, we are adding two fields. First, we are assigning the article to a review-type `category`. We will use this for selective display and filtering of the reviews onto individual index pages. Second, we are adding the ability for the user to toggle whether the review should be featured with a boolean field, `isFeatured`. We will also use this to filter the reviews that we display in the browser.

#### Adding filters to the piece manager

![Screenshot of the piece manager filters](../images/sec2-5-piece-filters.png)

Following the `fields` object, there is a `filters` object. The `filters` object can be configured with subsections: `add` and `remove`. This configuration can either be added as a static object, as in this example, or a function that takes `self` and `options` and returns an object. Filters must correspond to an existing `fields` name or custom query builder on the piece type. We will cover custom `queries` in the [Adding Extensions](/tutorials/adding-extensions.html) tutorial.

``` javascript
filters: {
  add: {
    isFeatured: {
      label: 'featured'
    },
    category: {
      label: 'category'
    }
  }
}
```

This block of code introduces filters for the `isFeatured` and `category` fields, enabling the user to display or exclude featured pieces and reviews from particular categories, respectively. We will return to how we can use the `isFeatured` filter in the section on [creating review pages.](#adding-the-review-pages)

#### Piece manager columns

``` javascript
columns: {
  add: {
    category: {
      label: 'Category'
    },
  }
}
```
By default, the piece manager displays the piece title and the date the piece was last edited. Like the `filters` object, the `columns` object allows for the addition or removal of columns based on the schema fields of the module. In this case we are electing to display the category of the review to the right of the 'Last Edited' column in the piece manager.


#### Localizing the UI
![Screenshot of the UI for adding a new review piece localized to German](../images/sec2-5-review-localization.png)
In the `options` object, we have the standard `label` and `pluralLable` properties, but we have a new property `i18n`. This option allows us to localize the review piece admin UI to different languages by passing `browser: true`. It is slightly different from the localization that we introduced when creating our `views/fragments/topbar.html` fragment. There, we were adding localization to our template, not the interface the author is using. In the template, our localized strings were within Nunjucks tags and passed to the `__t()` helper. In this case, we don't have to do anything extra. Adding the `i18n` option will let Apostrophe know that we want to translate any label where we have supplied a corresponding translation string.

Just like with the topbar, we need to create a module-level folder for our translation strings. Create a `modules/review/i18n` folder and add a file named `en.json` inside. Into that file, we are going to add all the labels from each of the schema fields, including the labels for the choices in the select field.

<AposCodeBlock>

``` json
{
  "Review": "Review",
  "Reviews": "Reviews",
  "Author": "Author",
  "Featured Image": "Featured Image",
  "Content": "Content",
  "Category": "Category",
  "Vehicle": "Vehicle",
  "Home-garden": "Home & Garden",
  "Appliances": "Appliances",
  "Electronics": "Electronics",
  "Toys": "Toys",
  "Featured": "Featured?",
  "Meta": "Meta",
  "All": "All"
}
```

<template v-slot:caption>
  modules/review/i18n/en.json
</template>

</AposCodeBlock>

In this case, since we are localizing the strings within a single project, we aren't using a namespace. If we were intending on distributing this module to multiple projects as a package, we would need to make a few changes to our `modules/review/index.js` file. First, we would need to prefix all the label strings to be translated with the namespace. For example, `label: 'review:Author'`. Second, we would need to move the `i18n` property out of the options object to be a top-level property. That property would then receive a namespace-named object with the `browser: true` property:

``` javascript
i18n: {
  review: {
    browser: true
  }
}
```

We also need a translations file for our `de` locale, so create a `de.json` file in the same location and add:

<AposCodeBlock>

``` json
{
  "Review": "Bewertungs",
  "Reviews": "Bewertungen",
  "Author": "Autor",
  "Featured Image": "Vorgestelltes Bild",
  "Content": "Inhalt",
  "Category": "Kategorie",
  "Vehicle": "Fahrzeug",
  "Home & Garden": "Haus & Garten",
  "Home-garden": "Haus & Garten",
  "Appliances": "Ger√§te",
  "Electronics": "Elektronik",
  "Toys": "Spielzeug",
  "Featured": "Vorgestellt?",
  "Meta": "Meta",
  "All": "Alle"
}
```

<template v-slot:caption>
  modules/review/i18n/de.json
</template>

</AposCodeBlock>

## <a name="adding-the-review-pages"></a>Adding the review pages

![Screenshot of the adminbar with the reviews piece type added](../images/sec2-5-adminbar.png)

We now have a way to create review pieces. If we were to spin up our project we would see a new item 'Reviews' in the admin bar. Clicking on the plus icon we would get a dropdown that will let us quickly add a new review piece by creating the piece and opening the edit modal without having to open the piece manager first. As we will revisit in the [admin bar configuration](/tutorials/admin-ui.html) tutorial, you can configure this bar to group items or prevent them from appearing in the quick create menu.

While we can now create new review pieces, they won't be displayed anywhere in our site. One way that we can display our pieces is to use a `piece-page-type`. Our CLI command has already created a `modules/review-page` folder for us. Opening the `index.js` file, we can see the normal `extend` and `options` properties. Because this folder is named `review-page`, Apostrophe automatically knows that these pages should be associated with the `review` piece-type. If we wanted to give this module a different name, we would have to add the `pieceModuleName` property to the `options` object with a value of `review`. We will alter this file after we create our `index.html` page.

> ‚ö†Ô∏è At this point, although the `review-page` module has been created and we added it to the `app.js` file, none of the page templates that we are constructing would be available for a user to select. We also need to add this module to the `modules/@apostrophecms/page/index.js` file. Open that file and add the following object into the `types` array:

``` javascript
{
  name: 'review-page',
  label: 'Category Pages'
}
```

### The index.html page

The `index.html` page is located in the piece-page-type module `views` folder. This page is meant to display a listing of pieces and takes markup much like our homepage. You can elect to use the same template as the homepage, or create an entirely new one. In the case of our project, we are going to mimic the look of our homepage with the same topbar, footer, and eventually, navigation fragments. Open the `modules/review-page/views/index.html` file and add the following:

<AposCodeBlock>

``` nunjucks
<!-- Pages should extend the layout to get the header and footer -->
{% extends "layout.html" %}

<!-- This loads in a macro to help with pagination -->
{% import '@apostrophecms/pager:macros.html' as pager with context %}

<!-- This grabs the current URL for adding query parameters to filter -->
{% set currentPath = data.page._url %}

<!-- This is the main content area -->
{% block main %}
  <div class="container ms-5 me-5">
    <div class="d-flex justify-content-between align-items-center mb-5">
      <h1 class="custom-underline display-6 ps-2 mb-5">Reviews</h1>
      <div>
        {% if data.query.isFeatured === 'true' %}
          <a href="{{ currentPath | build({isFeatured: null}) }}" class="btn btn-secondary">Show All</a>
        {% else %}
          <a href="{{ currentPath | build({isFeatured: true}) }}" class="btn btn-primary">Show Featured Only</a>
        {% endif %}
      </div>
    </div>
    <div class="row g-3">
      <!-- This loops through all of the review pieces and displays them -->
      {% for review in data.pieces %}

        <!-- Use a helper to get the image -->
        <!-- Use the Nunjucks `set` to create a variable -->
        {% set image = apos.image.first(review.featuredImage) %}

        <!-- Even though the featuredImage field is required, it's possible that the image has been deleted. So we need to check for that. -->
        {% if image %}
          {% set imageUrl = apos.attachment.url(image, {size: 'one-sixth' }) %}
        {% else %}
          <!-- Instead of an else you could choose to skip displaying an image. -->
          {% set imageUrl = 'https://picsum.photos/200' %}
        {% endif %}

        <!-- This is just to show how to get image details without using the helper -->
        {% set altText = review.featuredImage.items[0]._image[0].alt %}

        <div class="review col-md-4">
          <div class="review__image">
            <img src="{{ imageUrl }}" alt="{{ altText }}">
          </div>
          <div class="review__content">
            {% if review.isFeatured %}
              <span class="review__featured">Featured</span>
            {% endif %}
            <h2 class="review__title"><a href="{{ review._url }}" class=" text-decoration-none text-dark">{{ review.title }}</h2></a>
            <p class="review__author">Authored by: {{ review.author }}</p>
          </div>
        </div>

      {% endfor %}
    </div>

  <!-- This renders the page navigation -->
{% if data.totalPages !== 1 %}
  <div class="row justify-content-center mb-5">
    <div class="col-md-4 align-self-center bg-info border border-dark border-3 rounded">
      <p class="fs-3">Review Navigation</p>
    {{ pager.render({
      page: data.currentPage,
      total: data.totalPages,
      shown: 5,
      class: 'fs-3 ms-5'
      }, data.url) }}
    </div>
  </div>
{% endif %}
</div>
{% endblock %}
```

<template v-slot:caption>
  modules/review-page/views/index.html
</template>

</AposCodeBlock>

Walking through the code, we start with
``` nunjucks
{% extends "layout.html" %}
```
This allows our page to use the same head, topbar, and footer as the home page.

``` nunjucks
{% import '@apostrophecms/pager:macros.html' as pager with context %}
// ...
  <!-- This renders the page navigation -->
{% if data.totalPages !== 1 %}
  <div class="row justify-content-center mb-5">
    <div class="col-md-4 align-self-center bg-info border border-dark border-3 rounded">
      <p class="fs-3">Review Navigation</p>
    {{ pager.render({
      page: data.currentPage,
      total: data.totalPages,
      shown: 5,
      class: 'fs-3 ms-5'
      }, data.url) }}
    </div>
  </div>
{% endif %}
```
This first line of code imports markup from the `@apostrophecms/pager` module. This markup contains several [Nunjucks macros](https://mozilla.github.io/nunjucks/templating.html#macro), which are a little like fragments that we worked with when creating our homepage. These macros are helpers that parse the number of pieces that we want to display on the page, deliver them in customizable groups, and create a breadcrumb trail for navigating through the groups.

The final block below the main content adds in the markup for our navigation breadcrumbs.

``` nunjucks
{{ pager.render({
  page: data.currentPage,
  total: data.totalPages,
  shown: 5,
  class: 'fs-3 ms-5'
}, data.url) }}
```
This code calls the imported macro and passes in several items from the `data` object that is available on any `piece-page-type` index page. The `currentPage` contains what page of results is currently being shown starting with 1. The `totalPages` gives the total number of pages that there are given the current group size. The optional `shown` option defines the maximum number of pages that should be displayed in the pager breadcrumb display at one time. If the total number of pages exceeds this the macro will insert ellipses either at the beginning or end to indicate that there are more pages available. The optional `class` property will add these classes to the wrapper around the breadcrumbs. Finally, the macro needs the URL of the page in order to correctly construct the links. All of this data is available for you to create your own navigation macros.

``` nunjucks
<!-- This grabs the current URL for adding query parameters to filter -->
{% set currentPath = data.page._url %}
<!-- This is the main content area -->
{% block main %}
  <div class="container ms-5 me-5">
    <div class="d-flex justify-content-between align-items-center mb-5">
      <h1 class="custom-underline display-6 ps-2 mb-5">Reviews</h1>
      <div>
        {% if data.query.isFeatured === 'true' %}
          <a href="{{ currentPath | build({isFeatured: null}) }}" class="btn btn-secondary">Show All</a>
        {% else %}
          <a href="{{ currentPath | build({isFeatured: true}) }}" class="btn btn-primary">Show Featured Only</a>
        {% endif %}
      </div>
    </div>
```

Returning to the main markup of the page, after adding a tag to add our markup to the `main` block, we open a Bootstrap container. Within that container we add a wrapper `div` containing the main heading for the page and another `div`. Within that wrapper `div`, we apply Bootstrap classes for flexbox layout (`d-flex`), justifying the content to be evenly spaced between the start and the end (`justify-content-between`), and vertically aligning items in the center (`align-items-center`). We also add a margin-bottom (`mb-5`) for spacing.

Inside this wrapper `div`, there are two main elements:

1. The first is an `<h1>` tag that serves as the main heading for the page, labeled 'Reviews'. It uses the Bootstrap class `display-6` for styling, additional padding (`ps-2`), and a margin-bottom (`mb-5`). A custom underline is also applied with the `custom-underline` class.

2. The second is another `div` that contains conditional logic to render a button. This is done using the `{% if %}` and `{% endif %}` tags, which are part of the template engine.

  ``` nunjucks
  <!-- This grabs the current URL for adding query parameters to filter -->
  {% set currentPath = data.page._url %}
  ```

  Above the main block we are getting the current URL of the page, including any query parameters, using `data.page._url`. If that URL has a query parameter of `isFeatured=true`, a 'Show All' button is displayed with a secondary Bootstrap styling (`btn btn-secondary`). The URL for the button is dynamically generated by passing the page URL to the Apostrophe template filter [`build`](/guide/template-filters.html#build-url-path-data) - <span v-pre>`{{ currentPath | build({isFeatured: null}) }}`</span>. This will remove the `isFeatured` query parameter by setting it to `null`. If the query parameter isn't present in the current page URL, a 'Show Featured Only' button with primary Bootstrap styling (`btn btn-primary`) will be added. The URL for this button will be constructed with the same filter, but the `isFeatured=true` query parameter will be added to the current URL.

Please note that this is completely independent of the fact that we are using `isFeatured` as a filter for the piece manager. Most [schema fields have filters](/reference/module-api/module-options.html#piecesfilters) already available. The values of the fields will get added to fields in the database document. So for example, we could add `?author=name` and the page would only display review pieces by that author. For fields that contain strings, individual words are added to the document search fields. So for example, a piece titled "Best Bed Buys for 2023" would be returned by adding a query parameter of `?title=bed` to the URL. However, a custom filter is needed if you want to filter based on a derived value, like the year of publication when the date field also contains the month and day. We will cover this in the [Adding extensions](/tutorials/adding-extensions.md) tutorial.

We aren't going to step through the remainder of the main content markup of the page in detail since it uses familiar concepts from past tutorials.


In brief, we set up a loop to go through all the piece objects available in the `data.pieces` array. For each, we extract a featured image, a link to the individual piece page, the piece title, and the piece author. Note that we are getting the link as `_url`. The underscore in front indicates that it is a property that is computed, not retrieved from the database. In this case, this is because pieces can be assigned to different parent pages and these links need to be computed dynamically at the time of rendering. We will cover assigning pieces to different pages in the next sections.

Now that we have our index page created, we can reopen our `modules/review-page/index.js` file and update our `options` object to add `perPage: 9` which will cause the review pieces to be displayed in groups of 9 per page. At this point, you can go ahead and spin the site up and create some review pieces. You can then add a new page, selecting `Category Pages` for the page type from the dropdown on the right.

### Creating the `show.html` page

We now have a page to display all of our reviews, but we still need a template for showing an individual piece. Open the `modules/review-page/views/show.html` file and add the following code:

<AposCodeBlock>

``` nunjucks
<!--
  This page is for displaying individual review pieces.
-->

<!-- Pages should extend the layout to get the header and footer -->
{% extends "layout.html" %}

{% set review = data.piece %}

<!-- Use a helper to get the image -->
<!-- Use the Nunjucks `set` to create a variable -->
{% set image = apos.image.first(review.featuredImage) %}
<!-- Even though the featuredImage field is required, it's possible that the image
  has been deleted. So we need to check for that. -->
{% if image %}
  {% set imageUrl = apos.attachment.url(image, {size: 'full'}) %}
  {% set srcset = apos.image.srcset(image) %}
{% else %}
  <!-- Instead of an else you could choose to skip displaying an image. -->
  {% set imageUrl = 'https://picsum.photos/200' %}
{% endif %}

<!-- This is just to show how to get image details without using the helper -->
{% set altText = review.featuredImage.items[0]._image[0].alt %}

<!-- Take advantage of `{{apos.log()}}` to see what data is available -->

<!-- This is the main content area -->
{% block main %}
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <h1 class="ms-5 custom-underline display-6 ps-2 mb-5">Review</h1>
      </div>
      <div class="review col-md-12">
        <div class="review__image text-center">
          <img srcset="{{srcset}}" src="{{ imageUrl }}" class="img-fluid" alt="{{ altText }}">
          {% if review.isFeatured %}
            <span class="review__featured fs-4 carousel-caption">Featured Article </span>
          {% endif %}
        </div>
        <div class="review__content">
          <h2 class="review__title text-center display-1 my-3">{{ review.title }}</h2>
        </div>
      </div>
    </div>
    <div class="row justify-content-md-center">
      <div class="col-md-8">
          <p class="review__author fs-5 mb-3">Written by: {{ review.author }}</p>
        {% area review, 'content'%}
      </div>
    </div>
  </div>
{% endblock %}
```

<template v-slot:caption>
  modules/review-page/views/show.html
</template>

</AposCodeBlock>

The markup here is straightforward. One thing to note is that the markup is being populated by items from `data.piece` whereas the `index.html` file was using `data.pieces`. We are also making use of a helper from the `@apostrophecms/image` module, `apos.image.srcset()`. This will return a string containing a comma-separated list of each of the image sizes paired with a view width. This can help page loading speed by allowing the browser to pick the optimal image size to load.

### Displaying review pieces by category

Looking back at the schema fields of our review piece, we added a select field to be able to add a category. For example, reviews of vehicles or appliances. We want to give our site visitors the ability to look at just the reviews within a certain category. Luckily, Apostrophe provides an easy way to accomplish this. The `@apostrophecms/piece-page-type` module provides two methods, `filterByIndexPage()` and `chooseParentPage()`, that we can extend to allow us to assign specific pieces to certain pages.

We will start by adding a select to our `review-page/index.js` file that will allow the editor to select what types of pieces should be displayed on the page. Open that file and add this code after the `options` object, replacing the existing code:

<AposCodeBlock>

``` javascript
fields: {
  add: {
    displayCategory: {
      type: 'select',
      label: 'Display Category',
      choices: 'addCategoryChoices()'
    }
  },
  group: {
    basics: {
      label: 'Basics',
      fields: [ 'displayCategory' ]
    }
  }
}
```

<template v-slot:caption>
  modules/review-page/index.js
</template>

</AposCodeBlock>

This code will create a single new schema field that the author can use to select the page category. We used a similar schema field in creating our review piece module. The big difference is that here we are dynamically populating the choices. This is a powerful way to ensure that the range of choices stays current, even if, for example, there is a new category of reviews added. In this case, we are passing the `choices` property a **string** and not the actual method. This string refers to a method we can either import or define within this module and should always end with `()` to indicate that it is referring to a method.

After the `fields`, add this code:

<AposCodeBlock>

``` javascript
methods(self) {
  return {
    async addCategoryChoices(req) {
      const allReviews = await self.apos.modules.review.find(req)
        .project({
          category: 1
        })
        .toArray();
      const uniqueCategories = [ ...new Set(allReviews.map(review => review.category)) ];
      return [
        {
          label: 'All',
          value: 'all'
        },
        ...uniqueCategories.map(category => ({
          label: category.charAt(0).toUpperCase() + category.slice(1),
          value: category
        }))
      ];
    }
  };
}
```

<template v-slot:caption>
  modules/review-page/index.js
</template>

</AposCodeBlock>

We are taking advantage of the `methods(self)` configuration function that is part of every Apostrophe module. This allows us to define JavaScript functions to be used in the same module or to be called by any other custom module. This method always returns an object of functions. In this case, it is returning a single async function, `addCategoryChoices(req)`.

#### Querying the database

While it is possible to directly query the database, Apostrophe provides a way to make a wide variety of queries without knowing advanced MongoDB syntax. Further, queries using the Apostrophe API are secure and will only return content the active website user is allowed to access. Both page and piece modules have access to a `find()` method that initiates a database query. This method takes the `req` object and optional `criteria` and `options`.

``` javascript
const allReviews = await self.apos.modules.review.find(req)
  .project({
    category: 1
  })
  .toArray();
```
The `allReviews` variable uses the `find()` method, passing it the request object from the index page. From within the `review` module, we could use `await self.find(req)` because the method would be restricted to only review pieces. In this case, we are querying the `review` pieces from the `review-page` module, so we need to reference the `find()` method of that `review` module using `self.apos.modules.review.find(req)`. This query will initialize a query to return all the review pieces. These results are next filtered and modified by several "query builders". These query builders can alternatively be passed as an object to the `options` argument of the `find()` method, instead of chaining them, as is shown here.

The first query builder we are adding is `project()`. This query builder limits the data that is returned from our find operation and takes an object with document properties to be included as keys, and the value of each set to `1` or `true`. You can also use `project()` to eliminate fields by setting the value to `0` or `false`, but you **can not** provide a `project()` with both inclusion and exclusion criteria. In this case, we want to provide our content editor with a list of all the review categories. We don't need to supply the titles or authors, so we limit the amount of data that needs to be passed. Some other common query builders are `sort()` and `limit()`. You can read more about them in the [documentation](/guide/database-queries.md).

Finally, we pass our query to the `toArray()` query method. The other common query method is `toObject()`. Both these methods take the criteria and refinements added by the query builders and add logic to tell the database how we want the data returned, as an array of objects or a single object, respectively.

``` javascript
const uniqueCategories = [ ...new Set(allReviews.map(review => review.category)) ];
```

Our next constant definition takes the returned query array, extracts all the categories, removes duplicates, and assigns the array of unique categories to `uniqueCategories`.

``` javascript
return [
  {
    label: 'All',
    value: 'all'
  },
  ...uniqueCategories.map(category => ({
    label: category.charAt(0).toUpperCase() + category.slice(1),
    value: category
  }))
];
```
Finally, we are returning an array of choices to the `select` schema field. We are adding an initial choice of `all` so that the editor can choose to have a page where the results aren't filtered according to the review category. The first letter of each category is converted into upper-case so that the labels match our translation strings.

#### Filtering the index page
Now that we have a way for the user to determine what review pieces they want to be displayed on the page, we need to extend the `filterByIndexPage()` method. In this case, we are going to use the `extendMethods(self)` configuration method. This allows a method to essentially improve, rather than replace, a method defined in the base module. Like the `methods(self)` configuration method, it should return an object of methods. Each method it returns should take the same arguments as the original, plus the `_super` argument.

Add this code after the `methods(self)`, making sure to add a comma to separate the two methods:

<AposCodeBlock>

``` javascript
extendMethods(self) {
  return {
    filterByIndexPage(_super, query, page) {
      // if the page has a category, add it to the query
      // if the page category is `all`, don't modify the query and return all pieces
      if (page.displayCategory && page.displayCategory !== 'all') {
        query.category(page.displayCategory);
      }
      // return the query
      return query;
    };
  }
}
```
<template v-slot:caption>
  modules/review-page/index.js
</template>

</AposCodeBlock>

This original `filterByIndexPage()` method takes the `query` and `page` arguments. Since we are extending the method, we are also adding the `_super` argument. Inside the function we check to make sure the content creator has selected a category and that it isn't `all`. If so, we take advantage of the fact that Apostrophe automatically adds query builders for most schema fields. In this case, adding a query builder that checks that the value of the `review` piece `category` schema field for each piece is equal to the category that the editor selected.

#### Connecting the individual pieces to the correct parent

We have now solved one side of our routing equation. Each new review page that the user creates can be set to display pieces of a selected category. However, once we click on the link to take us to the individual reviews, that review `show.html` page won't have information about the parent page. We need to extend the `chooseParentPage()` method to assign the correct one.

After the `filterByIndexPage()` method we just added, add the following code (making sure to separate our methods with a comma):

<AposCodeBlock>

``` javascript
chooseParentPage(_super, pages, piece) {
  // if the piece has a category and there is more than one page, assign the correct one
  if (piece.category && pages.length > 1) {
    // grab the piece.category and assign it to a variable
    // set to `all` if it's not a string
    const pieceCategory = typeof piece.category === 'string' ? piece.category : 'all';
    // find the page with the correct category
    // if we didn't find a page with the correct category
    // use the `chooseParentPage` method of the parent module
    // to assign the fallback page
    return pages.find((page) => page.displayCategory === pieceCategory) || _super(pages, piece);
  }
  // if only a single page, use the default behavior
  return _super(pages, piece);
}
```

<template v-slot:caption>
  modules/review-page/index.js
</template>

</AposCodeBlock>

Again, the original method took two arguments that we are prefacing with the `_super` argument. The `pages` argument is going to contain an array of all the pages that are in the database that are the `review-page` page type. The `piece` argument is going to be the individual piece that is being requested for display.

First, we are checking that the category is set for the piece that is being requested and that there is more than one `review-page`. If not, then we return the results of the original method, using `_super(pages, piece)`. Otherwise, we set the `pieceCategory` constant to either the value the author selected or `all` if the field doesn't have a string value. This is then used with the *JavaScript* `Array.prototype.find()`, not the Apostrophe query initiator, to select a page from the `pages` array. As fallback, if no page has been created with a matching category it will fall back to the parental method to select the correct page.

::: info
This `chooseParentPage()` extended method is relatively simple. We could have elected to add it as a method instead, passing `data.pages[0]` back instead of the results of `_super(pages, piece)`.

At this point, you can spin the project up and create a new page for every category, plus another for 'all' to display all the pieces, or if you haven't done so yet, you can import the database from the final project (see the [repository README](https://github.com/apostrophecms/apostrophe-onboarding-project/blob/main/README.md) to learn how to accomplish this). In the next tutorial, we will add site navigation to link these pages to the homepage. Next, we are going to look at two further ways to display pieces on our pages.

## Creating a piece widget

<iframe src="https://www.youtube.com/embed/vl8ex11H0XY?si=aZiuoEc9XG_9_WXG" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

So far, we can only display pieces on a dedicated page, but obviously, we also want to be able to display pieces on other pages throughout our site. One way this can be accomplished is through the creation of a widget that can be added to any area. We are going to create two different widgets, a simple one to display any review article, and a more complex one that allows the content creator to select from either a featured review or the latest review.

### Adding the all reviews widget

![Screenshot of the final 'all-reviews-widget' markup.](../images/sec2-5-all-reviews.png)
We won't be using this widget in our project, but it will be useful to build in order to introduce a new schema field and how it is used within a template. After construction, we will add it to the `default-page` area to see what it looks like. As with most of our custom modules, we will use the CLI tool to create our widget.

``` sh
apos add widget all-reviews
```

This will create a `modules/all-reviews-widget` folder and populate it with an `index.js` file and a `views` folder with a `widget.html` file.

> ‚ö†Ô∏è Remember to add the new module to the `app.js` file

#### Creating the schema

Open the `index.js` file and add the following code:

``` javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'All Reviews Widget'
  },
  fields: {
    add: {
      _selectedReview: {
        type: 'relationship',
        label: 'Review to display',
        withType: 'review',
        required: true,
        max: 1,
        builders: {
          project: {
            title: 1,
            author: 1,
            _url: 1
          }
        },
        fields: {
          add: {
            recommender: {
              type: 'string',
              label: 'Recommender',
              required: true
            },
            recommendation: {
              type: 'string',
              label: 'Recommendation',
              required: true,
              textarea: true,
              max: 50
            }
          },
          group: {
            extras: {
              label: 'Extras',
              fields: [ 'recommender', 'recommendation' ]
            }
          }
        }
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [ '_selectedReview' ]
      }
    }
  }
};

```

For this code, we are using a new schema field, the `relationship` field. Note that the name of the field is prefixed with an underscore, `_selectedReview`. As we covered earlier in the tutorial, this means that the data returned by this field is computed at the time of render. The `withType` property identifies the Apostrophe doc type that is connected to the field. If we wanted to connect to a page, we would use `withType: '@apostrophecms/any-page-type'`.

In addition to the `required` and `max` properties, this relationship has two additional optional properties, `builders` and `fields`.

The `builders` property takes an object containing a `project` object that can limit the data returned, exactly like the query builders covered previously. In this case, only the `title`, `author`, and `_url` are being returned.

The `fields` property works like the top-level property of the same name. In this code, we are adding two additional fields to collect a recommender's name and recommendation. As with the top-level property, the `group` property is being used to group the fields on the `extras` tab. For the `recommendation` we are using a `string` type input field, but passing it the optional `textarea` boolean property to convert it into a textarea input, and a `max` property to limit the number of characters that can be added.

You can read more about the `relationship` field, like allowing nested relationships with `withRelationships`, as well as `reverseRelationship` fields and using `ifOnlyOne` to limit data in the [documentation](/reference/field-types/relationship.md).

#### Adding the widget markup

Open the `modules/all-reviews-widget/views/widget.html` file and add the following code:

<AposCodeBlock>

``` nunjucks
<section class="bg-light pb-5 pt-5">
  <div class="container pb-5 pt-5">
    <div class="align-items-center row">
      <!-- always check to make sure the review still exists and has been added -->
      {% if data.widget._selectedReview.length > 0 %}
        {% set review = data.widget._selectedReview[0] %}
        <div class="col-lg">
          <h2 class="h6 text-primary text-uppercase">Recommended</h2>
          <p class="text-primary ms-4">{{review._fields.recommender}} says: {{review._fields.recommendation}}
          </p>
          <h3 class="fw-bold h2 mb-3">{{review.title}}</h3>
          <p class="fw-light h4 ms-4">BY: {{ review.author }}</p>
        </div>
        <div class="col-lg-auto">
          <a href="{{ review._url }}" class="btn btn-primary text-uppercase">Read More</a>
        </div>
      {% endif %}
    </div>
  </div>
</section>
```

  <template v-slot:caption>
    modules/all-reviews-widget/views/widget.html
  </template>

</AposCodeBlock>

We are using an `if` within Nunjucks tags to make sure that the content creator added the review and it hasn't been archived by checking the `data.widget._selectedReview` value. A `relationship` field will return an array with all the selected documents, so that array should have a length longer than `0` if at least one review has been added. Next, since we are only expecting a single document in the array, we are setting the `review` variable to the first item in the array.

Within that review, we can access the additional fields through the `_fields` property. This allows us to add the recommender name and recommendation. The rest of the data coming from the review is accessed through the schema names directly.

Finally, add this widget to the default-page by adding it to the end of the `widgets` object. You can then spin the project up, add a new default page and add the new widget in the main area to see what it looks like.

### Creating the review widget

![Screenshot of the latest widget editor modal](../images/sec2-5-latest-review-schema.png)

We are going to create an additional widget that will allow the editor to select and display featured or recently published pieces. We are also going to give the content creator the ability to select the number of reviews to add, and a choice of whether to add an image. Again, we will start by using the CLI tool to create our widget.

``` sh
apos add widget review
```

> ‚ö†Ô∏è Don't forget to add your new module to the `app.js` file.

#### Adding the schema
Open the newly created `modules/review-widget/index.js` file and add the following code:

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Review Widget',
  },
  fields: {
    add: {
      displaySingle: {
        type: 'boolean',
        label: 'Display single review or list?',
        required: true,
        def: true,
        toggle: {
          true: 'Display single review',
          false: 'Display list of reviews'
        }
      },
      includeImage: {
        type: 'boolean',
        label: 'Include Image?',
        toggle: {
          true: 'Add image to review card',
          false: 'Show card without image'
        },
        if: {
          displaySingle: true
        }
      },
      imagePosition: {
        type: 'radio',
        label: 'Image Position',
        def: 'left',
        choices: [
          {
            label: 'Left',
            value: 'left'
          },
          {
            label: 'Right',
            value: 'right'
          }
        ],
        if: {
          includeImage: true
        }
      },
      _review: {
        type: 'relationship',
        withType: 'review',
        required: true,
        if: {
          displaySingle: true
        }
      },
      category: {
        type: 'select',
        label: 'Category',
        required: true,
        def: 'all',
        choices: [
          {
            label: 'All',
            value: 'all'
          },
          {
            label: 'vehicle',
            value: 'vehicle'
          },
          {
            label: 'Home & Garden',
            value: 'home-garden'
          },
          {
            label: 'Appliances',
            value: 'appliances'
          },
          {
            label: 'Electronics',
            value: 'electronics'
          },
          {
            label: 'Toys',
            value: 'toys'
          }
        ],
        if: {
          displaySingle: false
        }
      },
      time: {
        type: 'select',
        label: 'Type',
        choices: [
          {
            label: 'Latest',
            value: 'latest'
          },
          {
            label: 'Featured',
            value: 'featured'
          }
        ],
        if: {
          displaySingle: false
        }
      },
      number: {
        type: 'integer',
        label: 'Number of Reviews',
        min: 1,
        max: 10,
        if: {
          displaySingle: false
        }
      }
    }
  },
  components(self) {
    return {
      async returnReviews(req, data) {
        const criteria = (data.category === 'all') ? {} : { category: data.category };
        if (data.time === 'featured') {
          criteria.isFeatured = true;
        }
        const limit = data.number;
        /* Because we are not in the `review` module, we need to use `self.apos.modules.review` to access that module. To search the same module, we would use `self.find()`. We only need the 'title', '_url', and 'category' so we are limiting the returned data with `project({})`.
        */
        const reviews = await self.apos.modules.review.find(req, criteria)
          .project({
            title: 1,
            _url: 1,
            category: 1
          })
          .sort({ createdAt: -1 })
          .limit(limit)
          .toArray();
        return {
          reviews: reviews
        };
      }
    };
  }
};

```
  <template v-slot:caption>
    modules/review-widget/index.js
  </template>

</AposCodeBlock>

The `fields` object should look fairly familiar. We are using two new field types, `boolean` and `radio`. The `boolean` field returns either `true` or `false`. For both, we are adding the optional `toggle` property. Without the `toggle` property, the `boolean` input field places two buttons side-by-side labeled `Yes` and `No`. The `toggle` property adds the string values added for the `true` and `false` values to those buttons. It also changes the selected appearance from a colored dot to a change in the background color.

In this code, whether the `includeImage` field is added to the schema is controlled by the value of the `displaySingle` field. Note that even though we have added new labels to the buttons, the returned values are still `true` and `false`. If `displaySingle` is `false`, the final data object won't include the field.

The `radio` field allows for the selection of a single choice out of a list of choices. The decision to use a `radio` versus a `select` field usually comes down to the number of choices, since the choices in a `radio` field will always be displayed. Otherwise, these two types of field can be used interchangeably, including populating the choices dynamically.

We are going to ignore the final section of this code that adds a component until we add markup to the `views/widget.html` file.

### Create the markup
Open the `modules/review-widget/views/widget.html` file and add the following code:

<AposCodeBlock>

``` nunjucks
{% set data = data.widget %}
{% if data.displaySingle === true %}
  {% set review = data._review[0] %}
  {% if data.includeImage === true %}
    {% set image = apos.image.first(review.featuredImage) %}
    {% if image %}
      {% set imageUrl = apos.attachment.url(image, {size: 'one-half' }) %}
    {% else %}
      {% set imageUrl = 'https://picsum.photos/200' %}
    {% endif %}
    {% set imageBlock %}
      <div class="background-center-center background-cover col-xs-12 col-md-4" style="background-image:url('{{ imageUrl }}')"></div>
    {% endset %}
  {% endif %}
  {% set textBlock %}
    {% set extraClass = ' ps-3' if data.imagePosition === 'left' %}
    <div class="col-xs-12 col-md-8 headline-block{{extraClass}}">
      <div class="card-body">
        <h3 class="card-title display-5">
          <a href="/reviews/{{ review.slug }}" class="text-decoration-none text-dark">{{ review.title }}</a>
        </h3>
        <p class="card-text">A review by {{ review.author }}</p>
      </div>
    </div>
{% endset %}
<container class="container">
  <section data-review-widget class="border-2 border-bottom border-primary g-0 mb-4 row row-height">
    {% if data.imagePosition === 'left' %}
      {{ imageBlock | safe }}
      {{ textBlock | safe }}
    {% else %}
      {{ textBlock | safe }}
      {{ imageBlock | safe }}
    {% endif%}
  </section>
</container>
{% else %}
  <container class="article">
    <section data-review-widget>
      {% component 'review-widget:returnReviews' with { category:data.category,
      time:data.time, number:data.number } %}
    </section>
  </container>
{% endif %}
```

  <template v-slot:caption>
    modules/review-widget/views/widget.html
  </template>

</AposCodeBlock>

We are creating two chunks of markup that are enclosed in `if...else` conditional tags. The top section within the `if` provides markup for the display of a single review. It uses Nunjucks `set` tags to create a block of markup for the image and another for the text markup. Then there is an internal `if...else` conditional based on whether the text or image block should be shown first.

The markup in the main `else` block takes advantage of the async component that we added to our `index.js` file. It passes three pieces of data from the schema fields to the component method, the `category`, `time`, and `number`. We need to use a component here because we need to perform a database query before we can compose our markup.

#### The async component
``` javascript
components(self) {
    return {
      async returnReviews(req, data) {
        const criteria = (data.category === 'all') ? {} : { category: data.category };
        if (data.time === 'featured') {
          criteria.isFeatured = true;
        }
        const limit = data.number;
        /* Because we are not in the `review` module, we need to use `self.apos.modules.review` to access that module. To search the same module, we would use `self.find()`. We only need the 'title', '_url', and 'category' so we are limiting the returned data with `project({})`.
        */
        const reviews = await self.apos.modules.review.find(req, criteria)
          .project({
            title: 1,
            _url: 1
          })
          .sort({ createdAt: -1 })
          .limit(limit)
          .toArray();
        return {
          reviews: reviews
        };
      }
    };
  }
```

In the component method, we are setting our criteria to include the selected category and whether only `featured` reviews should be selected. This is getting passed into the `find()` query initialization method of the `review` module. We are using `project()` to limit the returned information. The `sort` query builder is arranging the reviews by their `createdAt` date in descending order, which means that the latest review will be first. The `limit()` query builder is being used to only return the number of reviews specified by the user. And finally, we are completing our query by specifying that those arrays should be delivered as an array of document objects and then passing that object to our component markup.

#### Component HTML

Now that the reviews have been fetched from the database, we need to create the markup to display them. Create a `modules/review-widget/views/returnReviews.html` file. Note that this file name matched the method name and the name used in the `views/widget.html` markup. Add the following code:

<AposCodeBlock>

``` nunjucks
<div class="border-2 border-info border-start row">
  <div class="mt-4">
    {% for review in data.reviews %}
      <div class="article ps-3">
        <p class="h4">
          <a href="{{ review._url }}" class="text-decoration-none text-dark">{{review.title}}</a>
        </p>
        <hr class="mt-2 text-info bg-info" />
      </div>
    {% endfor %}
  </div>
</div>
```
  <template v-slot:caption>
    modules/review-widget/views/returnReviews.html
  </template>

</AposCodeBlock>

Within this markup, we are creating a `for...in` loop to step through each of the returned reviews. We are creating a link for each based on the `_url` and `title`, and adding a `<hr>` horizontal rule afterward. If we wanted to alter this to include an image, we would have to change our `project()` query builder. However, it is interesting to note that if we were to log the information being delivered to the component markup, we would see that there are several computed fields, including `_id`, `_parentUrl`, and `_parentSlug` that can be used for creating navigation items, like a link to take the user to the particular index page that this review belongs on.

#### Adding styling

If we were to spin our site up now, we could populate our home page with our new widgets, but it wouldn't look quite like our final project, because we still need to add some additional styling. Just as a reminder, this styling can be placed in several locations within our project. It could be placed into a `ui/src` folder in our `review-widget` module. This would require adding or importing the styles into an `index.scss` file within that folder. Instead, we can create a new file in the `modules/asset/ui/src/scss` folder and import it in the `index.scss` file of that same module. Rather than adding the code here, I recommend copying the `_theme-reviews.scss` file from the `sec2-5-pieces` branch of the [GitHub repo](https://github.com/apostrophecms/apostrophe-onboarding-project). Next, open the `modules/asset/ui/src/index.scss` file and add `@import './scss/_theme-reviews';`.

Now with styling added, our review widget would look better, but we still need to pick where to display it! Open the `lib/area.js` file and add it to the end of the `fullConfig` object. Spinning the site up now will allow the addition of our new widget to any area that has a `row` widget. In the finished project this widget was used in both the upper and lower homepage areas.

> Unless you have added content, including reviews and category pages for any review types, the links for this widget won't be correctly formed. That is because each review document depends on having a computed `_parentURL` to create the link.

#### Fixing the Bootstrap styling issue

![Screenshot of the UI problem with the radio selector caused by Bootstrap](../images/sec2-5-bootstrap-fix.png)

The Apostrophe Admin UI styling is designed to be agnostic with regard to your project styling. In this case, the stylesheet that Bootstrap is using to normalize or reset all the base browser styling is causing a problem with the Apostrophe `radio` schema input field. The choices for where we want our image when we are displaying a single review piece are pushed off the right side of the page due to a rule on the `legend` selector. To fix this we need to add some additional styling.

Open the `modules/asset/ui/src/scss` folder and create a `_bootstrap-fixes.scss` file. Add the following code:

<AposCodeBlock>

``` scss
legend {
  float: unset;
}
```
  <template v-slot:caption>
    modules/asset/ui/src/scss/_bootstrap-fixes.scss
  </template>

</AposCodeBlock>

Next, open the `modules/asset/ui/src/index.scss` file and add an import for the new partial:

<AposCodeBlock>

``` javascript
/*
Anything in this file will be compiled into the final CSS file.
Apostrophe automatically includes the index.scss file from any
module that has a ui/src directory.
*/

// Add theme SASS variables
@import './scss/_theme-settings';
// Add theme fonts and base styles
@import './scss/_theme-main';
// Add styling for theme topbar
@import './scss/_theme-topbar';
// Add styling for reviews
@import './scss/_theme-reviews';
// Add fix for Bootstrap
@import './scss/bootstrap-fixes';

// Add theme framework styles
@import 'bootstrap';
```
  <template>
    modules/asset/ui/src/index.scss
  </template>

</AposCodeBlock>

## Adding pieces to the footer

![Screenshot of the footer with the review pieces added.](../images/sec2-5-footer-reviews.png)

To wrap up this tutorial, we will take a brief look at two final ways that we can use to display a piece without a widget or the direct need for a piece-page. We are going to add a latest review to the footer using a component defined in the review piece module. We are going to add a featured review in the same section of our footer using a `relationship` field in our `@apostrophecms/global` module. 

### Adding a piece using a component

Open the `modules/review/index.js` file and add the following code after the `fields` object:

<AposCodeBlock>

``` javascript
components(self) {
  return {
    async latestReview(req, data) {
      const review = await self.find(req)
        .sort({ createdAt: -1 })
        .limit(1)
        .toObject();
      return { review };
    }
  };
}
```
  <template v-slot:caption>
    modules/review/index.js
  </template>

</AposCodeBlock>

This code is creating a `latestReview()` method that queries the review-pieces to find the latest post and returns it as an object. Since we are in the `review` module, we only need to use `self.find()` to restrict the returned documents to review pieces. Next, we need to create markup to display the returned piece. Create a `/modules/review/views/latestReview.html` file and add the following code:

<AposCodeBlock>

``` nunjucks
<h3 class="fw-bold h6 mb-3"><a href="{{ data.review._url }}">{{ data.review.title }}</a></h3>
<p class="mb-3">{{ data.review.searchSummary | truncate(100) }}</p>
```
  <template v-slot:caption>
    /modules/review/views/latestReview.html
  </template>

</AposCodeBlock>

This markup will construct a link using the `data.review` object returned by the component method. It is also using a field, `searchSummary` that is created when saving the review-piece to the database. This is generated by the `@apostrophecms/search` module and can be disabled if you choose. In this case, it is easier than adding an additional field to the `review` module schema and asking the content editor for a summary. This field will contain all the text added to the page, and we are using the built-in Nunjucks `truncate()` filter to add just the first 100 characters to the markup.

We still need to edit our footer fragment to display this component, but we are going to wait to modify this until we modify our `modules/@apostrophecms/global/index.js` file to allow the content editor to select a review.

### Adding a piece with a relationship

![Screenshot of the global configuration menu location](../images/sec2-5-global-configuration.png)

Thus far, we have used the `modules/@apostrophecms/global` module as a place to house our topbar translation strings. It is also useful for adding content that will be used throughout the site in multiple modules. The schema fields that are added to this module are exposed as `data.global` in the data object available to all page types and widgets. In this case, we are just going to add a single schema field to deliver a selected review. We will return to the global module to finish our footer in a future tutorial. For now, create the `modules/@apostrophecms/global/index.js` file and add the following code:

<AposCodeBlock>

``` javascript
module.exports = {
  fields: {
    add: {
      _featuredPost: {
        label: 'Featured Post',
        type: 'relationship',
        withType: 'review',
        max: 1,
        required: true
      }
    },
    group: {
      footer: {
        label: 'Footer',
        fields: [ '_featuredPost' ]
      }
    }
  }
};

```
  <template v-slot:caption>
    modules/@apostrophecms/global/index.js
  </template>

</AposCodeBlock>

This will add a single input field to our global configuration. This can be edited by the user by opening the menu located at the upper right of the admin bar. Again, since we are using a `relationship` type field, we need to preface our field name with an underscore.

### Modifying the footer markup

Finally, we need to edit our footer to display the component. Open the `views/fragments/footer.html` file and modify the second column that has the `h2` tag with the text "Latest Posts" to include our component markup:

<AposCodeBlock>

``` nunjucks
{% fragment mainArea() %}
  <footer class="bg-info bg-opacity-10 pt-5 text-secondary">
    <div class="container">
      <div class="row">
        <div class="col-lg-4 py-3">
        <!-- remainder of code-->
        </div>
        <div class="col-lg-4 py-3">
        <!-- replace the markup in this column with the code below -->
          <h2 class="fw-bold h5 mb-4 text-primary text-uppercase">Latest Review</h2>
          {% component 'review:latestReview' %}
          <h2 class="fw-bold h5 mb-4 text-primary text-uppercase">Featured Review</h2>
          <h3 class="fw-bold h6 mb-3"><a href="{{ data.global._featuredPost[0]._url }}">{{ data.global._featuredPost[0].title }}</a></h3>
          <p class="mb-3">{{ data.global._featuredPost[0].searchSummary | truncate(100) }}</p>
          <!-- stop copying here -->
        </div>
        <div class="col-lg-4 py-3">
        <!-- Remainder of code -->
        </div>
      </div>
    </div>
  </footer>
{% endfragment %}
```
  <template v-slot:caption>
    views/fragments/footer.html
  </template>

</AposCodeBlock>

For the latest review, we are outputting the markup from the component created in our `review` module. For the featured review, we are adding essentially the exact same markup and populating it with the information from the `data.global` Note that the `_featuredPost` field will return an array, so we have to access the first item in that array with `_featuredPost[0]`. Even though this field is required in the global configuration, best practice would be to use an `if` conditional to make sure that the featured post document actually exists.

## Summary and next steps

Pieces are a powerful way to produce reusable content that can be displayed throughout your project. In this tutorial, we created a piece-type called `review` for our project. When creating our piece module we looked at how to add localization strings for our custom module UI using the `i18n` property. This is slightly different from the localization that we did in the homepage topbar in Section 2, tutorial 2 on pages.

We also examined multiple ways to display our new pieces. First, we created a `piece-page-type` with HTML markup to display individual pieces using the `show.html` template and display multiple pieces using the `index.html` template. We utilized the Apostrophe `pager` module to look at how to limit the number of pieces displayed at once and create a breadcrumb trail for the display of the rest on our index page. We also looked at how we can have multiple index pages in our project, each with different pieces associated by extending the `filterByIndexPage()` and `chooseParentPage()` methods. This introduced the module configuration function, `extendMethods()`. Finally, we looked at how you can add choices to a select field dynamically in order to keep the category choices the content editor can make up-to-date.

Second, we looked at using widgets to display our pieces. The newly created widget can display either a single, selected review or a list of them. This led to the introduction of query builders for retrieving documents from the database from within our component. We also revisited getting schema info from the `data.widget` object. We completed this section by revisiting how to add style rules in our project.

Third, we looked at how we can display pieces on our pages using a component defined within the original piece-type module or through the global configuration. We modified the `views/fragments/footer.html` file that is displayed on each project page.

While it was mentioned in the introduction, one thing that we didn't cover in this tutorial is using pieces to store information that can be retrieved but isn't displayed anywhere on the site. For example, you could have a 'roster' piece-type with the names of each member on a particular team. In the end, you would display a 'member' piece on a team page through data stored in the roster piece. This is an easy way to dynamically change the content added to a page.

In the upcoming tutorial, we'll focus on crafting the final global element for our page: the navigation menu. Our exploration will encompass a variety of approaches to achieve this, delving back into the global configuration. Moreover, we'll investigate various `data` objects accessible on pages, which play a vital role in facilitating navigation creation.

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS > Building Navigation
DOC_PATH: tutorials/navigation.md
URL: https://apostrophecms.com/docs/tutorials/navigation
================================================================================
# Navigation

<iframe src="https://www.youtube.com/embed/kFPzdD2zLA0?si=8TSASkvNzwWi0mWA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the video and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

Creating an intuitive and functional navigation system is a critical element in web design, and ApostropheCMS provides robust and flexible tools to achieve just this. In this tutorial, we will go through two methods for adding whole site navigation. The techniques we will be outlining can also be used for the creation of contextual navigation for the children of a page, for example. We will also take a shallow dive into generating breadcrumb navigation.

While we will be mainly focused on producing navigation for our project, we will also revisit changing our page layout using fragments, including multiple fragments in a single file, and utilizing the global configuration. Lastly, while covering the addition of breadcrumb navigation to our pages, we will also look at the `helper(self)` configuration function.

You can follow along by either editing the code of your project, or by switching to the `sec2-6-navigation` branch of the [GitHub repo](https://github.com/apostrophecms/apostrophe-onboarding-project).

## Generating site navigation from the page tree

![Screenshot of the Apostrophe page manager](../images/sec2-6-page-tree.png)

Pages in ApostropheCMS operate within a hierarchical structure, a feature that provides organization and structure to your site. By default, when you add a new page, it is placed as a 'child' to the home page, forming a first-tier relationship in the hierarchy. If you create a new page while on an existing page, the new page becomes a 'child' of the current page, instead of the home page. This dynamic arrangement signifies the page's position within the tree structure. Furthermore, the placement of pages isn't fixed, as ApostropheCMS enables rearrangement via a simple drag-and-drop mechanism. Crucially, information about this hierarchical tree structure is incorporated into the `data` object, which is readily accessible to any template. This aspect can prove highly beneficial, especially when dealing with parent or ancestor pages in your site navigation.

| Data object | What is it? |
| ------ | ------ |
| `data.home` | Home page data. It is similar to the data on `data.page`, but always references the home page. |
| `data.home._children` | Page data for pages one level below the home page in the page tree. |
| `data.page._ancestors` | Page data for the ancestors of the active page, starting with the home page. |
| `data.page._children` | Page data for pages one level *below* the active page. |

By default, one level of children is available on each ancestor, as well as on the home page. This default behavior can be altered by adding `builders` to the `@apostrophecme/page` module at project-level.

``` javascript
module.exports = {
  options: {
    builders: {
      children: true,
      ancestors: {
        children: {
          depth: 2,
          areas: [ 'main', 'thumbnail' ],
          relationships: false
        }
      }
    }
  }
}
```
For example, this code would increase the number of levels of child documents returned from any ancestor to two. We are also passing in an array of allowed `areas`. In this case, we are allowing two areas, named `main` and `thumbnail`, to be included in the data object. Further, we are preventing any relationship field data. In this way, we are limiting the size and complexity of the `data` object to just what is needed.

So, the question is how can we utilize this data to build our navigation? It is actually can be as simple as including the Nunjucks template to extract and present the page information from the `data` object. Create a `views/fragments/navigation.html` file and add the following code:

<AposCodeBlock>

``` nunjucks
{% fragment pagetreeNavigation() %}
  <section class="mb-4 topnav">
    <div class="d-flex flex-wrap gap-5 justify-content-center me-auto ms-auto p-5 text-center">
      {% for page in data.home._children %}
        {% if page.visibility === 'public' %}
            <a href="{{ page._url }}" style="text-decoration: none" class="fs-3 text-dark">{{ page.title }}</a>
        {% endif %}
      {% endfor %}
    </div>
  </section>
{% endfragment %}
```
  <template v-slot:caption>
    views/fragments/navigation.html
  </template>

</AposCodeBlock>

In this code we are accessing information about the children of the homepage using `data.home._children`. Using a `for...in` loop, we are parsing out each child document and creating a link using the computed URL `_url` and the page title. We are wrapping this in an `if` statement to make sure we are only displaying pages that have public, not private visibility.

Next, we need to add our new fragment to our `views/layout.html` file. Let's take a look at that file again.

<AposCodeBlock>

``` nunjucks
{# Automatically extends the right outer layout and also handles AJAX siutations #}
{% extends data.outerLayout %}

{% import 'fragments/topbar.html' as topbar %}
{% import 'fragments/footer.html' as footer %}

{% set title = data.piece.title or data.page.title %}
{% block title %}
  {{ title }}
  {% if not title %}
    {{ apos.log('Looks like you forgot to override the title block in a template that does not have access to an Apostrophe page or piece.') }}
  {% endif %}
{% endblock %}

{% block extraHead %}
<link rel="icon" sizes="16x16" href="{{ apos.asset.url('/modules/asset/favicon/favicon-16.png')}}">
<link rel="icon" sizes="32x32" href="{{ apos.asset.url('/modules/asset/favicon/favicon-32.png')}}">
<link rel="icon" sizes="96x96" href="{{ apos.asset.url('/modules/asset/favicon/favicon-96.png')}}">
<link rel="icon" sizes="180x180" href="{{ apos.asset.url('/modules/asset/favicon/favicon-180.png')}}">
<link rel="icon" sizes="512x512" href="{{ apos.asset.url('/modules/asset/favicon/favicon-512.png')}}">
{% endblock %}

{% block beforeMain %}
  <header>
    {% render topbar.mainArea() %}
  </header>
  <main class="pr-main">
{% endblock %}

{% block afterMain %}
  </main>
  <footer>
    {% render footer.mainArea() %}
  </footer>
{% endblock %}
```
  <template v-slot:caption>
    views/layout.html
  </template>

</AposCodeBlock>

At the beginning of the file, we indicate that we are extending the `data.outerLayout` template. This template exposes a number of blocks that we can either replace or extend using `_super()`. Next, we are importing our existing topbar and footer fragments. Just below these existing imports add the following import to the code:

``` nunjucks
{% import 'fragments/navigation.html' as navigation %}
```
Next, we need to render our navigation. Alter the `beforeMain` block to the following:

``` nunjucks
{% block beforeMain %}
  <header>
    {% render topbar.mainArea() %}
    {% render navigation.pagetreeNavigation() %}
  </header>
  <main class="pr-main">
{% endblock %}
```

![Screenshot of navigation created through the page tree data](../images/sec2-6-pagetree-nav.png)

With this one new line, we are adding the markup from the `pagetreeNavigation` fragment to our site just below the topbar. To match the appearance of the final project we will also need to add in additional CSS. The partial SCSS file, `_theme-navigation.scss` can be copied from the `modules/asset/ui/src/scss` folder of the sec2-6-navigation branch into a folder of the same name in your project. Additionally, import the styling by adding the following to the `modules/asset/ui/src/index.scss` file:

<AposCodeBlock>

``` scss
@import './scss/_theme-navigation';
```
  <template v-slot:caption>
    modules/asset/ui/src/index.scss
  </template>

</AposCodeBlock>

The appearance of your navigation will depend on how many pages you have added to your site. Right now, if you were to switch the localization of your site, unless you have already localized all of your review pages, your navigation would disappear. If you haven't localized them yet, while in edit mode on the homepage open the context menu (three horizontal dots) and select 'Localize...'. You will then get a modal asking what content you want to localize. If you select 'This document and related documents' it will localize all the review pages to the selected locale as drafts. You will then have to publish all the pages in the new locale. Since we are building our navigation from the page titles, you will need to translate the titles to match the new locale before publishing to have them added to the navigation in the correct language.

## Generating navigation manually

Another approach to generating your navigation that can be more flexible, but also requires more work for the content editors, is by providing schema fields for adding menu items. Since the navigation is appearing on all pages, we will create the additional fields in the `modules/@apostrophecms/global` module. If you prefer, you could instead create a stand-alone piece-type module to hold your navigation items. This would be created using the CLI by running `apos add piece navigation`, adding the new module to the `app.js` file, and then adding the code we are going to add to the global module.

### Adding the navigation schema

Open the `modules/@postrophecms/global/index.js` file and add the following to the `fields/add` object:

<AposCodeBlock>

``` javascript
// Adding our array field, `primaryNav`
primaryNav: {
  label: 'Primary site navigation',
  type: 'array',
  titleField: 'label',
  help: 'Add, remove, and reorder navigation items.',
  // The array schema for each item
  fields: {
    add: {
      label: {
        label: 'Nav item label',
        type: 'string'
      },
      type: {
        label: 'Link type',
        type: 'select',
        choices: [
          {
            label: 'Page',
            value: 'page'
          },
          {
            label: 'Custom URL',
            value: 'custom'
          }
        ]
      },
      _page: {
        label: 'Page to link',
        type: 'relationship',
        withType: '@apostrophecms/page',
        max: 1,
        required: true,
        builders: {
          project: {
            title: 1,
            _url: 1
          }
        },
        // Only if it's a page link
        if: {
          type: 'page'
        }
      },
      customUrl: {
        label: 'URL for custom link',
        type: 'url',
        required: true,
        // Only if it's a custom link
        if: {
          type: 'custom'
        }
      },
      // A nice option to have the link open in a new tab
      // Could use a boolean here
      target: {
        label: 'Open new browser tab?',
        type: 'checkboxes',
        choices: [
          {
            label: 'Open in new tab',
            value: '_blank'
          }
        ]
      }
    }
  }
},
```
  <template v-slot:caption>
    modules/@postrophecms/global/index.js
  </template>

</AposCodeBlock>

Additionally, add our new schema field to its own tab in the editor by adding the following code to the `group` object:

<AposCodeBlock>

``` javascript
navigation: {
  label: 'Navigation',
  fields: [ 'primaryNav' ]
}
```
  <template v-slot:caption>
    modules/@postrophecms/global/index.js
  </template>

</AposCodeBlock>

![Screenshot of the navigation configuration with a simple array field and six pages added.](../images/sec2-6-simple-nav-array.png)

To add our navigation we are using an `array` type schema field. This field has its own field schema and allows the content editor to add one or more entries that contain all of those fields. It is stored in the database as an array of objects, one for each entry. The `fields` property should look fairly familiar and only has the `add` property to define all the schema fields for each array item. One new property here is the `titleField`. This property takes the name of a schema field in the array that should be used to name the individual arrays that are listed in the tabs to the left. The tabs themselves can be rearranged through drag-and-drop.

![Screenshot of the navigation with an inline array field.](../images/sec2-6-inline-nav-array.png)

Adding the `inline: true` and `draggable: true` properties convert the UI presentation of the array to one more reminiscent of the page tree. Rather than displaying each array item in tabs on the left, they are displayed in a list with each of the schema fields visible. Much like the tabs and the page tree, individual arrays can be dragged to rearrange.

![Screenshot of the navigation with inline style set to table.](../images/sec2-6-table-nav-array.png)

Finally, if we add the `style: 'table'` property in addition to the `inline: true` property then each array appears as a row in a table. Again, each of the individual arrays is draggable. This method of display isn't recommended if your arrays have conditional fields, as it will change the column labels if some arrays have a field while others do not. In this case, the `type` field conditionally impacts what schema field is added in the third column. Unless the content editor selects the same type for all the links, there will be cases where the label for the column won't match the type of input.

Drilling down into the schema fields of each array, we are allowing the user to either select an existing page through a `relationship` type field or to add a custom link through a `url` field. We are also allowing the content editor to alter the behavior of the link. We could also decide to programmatically add `target='_blank'` to the links only if they are a custom type.

### Adding the navigation markup

Once again, we are going to add our markup to the `views/fragments/navigation.html` file. Open this file and add the following to the end:

<AposCodeBlock>

``` nunjucks
{% fragment globalNavigation() %}
  <section class="mb-4 topnav">
    <div class="d-flex flex-wrap gap-5 justify-content-center me-auto ms-auto p-5 text-center">
      {% for item in data.global.primaryNav %}
          {% set path = '' %}
          {% if item.type === 'page' and item._page and item._page[0] %}
            {% set path = item._page[0]._url %}
          {% elif item.type === 'custom' %}
            {% set path = item.customUrl %}
          {% endif %}
          <a href="{{ path }}" style="text-decoration: none" class="fs-3 text-dark"
            {% if item.target[0] === '_blank' %} target="_blank" {% endif %}
          >{{ item.label }}</a>
      {% endfor %}
    </div>
  </section>
{% endfragment %}
```
  <template v-slot:caption>
    views/fragments/navigation.html
  </template>

</AposCodeBlock>

To create our navigation, we are once again using a `for...in` loop to step through each of the array items added to the `data.global.primaryNav` schema field. The `data.global` object is available in all templates. For each array, we are using an `if...elif` conditional to test if it is a `page` or `custom` URL. For pages, we are also making sure that the review piece still exists and hasn't been archived. Remember that `relationship` field returns an array of objects, so we need to gather information from the first item in the array `_page[0]`. Lastly, we create our navigation loop using the path we just set, the string the content editor wants to use as a label, and an `if` conditional to add `target="_blank"`.

Finally, in order to display our new navigation, we need to add it to the `views/layout.html` file. Open the file and modify the `beforeMain` block:

<AposCodeBlock>

``` nunjucks
{% block beforeMain %}
  <header>
    {% render topbar.mainArea() %}
    {# {% render navigation.pagetreeNavigation() %} #}
    {% render navigation.globalNavigation() %}
  </header>
  <main class="pr-main">
{% endblock %}
```
  <template v-slot:caption>
    views/layout.html
  </template>

</AposCodeBlock>

Here we have commented out the `pagetreeNavigation` fragment, but you can of course simply delete it. Now if we spin up our site, our former page tree navigation will be replaced by any links that you add through the global configuration schema.

## Creating breadcrumb navigation

Breadcrumb navigation shows visitors the series of pages from the page they are on back to the home page or other major landing page. To add breadcrumbs to our pages we will use a similar technique as we used for automatically constructing our navigation from the page tree. In that case, we were using `data.home._children`. In this case, we will use a different object, `data.page._ancestors`. This provides an array of page objects, starting with the home page, continuing through the page tree and ending with the parent of the current page.

The only caveat is if a visitor is on the [show page](/guide/piece-pages.md#the-show-page-template) for a piece. In that case, the `data.page` object points at the index page for the piece, not the show page that the user is currently viewing. In this case, even though the individual review pieces don't have a page in the page tree, we can place them as children of the index page with a link. We can test if we are on a show page by checking if `data.piece` exists and change our markup output accordingly.

<AposCodeBlock>

  ``` nunjucks
  {# Use module helper to check environment variable #}
  {% set debugMode = apos.modules['asset'].debugMode() %}
  {# Breadcrumb trail to the current page or piece. Not on the home page, only in devMode #}
  {% if data.page and data.page._ancestors.length and debugMode %}
    <nav class="breadcrumb">
      {# Loop over the ancestors. #}
      {% for page in data.page._ancestors %}
        <a href="{{ page._url }}">{{ page.title }}</a> -> 
      {% endfor %}
      {% if data.piece %}
        {# We're rendering a show page. #}
        <a href="{{ data.page._url }}">{{ data.page.title }}</a> -> 
        <span>{{ data.piece.title }}</span>
      {% else %}
        {# We're rendering a normal page. #}
        <span>{{ data.page.title }}</span>
      {% endif %}
    </nav>
  {% endif %}
  ```
  <template v-slot:caption>
    views/layout.html
  </template>

</AposCodeBlock>

This breadcrumb trail isn't part of the design of our final project but might be useful for debugging, or at least demonstrating how you can change your template using an environment variable! If you want to see the output of the markup, you can add this code into the `views/layout.html` page in either the `beforeMain` or `afterMain` blocks.

Ignoring the first line of code for now, we are wrapping our markup in an `if` conditional and testing for three things. First, we are performing null checking on the `data.page` object, even though it should be there. Next, we are checking whether that same object has a computed `_ancestors` property. The only pages that shouldn't are the home page or another top-level landing page. Finally, we are checking the value of the `debugMode` variable that we will revisit. If all of these are true, we output the markup.

Next, we set up a `for...in` loop over the `_ancestors` object, outputting a link for each with their URL and title, plus an arrow (`->`) separator. Finally, we use an `if...else` conditional to determine if we are in a piece. If so, we output a link to the index page for that piece, plus the title of the piece as the final breadcrumb. Otherwise, we just output the page title.

Returning to the `debugMode` variable. If we only want to display this markup if the user enters an environment variable at startup, we need to have a way to check on that variable. We can't do that directly in a Nunjucks template, but we can in our module JavaScript.

<AposCodeBlock>

``` javascript
helpers(self) {
  return {
    async debugMode() {
      return process.env.DEBUG === 'true';
    }
  };
}
```

<template v-slot:caption>
  modules/asset/index.js
</template>

</AposCodeBlock>

In order to pass our environmental variable to the template, we are going to use a `helper()` configuration method in our asset module. This method essentially adds helper functions to the Nunjucks templates. In this case, we are adding a simple function, `async debugMode()`, that doesn't take any arguments. You can see by the function declaration that you could leverage the 'await' keyword to pause execution until a Promise is resolved, ensuring sequential execution where necessary. In this case, we are simply checking the `DEBUG` environment value and passing a boolean to the template based on that value. In the first line of code in the template, `{% set debugMode = apos.modules['asset'].debugMode() %}` we are calling the method. Since the template is located within the top-level `views` folder we need to use `apos.modules['asset']` to identify the module supplying the method. Let's reiterate, in this instance we're not passing any arguments from the template to the method. However, in your custom helpers, you might want to pass a value such as `data.piece.productPrice`. This could be useful, for instance, when calculating a sale price or regional taxes. Finally, we check that the returned value is `true`, indicating that the project was started with the `DEBUG` environment variable set to `true`. This results in the `debugMode` variable in our template being set to true, allowing the breadcrumb navigation to be rendered. To see your breadcrumbs start the site using `DEBUG=true npm run dev`.

## Adding quick links to the footer
In addition to primary navigation elements like breadcrumbs and menus, a website's footer serves as a secondary navigation area that's crucial for enhancing the user experience. One common feature is a section for 'Quick Links,' which provides easy access to important pages on your site or to external resources. Currently, our quick links section is populated with hard-coded links. To convert this to user selected links we are going to reuse code that we already added to the `modules/@apostrophecms/global/index.js` file. Open that file and add the following into the `add` object of the `property` below the `primaryNav` array field:

<AposCodeBlock>

``` javascript
quickLinks: {
  label: 'Quick links',
  type: 'array',
  titleField: 'label',
  help: 'Add, remove, and reorder navigation items.',
  // The array schema for each item
  fields: {
    add: {
      label: {
        label: 'Nav item label',
        type: 'string'
      },
      type: {
        label: 'Link type',
        type: 'select',
        choices: [
          {
            label: 'Page',
            value: 'page'
          },
          {
            label: 'Custom URL',
            value: 'custom'
          }
        ]
      },
      _page: {
        label: 'Page to link',
        type: 'relationship',
        withType: '@apostrophecms/page',
        max: 1,
        required: true,
        builders: {
          project: {
            title: 1,
            _url: 1
          }
        },
        // Only if it's a page link
        if: {
          type: 'page'
        }
      },
      customUrl: {
        label: 'URL for custom link',
        type: 'url',
        required: true,
        // Only if it's a custom link
        if: {
          type: 'custom'
        }
      },
      // A nice option to have the link open in a new tab
      target: {
        label: 'Will the link open a new browser tab?',
        type: 'checkboxes',
        choices: [
          {
            label: 'Open in new tab',
            value: '_blank'
          }
        ]
      }
    }
  }
},
```
  <template v-slot:caption>
    modules/@apostrophecms/global/index.js
  </template>

</AposCodeBlock>

This code almost completely duplicates the `primaryNav` field. In a real production site we would likely factor the fields for each array out into a separate file to be imported and added, rather than duplicating the code. Add the `quickLinks` to the `footer` tab of the groups:

<AposCodeBlock>

``` javascript
group: {
  navigation: {
    label: 'Navigation',
    fields: [ 'primaryNav' ]
  },
  footer: {
    label: 'Footer',
    fields: ['_featuredPost', 'quickLinks' ]
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/global/index.js
  </template>

</AposCodeBlock>

### Modifying the `footer.html` fragment
To display our new `quickLinks`, we need to change the Nunjucks markup for the first column in the `div` with a class of `row`. Replace the entire first column (with classes of `col-lg-4` and `py-3`) with the following:

<AposCodeBlock>

``` nunjucks
<div class="col-lg-4 py-3">
  <h2 class="fw-bold h5 mb-4 text-primary text-uppercase">Quick Links</h2>
  <div class="row">
    <div class="col-sm-6">
      <ul class="list-unstyled">
        {% for item in data.global.quickLinks %}
          <li class="mb-3">
            {% set path = '' %}
            {% if item.type === 'page' and item
              ._page and item
              ._page[0] %}
              {% set path = item
                ._page[0]
                ._url %}
            {% elif item.type === 'custom' %}
              {% set path = item.customUrl %}
            {% endif %}
            <a href="{{ path }}" class="text-secondary" {% if item.target[0] === '_blank' %} target="_blank" {% endif %}>{{ item.label }}</a>
          </li>
        {% endfor %}
        </ul>
    </div>
    <div class="col-sm-6">
      <ul class="list-unstyled">
        <li class="mb-3">
          <a href="#" class="text-secondary">Web Design</a>
        </li>
        <li class="mb-3">
          <a href="#" class="text-secondary">Web Development</a>
        </li>
        <li class="mb-3">
          <a href="#" class="text-secondary">WordPress</a>
        </li>
        <li class="mb-3">
          <a href="#" class="text-secondary">Digital Marketing</a>
        </li>
        <li class="mb-3">
          <a href="#" class="text-secondary">Content Writing</a>
        </li>
      </ul>
    </div>
  </div>
</div>
```
  <template v-slot:caption>
    views/fragments/footer.html
  </template>

</AposCodeBlock>

This will cause the first set of links in the quick links section to be replaced with the user's selection. It uses a `{% for ... in %}` loop to output each item as a list item. As with the `primaryNav` in the `views/fragments/navigation.html` that we added previously in this tutorial, we have some code to correctly set the link if it is a page or custom URL.

## Bonus: Adding social links to the footer
While the primary function of a website's footer is to assist with internal navigation, it can also serve as a bridge to external platforms, specifically social media channels. Including social media links in your footer is a strategic way to extend the user's journey beyond your website and encourage engagement on various social platforms. We will finish out this tutorial by quickly adding social media links using the font-awesome icon set we installed when creating the `rating-widget` module.

### Adding the schema fields
We will be adding our fields to select the social media links into the footer, so it makes sense to once again modify the `global` module. Open the `modules/@apostrophecms/global.index.js` file and add the following code to the `add` object of the `fields` property:

<AposCodeBlock>

``` javascript
socialLinks: {
  label: 'Social Links',
  type: 'array',
  titleField: 'label',
  fields: {
    add: {
      label: {
        label: 'Social Media Name',
        type: 'string',
        required: true
      },
      url: {
        label: 'Account URL',
        type: 'url',
        required: true
      },
      icon: {
        label: 'Icon',
        type: 'select',
        choices: [
          {
            label: 'Facebook',
            value: 'fab fa-facebook'
          },
          {
            label: 'Twitter',
            value: 'fab fa-twitter'
          },
          {
            label: 'Instagram',
            value: 'fab fa-instagram'
          },
          {
            label: 'YouTube',
            value: 'fab fa-youtube'
          },
          {
            label: 'Pinterest',
            value: 'fab fa-pinterest'
          },
          {
            label: 'LinkedIn',
            value: 'fab fa-linkedin'
          },
          {
            label: 'RSS',
            value: 'fas fa-rss'
          }
        ],
        required: true,
        def: 'fa-brands fa-facebook'
      }
    }
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/global/index.js
  </template>

</AposCodeBlock>

First up we are asking for the name of the social media network. This isn't really needed for the end markup, the first field in an array will give it a name in the list of array items. Next, we are capturing the link address, and finally we are providing an icon through a `select` field. The values for each choice are the font-awesome classes for that social network.

Make sure to add your new array field to the footer tab.
<AposCodeBlock>

``` javascript
group: {
  navigation: {
    label: 'Navigation',
    fields: [ 'primaryNav' ]
  },
  footer: {
    label: 'Footer',
    fields: ['_featuredPost', 'quickLinks', 'socialLinks' ]
  }
}
```
  <template v-slot:caption>
    modules/@apostrophecms/global/index.js
  </template>

</AposCodeBlock>

### Adding social links to the footer markup
Open the `views/fragments/footer.html` file and replace the code for the third column with the following code:

<AposCodeBlock>

``` nunjucks
<div class="col-lg-4 py-3">
  <h2 class="fw-bold h5 mb-4 text-primary text-uppercase">Other</h2>
  <p class="mb-3">Subscribe to our newsletter and get exclusive updates directly in your inbox.</p>
  <form class="mb-4">
    <div class="bg-white border input-group overflow-hidden p-1 rounded-pill">
      <input
        type="email"
        class="border-0 form-control pe-3 ps-3"
        placeholder="Enter email..."
        aria-label="Recipient's email"
        aria-describedby="button-addon2"
        required>
        <button class="btn btn-primary pb-2 pe-4 ps-4 pt-2 rounded-pill" type="submit" id="button-addon2" aria-label="submit">
          <svg viewBox="0 0 24 24" fill="currentColor" class="d-inline-block" height="16" width="16">
            <path d="M1.946 9.315c-.522-.174-.527-.455.01-.634l19.087-6.362c.529-.176.832.12.684.638l-5.454
              19.086c-.15.529-.455.547-.679.045L12 14l6-8-8 6-8.054-2.685z"></path>
          </svg>
        </button>
      </div>
  </form>
  <h2 class="fw-bold h5 mb-2 text-primary text-uppercase">Get Social</h2>
  <div class="d-inline-flex flex-wrap">
      {% for account in data.global.socialLinks %}
        {% set path = '' %}
        {% if account.url %}
          {% set path = account.url %}
        {% endif %}
        <a href="{{ path }}" class="p-1 text-secondary" aria-label="{{ account.label }}" target="_blank"><i class="{{ account.icon }}"></i></a>
      {% endfor %}
  </div>
  <div class="pb-3 pt-3 small">
    <hr class="mt-0 ">
    <div class="align-items-center row">
      <div class="col-md pb-2 pt-2">
        <p class="mb-0">&copy; 2002 - 2020. All Rights Reserved - Company Name</p>
      </div>
      <div class="col-md-auto pb-2 pt-2">
        <a href="#" class="text-secondary">Privacy Policy</a>
        |
        <a href="#" class="text-secondary">Terms of Use</a>
      </div>
    </div>
</div>
```
  <template v-slot:caption>
    views/fragments/footer.html
  </template>

</AposCodeBlock>

We are only altering the portion of code in the div below the `Get Social` H2 tag. Once again, we are using a `{% for ... in %}` loop to step through our array elements. This time we are just outputing a link with the URL entered by the user surrounding a span with the icon class names.

## Summary and next steps

In this tutorial, we looked at two different methods for constructing page navigation. The first used the `data` object that Apostrophe makes accessible from every template. For the second we revisited how to use the `@apostrophecms/global` module configuration schema to make data available from any page. For both of these methods, we took advantage of fragments and the `views/layout.html` file to add the navigation to our page. Unlike when we added the topbar and footer fragments, we added multiple fragments to the same file.

Although we only touched on it briefly, we also looked at how to add breadcrumbs to pages. While we only used the `data` object to accomplish this, we could also have used the global configuration. We also added this markup directly into the layout, but we could have easily added it as a fragment in the `views/fragments/navigation.html` file. We also touched on how `helper(self)` configuration methods can manipulate and pass data for use in your templates.

Finally, we looked at how to make the links in our footer more dynamic by allowing the user to add new quick links and social media links through the global site configuration editor.

In the next tutorial, we are going to look at some ways that the admin UI can be altered, including a look at re-organizing the admin-bar and how to configure the Personal Settings menu.

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS > Configuring the Admin Bar
DOC_PATH: tutorials/admin-ui.md
URL: https://apostrophecms.com/docs/tutorials/admin-ui
================================================================================
# Admin-bar Customization

<iframe src="https://www.youtube.com/embed/sqd11WxjcBs?si=FH5hYWmztxJmj1Eu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the video and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

The admin-bar serves as the primary interface for editors, enabling them to create new pieces and pages, manage media files, and handle user roles and permissions. Additionally, it offers access to global configuration settings, locale selection and the personal settings menu. One of its crucial functions is managing the document publication workflow, providing notification to users with appropriate permissions about documents awaiting approval.

In this tutorial, we aim to streamline the admin-bar to enhance the process of adding content to pages. We'll also touch on the process of adding custom buttons to further enhance your ApostropheCMS experience. You can either elect to make code changes as you follow along with the tutorial, or you can switch to branch `sec2-7-ui-customization` of the [repo](https://github.com/apostrophecms/apostrophe-onboarding-project).

## Managing menu items

### Grouping items
![Screenshot of the left side of the project admin-bar showing multiple related menus](../images/sec2-7-admin-bar.png)
The left side of our current project admin-bar has a number of items that could be grouped together. The `Images`, `Image Tags`, `Files`, and `File Tags` buttons all open modals that allow for the management of media files. To group these items, we will make a project-level extension of the core module and pass in a `groups` option. Create a `modules/@apostrophecms/admin-bar/index.js` file and add the following code:

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    groups: [
      {
        label: 'Media',
        items: [
          '@apostrophecms/image',
          '@apostrophecms/file',
          '@apostrophecms/image-tag',
          '@apostrophecms/file-tag'
        ]
      }
    ]
  }
};

```
  <template v-slot:caption>
    modules/@apostrophecms/admin-bar/index.js
  </template>

</AposCodeBlock>

We are only creating a single new group with this code, but by passing additional objects in the `groups` array we could create as many as we would like. Each of the objects should contain two required properties, `items` and `label`.

The `items` array contains the names of the individual menu items you want to appear in the dropdown, listed in the order you want them to appear. Note: Menu names for `piece-type` items are the name of the piece-type, not the label. For core items, like 'Images', the name is prefixed - `@apostrophecms/image`.

The `label` property provides a label on the admin-bar that is displayed to the user. If your project has several locales configured, this string should also be added to your project translation JSON files. In this case we are modifying both of our project files to include one new line at the end of each file.

<AposCodeBlock>

```json
{
  "apostropheProductReviews": "Apostrophe Product Reviews",
  "findTheBest": "Find the best",
  "becomeAMember": "Become a member",
  "Media": "Media"
}
```
  <template v-slot:caption>
    modules/@apostrophecms/global/i18n/en.json
  </template>

</AposCodeBlock>

<AposCodeBlock>

```json
{
  "apostropheProductReviews": "Apostrophe Produktbewertungen",
  "findTheBest": "Finden Sie das Beste",
  "becomeAMember": "Werden Sie Mitglied",
  "Media": "Medien"
}
```
  <template v-slot:caption>
    modules/@apostrophecms/global/i18n/de.json
  </template>

</AposCodeBlock>

### The quick create menu

By default, the quick create menu is located after the other menu items on the left side of the admin-bar and contains buttons for creating a new page and any custom piece-types. Clicking these buttons will skip the opening of the initial manager modal and opens a new item for editing directly. You can elect to block this default behavior by setting the `quickCreate` option to `false` in the `/modules/@apostrophecms/page/index.js` file for pages, or any custom piece-type module.

## Creating a custom menu item

The creation of a custom menu item is a two-step process. The first step is to add the button to the admin-bar using the `add()` function of the `@apostrophecms/admin-bar` module. The second is to add browser-side JavaScript to respond to the listener that Apostrophe adds to the admin-bar. We won't be using a custom button in this project, but it is a worthwhile exercise to add one to understand where to best add the code for future projects.

### Adding the custom button
![Screenshot of the project admin-bar with a custom button added before the Locales dropdown](../images/sec2-7-custom-button.png)

We are going to add the button through our custom `review` piece-type module. Open the `modules/review/index.js` file and insert the following code:

<AposCodeBlock>

``` javascript
init(self) {
  self.apos.adminBar.add('customButton', 'Custom', false, {
    contextUtility: true,
    icon: 'anchor-icon'
  });
},
```
  <template v-slot:caption>
    modules/review/index.js
  </template>

</AposCodeBlock>

The first argument is the name that will be emitted when the button is clicked. It should be unique, and we will return to this when we look at how to listen for the click event.

The second parameter specifies the label that appears on the button in the admin bar. If the menu item shows as an icon, this label will still be included but assigned a `apos-sr-only` class, making it accessible to screen readers while remaining hidden on the menu bar.

The third argument is the permissions required for a user to be able to see the button based on the action that it will perform. Setting it to false will let any logged-in user view and click the button. Delving into the object of actions and types this argument can take is beyond the scope of this tutorial, but is covered in the [documentation](/reference/modules/admin-bar.md#add-name-label-permission-options).

The final argument is an optional object of properties that dictate the position and display of the custom button. If you are adding multiple custom buttons, they are added in the order that the modules are registered in the `app.js` file. Setting the `last` option to `true` will place the button just to the left of the quick create menu icon, irrespective of when it is registered. The `contextUtility` option also takes a boolean value and if set to `true` will cause the button to show up on the right-hand side of the admin bar before any potential localization or the personal settings menu. If you set this option to true you must also set the `icon` option to a registered icon name as was covered in the [Creating Widgets](/tutorials/widgets.html) tutorial - you can also read about this in the [documentation](/reference/module-api/module-overview.md#icons).

### Adding button functionality

Now that we have a button added to our admin bar, we need to add JavaScript code to the front end to make it functional. Code that extends the app functionality is typically added into the `ui/apos` folder of the module. Within this folder there can be any number of folders, but two common folders are the `components` and `app` folders. The `components` folder is used when adding custom Vue components to the admin UI. In this case, we are going to add code to the `app` folder. This code will be added to the `public/apos-frontend/<releaseid>/apos-build.js` file at build time. This is in contrast to the JavaScript code we added to the `ui/src/` folder of the `ratings-widget` that gets compiled into the `src-build.js` in the same folder.

Create a `modules/review/ui/apos/apps/customButton.js` file and add the following code:

<AposCodeBlock>

``` javascript
export default () => {
  apos.bus.$on('admin-menu-click', async (name) => {

    console.log('admin-menu-click received for button named: ', name);
    // Make sure it is the button we care about, leave others to their own handlers
    if (name !== 'customButton') {
      return;
    }
    // Add the code that needs to run when the button is clicked here
    console.log('The custom button was clicked!');
  });
};
```
  <template v-slot:caption>
    modules/review/ui/apos/apps/customButton.js
  </template>

</AposCodeBlock>

The `apos.bus` helper allows you to listen for bus events emitted by any other module. In this case, one of the admin-bar Vue components emits the name of which button was clicked using `apos.bus.$emit('admin-menu-click', name);`. The code above "listens" for the `admin-menu-click` emission and passes the button name into the callback function. Just for fun, we are logging what button was clicked. Next, we test whether the passed name matches our custom button name and returns early if it doesn't. Otherwise, we run our custom code to perform our custom button function.

We can bring our project up and test the button functionality. It is good when altering the admin UI to start your project with the `APOS_DEV` environment variable on using `APOS_DEV=1 npm run dev`. This forces a rebuild of the UI. Normally this is turned off to save build time between code changes. Once your project is up, and you are logged in, you can click on any button in the admin-bar. This will result in a message being logged to the browser console - remember that this is browser-side code, not server side code. The message should have the name of the button that was clicked. If you click the new custom button, it will log the additional message. Note that the dropdown menus, like the quick create menu, will not emit an event.

## Customizing the personal settings menu

![Screenshot of the personal settings menu with new fields added.](../images/sec2-7-personal-settings.png)

The `@apostrophe/settings` module allows you to customize the dropdown menu on the right side of the admin-bar. When this module isn't configured this menu shows the user's display name that was set through the `Users` manager modal and can be used to logout. Any schema field that have been added to the `@apostrophecms/user` module either in core or at the project-level can be modified in the personal settings menu. This menu can also be configured to allow the user to select to have the admin UI language remain fixed when they change locales. This requires that the `adminLocals` option of the `@apostrophecms/i18n` modules be set.

### Configuring the `@apostrophecms/user` module

Open the `modules/@apostrophecms/settings/index.js` file and replace the existing code with the following:

<AposCodeBlock>

``` javascript
module.exports = {
  options: {
    subforms: {
      changePassword: {
        // This will have `protection: true` automatically.
        fields: [ 'password' ]
      },
      displayName: {
        // The default `title` field is labeled 'Display Name' in the `@apostrophecms/user` module.
        // Changing this field will **not** change the Username or Slug of the user.
        fields: [ 'title' ],
        reload: true
      },
      fullName: {
        // Passing in a label so that it doesn't use the label for `lastName`
        // These fields need to be added to the user schema
        label: 'Full Name',
        // Schema fields added at project level
        fields: [ 'lastName', 'firstName' ],
        preview: '{{ firstName }} {{lastName}}'
      },
      // The `adminLocales` option **must** be configured in the `@apostrophecms/i18n` module for this to be allowed
      adminLocale: {
        fields: [ 'adminLocale' ]
      }
    },
    groups: {
      account: {
        label: 'Account',
        subforms: [ 'displayName', 'fullName', 'changePassword' ]
      },
      preferences: {
        label: 'Preferences',
        // The `adminLocales` option **must** be configured in the `@apostrophecms/i18n` module for this to be allowed
        subforms: [ 'adminLocale' ]
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/settings/index.js
  </template>

</AposCodeBlock>

Walking through this code, you can see that the menu is configured through the `subforms` and `groups` options. In this case we are adding four subforms, items that will show up as editable fields in the menu, grouped into two tabs.

The first item we are adding will allow the user to change their password. The only configuration we are adding to the object is the required `fields` key. This property takes an array of strings that are the names of schema fields set in either the `@apostrophecms/user` module, or in one specific case, the `@apostrophecms/i18n` module. As noted in the code comments, this field is configured in the core module to automatically have a `protection: true` property. This will require the user to enter their password in order to change this field. This same property can be added to any `subform` object to require a password. The `password` field also automatically sets the `help` property of the subform to display 'Modify your existing password' to the right of the label, rather than the actual password. The `help` string for any subform can be localized to display in the user's preferred language by adding the text of the string to the appropriate language JSON files.

The second item we are adding is the `displayName`. This will alter the value of the existing `title` field in the user schema. Note that within the `Users` manager the slug and username fields follow the `title`. Changing the display name from the `Users` manager will alter these two fields, however, these fields will not be altered when using the personal settings menu. We are also adding a `reload: true` property. This will cause the site to reload after the information in this field is updated, otherwise the display name wouldn't change until the user manually refreshed the page. We don't need to add a `label` property because the `@apostrophecms/settings` module will automatically use the label for the `title` field from the existing `@apostrophecms/user` module configuration. We also don't need to set up a value to display to the right of the value since we are only modifying a single field, the module will automatically display the input value.

The third subform we are adding will actually alter the value of two user fields, `lastName` and `firstName`. In this case we are passing the `label` property to set what is displayed to the user. Otherwise, the module would use the label for the first schema field added to the `fields` array - in this case, `lastName`. We are also adding a `preview` property with a string that looks like Nunjucks templating. This actually leverages i18next as a templating system, allowing us to reorder and localize the input to match the preferred locale. In place of `preview` or `help`, we could also use the `previewComponent` property to add a custom Vue component for modifying and displaying the input. You can read more about this property in the [reference documentation](/reference/modules/settings.md#previewcomponent).

Finally, we are adding an input so that the user can change their preferred UI language. As explained in the code comment, this needs to be further configured in the `@apostrophecms/i18n` module to be functional.

The `groups` options works in the same way as the schema fields `groups` option. Each of the `subform` items can be added to a named tab with a `label` property and an array of `subforms` names added to the `subforms` property.

### Configuring the `@apostrophecms/i18n` module

Open the `modules/@apostrophecms/i18n/index.js` and modify the `options` to include:

<AposCodeBlock>

``` javascript
adminLocales: [
  // you can add an object for as many or few of the locales as desired
  // the user will only be able to select from these locales in the personal preferences menu
  {
    label: 'English',
    value: 'en'
  },
  {
    label: 'Deutsch',
    value: 'de'
  }
],
// This will cause the admin UI to always use the English locale
// unless the user deliberatly selects another language, or 
// for the UI language to change with the selected locale
defaultAdminLocale: 'en'
```
  <template v-slot:caption>
    modules/@apostrophecms/i18n/index.js
  </template>

</AposCodeBlock>

Adding the `adminLocales` to your `@apostrophecms/i18n` module options will automatically add a menu for language preference to the `Users` manager. Our `@apostrophecms/settings` module configuration will add it to the personal settings module.

### Configuring the `@apostrophecms/user` module

Create a `modules/@apostrophecms/user/index.js` file and add the following code:

<AposCodeBlock>

``` javascript
module.exports = {
  fields: {
    add: {
      firstName: {
        type: 'string',
        label: 'First Name'
      },
      lastName: {
        type: 'string',
        label: 'Last Name'
      }
    },
    group: {
      account: {
        label: 'Account',
        fields: [
          'firstName',
          'lastName'
        ]
      }
    }
  }
};

```
  <template v-slot:caption>
    modules/@apostrophecms/user/index.js
  </template>

</AposCodeBlock>

In this code we only need to add the `firstName` and `lastName` fields. All the other fields, like `title` or `changePassword` already exist in core or are added by other modules.


## Summary and next steps

In this tutorial, we focused on enhancing the functionality and user experience of the admin-bar in ApostropheCMS. We began by organizing related menu items into a single group to make navigation more intuitive. Additionally, we explored how to add a custom button to the admin-bar and walked through the process of adding front-end JavaScript to make this button functional. Finally, we covered how to customize the personal settings menu, allowing users to change their passwords and display names directly from the admin-bar.

This only scratches the surface of the modifications that can be made to the admin UI. In addition to changing the admin-bar, you can also add custom schema fields, custom manager modals, customized `@apostrophecms/rich-text-widget` controls, and more. You can read about these modifications in our [documentation pages](/guide/custom-ui.md).

Next, we are going to look at how to add an extension from Apostrophe's library of modules. Not only are these extensions useful for adding functionality to your projects, but they are also useful for better understanding the Apostrophe codebase. We will use this as an opportunity to look at how we can bundle our own custom modules that can be brought into multiple projects.

================================================================================
COLLECTION: tutorials
NAV_PATH: Intro to ApostropheCMS > Adding Extensions
DOC_PATH: tutorials/adding-extensions.md
URL: https://apostrophecms.com/docs/tutorials/adding-extensions
================================================================================
# Adding extensions to your project

<iframe src="https://www.youtube.com/embed/HSpGCfnBIe8?si=P-KSSpaM4vZFePv-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the video and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

Extensions are a way to easily add functionality to your project, whether by adding modules created by other developers, or a set of self-developed, custom modules that get installed in your project. Apostrophe's own library of extension also contains great examples for learning Apostrophe's codebase.

For the final tutorial of our basic project build, we are going to install two different extensions. First, we will install the `seo` extension. This extension is a good example of how a set of bundled modules can improve multiple core modules as well as modify the project layout template. Next, we will install the `blog` extension. In this case, the `blog` extension doesn't improve any core modules, but it provides a useful example of how to implement piece-type filters, queries, and the `extendMethods()` function when creating a new piece-type.

The amount of actual code creation in this template will be minimal,but you can switch to the `sec2-8-adding-extensions` branch of the [project repository](https://github.com/apostrophecms/apostrophe-onboarding-project) like with previous tutorials. Alternatively, you can just install the two extensions using the npm commmands detailed below and add the modules into the `app.js` file of your local project.

## The ApostropheCMS extensions page

![Screenshot of the ApostropheCMS website Extensions library page](../images/sec2-8-extension-page.png)

In addition to other resources like blog articles and tutorials, the [ApostropheCMS website](https://apostrophecms.com/extensions) has a section for extensions provided by the Apostrophe engineering team and outside contributors. The page is a great resource for searching through the extension library.

Once you find an extension that seems useful, you can click to read more information about the extension, find the installation instructions, or click through to the repository on GitHub to look at the code.

## The `seo` extension

The `@apostrophecms/seo` module adds meta fields to all pages and pieces, which provide useful functionality like Google Analytics support. In this section of the tutorial we aren't going to focus on proper SEO practices or the content that this module adds. Instead, we will focus on two aspects of this module. First, how the SEO module accomplishes the installation of multiple modules and second, how to modify multiple pages and pieces using `improve` and template injection.

### Installation

To install the `seo` extension we will go to the [extension page](https://apostrophecms.com/extensions/seo-tools-3) and follow the installation instructions. There are two steps. First, from within the root directory of your project run `npm install @apostrophecms/seo`. This command installs the modules into your `npm_modules/@apostrophecms` folder and updates your `package.json` file. Next, we open our `app.js` file and add it to our `modules` configuration as you would with any new project-level module. 

<AposCodeBlock>

``` javascript
require('apostrophe')({
  shortName: 'apostrophe-onboarding-project',
  modules: {
    '@apostrophecms/seo': {},
    // the remainder of the project modules
  }
};

```
  <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

A base URL is necessary for deploying an SEO extension-enabled project to production. Adding one can be done either by using the `APOS_BASE_URL` environment variable, or by setting the `baseUrl` option during deployment. If the base URL is set during local development you will see problems with asset loading and login.

### Package structure
Like the other custom modules we created for this onboarding project, the top level of this package is an `index.js` file.

<AposCodeBlock>

``` javascript
const fs = require('fs');
const path = require('path');

module.exports = {
  options: {
    alias: 'seo',
    i18n: {
      ns: 'aposSeo',
      browser: true
    }
  },
  bundle: {
    directory: 'modules',
    modules: getBundleModuleNames()
  },
  init(self) {
    self.apos.template.prepend('body', '@apostrophecms/seo:tagManagerBody');
    self.apos.template.append('head', '@apostrophecms/seo:tagManagerHead');
    self.apos.template.prepend('head', '@apostrophecms/seo:metaHead');
  },
  components(self) {
    return {
      async metaHead(req, data) {},
      async tagManagerBody(req, data) {},
      async tagManagerHead(req, data) {}
    };
  }
};

function getBundleModuleNames() {
  const source = path.join(__dirname, './modules/@apostrophecms');
  return fs
    .readdirSync(source, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => `@apostrophecms/${dirent.name}`);
}

```
  <template v-slot:caption>
    npm_modules/@apostrophecms/seo/index.js
  </template>

</AposCodeBlock>

#### `options`

``` javascript
options: {
  alias: 'seo',
  i18n: {
    ns: 'aposSeo',
    browser: true
  }
}
```
Let's walk through the code starting with the `options`. The first property, `alias`, provides a quick reference to the module on the `apos` object. We covered this briefly in the [Creating Widgets](/tutorials/widgets.html) tutorials in this series when we accessed the columns helper function. Basically, instead of using `apos.modules['@apostrophecms/seo']`, you can use `apos.seo`. You do **not** want to do this for most publicly available modules (those that would be distributed to multiple projects) to prevent naming conflicts.

The next option property is `i18n`. This property sets up a namespace for localization strings for files in this module. This method of setting the namespace is deprecated but still supported. Instead, within the `i18n` object an `aposSeo` key should be added with additional configuration supplied via an object of that key.

``` javascript
...
i18n: {
  aposSeo: {
    browser: true
  }
}
...
```
In this case, `browser: true` makes the translation strings available within the Vue components of the admin UI when a user is logged in. Looking at the overall project structure, we can see that there is an `i18n` folder at the root level of the project. The JSON files in this folder provide the translation strings and do not need to be prefixed with `aposSeo`. However, within the modules, any time these strings are used you need to prefix with `aposSeo:` to fetch the translation from the correct folder.

#### `bundle`

``` javascript
bundle: {
  directory: 'modules',
  modules: getBundleModuleNames()
},
```

Following the `options` is a top-level configuration object that we haven't covered: `bundle`. It can take an object with two properties. The `directory` property takes a relative path to the directory of the modules to be loaded. Looking at the `npm_modules/@apostrophecms/seo` folder, we can see that the `modules` folder is in the same directory as the `index.js` file.

``` javascript
function getBundleModuleNames() {
  const source = path.join(__dirname, './modules/@apostrophecms');
  return fs
    .readdirSync(source, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => `@apostrophecms/${dirent.name}`);
}
```

The `modules` property takes an array of module names. In this case, that array is supplied by the function `getBundleModuleNames()`, located at the end of the `index.js` code. Using this approach allows for registration of any number of modules quickly.

#### `init(self)` & `components(self)`

``` javascript
init(self) {
  self.apos.template.prepend('body', '@apostrophecms/seo:tagManagerBody');
  self.apos.template.append('head', '@apostrophecms/seo:tagManagerHead');
  self.apos.template.prepend('head', '@apostrophecms/seo:metaHead');
},
components(self) {
  return {
    async metaHead(req, data) {},
    async tagManagerBody(req, data) {},
    async tagManagerHead(req, data) {}
  };
}
```

The `init(self)` and `components(self)` configuration objects work together to add markup to the `<head>` and two sections of the `<body>`. First, three new components are added by the `components(self)` method. The template for each component is located in the `npm_modules/@apostrophecms/seo/views` folder where the name for the markup file matches the name of the function in the components object with `html` appended. This was covered in the [Creating Widgets](/tutorials/widgets.html) tutorial.

From within the `init(self)` function, the module takes advantage of the `prepend()` and `append()` functions exposed by the `@apostrophecms/template` module. These function specify where additional content can be added to the `@apostrophecms/template/views/outerLayoutBase.html` file. You can examine this file to see where these "injection" points are with respect to the blocks that we covered in the [Creating Pages](/tutorials/pages.html) tutorial. Modifying the base layout file allows you to modify all page templates that are using the `outerLayoutBase.html` file, without knowing the markup of the individual templates or having to add the module to every page individually.

#### The components
The Nunjucks templates for each of the components are fairly standard. The `views/404.html`, `views/tagManagerBody.html`, and `views/tagManagerHead.html` all poll the `@apostrophecms/global` module options. The `views/metaHead.html` markup is slightly different.

<AposCodeBlock>

``` nunjucks
{% set home = data.home %}
{% set piece = data.piece %}
{% set page = data.page %}
{% set global = data.global %}
{% set document = piece or page %}

{# title #}
{% set seoTitle = piece.seoTitle or page.seoTitle or home.seoTitle %}
{% if seoTitle %}
  <meta name="title" content="{{ seoTitle }}" />
{% endif %}
```
  <template v-slot:caption>
    node_modules/@apostrophecms/seo/views/metaHead.html
  </template>

</AposCodeBlock>

This same template can be used on a piece-page or another page-type, so it has to pull data from any of these sources. It then uses conditional logic to retrieve data from any of the possible sources to apply in the template. If there was also data being harvested and applied to widgets, `data.widgets` might also need to be polled for the desired data.

#### The modules
The `seo` extension bundles eight modules that each `improve` a different core apostrophe module. By improving each of these core modules, the core modules and all custom modules in your project that extend these same core modules will have these code changes.

``` javascript
module.exports = {
  improve: '@apostrophecms/file',
  options: {
    seoFields: false
  }
};
```

For five of the core modules, `apostrophecms/file`, `apostrophecms/file-tag`, `apostrophecms/image`, `apostrophecms/image-tag`, and `apostrophecms/user`, the only improvement is to pass the `seoFields/false` property in the option to disable the SEO field enhancements for those piece-types. This is necessary because the other modules of the extension, as we will see, improve core modules that these five extend but doesn't make sense for these five to add SEO data.

``` javascript
fields(self, options) {
  const add = {};
  const group = {
    seo: {
      label: 'aposSeo:group',
      fields: [],
      last: true
    }
  };
  if (options.seoGoogleTagManager) {
    add.seoGoogleTagManager = {
      label: 'aposSeo:gtmIdHelp',
      type: 'string',
      help: 'aposSeo:gtmIdHelp'
    };
    group.seo.fields.push('seoGoogleTagManager');
  }
  if (options.seoGoogleAnalytics) {
    add.seoGoogleTrackingId = {
      label: 'aposSeo:gaId',
      type: 'string',
      help: 'aposSeo:gaIdHelp'
    };
    group.seo.fields.push('seoGoogleTrackingId');
  }
  if (options.seoGoogleVerification) {
    add.seoGoogleVerificationId = {
      label: 'aposSeo:googleVerifyId',
      type: 'string',
      help: 'aposSeo:googleVerifyIdHelp'
    };
    group.seo.fields.push('seoGoogleVerificationId');
  }
  return Object.keys(add).length
    ? {
      add,
      group
    }
    : null;
}
```

The `seo-fields-global` module of the extension also disables the SEO fields for the global piece-type, but adds several other schema fields to a tab labeled with the `aposSeo:group` translation string. In this case, rather than add a `fields` object directly, the object is being returned from a function that uses conditionals to check whether three different options have been enabled. These options can be passed to the `@apostrophecms/global` module from two different places at project level. In the `README.md` file of the extension package it demonstrates enabling them by adding the module to the `modules` object of the `app.js` file.

``` javascript
require('apostrophe')({
  shortName: 'MYPROJECT',
  modules: {
    '@apostrophecms/seo': {},
    '@apostrophecms/global': {
      options: {
        seoGoogleAnalytics: true,
        seoGoogleTagManager: true,
        seoGoogleVerification: true
      }
    }
  }
});
```

In our project, we already have a `modules/@apostrophecms/global/index.js` file where we can enable these three options.

The `seo-fields-page-type` module enhances the `@apostrophecms/page-type` module by adding a single relationship schema field. Enhancements to the former module also benefit the `@apostrophecms/piece-page-type` module, as the latter extends the base module. These enhancements are implemented using a `fields()` method that returns an object instead of a static object. The method enables conditional field additions, depending on options for each page-type module.

Similarly, the `seo-fields-doc-type` module enhances the `@apostrophecms/doc-type` module. Enhancements here impact not just page-type modules but also the `@apostrophecms/piece-type` module. For the doc-type module, the `fields()` function returns an object that includes multiple schema fields, provided `options.seoFields` isn't set to `false`. The function also introduces an extra `select` type schema field if the extending module specifies an `seoCanonicalTypes` option with an array of piece-type module names or includes `@apostrophecms/page` to encompass all page types. Such an addition enables piece-type modules to identify a canonical link for a piece.

Overall, this extension provides a good blueprint for how to modify all the page- and piece-types in a project. A similar strategy could be used to include any combination of core modules, for example only improving the `@apostrophecms/widget-type` and `@apostrophcms/piece-type` modules.

## The `blog` extension

The [`blog` extension](https://apostrophecms.com/extensions/blog) adds a new `blog` piece-type and piece-page-type to your project. Like the `seo` extension it uses the `bundle` option to make an additional module available. A main feature of the blog module is the ability to filter the posts in the piece management modal by publication date that uses both `filters` and custom `queries`. The extensions code will also allow us to examine the `piecesFilters` option introduced in the [Creating Pieces](/tutorials/pieces.html) tutorial.

### Installation

To install the `@apostrophecms/blog` module, navigate to the [extension page](https://apostrophecms.com/extensions/blog) and follow the installation instructions. After running `npm install @apostrophecms/blog` in the root of our project a number of follow-up steps are necessary.

<AposCodeBlock>

``` javascript
require('apostrophe')({
  shortName: 'apostrophe-onboarding-project',
  bundles: [ '@apostrophecms/blog' ],
  modules: {
    // other project modules
    '@apostrophecms/blog': {},
    '@apostrophecms/blog-page': {}
  }
});

```
  <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

Unlike the `seo` extension, the `@apostrophecms/blog` module should be added to the `bundles` array of the project `app.js`. The modules added through this package `extend` the `@apostrophecms/piece-type` and `@apostrophecms/piece-page-types` core modules. For the `seo` extension, all the modules improved rather than extending the core modules, so it was sufficient to add the base `@apostrophecms/seo` module to the `modules` configuration object. Adding `@apostrophecms/blog` to the bundles can also allow you to use the two modules of the extension as a base to further extend your own custom modules without adding either of the extension modules to the `modules` configuration object.

While we aren't using them in this project, the next step of installation would be to add `@apostrophecms/blog` and `@apostrophecms/blog-page` to the `modules` object. Finally, the new page type needs to be added to the `modules/@apostrophecms/pages/index.js` file in order for it to show up as an option in the page-type selector.

### Package structure

This extension is slightly more modest in scope than the `seo` extension. The main `index.js` file adds the `@apostrophecms/blog` piece-type. It also uses the `bundle` configuration to load a module to provide the pages for the new piece-type. Since it is only a single module, the name of the module is added directly to the `bundles.modules` array instead of using a function that returns all the names in the directory. At the root of the extension there is a helper file, `queries.js`, that we will examine when we dissect the main `index.js` file. The `modules/@apostrophecms/blog-page` folder contains the `index.js` file for the new piece-page-type and also a `views` folder containing the expected `show.html` and `index.html` files, but also a `filters.html` file that contains the markup for the filters that users can apply to the pieces.

### The `blog` piece-type

#### The `index.js` file

Let's walk through the `npm_modules/@apostrophecms/blog/index.js` file. At the top, the file  uses `require` to bring two dependencies into the module, the `dayjs` library and the `queries.js` helper file.

``` javascript
bundle: {
  directory: 'modules',
  modules: [ '@apostrophecms/blog-page' ]
},
```
As was pointed out, unlike the `seo` extension, this extension adds the name of the additional module in the bundle directly, instead of using a function.

``` javascript
options: {
  label: 'aposBlog:label',
  pluralLabel: 'aposBlog:pluralLabel',
  sort: { publishedAt: -1 },
  i18n: {
    ns: 'aposBlog',
    browser: true
  }
}
```
Within the `options` a label and i18n namespace are added. Additionally, the `sort` option is set to sort on the `publishedAt` field in descending order, from newest to oldest date. This impacts the order in the piece manager and on the index page.

``` javascript
columns: {
  add: {
    publishedAt: {
      label: 'aposBlog:publishedAt'
    }
  }
},
```

As covered in the [Creating Pieces](/tutorials/pieces.html) tutorial, the `columns` configuration object adds additional columns to the piece manager. In this case it adds the value of the `publishedAt` schema field.

``` javascript
fields: {
  add: {
    publishedAt: {
      label: 'aposBlog:publishedAt',
      type: 'date',
      required: true
    }
  },
  group: {
    basics: {
      fields: [ 'publishedAt' ]
    }
  }
},
```

As outlined, this extension provides a ready-made way to filter blog articles based on date but not much else. As such, the `fields` configuration object only contains a single field, `publishedAt`. For actual blog pieces you would have to add additional fields like `author` and an area with widgets for content area.

``` javascript
filters: {
  add: {
    future: {
      label: 'aposBlog:futureArticles',
      def: null
    },
    year: {
      label: 'aposBlog:filterYear',
      def: null
    },
    month: {
      label: 'aposBlog:filterMonth',
      def: null
    },
    day: {
      label: 'aposBlog:filterDay',
      def: null
    }
  }
},
queries,
```
The `filters` configuration object adds four different filters to the piece manager. As covered in the [Creating Pieces](/tutorials/pieces.html) tutorial, this configuration object can take a `fields` schema field name or a custom query builder. In this case, all four use a custom query that is supplied by the `queries.js` helper file that was required at the beginning of the `index.js` file, and added just after the `filters`. This adds the object returned by the helper file to the [`queries(self, query)` configuration customization function](/reference/module-api/module-overview.html#queries-self-query). We will look at the helper file next.

``` javascript
extendMethods(self) {
  return {
    newInstance(_super) {
      const instance = _super();
      if (!instance.publishedAt) {
        instance.publishedAt = dayjs().format('YYYY-MM-DD');
      }
      return instance;
    }
  };
}
```

Finishing off the `index.js` file is an `extendMethods()` configuration function. The `newInstance()` method is the function that creates a new document when you save your piece. In this case it checks that the new piece has a `publishedAt` field, and if not it adds one with the current date.

#### The `queries.js` helper file
To reiterate, the `filters` configuration object can take either an existing schema field names or a custom query builder to filter pieces. In the case of these filters, none correspond directly to a schema field and all require examination and/or parsing of the `publishedAt` field. This file provides the custom queries for each of the added filters. We will step through two of the filters. The filters for `year`, `month`, and `day` are very similar. The filter for `future` is slightly different, so we will cover it and the `year` filter.

<ins>The `future` filter</ins>

``` javascript
future: {
  def: null,
  finalize() {
    let future = query.get('future');

    if (!self.apos.permission.can(query.req, 'edit', self.name, 'draft')) {
      future = false;
    }

    if (future === null) {
      return;
    }

    const today = dayjs().format('YYYY-MM-DD');
    if (future) {
      query.and({ publishedAt: { $gte: today } });
    } else {
      query.and({ publishedAt: { $lte: today } });
    }
  },
  launder(value) {
    return self.apos.launder.booleanOrNull(value);
  },
  choices() {
    return [
      {
        value: null,
        label: 'aposBlog:both'
      },
      {
        value: true,
        label: 'aposBlog:future'
      },
      {
        value: false,
        label: 'aposBlog:past'
      }
    ];
  }
},
```
The query builders for each filter are defined as named objects within the `builders` object. Here this code snippet provides the builder for the `future` filter.

Each of filters in this file are initialized with a default value of `null` from the `def` property. They each also have three functions, `finalize()`, `launder()`, and `choices()`. We will start with the `choices()` method as it makes it easier to then understand the `finalize()` method.

``` javascript
choices() {
  return [
    {
      value: null,
      label: 'aposBlog:both'
    },
    {
      value: true,
      label: 'aposBlog:future'
    },
    {
      value: false,
      label: 'aposBlog:past'
    }
  ];
}
```
These choices returned by the `choices()` method are presented to the user in the filters dropdown of the piece manager. When the user selects one it is set on the query object. Again, by default, this filter has a value of `null` which will leave the blog pieces unfiltered. Selecting to filter for only articles to be published in the future will set `future: true` on the query object, while selecting for already published articles will set it to `false`.

``` javascript
finalize() {
  let future = query.get('future');

  if (!self.apos.permission.can(query.req, 'edit', self.name, 'draft')) {
    future = false;
  }

  if (future === null) {
    return;
  }

  const today = dayjs().format('YYYY-MM-DD');
  if (future) {
    query.and({ publishedAt: { $gte: today } });
  } else {
    query.and({ publishedAt: { $lte: today } });
  }
},
```
The `finalize()` method runs at the end of query building prior to processing by the database. There are also `prefinalize()` and `after()` methods that run prior to the `finalize()` method and after database submission, respectively. You can read more about them in the [documentation](/reference/module-api/module-overview.md#builders). 

The first thing this method does is retrieve the value of the `future` key from the query object. The first conditional then tests if the user is able to edit draft versions of pieces. If not, then the value of `future` is set to false, allowing the user to only see blog pieces that have already been published.

If the next conditional, `future === null`, tests positive then the query will be returned without any modification since the user wants to see all pieces.

Finally, the method gets the current date using the `dayjs` library and modifies the query to require the value of the `publishedAt` field to be greater than (`$gte`) the current date if future is `true` or less than (`$lte`) if `false`.

``` javascript
launder(value) {
  return self.apos.launder.booleanOrNull(value);
},
```
The `launder()` method validates the values that are passed as arguments and returns `true` if valid. In this case the method passes the value through a method exposed by the `@apostrophecms/launder` module. This module actually attaches an instance of the stand-alone launder package that can be used in any project. The method being used allows the returned value to be `true`, `false`, or `null` (actually, it also allows a lot of other values like `t` for true - [package here](https://www.npmjs.com/package/launder)).

<ins> The `year` filter</ins>

``` javascript
year: {
  def: null,
  finalize() {
    const year = query.get('year');
    if (!year) {
      return;
    }

    query.and({ publishedAt: { $regex: '^' + year } });
  },
  launder(value) {
    const year = self.apos.launder.string(value);

    if (!year.match(/^\d\d\d\d$/)) {
      return '';
    }

    return year;
  },
  async choices() {
    const allDates = await query.toDistinct('publishedAt');
    const years = [
      {
        value: null,
        label: 'aposBlog:filterAll'
      }
    ];

    for (const eachDate of allDates) {
      const year = eachDate.substr(0, 4);
      if (!years.find((e) => e.value === year)) {
        years.push({
          value: year,
          label: year
        });
      }
    }
    years.sort().reverse();

    return years;
  }
},

```

Like the `future` filter, the `year` filter has `finalize()`, `launder()`, and `choices()` methods, plus it sets the default choice to `null`.

``` javascript
finalize() {
  const year = query.get('year');
  if (!year) {
    return;
  }

  query.and({ publishedAt: { $regex: '^' + year } });
},
```
The `finalize()` method is significantly simpler for the `year` filter as compared with the `future` filter. It checks the `query` object to ensure that the `year` is set and returns without modifying the query if it isn't. Otherwise, it adds regex to the query to detect the year value at the beginning of the piece `publishedAt` field value.

``` javascript
async choices() {
  const allDates = await query.toDistinct('publishedAt');
  const years = [
    {
      value: null,
      label: 'aposBlog:filterAll'
    }
  ];

  for (const eachDate of allDates) {
    const year = eachDate.substr(0, 4);
    if (!years.find((e) => e.value === year)) {
      years.push({
        value: year,
        label: year
      });
    }
  }
  years.sort().reverse();

  return years;
}
```

The `choices()` method populates the user choices by performing a database query and then creating an array from the database results. The value of the `allDates` variable is set by modifying the query with the [`toDistinct()`](/guide/database-queries.md#finishing-with-query-methods) query method. This query method returns an array with all the `publishedAt` values across all the blog pieces, with each value only appearing once. It then takes each full date, extracts just the year, and pushes that value to the `years` array, finally sorting the array before returning it. Additionally, in order to allow the user to remove the year filter and have blog articles from any year appear, the `years` array is defined with a first item that passes `null` as a value to the `finalize()` method.

``` javascript
launder(value) {
  const year = self.apos.launder.string(value);

  if (!year.match(/^\d\d\d\d$/)) {
    return '';
  }

  return year;
},
```

The `launder()` method in this case uses the JavaScript `match()` method to test that the value is a valid four digit year.

The filters for months and days are almost identical except for `publishedAt`, which is parsed for the desired value and the regular expression used in the `launder()` method.

To summarize, you can create a custom filter for any user submitted value, like part of a date, by providing three methods that parse and launder the values to provide choices that can be used to identify a subsection of documents. The custom filter can then be used both in the piece manager, but also in the `index.html` piece-page-type to display a subset of the pieces.
 
### The `blog-page` module

This module implements the pages for showing your blog pieces. The `index.html` file also demonstrates how to implement filtering that can be adapted for use on any piece index page.

#### The `index.js` file

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',

  options: {
    label: 'aposBlog:page',
    piecesFilters: [ { name: 'year' }, { name: 'month' }, { name: 'day' } ]
  },

  extendMethods(self) {
    return {
      indexQuery(_super, req) {
        return _super(req).future(false);
      },
      showQuery(_super, req) {
        return _super(req).future(false);
      }
    };
  }
};
```
  <template v-slot:caption>
    node_modules/@apostrophecms/blog
  </template>

</AposCodeBlock>

The primary take-away from this file is how filters are added and modified in the piece pages. Within the `options` object three of the four custom filters are added to the page. This allows filtering of the pieces that are included in the `data.pieces` object that is delivered to the index page through adding query parameters to the page URL.

Within the `extendMethods()` configuration object there are two core methods being extended. Again, as was covered in the [Creating Pieces](/tutorials/pieces.html) tutorial, the method being extended should take `_super` and any arguments that were passed to the original method. In this case we are modifying the query object that is being passed to the filters of either the index page for the `indexQuery()` method, or the individual piece show pages with the `showQuery()` method. In both cases, we override the value of the `future` key in order to exclude an unpublished blog pieces. This same `extendMethods()` function can be used at project-level to change the value of `future` to `null` or `true`. For example, you could check the users permissions, like was performed in the main piece `index.js` field, and allow users who can edit the piece type to see unpublished articles.

#### The `index.html` and `show.html` files

These two markup files are fairly standard for piece-page-types and for more in-depth explanations you can look at the [Creating Pieces](/tutorials/pieces.html) tutorial. Both templates extend the `@apostrophecms/template/views/outerLayout.html` file. The `index.js` file imports the `macros.html` file from the `@apostrophecms/pager` module in order to paginate the pieces. Within the `index.js` file there is a loop, `{% for piece in data.pieces %}` to step through all the pieces. Since the filters change the `data.pieces` object, no changes have to be made in order for the content to be filterable. The `show.html` page is also quite standard, simply displaying the data passed through the `data.piece` object.

#### The `filters.html` file

``` nunjucks
{% render filters.render({
  filters: data.piecesFilters,
  query: data.query,
  url: data.page._url
}) %}
```

Unlike our past examples, the `index.html` also imports another Nunjucks file, `filters.html`, containing a fragment to be rendered on the page. This render call passes three arguments. First, it passes the `data.piecesFilters` object that contains the values generated by the `choices()` method of the query builders. Second, it passes the URL query parameters of the current page, `data.query`. Finally, it passes the current page URL, `data.page._url`.

``` nunjucks
{% fragment render(data) %}
  <h3>{{ __t('aposBlog:filterYear') }}</h3>
  <ul>
    {% for year in data.filters.year %}
      <li>
        <a
          style="{{ 'font-style: italic' if data.query.year == year.value }}"
          href="{{ here(data.url, { year: year.value }) }}"
        >{{ __t(year.label) }}</a>
      </li>
    {% endfor %}
  </ul>
  ...
{% endfragment %}
```
In the `filters.html` file we will just look at the year filter markup since the markup for the month and day filters is very similar. Within the fragment, the available pieces are passed as `data.filters`. For each year, the template generates a list item. Inside this list item, a hyperlink is added. The text of the hyperlink is the year itself. Additionally, the font style of the hyperlink changes if the current webpage's URL includes a year query parameter matching the year in the current iteration. The `href` attribute for the hyperlink is set using a macro called `here()` that is defined at the top of the file.

``` nunjucks
{%- macro here(url, changes) -%}
  {{ url | build({
    year: data.query.year,
    month: data.query.month,
    day: data.query.day
  }, changes) }}
{%- endmacro -%}
```

In Nunjucks, macros act like methods, taking multiple arguments and returning some value. In this case, the macro takes the current page URL as the first argument, and an object containing the date (either year, month, or day) as the second. It uses these values to create a new URL by piping the current URL into the build filter. The [build filter](/guide/template-filters.md#build-url-path-data) then appends the data from the passed object to the URL as query parameters. This then gets passed back to the hyperlink.

When the user then clicks on the link, the browser navigates to essentially the same page, but with the query parameter added. Apostrophe intercepts this query parameter, and it is passed to the `finalize()` method of our filters to populate the `data.pieces` object with only the documents that match the filter value. The loop in the `index.html` filter steps through each of the returned pieces to output the final markup on the page.

## Summary
In the tutorial, we explored the addition of two different extensions from the Apostrophe library to our project. The exploration offered insights into the `bundle` configuration property and the implications of using `extend` versus `improve` for modifying core modules. The tutorial also facilitated a deep dive into `filters`, `queries`, `builders`, and `piecesFilters`.

Equipped with the insights gained from the tutorial at hand, you should be well-prepared to develop your own custom extensions. Such extensions can easily be published on npm, facilitating their integration into various projects. This also enables other developers to leverage your work. Given the comprehensive understanding acquired from the entire tutorial series, you should be adept at crafting a sophisticated CMS experience, encompassing custom pages, pieces, widgets, and admin interfaces. With these skills, you transition from merely being a user of the CMS to becoming a contributor who can tailor the system to specific needs.

================================================================================
COLLECTION: tutorials
NAV_PATH: ApostropheCMS & Astro
DOC_PATH: tutorials/astro/apostrophecms-and-astro.md
URL: https://apostrophecms.com/docs/tutorials/astro/apostrophecms-and-astro
================================================================================
# Building Websites with ApostropheCMS and Astro

## Introduction

The tutorials in this section will guide you through building modern websites using ApostropheCMS as your content management system with Astro powering your frontend. This combination offers powerful advantages for different types of developers:

### Who Is This For?

**Astro Developers**
- You need a robust CMS backend for your Astro projects
- You want more than just a headless CMS - you need full in-context editing
- You're looking for a flexible content management system that works with your existing components

**Current ApostropheCMS Developers**
- You're experienced with ApostropheCMS and ready to explore additional frontend options
- You're interested in expanding your stack to include modern frontend frameworks alongside ApostropheCMS's powerful content management
- You want to enhance your sites while preserving the intuitive in-context editing experience your clients value

**Teams Building Modern Websites**
- You're looking for a modern, flexible CMS solution
- You want to build high-performance sites with excellent developer experience
- You need a system that scales well for building multiple client sites

### What Makes This Integration Special?

1. **Content Management + Modern Frontend**
   - ApostropheCMS provides an intuitive, powerful interface for content management
   - Astro enables you to use modern frontend frameworks while maintaining excellent performance
   - Unlike typical headless CMS setups, you maintain full in-context editing capabilities

2. **Developer Experience**
   - Clear separation between backend and frontend codebases
   - Familiar development patterns for both systems
   - Freedom to use your preferred frontend frameworks (React, Vue, Svelte) through Astro

3. **Agency-Ready Features**
   - Streamlined project setup for multiple sites
   - Flexible content modeling
   - Built-in image optimization
   - Strong security features
   - Efficient development workflow

### Getting Help

If you get stuck:
- Join our [Discord community](http://chat.apostrophecms.org)
- Check the [ApostropheCMS documentation](https://apostrophecms.com/docs)
- Review the [Astro documentation](https://docs.astro.build)
- Visit our [Github repository](https://github.com/apostrophecms/apostrophe-astro)

Ready to start building? Begin with our [introduction to Apollo and core concepts tutorial](/tutorials/astro/introducing-apollo.html).

## Want to learn more?
Listen to the CTO of ApostropheCMS talk about the integration of ApostropheCMS and Astro:
<iframe width="560" height="315" src="https://www.youtube.com/embed/8HczFSLFDno?si=tHxIhDTdOboNyIPN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

================================================================================
COLLECTION: tutorials
NAV_PATH: ApostropheCMS & Astro > Introducing Apollo
DOC_PATH: tutorials/astro/introducing-apollo.md
URL: https://apostrophecms.com/docs/tutorials/astro/introducing-apollo
================================================================================
# Introducing Apollo

## Introduction

Many of the tutorials in this section explore the integration of ApostropheCMS with Astro, using the [Apollo project](https://github.com/apostrophecms/apollo) as a working example. While Apollo provides an opinionated, production-ready setup, the principles and patterns covered here apply to any ApostropheCMS-Astro integration, regardless of your preferred frontend framework or styling approach. These tutorials are not aimed at being a comprehensive dissection of the entire Apollo codebase, but rather a high level introduction to using Astro as a frontend for ApostropheCMS.

::: tip Watch & Learn! üé•
This tutorial is available in both text and video formats. The videos cover the key highlights, while this page provides additional details and references. Watch the videos for a guided introduction, then read on for deeper insights!


### Learning Through Apollo

We'll use the [`Apollo`](https://github.com/apostrophecms/apollo) project to demonstrate the basic concepts of hybrid project development, and the overall codebase can be used as examples for topics not covered by this tutorial. Apollo includes:
- A complete project structure demonstrating proper separation of concerns
- Examples of page types, pieces, and widgets showing integration patterns
- Setup of global content and styling (headers, footers, logos, etc.) alongside page-specific configurations
- Theme system showcasing content management approaches
- Helper functions for image handling, including URL generation and responsive sizing

Throughout our tutorials, we'll highlight which patterns are Apollo-specific and which are universal best practices for any ApostropheCMS-Astro integration. Whether you plan to use Apollo as your starting point or build your own integration from scratch, you'll learn how to:
1. Structure your development environment
2. Implement proper template mapping
3. Create effective widget systems
4. Handle routing and data flow
5. Deploy your integrated solution

### Integration with Astro

The [`apostrophe-astro` package](https://github.com/apostrophecms/apostrophe-astro) seamlessly connects ApostropheCMS with Astro, handling all the complex integration work behind the scenes. Once installed in your Astro project, you get:
- Full use of the ApostropheCMS Admin UI with in-context editing
- Zero-configuration content delivery - no need to write any fetch code or API calls
- Automatic routing that matches your ApostropheCMS page tree
- Support for your choice of frontend framework (React, Vue, Svelte, etc.) or Astro's native templating system

The Apollo theme and the more bare bones [`combined-astro-starter-kit`](https://github.com/apostrophecms/combined-astro-starter-kit) both include this package as a dependency and provide the necessary `astro.config.mjs` configuration. You can explore additional configuration options in the [package documentation](https://github.com/apostrophecms/apostrophe-astro).

```javascript
// backend/astro.config.mjs
import { defineConfig } from 'astro/config';
import node from '@astrojs/node';
import apostrophe from '@apostrophecms/apostrophe-astro';
import path from 'path';

export default defineConfig({
  viewTransitions: true,
  output: "server",
  server: {
    port: process.env.PORT ? parseInt(process.env.PORT) : 4321,
    // Required for some hosting, like Heroku
    // host: true
  },
  adapter: node({
    mode: 'standalone'
  }),
  integrations: [apostrophe({
    aposHost: 'http://localhost:3000',
    widgetsMapping: './src/widgets',
    templatesMapping: './src/templates',
    includeResponseHeaders: [
      'content-security-policy',
      'strict-transport-security',
      'x-frame-options',
      'referrer-policy',
      'cache-control'
    ],
    excludeRequestHeaders: [
      // For hosting on multiple servers, block the host header
      // 'host'
    ]
  })],
  vite: {
    ssr: {
      // Do not externalize the @apostrophecms/apostrophe-astro plugin, we need
      // to be able to use virtual: URLs there
      noExternal: ['@apostrophecms/apostrophe-astro']
    }
  }
});
```
The key parts of this Astro configuration file are the specification of server-side rendering using `output: "server"`, usage of the `node` adapter, and `integration` of the `apostrophe` extension. The `aposHost` setting tells Astro where to find your ApostropheCMS server, defaulting to `localhost:3000` in development. This gets set by an environment variable during deployment. Within the extension configuration, we specify where the template and widget components for mapping to ApostropheCMS documents should be located - we'll cover this mapping system in detail later. We also configure which headers should be passed between the servers: `includeResponseHeaders` preserves important security and caching headers from ApostropheCMS responses, while `excludeRequestHeaders` lets you block specific headers from being forwarded (useful when hosting the frontend and backend on different servers where the host header might cause conflicts). Finally, the `vite.ssr.noExternal` setting ensures the integration can properly handle virtual URLs during server-side rendering.

## Development Environment Set Up

Before diving into the ApostropheCMS and Astro integration, let's set up your development environment. The requirements for ApostropheCMS and Astro largely overlap, so you can look at our [ApostropheCMS guides to setting up your environment](/guide/development-setup.html).

<iframe width="560" height="315" src="https://www.youtube.com/embed/aiDBlbDkTwY?si=dY5sbhWgLZFlGj1O" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Prerequisites
  > [!IMPORTANT]
  > **Windows Users**: Please install WSL2 (Windows Subsystem for Linux 2)
  > - Required for ALL Windows development with ApostropheCMS
  > - Ensures consistent behavior with image processing and file system operations
  > - Follow our [Windows Development Guide](/cookbook/windows-development.html)
  > - All prerequisites should be installed from within WSL2

1. **Node.js**: Version 18 or higher required
   ```bash
   node --version  # Should be >= 18.0.0
   ```

2. **MongoDB**: Three options for setup (see our [Development Set Up Guide](/guide/development-setup.html) for details):

   a. **MongoDB Community Server**: Install from [mongodb.com](https://www.mongodb.com/try/download/community) following the instructions for your specific OS

   b. **MongoDB Atlas**: Create a free cluster at [mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas)

    c. **Docker/Podman Container**
   - Install Docker/Podman first
   - Then set up the MongoDB container following the instructions in the [mongodb-container repo readme](https://github.com/BoDonkey/mongodb-container/blob/main/README.md). In brief:
     ```bash
     git clone https://github.com/BoDonkey/mongodb-container
     cd mongodb-container
     ./start-mongo.sh
     ```

   >[!IMPORTANT]
   >No matter the method chosen, your MongoDB instance needs to be available when you load in the starter content or create your admin user.

### Project Structure

The Apollo project uses a monorepo structure that contains the code for both the ApostropheCMS backend and Astro frontend:

```
apollo/
‚îú‚îÄ‚îÄ backend/         # ApostropheCMS codebase
‚îú‚îÄ‚îÄ frontend/        # Astro codebase
‚îî‚îÄ‚îÄ package.json     # Root-level dependencies and scripts
```

### Initial Setup

1. Clone the Apollo repository - optionally you can give your project a custom name, but note, you will also need to [change the ApostropheCMS shortname](/guide/development-setup.html#if-you-don-t-want-to-use-the-cli-or-if-you-want-to-see-other-things-it-does-for-you-continue-on) in the `app.js` file if you want your database name to match:
    ```bash
    git clone https://github.com/apostrophecms/apollo
    cd apollo
    ```
    or
    ```bash
    git clone https://github.com/apostrophecms/apollo <my-project>
    cd <my-project>
    ```

2. Install all dependencies:
    ```bash
    npm install  # This triggers install for both frontend and backend
    ```

3. Load starter content and set admin password (*optional*):
    ```bash
    npm run load-starter-content
    ```
    If you prefer not to load the starter content, you should still create an initial admin user:
    ```bash
    cd backend
    node app @apostrophecms/user:add admin admin
    ```

### Environment Configuration

The ApostropheCMS backend and Astro frontend development servers must be started in separate terminal instances. Ensure that the necessary environment variables are set for each before launching.

**For your ApostropheCMS project:**
```bash
cd backend
export APOS_EXTERNAL_FRONT_KEY=your-secret-key-here

# If you are running MongoDB on the default port,
# no further environment variables needed

# MongoDB Atlas: Use the connection string from Atlas dashboard
export APOS_MONGODB_URI=mongodb+srv://<username>:<password>@<cluster>.mongodb.net/<dbname>

# Local MongoDB on different port:
export APOS_MONGODB_URI=mongodb://localhost:27018
```

For MongoDB Atlas users: Replace `<username>`, `<password>`, `<cluster>`, and `<dbname>` with your actual Atlas connection details found in the Atlas dashboard under "Connect to Database".

**For your Astro project:**
```bash
cd frontend
export APOS_EXTERNAL_FRONT_KEY=your-secret-key-here

# If the ApostropheCMS backend is *not* running on default port
export APOS_HOST=http://localhost:<port>
```
### Starting the Development Servers

1. Start the backend (in one terminal):
```bash
cd backend
npm run dev
```

2. Start the frontend (in another terminal):
```bash
cd frontend
npm run dev
```

Your development environment is now ready with:
- Backend at http://localhost:3000
  - Used for checking the connection to the frontend only
- Frontend at http://localhost:4321
  - Where all your content editing will occur

### Preparing for Production
Before deploying, you may want to test how your Astro frontend behaves in production mode. The development (npm run dev) and preview (npm run preview) modes differ slightly, especially in how they handle SSR, static asset generation, and environment variables.

To build and preview your site before deployment, run:

```bash
cd frontend
npm run build
npm run preview
```
This serves your built project in a production-like environment, helping you catch any issues before deployment.

With our development environment ready, we need to understand some fundamental concepts before we start building. Both ApostropheCMS and Astro bring their own paradigms to web development, and seeing how they work together will be crucial for building effective websites with the Apollo Theme.

## Core concepts

Current ApostropheCMS users are likely already familiar with its core concepts and components. This section covers those fundamentals and will be especially useful for developers coming from Astro or those new to this stack.

That said, even experienced ApostropheCMS developers will find value here ‚Äî we‚Äôre not just reviewing core concepts, but also how they integrate with Astro.

ApostropheCMS provides a structured approach to managing content and design, and understanding these concepts is key because they require implementation on both the backend (ApostropheCMS) and the frontend (Astro). If you're already comfortable with ApostropheCMS, the transition to using Astro as a frontend isn‚Äôt a huge leap‚Äîyou‚Äôll primarily be shifting how you handle templates.

<iframe width="560" height="315" src="https://www.youtube.com/embed/P3ELmgL5aYA?si=CZnLq56_M5yOEkR1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

#### Areas
[Areas](/guide/areas-and-widgets.html) are editable regions on your pages where content editors can add and arrange content. In the ApostropheCMS backend, you define what types of content (widgets) can be placed in each area and configure their options. In your Astro frontend templates, these areas are rendered using the `AposArea` component, which maintains the in-context editing capabilities of ApostropheCMS while working within Astro's component system.

Here's how an area is configured in your backend:

<AposCodeBlock>

```javascript
export default {
  fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {},
            'row': {}
          }
        }
      }
    }
  }
};
```
<template v-slot:caption>
  backend/modules/@apostrophecms/home-page/index.js
</template>
</AposCodeBlock>

This area would allow for content managers to add any number of three different widget types - rich-text, image, and row. You can [read about](/guide/areas-and-widgets.html) additional configuration options, like limiting the number of widgets that can be added, and passing options to the individual widgets.

::: info
Note two things:
  - the widgets are passed into the area options without including the `-widget` suffix
  - widgets that come from the ApostropheCMS core are prefixed with `@apostrophecms/` - This is also true for any other widgets that come from official ApostropheCMS npm packages

And here's how that same area is rendered in your Astro frontend:

<AposCodeBlock>

```Astro
---
import AposArea from '@apostrophecms/apostrophe-astro/components/AposArea.astro';
const { page } = Astro.props.aposData;
---

<div class="main-content">
  <AposArea area={page.main} />
</div>
```
<template v-slot:caption>
  frontend/src/templates/HomePage.astro
</template>
</AposCodeBlock>

In this example, the `area` schema field in the ApostropheCMS backend is named `main`. Data from the page is passed into the template through the `aposData` prop. The individual `main` area is then passed to the `AposArea` component through the named `area` prop.

Note that widgets themselves can have areas. For example, the layout widgets in the Apollo theme each have multiple areas for adding content widgets.

#### Page Types
[Page types](/guide/pages.html) are the building blocks that give your ApostropheCMS site structure and flexibility. They allow you to create distinct templates for different content needs - whether that's blog posts, team member profiles, project showcases, or landing pages. Each page type is configured in both your frontend templates and backend modules, working together to define how content is managed and displayed. In the ApostropheCMS backend, you define the schema fields, area configurations, and other settings that determine what content can be managed for that page type. In your Astro frontend, you create corresponding template components that determine how that content is displayed.

For example, a blog post page type might be configured in your backend to capture fields like title, author, publication date, and content areas. The corresponding Astro template would then structure how these fields are presented on the actual webpage, handling both the display of the content and any necessary frontend interactivity.

Pages are managed through ApostropheCMS's page tree interface, which you can access in the admin UI. When creating a new page, you'll select from your available page types using the utility rail (the menu on the right side of the page manager). This selection determines which fields and areas are available for content entry, as well as which Astro template will render the page.

#### Template Mapping
Template mapping is a crucial concept in the ApostropheCMS + Astro integration because it creates the bridge between your backend page types and your frontend templates. When ApostropheCMS serves a page, the frontend `[...slug].astro` needs to know which Astro template should render that content. This mapping is defined in the frontend Astro `src/templates/index.js` file:

<AposCodeBlock>

```javascript
import HomePage from './HomePage.astro';
import DefaultPage from './DefaultPage.astro';
import ArticleIndexPage from './ArticleIndexPage.astro';
import ArticleShowPage from './ArticleShowPage.astro';

export default {
  '@apostrophecms/home-page': HomePage,
  'default-page': DefaultPage,
  'article-page:index': ArticleIndexPage,
  'article-page:show': ArticleShowPage
};
```
  <template v-slot:caption>
    frontend/src/templates/index.js
  </template>
</AposCodeBlock>

This mapping ensures that when someone visits your homepage, Astro knows to use the `HomePage.astro` template to render the content that ApostropheCMS provides.

Page types that come from the ApostropheCMS core are prefixed with `@apostrophecms/` and any page types coming from packages in the `node-modules` folder should be prefixed accordingly.

ApostropheCMS [piece type pages](/guide/piece-pages.html) render an `index` template when viewing the main page of the blog, and a `show` template when viewing a single blog post (a "permalink" page) - these templates are identified by adding the template name following a `:` as a suffix, as shown in the example.

::: info
Note that in a standard ApostropheCMS project the file name for the template of a standard page type is `page.html`. While the non-piece type pages don't have a suffix at the end, by default they are treated as if they have `:page` at the end.

#### Piece Types
[Piece types](/guide/pieces.html) represent reusable content that exists independently of your page hierarchy. Common examples include blog posts, team members, or products. Like page types, they require both backend configuration and frontend templates, but pieces are managed differently from pages.

Pieces are accessed through the admin bar at the top of your site. By default, each piece type gets its own menu item, but you can [customize this](/tutorials/admin-ui.html) to organize related piece types into groups (for example, grouping "Articles" and "Authors" under a "Content" menu). Each piece type has its own manager interface where you can add, edit, and organize your content.

In the backend, you define:
- The schema fields that make up the content structure
- How the pieces can be organized and filtered

In the frontend, you create:
- Templates for displaying individual pieces ("show" pages)
- Templates for displaying lists of pieces ("index" pages)

A blog piece type might have a show template for full articles and an index template for the main blog listing. However, through relationships and use of the REST API endpoints, these same pieces can appear anywhere on your site - featured posts on your homepage, related articles on other blog posts, or in a "Latest News" widget in your sidebar. This flexibility lets you manage content in one place while displaying it in multiple contexts.

#### Widgets
[Widgets](/guide/core-widgets.html) are the building blocks that editors use to construct content within areas. Unlike pieces or pages, widgets don't exist as standalone content - they are always part of an area field within a page, piece, or another widget. When that parent content is removed, its widgets are removed as well.

Areas appear on the page as editable regions where users can add, remove, and reorder widgets to create their desired layout and content. Each widget type provides a specific content structure and functionality, like rich text editing, image display, or content layout into rows.

Each widget type requires two key components:

1. A backend module that defines:
   - The widget's schema fields
   - Any server-side functionality
   - Configuration options

2. An Astro component that determines:
   - How the widget renders on the frontend
   - Any client-side interactivity

For example, a testimonial widget might look like this in the backend:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  fields: {
    add: {
      quote: {
        type: 'string',
        textarea: true
      },
      author: {
        type: 'string'
      }
    }
  }
};
```
<template v-slot:caption>
backend/modules/testimonial-widget/index.js
</template>
</AposCodeBlock>

And have a corresponding frontend component:

<AposCodeBlock>

```astro
---
const { widget } = Astro.props;
---

<div class="testimonial">
  <blockquote>{widget.quote}</blockquote>
  <cite>{widget.author}</cite>
</div>
```
<template v-slot:caption>
frontend/src/widgets/TestimonialWidget.astro
</template>
</AposCodeBlock>

Any added widget needs to be mapped in your frontend's `widgets/index.js` file, similar to how templates are mapped:

<AposCodeBlock>

```javascript
import TestimonialWidget from './TestimonialWidget.astro';
import RichTextWidget from './RichTextWidget.astro';

export default {
  'testimonial': TestimonialWidget,
  '@apostrophecms/rich-text': RichTextWidget
};
```
<template v-slot:caption>
frontend/src/widgets/index.js
</template>
</AposCodeBlock>

Just like adding widgets to areas, core widgets should be prefixed with `@apostrophecms/`, while project-level widgets are mapped without prefix. The mapping should leave the `-widget` suffix off of the ApostropheCMS widget name.

### Understanding the Development Flow

When developing with ApostropheCMS and Astro, you'll typically follow this pattern:

1. Define your content structure in the backend through ApostropheCMS modules
2. Create corresponding Astro components in the frontend
3. Map these components in the appropriate index.js files
4. Test the integration to ensure the editing experience works smoothly

This dual-sided development approach allows you to leverage the strengths of both systems: ApostropheCMS's robust content management capabilities and Astro's modern frontend development features. The integration layer handles the communication between the two, maintaining features like in-context editing that make ApostropheCMS powerful while allowing you to build your frontend using modern tools and practices.

Now that we understand these core concepts - how content is structured in ApostropheCMS and how it maps to Astro components - we can explore how the Apollo Theme puts them into practice. The theme provides a collection of pre-built components that demonstrate these concepts while giving you a foundation to build upon.

## Introducing the Apollo Theme
The [Apollo theme](https://github.com/apostrophecms/apollo) can serve as a starting point for building out your own project, but is also a complete example of how these two systems can be used together to produce a production-ready site.

<iframe width="560" height="315" src="https://www.youtube.com/embed/-qCb-qhpmAg?si=_IAc0AO18VBVHuIo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Page Types and Layout

The theme provides several page types, each designed to serve different content needs.

#### Home Page
The home page comes with three distinct layouts that showcase different approaches to content presentation:

 - Minimal: A clean layout with the common page header, footer, and a single content area
   - This layout serves as an excellent starting point for landing pages or when you want content to take center stage.
 - Foundation: Adds a hero section above the content area
   - This hero section can feature prominently displayed content, making it ideal for marketing pages or when you need to make a strong first impression.
- Showcase: Includes a slideshow component for featuring multiple content pieces
  - This layout is ideal when you need to feature multiple pieces of content prominently - for example, highlighting different products, showcasing portfolio items, or rotating through key announcements.

It should be noted that while this page is used as the template for the parked home page of your site, you can add additional instances of this page in your site.

#### Default Page
The default page provides a flexible template for general content, inheriting the same header and footer components as the home page, with a main content area that accepts any of the theme's widgets.

#### Article Page
The two article page templates are for displaying the article piece type included with the theme. There is a single page type that is added to the page tree.

When the user first navigates to the page, the `ArticleIndexPage.astro` template lists all the articles. This page can be filtered to display a subset of articles and comes in three different layout options. Depending on the layout, additional areas for widget content are added to the page. This page also acts to demonstrate how to add pagination in your hybrid project.

The user can then select to view individual articles displayed by the `ArticleShowPage.astro`. Again, three different potential layouts can be selected for the display of this content.

### Content Components

The theme includes ten widgets that cover common content needs while demonstrating different aspects of component development. These widgets fall into two main categories: layout and content.

The layout widgets help structure your content. The **Rows** widget creates rows with varying numbers of columns that automatically adjust for different screen sizes. The **Grid Layout** widget provides even more flexibility, allowing you to either select from preconfigured layouts or create custom layouts using CSS grid. These layout components show how complex styling can be abstracted into manageable, reusable pieces.

The content widgets allow content managers to add a wide variety of engaging elements to their pages without needing technical knowledge.

The theme includes three core ApostropheCMS widgets:

- **Rich Text Widget**: Provides formatted text editing with standard controls for headings, tables, lists, links, and text styling
- **Image Widget**: Adds images with support for alt text, cropping, responsive sizing, and focal point control
- **Video Widget**: Embeds videos from services like YouTube and Vimeo

It also includes five custom widgets designed for common content needs:

- **Hero Widget**: Creates customizable hero sections with options for color gradient, image, or video backgrounds
- **Slideshow Widget**: Adds interactive slideshows with customizable transitions and navigation controls
- **Accordion Widget**: Organizes content into collapsible sections for better information hierarchy
- **Card Widget**: Displays content in various card formats with multiple style options
- **Link Widget**: Creates links that can be styled as text or customizable buttons

### Available Piece Types

The theme implements two piece types that demonstrate different aspects of content management. The **article** piece type shows how to structure longer-form content, complete with rich text editing, image management, and metadata handling. As mentioned above, this piece type comes with two page templates. The **author** piece type demonstrates relationship fields, showing how different pieces of content can be connected. There isn't a dedicated page for this piece type. Instead, it is used and displayed within the article piece type.

### Image Helpers
The theme includes several helper functions for working with images, whether they come from relationships or attachment fields. These helpers handle:

- URL generation
- Responsive `srcset` image sets
- Cropped image selection
- Focal point management

We'll cover the usage of these helpers in more detail when we look at implementing widgets and piece types.

### Theme Customization

While the Apollo Theme provides a complete website toolbox out of the box, it's designed to be customized. The theme uses [Bulma](https://bulma.io/) as its CSS framework, with variables carefully organized for easy customization. You can adjust colors, typography, spacing, and other design elements by modifying these variables. You can read further about this in the repository README file and in the code comments of the `frontend/src/styles.main.scss` file.

The theme's component structure makes it easy to extend or replace functionality. Each component is self-contained, with clear separation between content structure and presentation. This means you can modify a component's appearance without affecting its content management capabilities, or extend its functionality while maintaining its existing styling.

Now that we understand these core concepts - how content is structured in ApostropheCMS and how it maps to Astro components - we can explore how the Apollo Theme puts them into practice. In the next section, we'll dive into implementing pages and components, starting with how Astro's single dynamic route handles all your ApostropheCMS content. We'll see how these concepts come together in real-world examples, with detailed explanations of the code and patterns you'll use in your own projects.

================================================================================
COLLECTION: tutorials
NAV_PATH: ApostropheCMS & Astro > Creating Pages
DOC_PATH: tutorials/astro/creating-pages.md
URL: https://apostrophecms.com/docs/tutorials/astro/creating-pages
================================================================================
# Building Pages in ApostropheCMS + Astro
This section will give you an idea of the basics of page creation, but it only scratches the surface of using Astro components for templating. We encourage you to look at the excellent [Astro documentation](https://docs.astro.build/en/basics/astro-pages/#astro-pages).

::: tip Watch & Learn! üé•
This tutorial is available in both text and video formats. The videos cover the key highlights, while this page provides additional details and references. Watch the videos for a guided introduction, then read on for deeper insights!

<iframe width="560" height="315" src="https://www.youtube.com/embed/lKJkXomBa4U?si=Nw5i3RYStlXmOZl-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Understanding Astro Page Structure
If you're coming from ApostropheCMS, Astro's page structure might look quite different from what you're used to. Let's break down the key components of an Astro page:

**Frontmatter Scripts**
Astro pages begin with a frontmatter section enclosed by triple dashes (---). This section contains JavaScript that runs during server-side rendering:

```astro
---
// This is the frontmatter section
import AposArea from '@apostrophecms/apostrophe-astro/components/AposArea.astro';

// Props are available in Astro.props
const { page, user } = Astro.props.aposData;

// You can run any server-side JavaScript here
const formattedDate = new Date().toLocaleDateString();
---
```

The frontmatter is where you:

- Import components and utilities
- Access data passed as props
- Run server-side computations
- Define variables used in your template

**Template Section**
After the frontmatter comes the template section, which contains your HTML markup and component usage:

```astro
<section class="main-content">
  <h1>{page.title}</h1>
  <AposArea area={page.main} />
</section>
```
The template section supports:

- HTML markup
- Dynamic expressions in curly braces
- Component usage from various frameworks (like Vue or React)
- Conditional rendering and loops

**Styles & Scripts**
Astro components can include scoped styles, global styles, and client-side scripts with a number of options for rendering. Consult the documentation for [styling](https://docs.astro.build/en/guides/styling/) and [adding scripts](https://docs.astro.build/en/guides/client-side-scripts/) for additional details.

```html
<style>
  /* These styles only affect this component */
  .main-content {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
  }
</style>

<script>
  // This JavaScript runs in the browser after the component loads
  const element = document.querySelector('.my-element');
  element.addEventListener('click', () => {
    // Handle interaction
  });
</script>
```
Unlike the frontmatter section which runs during server-side rendering, code in the `<script>` tag runs client-side. Astro deduplicates script tags from the same component, ensuring each script only appears once in the final HTML, regardless of how many component instances exist on the page. The script executes once when loaded by the browser (after the DOM is ready), so you don't need a `DOMContentLoaded` listener. If your component appears multiple times, your script should use DOM queries to find and initialize all instances. Some widgets that interact with the ApostropheCMS admin UI may require additional initialization strategies, which we'll cover in the widgets section.

Now that we understand Astro's structure, let's look at how pages work in an ApostropheCMS + Astro project.

## Understanding Route Handling

In this hybrid setup, all page routing is handled through a single dynamic route file: `[...slug].astro`. This file acts as the central bridge between ApostropheCMS's content management and Astro's rendering system. While Astro projects typically have multiple page files for different routes, our setup leverages ApostropheCMS's routing capabilities, with the `[...slug].astro` file determining how that content gets rendered.

<AposCodeBlock>

```astro
---
import aposPageFetch from '@apostrophecms/apostrophe-astro/lib/aposPageFetch.js';
import AposLayout from '@apostrophecms/apostrophe-astro/components/layouts/AposLayout.astro';
import AposTemplate from '@apostrophecms/apostrophe-astro/components/AposTemplate.astro';

const aposData = await aposPageFetch(Astro.request);
const bodyClass = `myclass`;
---
<AposLayout title={aposData.page?.title} {aposData} {bodyClass}>
    <Fragment slot="standardHead">
      <meta name="description" content={aposData.page?.seoDescription} />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <meta charset="UTF-8" />
    </Fragment>
    <AposTemplate {aposData} slot="main" />
</AposLayout>
```
  <template v-slot:caption>
    frontend/src/pages/[...slug].astro
  </template>
</AposCodeBlock>

Let's do a walkthrough of the relevant sections of code:

``` javascript
import aposPageFetch from '@apostrophecms/apostrophe-astro/lib/aposPageFetch.js';
import AposLayout from '@apostrophecms/apostrophe-astro/components/layouts/AposLayout.astro';
import AposTemplate from '@apostrophecms/apostrophe-astro/components/AposTemplate.astro';
```
There are several imports in the slug file frontmatter. The `aposPageFetch` function retrieves content from ApostropheCMS for the current URL. The `AposLayout` component provides a comprehensive set of slots for customizing your page structure. Unlike a traditional ApostropheCMS project where page templates have direct access to the named slots, here only the slug file does. These slots are defined in the `apostrophe-astro` extension and provide specific insertion points throughout your core HTML document:

**Head Section Slots**

- `startHead`: For elements that need to be at the very beginning of the `<head>`, such as character encoding or early-loading scripts
- `standardHead`: For typical meta tags, title, and standard head content
- `extraHead`: For additional head content that should be loaded last, like page-specific styles or scripts

**Body Section Slots**

- `startBody`: Content immediately after the opening `<body>` tag - not part of the refresh zone in edit mode
- `beforeMain`: Content before the main content area - part of the refresh zone in edit mode
- `main`: The primary content area - part of the refresh zone in edit mode
- `afterMain`: Content after the main content area - part of the refresh zone in edit mode
- `endBody`: Content at the end of the `<body>` - not part of the refresh zone in edit mode

Here is the layout that is delivered when no user is logged in:

<AposCodeBlock>

```astro
---
const { title, bodyClass, lang } = Astro.props;
---

<!DOCTYPE html>
<html lang={ lang }>
  <head>
    <slot name="startHead" />
    <title>{ title }</title>
    <slot name="standardHead" />
    <slot name="extraHead" />
  </head>
  <body class={ bodyClass }>
    <slot name="startBody" />
    <slot name="beforeMain" />
    <slot name="main" />
    <slot name="afterMain" />
    <slot name="endBody" />
  </body>
</html>
```
  <template v-slot:caption>
    apostrophe-astro/components/layouts/AposRunLayout.astro
  </template>
</AposCodeBlock>

The `AposLayout` component can also take props for the page title and body classes, in addition to page language for localization. It also takes care of wrapping the body content to allow for in-context editing and content addition when there is a user that is logged in.

Finally, the `AposTemplate` selects the correct template from the mapping index based on the name of the template that ApostropheCMS is requesting and places it in the `main` slot.

```javascript
const aposData = await aposPageFetch(Astro.request);
```
Next up, we use the `aposPageFetch` helper function we imported to populate `aposData` with the information being returned from the ApostropheCMS request query. This data is passed to out `AposTemplate` component as a standard Astro prop.

The rest of the code in this file just uses the components to create content that will be displayed on all pages in your project, plus the imported `AposTemplate` to add the selected template to the `main` slot.

The full `[...slug].astro` file in the Apollo theme also handles 404 errors and the addition of a common header and footer component, since we will want these on all our pages. You can look at this file to see how we handle this content.

## Template Slot Limitations

When working with an ApostropheCMS-Astro project, it's important to understand how template content and slots work:

1. Individual page templates (like `HomePage.astro` or `DefaultPage.astro`) can only render content within the `main` slot because the `AposTemplate` component is specifically placed in the `main` slot in your `[...slug].astro` file:

```astro
<AposTemplate {aposData} slot="main" />
```

1. Content that needs to appear in other slots (like `startHead`, `standardHead`, `beforeMain`, etc.) must be defined in your `[...slug].astro` file.

## Customization Strategies

There are several approaches to customizing your pages in an ApostropheCMS and Astro project. The Apollo template uses the simplest and most straightforward approach: adding site-wide elements directly in the `[...slug].astro` file:

<AposCodeBlock>

```astro
---
import SiteHeader from '../components/SiteHeader.astro';
import SiteFooter from '../components/SiteFooter.astro';
---
<AposLayout title={aposData.page?.title} {aposData} {bodyClass}>
    <Fragment slot="standardHead">
      <meta name="description" content={aposData.page?.seoDescription} />
      <link rel="stylesheet" href="/styles/global.css" />
    </Fragment>

    <Fragment slot="beforeMain">
      <SiteHeader />
    </Fragment>

    <AposTemplate {aposData} slot="main" />

    <Fragment slot="afterMain">
      <SiteFooter />
    </Fragment>
</AposLayout>
```
  <template v-slot:caption>
    frontend/src/pages/[...slug].astro
  </template>
</AposCodeBlock>

While this is the approach used in Apollo, there are other valid strategies you might consider. You could use conditional rendering based on page types - for example, showing different components or styles on your home page versus other pages.
 In your `[...slug].astro` page:

<AposCodeBlock>

```astro
<Fragment slot="standardHead">
  <meta name="description" content={aposData.page?.seoDescription} />
  {isHomePage && <link rel="stylesheet" href="/styles/home.css" />}
</Fragment>
```
<template v-slot:caption>
backend/src/pages/[...slug].astro
</template>
</AposCodeBlock>

And in your `HomePage.astro` template:

<AposCodeBlock>

```astro
----
// imports and other code

const isHomePage = aposData.page?.type === '@apostrophecms/home-page';
---
```
<template v-slot:caption>
backend/src/templates/HomePage.astro
</template>
</AposCodeBlock>

Adding this check to the frontmatter of your HomePage template will check the type of page data being supplied by the backend (ApostropheCMS). This will set the `isHomePage` variable and in turn conditionally determine the addition of the extra styling.

Another approach is to pass custom props through to your page templates, allowing for more dynamic customization of how each template renders.

<AposCodeBlock>

```astro
---
const customProps = {
  showSidebar: aposData.page?.type === 'default-page',
  theme: aposData.page?.type === '@apostrophecms/home-page' ? 'dark' : 'light'
};
---
<AposTemplate {aposData} slot="main" {...customProps} />
```
<template v-slot:caption>
frontend/src/pages/[...slug].astro
</template>
</AposCodeBlock>

<AposCodeBlock>

```astro
---
const { showSidebar, theme } = Astro.props;
---
<div class={`page-content theme-${theme}`}>
  {showSidebar && <Sidebar />}
  <main>
    <!-- Page content here -->
  </main>
</div>
```
<template v-slot:caption>
frontend/src/templates/DefaultPage.astro
</template>
</AposCodeBlock>

Each of these strategies serves different needs in your site architecture. The first option provides a clean way to manage global elements, the second allows for page-specific customizations, and the third offers deep template customization through props. You can mix and match these approaches based on your specific requirements - for instance, using global elements for your header and footer while employing props for page-specific customizations.

While there are many ways to organize your templates and slots, the key is to use component composition effectively. Breaking down slot management into reusable components makes your code more maintainable and easier to test. Choose the approach that best fits your project's needs, whether that's organizing slots in the main layout file or creating dedicated components for different sections of your site.

### Understanding Edit Mode Implications

Remember that content in different slots behaves differently in edit mode:

- Content in `beforeMain`, `main`, `afterMain` and `endBody` slots refreshes when content is updated
- Content in head slots and `startBody` remains static until full page reload
- Consider these behaviors when deciding where to place dynamic content

This slot system provides a structured way to organize your site's content while maintaining the benefits of the in-context editing capabilities of ApostropheCMS.

## Implementing a Default Page

Now let's look at a simple default page type that can be used for basic content pages. This requires configuration in both the backend (ApostropheCMS) and frontend (Astro).

<iframe width="560" height="315" src="https://www.youtube.com/embed/AlWPERA3E1w?si=sm7zo2cn3AQ6yEMA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Backend Configuration

The backend ApostropheCMS module defines the page type's structure and available content areas.

::: info
The Apollo project uses ECMAScript modules (ESM) syntax in the ApostropheCMS backend code rather than CommonJS (CJS). This aligns with modern JavaScript practices and is the recommended approach for new ApostropheCMS projects. You don't have to follow this pattern, but keep in mind the entire backend project must be written with 100% ESM or 100% CommonJS.

<AposCodeBlock>

```javascript
import { getWidgetGroups } from '../../lib/helpers/area-widgets.js';

export default {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Default Page'
  },
  fields: {
    add: {
      main: {
        type: 'area',
        options: getWidgetGroups({
          includeLayouts: true
        })
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [
          'main'
        ]
      }
    }
  }
};
```
  <template v-slot:caption>
    backend/modules/default-page/index.js
  </template>
</AposCodeBlock>

This setup is exactly what you would see in a standard ApostropheCMS project without an Astro frontend. It extends the core page type and creates a main content area that accepts various widgets. In the case of the Apollo theme, we have created a `backend/lib/helpers/area-widgets.js` helper that allows for easy addition of widgets to areas. You can check out this file to see how we do this, but this helper function allows the developer to pass the `includeLayouts` property to determine if the area should contain just the content widgets, like the rich-text and image widgets, or also include the layout widgets. The `group` property places this `main` schema field onto the basics tab. You can read more about creating pages in the main [ApostropheCMS documentation](/guide/pages.html).

Next, we need to add the page to the `backend/app.js` file.

<AposCodeBlock>

```javascript
import apostrophe from 'apostrophe';

export default apostrophe({
  root: import.meta,
  shortName: 'apollo',
  modules: {
    // ... other modules
    'default-page': {}
  }
});
```
<template v-slot:caption>
backend/app.js
</template>
</AposCodeBlock>

Finally, we need to register the page so that it shows up as a page type for the content manager to select from the page creation modal. This is accomplished by adding it to the `types` array in the `backend/modules/@apostrophecms/page/index.js` file:

<AposCodeBlock>

```javascript
export default {
  options: {
    builders: {
      children: true,
      ancestors: {
        children: {
          depth: 2,
          relationships: false
        }
      }
    },
    types: [
      {
        name: '@apostrophecms/home-page',
        label: 'Home'
      },
      {
        name: 'default-page',
        label: 'Default'
      }
    ]
  }
};
```
<template v-slot:caption>
backend/modules/@apostrophecms/page/index.js
</template>
</AposCodeBlock>

In this case, our `default-page` module is at the project-level, so we don't prefix it with `@apostrophecms/`.

### Frontend Template

Next, we need a frontend (Astro) template to render the page. Instead of creating pages in the `src/pages` directory, we create them in the `src/templates` directory. These templates correspond to your ApostropheCMS page types.

<AposCodeBlock>

```astro
---
import AposArea from '@apostrophecms/apostrophe-astro/components/AposArea.astro';
const { page, user, query } = Astro.props.aposData;
const { main } = page;
---
<section class="main-content astro-default-content">
  <AposArea area={main} />
</section>
```
  <template v-slot:caption>
    frontend/src/templates/DefaultPage.astro
  </template>
</AposCodeBlock>

While simple, this template demonstrates several important concepts. First, it shows how to access the data passed from the ApostropheCMS backend through the `aposData` prop. While we are only using the `page` data in this template, there is additional data available to us.

Common data properties for page templates include:

```javascript
const {
  page,      // The current page document
  piece,     // Current piece (for show pages)
  pieces,    // Array of pieces (for index pages)
  user,      // Current user info
  query,     // URL query parameters
  global     // Global document
} = Astro.props.aposData;
```

Second, it shows the import of the `AposArea` component that is used to easily output each user-edited area's widget content to the page. Here, we are passing in the contents of the `main` schema field that we set up in the ApostropheCMS schema field as the `area` prop.

::: info
You can pass any number of props to the `AposArea` component besides the required `area` named prop. You just need to have your widget template destructure those props from the `Astro.props` to use them. This is shown with the implementation of the core `ImageWidget.astro` component and the author piece image in the `backend/src/layouts/article-layouts/HeroGrid.astro` template.

### Template Mapping

To connect the backend (ApostropheCMS) and frontend (Astro), we need to map the page type to its template:

<AposCodeBlock>

```javascript
import HomePage from './HomePage.astro';
import DefaultPage from './DefaultPage.astro';

const templateComponents = {
  '@apostrophecms/home-page': HomePage,
  'default-page': DefaultPage

  // other page type mappings...
};

export default templateComponents;
};
```
  <template v-slot:caption>
    frontend/src/templates/index.js
  </template>
</AposCodeBlock>

## Implementing Piece Pages

<iframe width="560" height="315" src="https://www.youtube.com/embed/grvZKHb35BQ?si=PstzMnL5mklc1zYq" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

While standard pages have a straightforward one-to-one mapping between ApostropheCMS page types and Astro templates, piece pages require a different approach. A single piece page type in ApostropheCMS typically needs two different templates:

1. An **index template** that displays a list of pieces (like a blog listing page)
2. A **show template** that displays a single piece (like an individual blog post)

In a standard ApostropheCMS project, this would be accomplished by adding `index.html` and `show.html` templates to the `views` folder of your piece page module.

## Template Mapping for Piece Pages

To handle this, the template mapping uses a suffix notation with `:index` and `:show` to specify which template handles which view:

<AposCodeBlock>

```javascript
// other template imports
import ArticleIndexPage from './ArticleIndexPage.astro';
import ArticleShowPage from './ArticleShowPage.astro';

export default {
  // Standard pages
  '@apostrophecms/home-page': HomePage,
  'default-page': DefaultPage,
  // Piece pages with suffixes
  'article-page:index': ArticleIndexPage,
  'article-page:show': ArticleShowPage
};
```
<template v-slot:caption>
frontend/src/templates/index.js
</template>
</AposCodeBlock>

## Handling Index Pages

Index templates need to handle not just the display of multiple pieces, but also pagination and filtering. We will cover this in greater depth, along with options that can be passed to your piece page type when we cover pieces. As a first glance, ApostropheCMS provides extra data to these types of pages through the `aposData` prop:

<AposCodeBlock>

```astro
---
const {
  pieces,      // Array of pieces for current page
  totalPages,  // Total number of pages
  currentPage, // Current page number
  query        // URL query parameters
} = Astro.props.aposData;
---

<div class="article-listing">
  {pieces.map(article => (
    <article>
      <h2><a href={article._url}>{article.title}</a></h2>
      <!-- Additional article preview content -->
    </article>
  ))}
</div>
```
<template v-slot:caption>
frontend/src/templates/ArticleIndexPage.astro
</template>
</AposCodeBlock>

The template uses Astro's curly brace syntax for dynamic content. Inside these braces, you can write JavaScript expressions, including array methods like map().
This code:

1. Takes the pieces array provided by ApostropheCMS
2. Uses map() to loop through each article
3. Creates an `<article>` element for each piece
4. Uses curly braces to insert the article's URL and title into the HTML

The curly braces tell Astro to evaluate the JavaScript expression inside and insert the result into the HTML. This is similar to other template systems like <span v-pre>`{{ }}`</span> in Vue or `<%= %>` in EJS, but with native JavaScript syntax.

We can use the pagination data passed into our piece page to create our own pagination, but as we will cover in the section on pieces, we can also use a helper component from the `apostrophe-astro` extension.

## Show Templates for Individual Pieces

Show templates receive the individual piece through the `piece` property of `aposData`:

<AposCodeBlock>

```astro
---
const { piece: article } = Astro.props.aposData;
---

<article>
  <h1>{article.title}</h1>
  <AposArea area={article.main} />

  <!-- Example of accessing relationships -->
  {article._author?.[0] && (
    <div class="author-info">
      <h2>About the Author</h2>
      <p>{article._author[0].title}</p>
    </div>
  )}
</article>
```
<template v-slot:caption>
frontend/src/templates/ArticleShowPage.astro
</template>
</AposCodeBlock>

### URL Generation

Note that piece documents include a `_url` property that provides the correct URL for viewing that piece. Always use this property rather than constructing URLs manually, as it handles:
- The correct base URL for your site
- Any configured URL prefixes
- Localization prefixes if your site is multilingual
- Special parameters needed for draft preview mode

## Common Page Patterns

### Working with Query Parameters
When building interactive pages, you'll often need to work with query parameters for features like pagination, filtering, or search. The `apostrophe-astro` package provides the `aposSetQueryParameter` helper to safely manage URL parameters while preserving ApostropheCMS's admin UI parameters:

```astro
---
import setParameter from '@apostrophecms/apostrophe-astro/lib/aposSetQueryParameter.js';

// Add or update a parameter
const filterUrl = setParameter(Astro.url, 'category', 'news');

// Remove a parameter by passing empty string
const clearFilter = setParameter(Astro.url, 'category', '');
---
```

#### Accessing Global Data
ApostropheCMS provides a global document for site-wide settings and content. This is configured in your backend through the `@apostrophecms/global` module:

<AposCodeBlock>

```javascript
export default {
  fields: {
    add: {
      // Simple fields
      siteTitle: {
        type: 'string',
        label: 'Site Title'
      },
      footerText: {
        type: 'string',
        label: 'Footer Text',
        textarea: true
      },
      // Areas for widgets
      footer: {
        type: 'area',
        label: 'Footer Content',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {}
          }
        }
      },
      socialLinks: {
        type: 'array',
        label: 'Social Media Links',
        fields: {
          add: {
            platform: {
              type: 'select',
              label: 'Platform',
              choices: [
                { label: 'Twitter', value: 'twitter' },
                { label: 'LinkedIn', value: 'linkedin' }
              ]
            },
            url: {
              type: 'url',
              label: 'URL'
            }
          }
        }
      }
    },
    group: {
      basics: {
        label: 'Site Settings',
        fields: ['siteTitle', 'footerText']
      },
      footer: {
        label: 'Footer',
        fields: ['footer', 'socialLinks']
      }
    }
  }
};
```
<template v-slot:caption>
backend/modules/@apostrophecms/global/index.js
</template>
</AposCodeBlock>

The global data is then available in any Astro template through the `aposData` prop. This also means that you should use relationships sparingly in the global document. Remember they must be loaded on every page view.

```astro
---
const { global } = Astro.props.aposData;
---
// Using simple fields
<h1>{global.siteTitle}</h1>

// Using areas
<footer>
  <div class="footer-content">
    <AposArea area={global.footer} />
  </div>
  
  // Using array fields
  <div class="social-links">
    {global.socialLinks?.map(link => (
      <a href={link.url} class={`icon-${link.platform}`}>
        {link.platform}
      </a>
    ))}
  </div>
</footer>
```

The global document is perfect for content that needs to appear across your site, such as:
- Header and footer content
- Site-wide navigation
- Social media links
- Company contact information
- Default SEO metadata
- Branding assets like logos

Unlike page content, global fields are edited through the admin bar's "Global" menu item rather than on the page itself.

### Page Layouts
While every page type could define its own complete structure, it's often useful to create reusable layouts. The Apollo theme demonstrates several approaches to layouts:

- Layout selection through the admin UI (see the home page's three layouts)
- Shared components for common elements like headers and footers
- Content-specific layouts (see the article index and show page layouts)

For detailed examples of these patterns in action, explore the Apollo theme's source code, particularly:
- The home page implementation with its three layout options
- The article page layouts in `frontend/src/layouts/article-layouts/`
- The global header and footer components

With our understanding of how pages work in an ApostropheCMS + Astro project, we can now turn our attention to another crucial component: widgets. These modular building blocks provide the actual content and functionality within your page areas, and mastering their creation is essential for building flexible, editor-friendly websites.

================================================================================
COLLECTION: tutorials
NAV_PATH: ApostropheCMS & Astro > Creating Widgets
DOC_PATH: tutorials/astro/creating-widgets.md
URL: https://apostrophecms.com/docs/tutorials/astro/creating-widgets
================================================================================
# Creating Widgets in ApostropheCMS + Astro
Widgets are the fundamental building blocks of content in ApostropheCMS. They allow content editors to change the page layout, add images, or rich text to a page. As we covered in the [Core Concepts](/tutorials/astro/introducing-apollo.html#core-concepts) section of the Apollo introduction, this occurs through the addition of widgets to areas on the page. As we will briefly touch on, Astro also allows developers to reuse widgets as components added directly to the page. To understand widget creation, we will first look at several widgets from the Apollo theme and then create a new widget from scratch.

::: tip Watch & Learn! üé•
This tutorial is available in both text and video formats. The videos cover the key highlights, while this page provides additional details and references. Watch the videos for a guided introduction, then read on for deeper insights!

This tutorial provides only a brief introduction to widget development in ApostropheCMS, but there's much more to explore. For comprehensive documentation on Apostrophe's field types, query syntax, and advanced widget features, visit the [core ApostropheCMS documentation](https://apostrophecms.com/docs).

<iframe width="560" height="315" src="https://www.youtube.com/embed/tC6vJwqYO8o?si=Inv-0eTcMhbpE-a_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Understanding Widget Mapping

As with pages, when ApostropheCMS serves content containing widgets, the Astro frontend needs to know which component should render each widget type. This is handled through a mapping configuration defined in your Astro project.

The mapping between ApostropheCMS widget types and Astro components is defined in the `frontend/src/widgets/index.js` file:

<AposCodeBlock>

```javascript
import RichTextWidget from './RichTextWidget.astro';
import ImageWidget from './ImageWidget.astro';
import VideoWidget from './VideoWidget.astro';
import GridLayoutWidget from './GridLayoutWidget.astro';
import AccordionWidget from './AccordionWidget.astro';
import CardWidget from './CardWidget.astro';
import HeroWidget from './HeroWidget.astro';
import LinkWidget from './LinkWidget.astro';
import SlideshowWidget from './SlideshowWidget.astro';
import RowsWidget from './RowsWidget.astro';

const widgetComponents = {
  '@apostrophecms/rich-text': RichTextWidget,
  '@apostrophecms/image': ImageWidget,
  '@apostrophecms/video': VideoWidget,
  'grid-layout': GridLayoutWidget,
  'accordion': AccordionWidget,
  'card': CardWidget,
  'hero': HeroWidget,
  'link': LinkWidget,
  'slideshow': SlideshowWidget,
  'rows': RowsWidget
};

export default widgetComponents;
```
<template v-slot:caption>
frontend/src/widgets/index.js
</template>
</AposCodeBlock>

This mapping file is referenced in your `astro.config.mjs` through the `apostrophe` integration settings:

```javascript
// astro.config.mjs
integrations: [apostrophe({
  // Other configuration...
  widgetsMapping: './src/widgets',
  // Additional settings...
})],
```
If desired, you could use this configuration setting to specify that the mapping come from a different file.

As with pages, core widgets and widgets added through packages in the node modules are prefixed with the namespace, e.g. `@apostrophecms/widget-name`. Project-level widgets use just the base name. For all the widgets you remove the `-widget` suffix.

## The Apollo Rows Widget
![The rows-widget edit modal](../../images/apollo-rows-widget.png)

In ApostropheCMS, areas provide a flexible way to structure content, making it easy to build dynamic layouts. While areas can be defined at the page level, widgets (and pieces) can also have their own areas, allowing them to act as containers for other widgets. This enables complex, nested layouts.

<iframe width="560" height="315" src="https://www.youtube.com/embed/grhDL8Xo0xE?si=_00W4gmum16Wo3ZG" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

A great example of this is the rows widget in the Apollo project. When added to a page, it lets users configure a set number of column areas based on their chosen layout. Each column can hold any type of widget‚Äîincluding another rows widget‚Äîenabling deep nesting when needed. This pattern appears throughout Apollo; for instance, the hero widget uses an area to manage call-to-action buttons while still fitting seamlessly into ApostropheCMS‚Äôs editing interface.

By structuring layouts this way, you get the best of both worlds: modular, reusable components and a maintainable codebase. Now, let‚Äôs break down how this works under the hood‚Äîboth on the backend and frontend.

### Backend Implementation
In ApostropheCMS, the rows widget module demonstrates several key concepts for widget development. Let's break down its structure:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Rows Layout',
    icon: 'view-column-icon',
    description: 'Create row and column-based layouts for your content.'
  }
}
```
<template v-slot:caption>
backend/modules/rows-widget
</template>
</AposCodeBlock>

The module extends the base widget type and provides metadata used in the editor interface. The `icon` designates an already [registered icon](/reference/module-api/module-overview.html#icons) that will be displayed in the [widget selection flyout](/guide/areas-and-widgets.html#expanded-widget-preview-menu-configuration). The real complexity comes in the `fields` configuration, where we define both the layout controls and the areas:

<AposCodeBlock>

```javascript
fields: {
  add: {
    columnLayout: {
      type: 'select',
      label: 'Column Layout',
      def: 'single',
      choices: [
        {
          label: 'Single Column',
          value: 'single'
        },
        {
          label: 'Two Equal Columns (50/50)',
          value: 'two-equal'
        }
        // Additional layouts...
      ]
    },
    columnOneContent: {
      type: 'area',
      label: 'First Column',
      options: getWidgetGroups({
        includeLayouts: true,
        exclude: [ 'grid-layout' ]
      })
    },
    // additional area fields
  }
}
```
<template v-slot:caption>
backend/modules/rows-widget
</template>
</AposCodeBlock>

A key feature is the [conditional visibility](/guide/conditional-fields.html#displaying-conditional-fields) of areas based on the selected layout. For example, the second column area only appears when certain layouts are selected:

<AposCodeBlock>

```javascript
columnTwoContent: {
  type: 'area',
  label: 'Second Column',
  options: getWidgetGroups({
    includeLayouts: true,
    exclude: ['grid-layout']
  }),
  if: {
    $or: [
      { columnLayout: 'two-equal' },
      { columnLayout: 'three-equal' },
      { columnLayout: 'four-equal' },
      { columnLayout: 'one-third-two-thirds' },
      { columnLayout: 'two-thirds-one-third' },
      { columnLayout: 'quarter-half-quarter' }
    ]
  }
}
```
<template v-slot:caption>
backend/modules/rows-widget
</template>
</AposCodeBlock>

The `if` condition with `$or` operator is part of ApostropheCMS's MongoDB-style query syntax. It's used throughout Apostrophe for conditional field visibility, permissions, and querying content. Each potential column gets its own uniquely named area, which becomes available for content only when the chosen layout supports it.

The `getWidgetGroups` helper used in the `options` is a utility that transforms a simple configuration into a fully expanded area configuration with organized widget groups. Without this helper, a standard area configuration would look more verbose:

```javascript
columnOneContent: {
  type: 'area',
  label: 'First Column',
  options: {
    widgets: {
      '@apostrophecms/rich-text': {
        toolbar: ['styles', 'bold', 'italic', 'link']
      },
      '@apostrophecms/image': {},
      '@apostrophecms/video': {},
      'hero': {},
      'card': {}
      // Each widget must be individually configured
    }
  }
}
```

The helper centralizes these configurations and organizes widgets into groups, making the code more maintainable. For more details on how this helper works, you can examine the `backend/lib/helpers/area-widgets.js` file in the Apollo project. Using the `getWidgetGroups` helper ensures that each area of the row accepts the same set of widgets, excluding the grid layout to prevent nesting conflicts.

Note that within areas you use the same naming conventions used for mapping. Core widgets get prefixed, and none receive the `-widget` suffix.

### Frontend Implementation in Astro
Just like the page template components, the widget frontend implementation starts with the component frontmatter, where we handle imports, type definitions, and data processing:

<AposCodeBlock>

```astro
---
const { widget } = Astro.props;
import AposArea from '@apostrophecms/apostrophe-astro/components/AposArea.astro';
```
<template v-slot:caption>
frontend/src/widgets/RowsWidget.astro
</template>
</AposCodeBlock>

When a widget is rendered in an area, Astro passes the data from the ApostropheCMS backend through the `widget` prop. The values of these schema fields can then be used in the template as we did with our pages. If the widget also contains any areas, as the rows widget does, we can also import the `AposArea` helper for rendering those additional widgets.

The component then defines configuration objects that map our backend choices to frontend styling:

<AposCodeBlock>

```javascript
const layouts = {
  'two-equal': {
    classes: ['is-12-mobile is-6-tablet', 'is-12-mobile is-6-tablet'],
    areas: ['columnOneContent', 'columnTwoContent']
  },
  'three-equal': {
    classes: ['is-12-mobile is-6-tablet is-4-desktop', 'is-12-mobile is-6-tablet is-4-desktop', 'is-12-mobile is-6-tablet is-4-desktop'],
    areas: ['columnOneContent', 'columnTwoContent', 'columnThreeContent']
  }
  // Additional layouts...
};
```
<template v-slot:caption>
frontend/src/widgets/RowsWidget.astro
</template>
</AposCodeBlock>

These configurations are processed in the frontmatter to generate our final classes:

<AposCodeBlock>

```javascript
const currentLayout = layouts[widget.columnLayout || 'two-equal'];
const columnsClasses = [
  'columns',
  spacingClass,
  verticalAlignClass,
  horizontalAlignClass,
  maxWidth,
  'mx-auto'
].filter(Boolean).join(' ');
```
<template v-slot:caption>
frontend/src/widgets/RowsWidget.astro
</template>
</AposCodeBlock>

::: info
Astro has a built-in directive for creating class lists - [`class:list`](https://docs.astro.build/en/reference/directives-reference/#classlist). This allows for construction of the class list directly in the template instead of the frontmatter.
```astro
<span class:list={['columns', {spacingClass}, {verticalAlignClass}, ['mx-auto'] ]} />
```
Since in many cases we are translating to Bulma classes we created some helper functions and have elected to create our class lists in the frontmatter.

These configurations and processed classes are then used in the template section to create our dynamic layout:

<AposCodeBlock>

```astro
<section
  class="column-layout container is-fluid mb-6"
  role="region"
  aria-label={widget.label || 'Content columns'}
>
  <div class={columnsClasses} role="presentation">
    {currentLayout.areas.map((areaName, index) => (
      widget[areaName] && (
        <div
          class={`column ${currentLayout.classes[index]} editor-column`}
          data-column-index={index + 1}
          role="region"
          aria-label={`Column ${index + 1}`}
        >
          <div class="column-content">
            <AposArea area={widget[areaName]} />
          </div>
        </div>
      )
    ))}
  </div>
</section>
```
<template v-slot:caption>
frontend/src/widgets/RowsWidget.astro
</template>
</AposCodeBlock>

The template demonstrates several key concepts:

1. The `currentLayout.areas` array drives the structure, mapping to our backend area fields
2. Each area is only rendered if it exists in the widget data (`widget[areaName]`)
3. The `AposArea` component renders the nested content, maintaining the widget-within-widget pattern
4. Layout classes are applied dynamically based on the selected configuration

The `AposArea` component is doing the heavy lifting here - it takes our area data and renders any widgets that have been added to that area by content editors. This creates the recursive structure we discussed earlier, where each column can contain its own set of widgets.

The rows widget demonstrates the foundational patterns of widget development in ApostropheCMS and Astro:
- Widget configuration through fields and options in the backend
- Conditional field visibility using Apostrophe's conditional syntax
- Area fields that enable nested widget structures
- Frontend component organization with configuration objects and dynamic templating
- Integration with the `AposArea` component for nested content rendering

Next, let's look at how we can add client-side interactivity to widgets. The video and slideshow widgets offer two different approaches to handling JavaScript in the widget ecosystem.

## Adding Client-Side Interactivity to Widgets
Astro provides several routes for adding JavaScript to the browser. This can take the form of public scripts loaded on every page, `<script>` tags in your components, and the addition of client-side framework components, e.g. Vue or React components. Let's explore the different approaches available for adding client-side interactivity to widgets in the ApostropheCMS + Astro environment, using examples from the Apollo project.

<iframe width="560" height="315" src="https://www.youtube.com/embed/JEU2RdgqrIs?si=reRnkOBt_rTIpXTA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Web Components Approach

Web Components are a great choice for widgets that need to maintain their own state and behavior. The Apollo `VideoWidget` relies on a custom web component to access the ApostropheCMS backend oEmbed endpoint.

::: info
You can add additional routes into your ApostropheCMS backend that can be accessed by client-side fetch operations. If they are prefixed with `/api/v1/` they will be proxied by the `apostrophe-astro` extension. If not, they can be added to the `proxyRoutes` array in the extension configuration within the `astro.config.mjs` file.

Within the widget it passes `title` and `URL` data to this component:

<AposCodeBlock>

```astro
<video-widget
  url={placeholder ? PLACEHOLDER_VIDEO_URL : url}
  title={videoTitle}
>
</video-widget>
```
<template v-slot:caption>
frontend/src/widgets/VideoWidget.astro
</template>
</AposCodeBlock>

In past versions of Astro, JavaScript included in your components through the `<script>` tag was hoisted and initiated as soon as a component was added to the page through dynamic editing. In modern versions of Astro, this is no longer true. If you are generating static pages with Astro, this isn't typically a concern and can make overall bundle size smaller depending on page content. For Apostrophe widget addition however, we want a dynamic editing experience where widget content is available upon in-context addition.

Any scripts added directly to your Astro components are linked inline and only initiated after full page reload. This presents a problem when we initially add our custom `<video-widget>` to the page, because the web component won't exist until the script is run and will therefore throw an error. To get around this limitation, we moved the client-side JavaScript to the `frontend/public/scripts` folder and are loading the component script in the `[...slug].astro` file.

#### Widget Template Structure

First, let's look at how the widget template is structured:

<AposCodeBlock>

```astro
---
const { widget } = Astro.props;
const { video, title } = widget;
const url = video?.url;
const videoTitle = title || 'Video';
const placeholder = widget?.aposPlaceholder;
const PLACEHOLDER_VIDEO_URL = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';
---

<div class="video-widget-wrapper">
  <video-widget
    url={placeholder ? PLACEHOLDER_VIDEO_URL : url}
    title={videoTitle}
  >
  </video-widget>
</div>
```
<template v-slot:caption>
frontend/src/widgets/VideoWidget.astro
</template>
</AposCodeBlock>

We are accessing the data passed from the ApostropheCMS backend server through the `widget` prop and destructuring the two fields, `video` and `title`. This information is then passed to the `<video-widget>` web component. Note that in an Astro only project we could instead import the web component in this template.

#### Web Component Implementation

The [web component](https://developer.mozilla.org/en-US/docs/Web/API/Web_components) itself is defined in a separate file. Here's a simplified version showing the core functionality:

<AposCodeBlock>

```javascript
class VideoWidget extends HTMLElement {
  static observedAttributes = ['url', 'title'];

  constructor() {
    super();
    this.videoData = null;
  }

  async connectedCallback() {
    await this.initializeVideo();
  }

  async attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue && this.isConnected) {
      await this.initializeVideo();
    }
  }

  async initializeVideo() {
    const url = this.getAttribute('url');
    if (!url) return;

    try {
      // Fetch oEmbed data from ApostropheCMS
      const response = await fetch(`/api/v1/@apostrophecms/oembed/query?url=${encodeURIComponent(url)}`);
      this.videoData = await response.json();
      this.render();
    } catch (error) {
      console.error('Error fetching video data:', error);
    }
  }

  render() {
    if (!this.videoData) return;

    // Create responsive wrapper
    const wrapper = document.createElement('div');
    wrapper.className = 'video-responsive';
    wrapper.innerHTML = this.videoData.html;

    // Clear and update content
    this.innerHTML = '';
    this.appendChild(wrapper);
  }
}

customElements.define('video-widget', VideoWidget);
```
<template v-slot:caption>
frontend/public/scripts/video-widget.js
</template>
</AposCodeBlock>

We aren't going to go through this file in detail. The one thing that you will note is that it is making an API call to the ApostropheCMS server:
```javascript
const response = await fetch(`/api/v1/oembed?url=${encodeURIComponent(url)}`);
```
If desired, you could create [custom API routes](/reference/module-api/module-overview.html#restapiroutes-self) for any of your widgets or other web components to query in this manner. We will touch on this in the [Creating Pieces tutorial](/tutorials/astro/creating-pieces.md#approach-2-custom-api-routes) section.

#### Loading the Web Component

In the Apollo `[...slug].astro` file we are adding the web component script to the `startHead` slot:

<AposCodeBlock>

```astro
<AposLayout title={aposData.page?.title} {aposData} {bodyClass}>
  <Fragment slot="startHead">
    <script src="/scripts/video-widget.js"></script>
  </Fragment>
  <!-- ... rest of layout -->
</AposLayout>
```
<template v-slot:caption>
frontend/src/pages/[...slug].astro
</template>
</AposCodeBlock>

### Traditional JavaScript Initialization

For widgets that need more traditional JavaScript initialization, like the `SlideshowWidget`, we need a different approach.

#### Widget Template

<AposCodeBlock>

```astro
---
const { widget } = Astro.props;
const { images, _id } = widget;
---

<div
  class="slideshow-widget"
  data-slideshow
  data-widget-id={_id}
>
  <div class="slideshow-content">
    {images?.map((image, index) => (
      <div
        class:list={[
          'slide',
          { active: index === 0 }
        ]}
        data-slide={index}
      >
        <img src={image._urls.max} alt={image.title || ''} />
      </div>
    ))}
  </div>

  <div class="slideshow-controls">
    <button class="prev" aria-label="Previous slide">‚Üê</button>
    <button class="next" aria-label="Next slide">‚Üí</button>
  </div>
</div>
```
<template v-slot:caption>
frontend/src/widgets/SlideshowWidget.astro
</template>
</AposCodeBlock>

The template just brings in the widget data and creates simple markup to display and navigate through the slides.

#### JavaScript Initialization

We won't look at all the JavaScript powering the slideshow functionality, just the portion that initializes the script during page load.

<AposCodeBlock>

```astro
<script>
// ... other slideshow specific code

const slideshows = new Map();

setTimeout(() => {
  initSlideshows();

  if (window.apos) {
    apos.bus.$on('refreshed', initSlideshows);
    apos.bus.$on('modal-resolved', initSlideshows);
  }
}, 300);

function initSlideshows() {
  slideshows.forEach((slideshow) => slideshow.destroy());
  slideshows.clear();

  setTimeout(() => {
    document.querySelectorAll('.slideshow-container').forEach((container) => {
      const slideshowId = container.dataset.slideshowId;
      if (slideshowId) {
        slideshows.set(slideshowId, new Slideshow(container));
      }
    });
  }, 100);
}
</script>
```
<template v-slot:caption>
frontend/src/widgets/SlideshowWidget.astro
</template>
</AposCodeBlock>

The slideshow widget uses a combination of Astro and ApostropheCMS event handling to manage slideshow functionality. When in editing mode, the widget properly reinitializes after preview/edit toggles by listening to ApostropheCMS's event bus. Here we are listening for two different emit events - `refreshed` that occurs when a user switches between the edit and preview modes, and `modal-resolved` that occurs after the user closes the editing modal to reinitialize when slides are removed or added. A small timeout ensures both ApostropheCMS is available and the DOM has been updated before initializing or reinitializing slideshows. Each slideshow instance is tracked in a Map to properly clean up event listeners and autoplay intervals when needed.

Currently, when a new slideshow widget is first added to a page through ApostropheCMS, a page reload is required for the JavaScript initialization to take effect. However, once the page has been reloaded, the slideshow functions normally and handles preview/edit mode switches correctly. This initial load limitation is a known issue in the current implementation, related to the timing of widget addition and script hydration.

Another approach to initializing JavaScript is to use a `MutationObserver` as we do in the `backend/src/widgets/AccordionWidget.astro`. We won't go through this approach in detail, but you can look through the code to see if it is a preferred approach in your own project.

## Creating a Custom Testimonial Widget

Let's create a testimonial widget from scratch to demonstrate the complete widget development process. This widget will display customer testimonials with a quote, author name, role, and optional image.

### Backend Setup

First, create the widget module in your backend project:

```bash
mkdir -p backend/modules/testimonial-widget
touch backend/modules/testimonial-widget/index.js
```

#### Module Configuration

Add this configuration to `backend/modules/testimonial-widget/index.js`:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Testimonial',
    icon: 'format-quote-icon',
    description: 'Add customer testimonials to your page'
  },
  fields: {
    add: {
      quote: {
        type: 'string',
        label: 'Quote',
        textarea: true,
        required: true
      },
      author: {
        type: 'string',
        label: 'Author Name',
        required: true
      },
      role: {
        type: 'string',
        label: 'Author Role'
      },
      authorImage: {
        type: 'area',
        label: 'Author Image',
        options: {
          max: 1,
          widgets: {
            '@apostrophecms/image': {}
          }
        }
      },
      style: {
        type: 'select',
        label: 'Display Style',
        def: 'simple',
        choices: [
          {
            label: 'Simple',
            value: 'simple'
          },
          {
            label: 'Card',
            value: 'card'
          },
          {
            label: 'Featured',
            value: 'featured'
          }
        ]
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [
          'quote',
          'author',
          'role'
        ]
      },
      appearance: {
        label: 'Appearance',
        fields: [
          'authorImage',
          'style'
        ]
      }
    }
  }
};
```
<template v-slot:caption>
backend/modules/testimonial-widget/index.js
</template>
</AposCodeBlock>

### Register the Widget

1. First, add the widget to the widget groups in `backend/lib/helpers/area-widgets.js`:

<AposCodeBlock>

```javascript
export const widgetGroups = {
  // ... existing groups
  content: {
    label: 'Content',
    columns: 3,
    widgets: {
      '@apostrophecms/image': {},
      '@apostrophecms/video': {},
      '@apostrophecms/rich-text': {},
      // ... other content widgets
      testimonial: {} // Add our new testimonial widget
    }
  }
};
```
<template v-slot:caption>
backend/lib/helpers/area-widgets.js
</template>
</AposCodeBlock>

The `area-widgets.js` helper provides a clean, maintainable way to:
- Organize widgets into logical groups (layout vs. content)
- Configure widget display in the admin UI (columns, labels)
- Centrally manage widget availability across different areas
- Easily exclude specific widgets when needed

2. Then add the widget to `backend/app.js`:

<AposCodeBlock>

```javascript
export default {
  modules: {
    // ... other modules
    'testimonial-widget': {}
  }
}
```
<template v-slot:caption>
backend/app.js
</template>
</AposCodeBlock>

### Using the Widget in Areas

Now you can use the helper to add the testimonial widget to any area. For example, in a page type:

<AposCodeBlock>

```javascript
import { getWidgetGroups } from '../../lib/helpers/area-widgets.js';

export default {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'My Page Type'
  },
  fields: {
    add: {
      main: {
        type: 'area',
        options: getWidgetGroups({
          includeLayouts: true // Include layout widgets if needed
        })
      }
    }
  }
};
```
<template v-slot:caption>
</template>
</AposCodeBlock>

### Frontend Implementation

#### Create the Widget Component

Create a new file at `frontend/src/widgets/TestimonialWidget.astro`:

<AposCodeBlock>

```astro
---
import AposArea from '@apostrophecms/apostrophe-astro/components/AposArea.astro';

const { widget } = Astro.props;
const { quote, author, role, style = 'simple', authorImage } = widget;

// Map styles to Bulma classes
const styleClasses = {
  simple: 'is-light',
  card: 'is-primary',
  featured: 'is-info is-large'
};

const boxClass = `box notification ${styleClasses[style]} p-5`;
---

<div class={boxClass}>
  {authorImage && (
    <figure class="image is-96x96 mb-4 mx-auto">
      <AposArea area={authorImage} />
    </figure>
  )}

  <blockquote class="is-size-5 has-text-centered mb-4">
    "{quote}"
  </blockquote>

  <div class="has-text-centered">
    <strong class="is-block">{author}</strong>
    {role && <span class="is-block has-text-grey">{role}</span>}
  </div>
</div>

<style>
  blockquote {
    font-style: italic;
    line-height: 1.5;
  }

  .box {
    max-width: 800px;
    margin: 2rem auto;
  }

  .is-large {
    font-size: 1.25rem;
  }
</style>
```
<template v-slot:caption>
frontend/src/widgets/TestimonialWidget.astro
</template>
</AposCodeBlock>

### Register the Widget Component

Add the widget to `frontend/src/widgets/index.js`:

<AposCodeBlock>

```javascript
import TestimonialWidget from './TestimonialWidget.astro';

export default {
  // ... other widgets
  'testimonial': TestimonialWidget
};
```
<template v-slot:caption>
frontend/src/widgets/index.js
</template>
</AposCodeBlock>

## Reusing Widget Schema Fields in Page Templates

One powerful advantage of working with ApostropheCMS and Astro together is the ability to reuse widget components directly in page templates rather than only within areas. In a traditional ApostropheCMS-only project, widgets can only be added to areas through the editing interface. However, in a hybrid ApostropheCMS + Astro project, you can also use widgets as standalone Astro components directly in your page templates.

### The Schema Sharing Pattern

To facilitate this flexibility, we can extract widget schema field definitions into reusable modules that can be imported by both widget modules and page modules. The Apollo theme demonstrates this pattern with several widgets, including the hero, card, link, and slideshow widgets.

Let's see how this works with the hero widget as an example:

1. **Create a schema mixin file**

First, we define our schema fields in a dedicated module:

<AposCodeBlock>

```javascript
import colorOptionsHelper from '../../lib/helpers/color-options.js';

export default {
  layout: {
    type: 'select',
    label: 'Layout Style',
    def: 'full',
    choices: [
      {
        label: 'Full Width',
        value: 'full'
      },
      {
        label: 'Split Content',
        value: 'split'
      }
    ]
  },
  // ... many more schema fields for the hero component
  // Including background options, content settings, etc.
  callToAction: {
    type: 'area',
    label: 'Call-to-Action Links',
    options: {
      widgets: {
        link: {}
      },
      max: 2
    }
  }
};
```
<template v-slot:caption>
backend/lib/schema-mixins/hero-fields.js
</template>
</AposCodeBlock>

2. **Import in the widget module**

The hero widget module imports these fields:

<AposCodeBlock>

```javascript
import heroFields from '../../lib/schema-mixins/hero-fields.js';

export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Hero Section',
    icon: 'presentation',
    description: 'Add a hero section with customizable background and content'
  },
  fields: {
    add: heroFields
  }
};
```
<template v-slot:caption>
backend/modules/hero-widget/index.js
</template>
</AposCodeBlock>

3. **Import in the page module**

The same fields can now be imported and used in a page module:

<AposCodeBlock>

```javascript
import heroFields from '../../../lib/schema-mixins/hero-fields.js';

export default {
  options: {
    label: 'Home Page'
  },
  fields: {
    add: {
      layout: {
        type: 'select',
        label: 'Layout',
        def: 'minimal',
        choices: [
          {
            label: 'Minimal',
            value: 'minimal'
          },
          {
            label: 'Foundation',
            value: 'foundation'
          },
          {
            label: 'Showcase',
            value: 'showcase'
          }
        ]
      },
      heroSection: {
        type: 'object',
        label: 'Hero Section',
        fields: {
          add: heroFields
        },
        if: {
          layout: 'foundation'
        }
      },
      // ... other fields
    }
  }
};
```
<template v-slot:caption>
backend/modules/@apostrophecms/home-page/index.js
</template>
</AposCodeBlock>

4. **Use the widget component directly in the page template**

Finally, in your Astro page template, you can import and use the widget component directly:

<AposCodeBlock>

```astro
---
import Hero from '../widgets/HeroWidget.astro';
import AposArea from '@apostrophecms/apostrophe-astro/components/AposArea.astro';
const { page } = Astro.props.aposData;
---

{page.layout === 'foundation' && (
  <Hero widget={page.heroSection} />
)}

<div class="main-content">
  <AposArea area={page.main} />
</div>
```
<template v-slot:caption>
frontend/src/templates/HomePage.astro
</template>
</AposCodeBlock>

### Benefits of This Approach

This schema sharing pattern offers several advantages:

1. **DRY (Don't Repeat Yourself)**: Define field schemas once, use them in multiple places.
2. **Consistency**: Ensure that the same options are available whether using the component in an area or directly in a page.
3. **Maintainability**: Changes to the schema need to be made in only one place.
4. **Flexibility**: Allow content editors to use components either as widgets in areas or as fixed elements in specific page templates.

### When to Use This Pattern

This approach is particularly useful for:

- **Page-specific features**: Elements like heroes or headers that are integral to specific page types but might also be useful as flexible widgets.
- **Complex components**: When a component has many configuration options that would be tedious to duplicate.
- **Standardized elements**: Components that should maintain consistent options across your site.

In the Apollo theme, this pattern is used for several widgets including the hero, card, link, and slideshow widgets - all components that benefit from being available both as widgets in areas and as direct components in templates.

By leveraging schema mixins, you can create a more flexible, maintainable codebase while providing both developers and content editors with powerful tools for building diverse page layouts.

## Next Steps: Working with Pieces
While widgets handle modular content and layouts, pieces in ApostropheCMS serve a different purpose - managing collections of content like blog posts, team members, or products. In the next section, we'll explore how pieces work in an ApostropheCMS + Astro environment, including:

- Creating piece types
- Building piece pages
- Managing relationships
- Implementing piece widgets
- Handling piece data in Astro templates

Pieces complement widgets by providing reusable content that can be displayed across your site in various contexts. Understanding both systems gives you powerful tools for building flexible, content-rich websites.

================================================================================
COLLECTION: tutorials
NAV_PATH: ApostropheCMS & Astro > Creating Pieces
DOC_PATH: tutorials/astro/creating-pieces.md
URL: https://apostrophecms.com/docs/tutorials/astro/creating-pieces
================================================================================
# Working with Pieces in ApostropheCMS + Astro

While widgets excel at providing modular content blocks for your pages, pieces serve a different purpose in ApostropheCMS. They represent collections of structured content that can be reused throughout your site. The Apollo project demonstrates this through two key piece types: articles and authors.

::: tip Watch & Learn! üé•
This tutorial is available in both text and video formats. The videos cover the key highlights, while this page provides additional details and references. Watch the videos for a guided introduction, then read on for deeper insights!

<iframe width="560" height="315" src="https://www.youtube.com/embed/tCG5GtbIlYI?si=Nw5i3RYStlXmOZl-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>


## Understanding Pieces in Apollo

The article and author pieces in Apollo showcase different aspects of piece functionality:

- **Articles** are the primary content pieces (blog posts, news items) that form the bulk of your site's content
- **Authors** demonstrate how pieces can create relationships between different content types

Unlike widgets (which are managed within pages), pieces get their own dedicated management modals. This provides a more focused interface for managing collections of content with features like filtering, searching, and batch operations. In Apollo, the managers for "Articles" and "Authors" are grouped in the "Blog" section of the admin bar. You can learn more about grouping admin bar items in the [ApostropheCMS documentation](/reference/modules/admin-bar.md#groups) and examine the implementation in `backend/modules/@apostrophecms/admin-bar/index.js`.

## Examining the Article Piece Type

Let's look at Apollo's article piece module (`backend/modules/article/index.js`) as an example of a piece type implementation:

<AposCodeBlock>

```javascript
import { getWidgetGroups } from '../../lib/helpers/area-widgets.js';

export default {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Article',
    pluralLabel: 'Articles',
    shortcut: 'Shift+Alt+A'
  },
  fields: {
    add: {
      category: {
        type: 'select',
        label: 'Category',
        help: 'Choose a category for this article',
        choices: [
          {
            label: 'News',
            value: 'news'
          },
          {
            label: 'Opinion',
            value: 'opinion'
          },
          {
            label: 'Feature',
            value: 'feature'
          },
          {
            label: 'Review',
            value: 'review'
          }
        ]
      },
      _heroImage: {
        type: 'relationship',
        label: 'Hero Image',
        withType: '@apostrophecms/image',
        max: 1
      },
      excerpt: {
        type: 'string',
        textarea: true,
        label: 'Article Excerpt',
        help: 'Brief summary for listings and previews'
      },
      mainContent: {
        type: 'area',
        options: getWidgetGroups({
          includeLayouts: true
        })
      },
      _author: {
        type: 'relationship',
        label: 'Author',
        withType: 'author',
        withRelationships: [ '_articles' ]
      },
      publishDate: {
        label: 'Publication Date',
        type: 'date',
        required: true
      },
      _related: {
        type: 'relationship',
        label: 'Related Articles',
        withType: 'article',
        max: 4,
        builders: {
          project: {
            title: 1,
            _url: 1
          }
        },
        withRelationships: [ '_heroImage' ]
      }
    },
    group: {
      basics: {
        label: 'Basic Info',
        fields: ['_author', 'category', 'publishDate', '_related']
      },
      content: {
        label: 'Content',
        fields: ['_heroImage', 'excerpt', 'mainContent']
      }
    }
  }
};
```
<template v-slot:caption>
backend/modules/article/index.js
</template>
</AposCodeBlock>

This piece type includes:

- Basic metadata like categories and publication dates
- A relationship to authors (`_author` field)
- Content areas that can contain widgets (`mainContent`)
- Relationships to other articles (`_related`)
- Organizational grouping of fields through the `group` property

The relationship between articles and authors demonstrates a key strength of pieces in ApostropheCMS. By specifying `withRelationships: [ '_articles' ]` in the `_author` field, we establish a bidirectional relationship where authors know which articles they've written and articles store who authored them. For more information on relationships in ApostropheCMS, refer to the [relationship field documentation](/reference/field-types/relationship.md).

## Displaying Pieces in Astro Templates

The Apollo project includes two templates for displaying articles:

1. An **index page** (`frontend/src/templates/ArticleIndexPage.astro`) that shows a collection of articles with pagination and filtering
2. A **show page** (`frontend/src/templates/ArticleShowPage.astro`) for individual articles with details and related content

Each template comes with multiple layout options in the `frontend/src/layouts/article-layouts` directory (like `HeroGrid.astro`, `HorizontalList.astro`, etc.) that content editors can select, demonstrating how the same data can be presented in different ways. You can review the piece page type implementation in `backend/modules/article-page/index.js`.

### Template Mapping for Piece Pages

Remember that piece pages require special mapping in your `frontend/src/templates/index.js` file. Unlike regular pages, piece types have both an index template (for listing pieces) and a show template (for individual pieces):

<AposCodeBlock>

```javascript
import ArticleIndexPage from './ArticleIndexPage.astro';
import ArticleShowPage from './ArticleShowPage.astro';

export default {
  // Regular pages
  '@apostrophecms/home-page': HomePage,
  'default-page': DefaultPage,

  // Piece pages with their specific templates
  'article-page:index': ArticleIndexPage,
  'article-page:show': ArticleShowPage
};
```
<template v-slot:caption>
frontend/src/templates/index.js
</template>
</AposCodeBlock>

The `:index` and `:show` suffixes tell ApostropheCMS which template to use for each view. This mapping ensures that when users navigate to an article listing page or an individual article, the correct template is rendered.

### The Index Page: Listing Articles with Filtering and Pagination

The `ArticleIndexPage.astro` template demonstrates several important concepts for displaying collections of pieces:

<AposCodeBlock>

```astro
---
import setParameter from '@apostrophecms/apostrophe-astro/lib/aposSetQueryParameter.js';
import AposArea from '@apostrophecms/apostrophe-astro/components/AposArea.astro';

import Pagination from '../components/Pagination.astro';

import HeroGrid from '../layouts/article-layouts/HeroGrid.astro';
import ListAside from '../layouts/article-layouts/ListAside.astro';
import Standard from '../layouts/article-layouts/Standard.astro';

const {
  page,
  user,
  query,
  piecesFilters = [],
  pieces,
  currentPage,
  totalPages
} = Astro.props.aposData;

const pages = [];
for (let i = 1; i <= totalPages; i++) {
  pages.push({
    number: i,
    current: i === currentPage,
    url: setParameter(Astro.url, 'page', i)
  });
}
---
<section class='main-content content-index-page section'>
  <div class='container'>
    <h1 class="is-size-1">{page.title}</h1>

    {/* Global Masthead - Shows for all layouts */}
    {
      page.masthead && (
        <div class='container mb-6'>
          <div class='content has-text-centered'>
            <AposArea area={page.masthead} />
          </div>
        </div>
      )
    }

    {/* Display Filters */}
    {
      Array.isArray(piecesFilters) && piecesFilters.length > 0 && (
        <div class='tags are-medium mb-5'>
          {piecesFilters.map((filter) => (
            <a
              href={filter.url}
              class={`tag ${filter.active ? 'is-primary' : 'is-light'}`}
            >
              {filter.label}
            </a>
          ))}
        </div>
      )
    }

    {/* Before Content Area */}
    {page.beforeContent && (
      <div class='mb-6'>
        <AposArea area={page.beforeContent} />
      </div>
    )}

    {/* Dynamic Layout Selection */}
    {page.indexLayout === 'heroGrid' && (
      <HeroGrid
        pieces={pieces}
        gridColumns={3}
        heroImageClass="is-2by1"
      />
    )}

    {page.indexLayout === 'listAside' && (
    <ListAside
      pieces={pieces}
      sidebarWidth={4}
      showRelated={true}
      showAuthorAvatar={true}
      sidebarArea={page.sidebarContent}
    />
    )}

    {page.indexLayout === 'standard' && (
    <Standard
      pieces={pieces}
      showImage={true}
      imageWidth={4}
      showAuthorAvatar={true}
      excerptLength={200}
    />
    )}

    {/* After Content Area */}
    {page.afterContent && (
      <div class='mt-6'>
        <AposArea area={page.afterContent} />
      </div>
    )}

    {/* Pagination */}
    {totalPages > 1 && (
      <Pagination
      currentPage={currentPage}
      totalPages={totalPages}
      url={Astro.url}
      class="my-8"
      />
    )}
  </div>
</section>
```
<template v-slot:caption>
frontend/src/templates/ArticleIndexPage.astro
</template>
</AposCodeBlock>

This template highlights several important features:

#### 1. Data from ApostropheCMS

The `aposData` prop includes everything needed for a piece index page:

```javascript
const {
  page,           // The current page document
  user,           // Current user info
  query,          // URL query parameters
  piecesFilters,  // Available filters for the pieces
  pieces,         // Array of piece documents for this page
  currentPage,    // Current pagination page number
  totalPages      // Total number of pagination pages
} = Astro.props.aposData;
```

#### 2. Filtering with `piecesFilters`

The `piecesFilters` array provides pre-configured filtering options for your piece collection. This is powered by the [ApostropheCMS filters system](/reference/modules/piece-page-type.html#piecesfilters) which is configured in the piece page module:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/piece-page-type',
  options: {
    label: 'Article Page',
    perPage: 7,
    piecesFilters: [
      {
        name: 'category'
      }
    ]
  },
  // ... more configuration
};
```
<template v-slot:caption>
backend/modules/article-page/index.js
</template>
</AposCodeBlock>

The template then renders each of the values for the `article` module `category` field as clickable filter tags:

<AposCodeBlock>

```astro
{
  Array.isArray(piecesFilters) && piecesFilters.length > 0 && (
    <div class='tags are-medium mb-5'>
      {piecesFilters.map((filter) => (
        <a
          href={filter.url}
          class={`tag ${filter.active ? 'is-primary' : 'is-light'}`}
        >
          {filter.label}
        </a>
      ))}
    </div>
  )
}
```
<template v-slot:caption>
frontend/src/templates/ArticleIndexPage.astro
</template>
</AposCodeBlock>

Clicking on one of these filters will result in the backend populating the `aposData.pieces` with only those that match the filter value. So, you don't need any special markup, just the same markup you use to display all the unfiltered pieces.

#### 3. Pagination

The template handles pagination in two parts:

First, it generates an array of page objects with URLs:

<AposCodeBlock>

```javascript
const pages = [];
for (let i = 1; i <= totalPages; i++) {
  pages.push({
    number: i,
    current: i === currentPage,
    url: setParameter(Astro.url, 'page', i)
  });
}
```
<template v-slot:caption>
frontend/src/templates/ArticleIndexPage.astro
</template>
</AposCodeBlock>

The `setParameter` helper from the `apostrophe-astro` package ensures that pagination URLs maintain other query parameters (like active filters) while changing only the page number.

Then it renders a pagination component if there's more than one page:

<AposCodeBlock>

```astro
{totalPages > 1 && (
  <Pagination
  currentPage={currentPage}
  totalPages={totalPages}
  url={Astro.url}
  class="my-8"
  />
)}
```
<template v-slot:caption>
frontend/src/templates/ArticleIndexPage.astro
</template>
</AposCodeBlock>

#### 4. Dynamic Layout Selection

The template renders different layouts based on the `indexLayout` value from the page document:

<AposCodeBlock>

```astro
{page.indexLayout === 'heroGrid' && (
  <HeroGrid
    pieces={pieces}
    gridColumns={3}
    heroImageClass="is-2by1"
  />
)}

{page.indexLayout === 'listAside' && (
  <ListAside
    pieces={pieces}
    sidebarWidth={4}
    showRelated={true}
    showAuthorAvatar={true}
    sidebarArea={page.sidebarContent}
  />
)}
```
<template v-slot:caption>
frontend/src/templates/ArticleIndexPage.astro
</template>
</AposCodeBlock>

This allows content editors to select their preferred layout from the page settings in the ApostropheCMS admin UI.

### The Show Page: Displaying Individual Articles

The `ArticleShowPage.astro` template is more simple, but demonstrates a similar dynamic layout approach:

<AposCodeBlock>

```astro
---
import FullWidth from '../layouts/article-layouts/ShowFullWidth.astro';
import Magazine from '../layouts/article-layouts/ShowMagazine.astro';
import Minimal from '../layouts/article-layouts/ShowMinimal.astro';

const { piece } = Astro.props.aposData;

const layouts = {
  fullWidth: FullWidth,
  magazine: Magazine,
  minimal: Minimal
};

const SelectedLayout = layouts[page.showLayout] || FullWidth;
---

<div class="main-content article-show-page">
  <SelectedLayout article={piece} />
</div>
```
<template v-slot:caption>
frontend/src/templates/ArticleShowPage.astro
</template>
</AposCodeBlock>

Key points from this template:

1. It imports all possible layout components
2. It accesses the `piece` object from `aposData` which contains the full article document
3. It dynamically selects the appropriate layout component based on the `page.showLayout` value
4. It passes the article data to the selected layout component

This approach gives content editors flexibility in how they present articles while keeping the template code clean and maintainable.

## Using Pieces Outside Dedicated Pages

While piece pages provide a structured way to display collections of content, there are many situations where you'll want to use pieces in other contexts throughout your site. Let's explore three approaches to incorporate pieces anywhere in your site: using built-in API endpoints, creating custom API routes, and leveraging relationships.

<iframe width="560" height="315" src="https://www.youtube.com/embed/_spAfke_Rt8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Approach 1: Built-in API Endpoints

An easy way to fetch pieces is through ApostropheCMS's built-in API endpoints. These endpoints accept query parameters that let you filter and sort pieces without writing any backend code.

Here's an example that fetches and displays article pieces that have a `news` category. In your Astro component you would construct your fetch along with parameters to structure what pieces you get back:

```javascript
---
// frontend/src/components/NewsArticles.astro
const apiUrl = new URL('/api/v1/article', Astro.url.origin);
// Add query parameters to filter for news category
apiUrl.searchParams.set('category', 'news');
// Sort by publish date, most recent first
apiUrl.searchParams.set('sort', '{"publishDate":-1}');
// Limit to 5 articles
apiUrl.searchParams.set('limit', '5');

const response = await fetch(apiUrl);
const { results: newsArticles } = await response.json();
---

<div class="latest-news">
  <h2>Latest News</h2>
  <div class="news-grid">
    {newsArticles.map(article => (
      <article class="news-item">
        <h3>{article.title}</h3>
        <p>{article.excerpt}</p>
        <a href={article._url}>Read More</a>
      </article>
    ))}
  </div>
</div>
```

On the backend (ApostropheCMS), you need to give permission for this `GET` request by setting the [`publicApiProjection` option](/reference/modules/piece-type.html#publicapiprojection) in the `backend/modules/article/index.js` file:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Article',
    pluralLabel: 'Articles',
    shortcut: 'Shift+Alt+A',
    publicApiProjection: {
      title: 1,
      excerpt: 1,
      _url: 1
    }
  },
  // ... remainder of code
```
<template v-slot:caption>
backend/modules/article/index.js
</template>
</AposCodeBlock>

The `publicApiProjection` can be set to allow any of the document fields to be returned. In this case, since we do have a piece type page for displaying the individual article pieces, we are also returning the computed `_url` property.

This approach is perfect for simple filtering and sorting needs - no custom backend code is required. The query parameters correspond directly to MongoDB query operators, giving you powerful filtering capabilities out of the box. You can [read more](/guide/database-queries.html) about this in the main documentation.

### Approach 2: Custom API Routes

Sometimes you need more complex logic to fetch and transform your piece's data. That's where custom API routes come in. Let's look at an example that fetches the latest article from each author and adds a purchase link:

<AposCodeBlock>

```javascript
apiRoutes(self) {
  return {
    get: {
      async latestByAuthor(req) {
        // Fetch all authors
        // Since this is the article module, we need to specify
        // we want documents from the author module
        const authors = await self.apos.modules.author.find(req).toArray();

        if (!authors.length) {
          return [];
        }

        // Fetch the latest article for each author
        const latestArticles = await Promise.all(authors.map(async (author) => {
          // Here we can use just `self.find()` since we want article pieces
          const article = await self.find(req, {
            // There can be more than one author so it is an array
            authorIds: { $in: [ author.aposDocId ] }
          })
            .sort({ publishDate: -1 })
            // We only need the title, no since grabbing extra data
            .project({
              title: 1
            })
            .limit(1)
            .toArray();

          return article.length
            ? {
              author: author.title,
              articleTitle: article[0].title,
              purchaseLink: `https://www.amazon.com/s?k=${encodeURIComponent(article[0].title)}`
            }
            : null;
        }));

        // Filter out authors without articles
        return latestArticles.filter(entry => entry !== null);
      }
    }
  };
}
```
<template v-slot:caption>
backend/modules/article/index.js
</template>
</AposCodeBlock>

Then we can use this custom endpoint in any Astro component:

<AposCodeBlock>

```astro
---
// ApostropheCMS will automatically kebab-case our `latestByAuthor` route
const apiUrl = new URL('/api/v1/article/latest-by-author', Astro.url.origin);
const response = await fetch(apiUrl);
const latestArticles = await response.json();
---

<section class="author-latest">
  <h3>Latest Articles by Our Authors</h3>
  <ul class="article-list">
    {
      latestArticles.length > 0 ? (
        latestArticles.map((entry) => (
          <li class="article-item">
            <strong>{entry.author}</strong>: "{entry.articleTitle}" -
            <a href={entry.purchaseLink} target="_blank" rel="noopener noreferrer">
              Buy on Amazon
            </a>
          </li>
        ))
      ) : (
        <p>No articles found.</p>
      )
    }
  </ul>
</section>
```
<template v-slot:caption>
frontend/src/templates/HomePage.astro
</template>
</AposCodeBlock>

This approach lets you create specialized endpoints that encapsulate complex business logic while keeping your frontend code clean and focused on presentation.

### Approach 3: Using Relationships

The third approach leverages ApostropheCMS's relationship fields to connect pieces to your pages or widgets. This is perfect for curated content selections where editors want direct control over which pieces appear.

For example, let's say you want to feature specific articles on your homepage. First, add a relationship field to your home page type:

<AposCodeBlock>

```javascript
export default {
  fields: {
    add: {
      _featuredArticles: {
        type: 'relationship',
        label: 'Featured Articles',
        withType: 'article',
        max: 3,
        builders: {
          // Only fetch the fields we need
          project: {
            title: 1,
            excerpt: 1,
            _url: 1
          }
        }
      }
    }
  }
};
```
<template v-slot:caption>
backend/modules/@apostrophecms/home-page/index.js
</template>
</AposCodeBlock>

Then use these relationships in your home page template:

<AposCodeBlock>

```astro
---
const { page } = Astro.props.aposData;
const featuredArticles = page._featuredArticles || [];
---

<section class="featured-articles">
  <h2>Featured Articles</h2>
  <div class="article-grid">
    {featuredArticles.map(article => (
      <article class="featured-item">
        <h3>{article.title}</h3>
        <p>{article.excerpt}</p>
        <a href={article._url}>Read More</a>
      </article>
    ))}
  </div>
</section>
```
<template v-slot:caption>
frontend/src/templates/HomePage.astro
</template>
</AposCodeBlock>

The beauty of relationships is that they maintain referential integrity - if an article is archived or deleted, it's automatically removed from the relationships. Plus, editors can easily manage these connections through the ApostropheCMS admin UI.

Each of these approaches has its strengths:
- **Built-in API endpoints** are perfect for simple filtering and sorting
- **Custom API routes** handle complex data transformations and business logic
- **Relationships** give editors direct control over content connections

By combining these approaches, you can create rich, interconnected content experiences that go well beyond traditional page-based navigation.

## The Author Piece Type

The author piece type (`backend/modules/author/index.js`) in Apollo demonstrates how pieces can serve supporting roles without needing their own dedicated pages. Authors include fields for:

- Biographical information 
- Profile images
- Contact details
- A reverse relationship to articles they've written (`_articles` field)

While authors don't have their own piece pages in the Apollo setup, their information appears within article displays (see `frontend/src/layouts/article-layouts/Standard.astro` for an example). This shows how pieces can enhance other content through relationships without necessarily being featured as standalone content.

You can examine how author information is accessed in the article templates by looking at code like this:

```javascript
// Example from an article layout template
const authors = piece._author || [];
```

And then displayed:

```astro
<!-- Display author information -->
{authors.length > 0 && (
  <div class="article-authors">
    {authors.map(author => (
      <div class="author-card">
        {author._image?.[0] && (
          <img src={getAttachmentUrl(author._image[0], { size: 'one-sixth' })} 
               alt={author.title} />
        )}
        <h4>{author.title}</h4>
        <p>{author.bio}</p>
      </div>
    ))}
  </div>
)}
```

================================================================================
COLLECTION: tutorials
NAV_PATH: ApostropheCMS & Astro > Deploying With Astro
DOC_PATH: tutorials/astro/deploying-hybrid-projects.md
URL: https://apostrophecms.com/docs/tutorials/astro/deploying-hybrid-projects
================================================================================
# Deploying ApostropheCMS + Astro Projects

Now that you've built your site with ApostropheCMS and Astro, it's time to deploy it for the world to see. The Apollo project's dual-repository structure (backend + frontend) offers flexibility but also requires special considerations for deployment.

## Understanding Deployment Options

There are two main approaches to deploying your ApostropheCMS + Astro project:

1. **Unified Deployment** (via Apostrophe Hosting or hosting that supports Node.js)
   - Deploy both frontend and backend together
   - Simplest option with minimal configuration
   - Managed infrastructure and automatic updates with Apostrophe Hosting

2. **Split Deployment**
   - Deploy backend and frontend to separate services
   - More flexibility and control
   - Requires more configuration and coordination

## Prerequisites for Production Deployment

Regardless of your deployment method, you'll need:

- A MongoDB database - Atlas or host-specific
- Environment variables properly configured
- Asset storage solution like AWS S3 or a persistent folder that doesn't get erased during each deployment (for uploaded images/files)

If you prefer, we can handle all of those details for you via our [Managed Hosting](https://apostrophecms.com/hosting).

## Configuring Astro for Production

Before deploying your Astro frontend, you'll need to adjust the `astro.config.mjs` file for production. Let's look at key configuration options:

```javascript
import { defineConfig } from 'astro/config';
import node from '@astrojs/node';
import apostrophe from '@apostrophecms/apostrophe-astro';

export default defineConfig({
  output: "server",  // Required for SSR
  server: {
    port: process.env.PORT ? parseInt(process.env.PORT) : 4321,
    // Uncomment for hosting platforms like Heroku that need this
    // host: true
  },
  adapter: node({
    mode: 'standalone'  // For most deployment scenarios
  }),
  integrations: [apostrophe({
    // In production, this should be set via the APOS_HOST env variable
    aposHost: process.env.APOS_HOST || 'http://localhost:3000',
    widgetsMapping: './src/widgets',
    templatesMapping: './src/templates',
    
    // Security headers to pass from backend to frontend
    includeResponseHeaders: [
      'content-security-policy',
      'strict-transport-security',
      'x-frame-options',
      'referrer-policy',
      'cache-control'
    ],
    
    // For split deployment (separate servers), you may need to uncomment:
    // excludeRequestHeaders: ['host']
  })],
  
  // Required to handle virtual URLs in the integration
  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          quietDeps: true
        }
      }
    },
    ssr: {
      noExternal: ['@apostrophecms/apostrophe-astro']
    }
  },
  
  // SCSS configuration if using Sass
  css: {
    preprocessorOptions: {
      scss: {
        api: 'modern-compiler',
      }
    }
  }
});
```

### Key Configuration Areas

1. **Port Configuration**
   - The `server.port` setting defaults to 4321 but reads from the `PORT` environment variable if set
   - Some platforms (Heroku, Railway) require `host: true` to listen on all interfaces

2. **Integration Settings**
   - `aposHost` must point to your production backend URL in production
   - Set via the `APOS_HOST` environment variable rather than hardcoding

3. **Header Configuration**
   - `includeResponseHeaders` determines which response headers from ApostropheCMS are preserved
   - Essential for maintaining security settings between backend and frontend

4. **Split Deployment Settings**
   - When deploying to separate servers, you may need to exclude the `host` header
   - Uncomment `excludeRequestHeaders: ['host']` to prevent hostname conflicts


## Deploying with Apostrophe Hosting

Apostrophe offers a straightforward hosting solution specifically designed for ApostropheCMS projects, including those with Astro frontends.

### Benefits

- Zero configuration for ApostropheCMS + Astro integration
- Database provisioning and management handled automatically
- Built-in asset storage and delivery
- SSL certificate management
- Automatic backups
- Security updates

### Getting Started with Apostrophe Hosting

Contact the Apostrophe team through their [website](https://apostrophecms.com/hosting) to set up your hosting. The team will provide detailed instructions for connecting your repository for automatic deployment.

## Split Deployment (Separate Backend and Frontend)

For more control or to leverage specific platform features, you can deploy the backend and frontend separately.

### Backend (ApostropheCMS) Deployment

Your ApostropheCMS backend requires:

- Node.js environment (v18 or better, at least v20 recommended)
- MongoDB database connection
- Asset storage solution (S3 or equivalent cloud storage)

#### Common Backend Hosting Options

1. **Traditional VPS/Dedicated Servers** (DigitalOcean, Linode, AWS EC2)
   - Complete control over the environment
   - Requires server management knowledge
   - Good for high-performance requirements

2. **Platform as a Service** (Heroku, Render, Railway)
   - Simpler deployment with less configuration
   - Often includes easy database integration
   - Automatic scaling options

#### Example: Deploying to Render

1. Create a new Web Service in Render
2. Connect your GitHub repository
3. Configure build settings:
   - Root Directory: `backend`
   - Build Command: `npm run build`
   - Start Command: `npm run serve`
4. Set environment variables:
   ```
   NODE_ENV=production
   APOS_MONGODB_URI=your_mongodb_connection_string
   APOS_EXTERNAL_FRONT_KEY=your_shared_secret_key
   APOS_S3_BUCKET=your-bucket-name
   APOS_S3_SECRET=your-s3-secret
   APOS_S3_KEY=your-s3-key
   APOS_S3_REGION=your-chosen-region
   ```
There are several guides for other [deployment options](/guide/hosting.html) and configuring [storage services](/cookbook/using-s3-storage.html) in the main ApostropheCMS documentation.

### Frontend (Astro) Deployment

Your Astro frontend can be deployed to any service, including our [managed hosting](https://apostrophecms.com/hosting), that supports SSR (Server-Side Rendering). Depending on the hosting provider you may also need to make changes to your `astro.config.mjs` file. The [Astro.build](https://docs.astro.build/en/guides/deploy/#deployment-guides) site has a number of guides for deployment. The only extra consideration is that we are deploying a monorepo, so you need to take the extra steps to identify the `frontend' folder as the root for your Astro deployment.

#### Common Frontend Hosting Options

1. **ApostropheCMS**
  - Hosts the combined Astro + ApostropheCMS monorepo in one step
  - Zero latency when Astro communicates with ApostropheCMS
  - Configures MongoDB and S3 automatically
  - Provides `APOS_EXTERNAL_FRONTEND_KEY` automatically

2. **Netlify**
   - Excellent Astro integration
   - Easy setup with continuous deployment
   - Great for sites with moderate traffic

3. **Vercel**
   - Strong Node.js support
   - Optimized for SSR applications
   - Robust edge network

4. **Cloudflare Pages**
   - Global CDN with edge computing
   - Strong caching capabilities
   - Good for high-traffic sites

#### Example: Deploying to Netlify

1. Log in to your [Netlify](https://www.netlify.com/) account
2. Create a new site by connecting your GitHub repository
3. Configure build settings:
   - Base directory: `frontend`
   - Build command: `npm run build`
   - Publish directory: `frontend/dist`
4. Set environment variables:
   ```
   APOS_EXTERNAL_FRONT_KEY=your_shared_secret_key
   APOS_HOST=https://your-backend-url.com
   ```

You can also use a `netlify.toml` file at the root of your project for configuration:

```toml
[build]
  base = "frontend"
  command = "npm run build"
  publish = "dist"

[build.environment]
  NODE_VERSION = "18"

[[redirects]]
  from = "/*"
  to = "/.netlify/functions/entry"
  status = 200
```

## Environment Configuration for Production

### Critical Environment Variables

#### Backend Environment Variables

```bash
# Required
NODE_ENV=production
APOS_MONGODB_URI=your_mongodb_connection_string
APOS_EXTERNAL_FRONT_KEY=your_shared_secret_key

# For cloud asset storage (e.g., AWS S3)
APOS_S3_BUCKET=your-bucket-name
APOS_S3_SECRET=your-s3-secret
APOS_S3_KEY=your-s3-key
APOS_S3_REGION=your-chosen-region

# For identifying releases (if not using Git-based deployment)
APOS_RELEASE_ID=unique-random-string
```

#### Frontend Environment Variables

```bash
# Required
APOS_EXTERNAL_FRONT_KEY=your_shared_secret_key  # Must match backend
APOS_HOST=https://your-backend-url.com

# Optional for specific hosts
PORT=8080  # If your host requires a specific port
HOST=0.0.0.0  # For hosts that need to listen on all interfaces
```

## Best Practices for Production

1. **Always use HTTPS** for both frontend and backend
2. **Test your build locally** before deploying:
   ```bash
   cd frontend
   npm run build
   npm run preview
   ```
3. **Keep your `APOS_EXTERNAL_FRONT_KEY` secret** - it's your security link between frontend and backend

## Troubleshooting Common Issues

### Connection Problems
If your frontend can't connect to the backend:
1. Verify the `APOS_HOST` environment variable is set correctly
2. Ensure `APOS_EXTERNAL_FRONT_KEY` matches between frontend and backend
3. Check network access between your frontend and backend servers

### Header Issues
If security headers aren't propagating properly, check your `includeResponseHeaders` configuration in the Astro config.


## Conclusion

Deploying an ApostropheCMS + Astro project requires careful consideration of how the two parts interact. Whether you choose unified deployment through Apostrophe Hosting or split your frontend and backend across specialized services, the key is ensuring they can communicate securely and efficiently.

For further assistance, consider:
- Joining the [ApostropheCMS Discord community](http://chat.apostrophecms.org)
- Consulting the [Astro deployment documentation](https://docs.astro.build/en/guides/deploy/)
- Reaching out to the Apostrophe team for hosting solutions

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes
DOC_PATH: tutorials/recipes.md
URL: https://apostrophecms.com/docs/tutorials/recipes
================================================================================
# Recipes

Practical, standalone tutorials for solving specific challenges in ApostropheCMS. These recipes range from simple tips to advanced patterns and can be filtered by topic to match your needs.

<AposTutorialFilter />

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Customizing Rich Text
DOC_PATH: tutorials/introduction-to-rich-text-extensions.md
URL: https://apostrophecms.com/docs/tutorials/introduction-to-rich-text-extensions
================================================================================
# Creating custom extensions for Rich Text widgets

The ApostropheCMS `rich-text-widget` is powered by [Tiptap](https://tiptap.dev), a headless wrapper for the [ProseMirror](https://prosemirror.net/) toolkit for building rich-text WYSIWYG editors. Both of these frameworks offer a wide array of ready-made extensions to enhance their capabilities and also offer a rich API to further customize their behavior. In this series of tutorials, we'll explore both how to integrate existing Tiptap extensions, in addition to developing custom extensions to enhance functionality in ApostropheCMS projects.

You can choose to build out each of these extensions from scratch or install the [`rich-text-example-extensions`](https://github.com/apostrophecms/rich-text-example-extensions) repository in your project. The code from this repository can also be cloned locally or examined on the GitHub site. To install use `npm install @apostrophecms/rich-text-example-extensions` in the root of your project. Next, modify your `app.js` to include the bundle and any modules you wish to try.

<AposCodeBlock>

```javascript
require('apostrophe')({
  shortName: 'my-project',
  // Activate the bundle
  bundles: [ '@apostrophecms/rich-text-example-extensions' ],
  modules: {
    // The typography module
    '@apostrophecms/typography': {},
    // The smilies module
    '@apostrophecms/smilies': {},
    // The character count module
    '@apostrophecms/characterCount': {}
  }
});
```

<template v-slot:caption>
  app.js
</template>
</AposCodeBlock>

The [first tutorial](/tutorials/using-tiptap-extensions.html) in this series will demonstrate how to add a pre-existing extension for either Tiptap or ProseMirror to your ApostropheCMS project.  While Apostrophe includes more than 30 Tiptap extensions, there are still more that you can add to enhance your content creator's experience. For example, the official Tiptap [`mention` extension](https://tiptap.dev/api/nodes/mention) that has its own UI element and wouldn't rely and adding a button to the toolbar. This tutorial will also touch on how you can extend the `getBrowserData()` method to add configuration options to your custom extensions and modules.

The [second tutorial](/tutorials/creating-a-text-replacement-extension.html) will show you how to create your own extension to allow content creators to add emojis by typing a colon and the emoji name, for example, `:smiley ` will auto-convert to 'üòÉ'. While this example may be useful to you as-is, it provides a good template for creating a text replacement extension customized for your purposes, whether you want to automate content formatting, insert specialized symbols, implement auto-completion, or develop unique content transformations. This tutorial will also introduce key Tiptap components, including `Extension`, a constructor function for creating new extensions; `AddInputRules`, a utility for incorporating input rules into extensions; and `textInputRule`, a specific type of input rule for defining how text input is handled and transformed. These concepts are essential for crafting a variety of text-related behaviors.

The [third tutorial](/tutorials/rich-text-extension-deep-dive.md) delves deeper into customizing the ApostropheCMS rich-text-widget by teaching you how to add buttons to the toolbar and insert menu for triggering extension functionality. In this tutorial, we'll build an extension that not only offers valuable statistics about the number of characters and words in the editor but also implements a character limit feature to illustrate how to use the Tiptap `transaction` object and ProseMirror API. Additionally, this tutorial will explore more advanced Tiptap components like `addCommands()` and `addProseMirrorPlugins`, plus how to handle text being pasted into the editor. Overall, this extension will provide a good stepping-stone for the construction of more complex rich-text-widget extensions.

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Customizing Rich Text > Installing Extensions
DOC_PATH: tutorials/using-tiptap-extensions.md
URL: https://apostrophecms.com/docs/tutorials/using-tiptap-extensions
================================================================================
# The `@apostrophecms/typography` extension
![Examples of character conversion in the typography extension](../images/typography.png)

The first module, `@apostrophecms/typography` adds a whole series of autocomplete actions to your editor. For example, typing `(tm)` will autoconvert to `‚Ñ¢`.  It serves as a template for how we can install a premade Tiptap extension into our project. For the whole list of autocomplete actions check out the [documentation](https://tiptap.dev/api/extensions/typography) for the extension on the Tiptap site. Note that some auto-convert rules (like fractions) won't work if you have the insert menu turned on.

The overall structure of this module represents the minimum needed to incorporate a Tiptap extension, an `index.js` file, and a `ui/apos/tiptap-extension/<extension-name>.js` file. We have also added extra code to allow the developer to set options at the project or per-area level.

### Installing the Tiptap extension package
The first step to installing a Tiptap or ProseMirror extension is to install the package in our project. Luckily for us, Tiptap offers all of its open-source extensions in npm, so we can use `npm install @tiptap/extension-typography`. Looking at the `package.json` file of the bundle, we can see this package listed in the dependencies. You might need to use an alternative method of installation for packages from other developers.

### The `index.js` file
Let's look at the `index.js` file:

<AposCodeBlock>

```javascript
module.exports = {
  improve: '@apostrophecms/rich-text-widget',
  options: {
    typoConfig: {}
  },
  extendMethods(self) {
    return {
      // We need to extend this method so that our configuration data is available
      getBrowserData(_super, req) {
        const initialData = _super(req);
        const finalData = {
          ...initialData,
          aposTypoConfig: self.options.typoConfig
        }
        return finalData;
      }
    }
  }
};
```

<template v-slot:caption>
  @apostrophcms/typography/index.js
</template>

</AposCodeBlock>

Starting at the top, we are stating that this module is going to improve the `@apostrophecms/rich-text-widget`. Remember that when we [`improve`](/reference/module-api/module-overview.html#improve) a module, any instance of that module will have that new code. The `improve` configuration method can *only* be used in modules we are installing from a package. If we were doing this with a custom module at project level, we would need to [`extend`](/reference/module-api/module-overview.html#improve) the `@apostrophecms/rich-text-widget`, giving it a new name and using that custom widget in any areas where we want the modified behavior. In this case, we are improving our widget project-wide so that any area that already has a `rich-text-widget` will have this enhanced functionality. This one line is actually all that we would need in the `index.js` file to add the Tiptap extension, but we are also allowing the user to pass additional configuration to the extension using the `typoConfig` option, as outlined in the repository [README](https://github.com/apostrophecms/rich-text-example-extensions) and [Tiptap documentation](https://tiptap.dev/api/extensions/typography).  We are setting it to an empty object by default.

In order to be able to access the options that the user sets from the front end, we need to extend the Apostrophe `getBrowserData()` method. This is extended by most of the Apostrophe core modules. To accomplish this we are using the [`extendMethods(self)`](/reference/module-api/module-overview.md#extendmethods-self) configuration method. Any methods extended this way take the arguments of the original (in this case just `req`), plus the `_super` argument. This gives the extended method access to the output of the original function.

```javascript
const initialData = _super(req);
```
This line uses `_super` and the `req` request object to get the pre-existing values returned by the `getBrowserData()` method.

```javascript
const finalData = {
  ...initialData,
  aposTypoConfig: self.options.typoConfig
}
return finalData;
```
Next, we construct and return an object consisting of the original data with our new option added as the value for the `aposTypoConfig` key. When using this in your own module you should be careful to add a namespace to the beginning of your key so that you don't overwrite any existing data that is being passed.

### The `ui/apos/tiptap-extension/typography.js` file

<AposCodeBlock>

```javascript
// imports the tiptap extension from node_modules
import Typography from '@tiptap/extension-typography';
export default (options) => {
  // gets options added in each area
  const perAreaConfig = options.typoConfig || {};
  // gets options added at project level to the widget `modules/@apostrophecms/rich-text-widget/index.js`
  const globalConfig = self.apos.modules['@apostrophecms/rich-text-widget'].aposTypoConfig || {};
  const configuration = Object.assign({}, globalConfig, perAreaConfig);
  // instantiates the extension with our options
  return Typography.configure(configuration);
};
```

<template v-slot:caption>
  typography/ui/apos/tiptap-extensions/typography.js
</template>

</AposCodeBlock>

Once again, this file is more complex than it would be if we weren't passing options to the extension. We would only need to import the extension, as we are doing here in the first line, and create the default export that returns the extension with an empty configuration object. In this case, we are getting the per-area options from the `options` object and the project-wide options from the `aposTypoConfig` object that we added by extending the `getBrowserData()` method.

That's all it takes to add a Tiptap extension!

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Customizing Rich Text > Creating an Extension
DOC_PATH: tutorials/creating-a-text-replacement-extension.md
URL: https://apostrophecms.com/docs/tutorials/creating-a-text-replacement-extension
================================================================================
# The `@apostrophecms/smilies` extension
![Screenshot of emojis added in the ApostropheCMS rich-test-widget](../images/smilies.png)

The `@apostrophecms/smilies` extension adds a host of text shortcuts for smilie and other emojis, plus my favorite non-emoji, `:ashrug ` (`¬Ø\_(„ÉÑ)_/¬Ø`). You can see the full list in the `modules/@apostrophecms/smilies/lib/replacementEmojis.js` file. This extension also takes a `tone` option passed in the `smiliesConfig` object in either the per-area or global rich-text-widget configuration. This option takes a number from 1-5 to provide a skin tone for modifiable emojis. Note that which emojis are modifiable varies based on operating system. See the [repository README](https://github.com/apostrophecms/rich-text-example-extensions/blob/main/README.md) for more detailed information.

The overall structure of the module is almost the same as the typography module that we covered in the [first tutorial](/tutorials/using-tiptap-extensions.html) so we will only briefly review the repetative files in this extension.

<AposCodeBlock>

```javascript
module.exports = {
  improve: '@apostrophecms/rich-text-widget',
  options: {
    smiliesConfig: {}
  },
  extendMethods(self) {
    return {
      // We need to extend this method so that our configuration data is available
      getBrowserData(_super, req) {
        const initialData = _super(req);
        const finalData = {
          ...initialData,
          aposSmiliesConfig: self.options.smiliesConfig
        }
        return finalData;
      }
    }
  }
};
```
  <template v-slot:caption>
    @apostrophcms/smilies/index.js
  </template>

</AposCodeBlock>

The `index.js` file improves the rich-text-widget and extends the `getBrowserData()` method. This allows us to pass global and per-area configuration to the widget through the `smiliesConfig` object.

<AposCodeBlock>

```javascript
import { Smilie } from '../../../lib/smilies.js';
export default (options) => {
  // gets options added in each area
  const perAreaConfig = options.smiliesConfig || {};
  // gets options added at project level to the widget `modules/@apostrophecms/rich-text-widget/index.js`
  const globalConfig = self.apos.modules['@apostrophecms/rich-text-widget'].aposSmiliesConfig || {};
  const configuration = Object.assign({}, globalConfig, perAreaConfig);
  // instantiates the extension with our options
  return Smilie.configure(configuration);
};
```
  <template v-slot:caption>
    @apostrophcms/smilies/ui/apos/tiptap-extensions/smilie.js
  </template>

</AposCodeBlock>

The first extension also had a `ui/apos/tiptap-extensions` folder containing the core code to instantiate the Tiptap extension. The `smilie.js` file collects the per-area and project-wide configuration options and instantiates the extension.

The biggest change here from the typography extension code is the presence of a `lib` folder with two files. Let's look more closely at these files.

### The `lib` folder
The `smilies/lib/extensions-smilies.js` file provides the code that extends the Tiptap functionality like the `@tiptap/extension-typography` files did for our first module.

<AposCodeBlock>

```javascript
// Extension adapted from the tiptap.dev site examples

// Import the functions we need from tiptap core
import { textInputRule, Extension } from '@tiptap/core';

// Import the list of emojis and regex for each
import replacementEmojis from './replacementEmojis';

const Smilie = Extension.create({
  name: 'smilie',
  addInputRules() {
    const inputRules = [];
    const tone = this.options.tone || 2;
    const convertedEmojis = changeTone(replacementEmojis, tone);
    for (let index = 0; index < convertedEmojis.length; index++) {
      inputRules[index] = textInputRule(convertedEmojis[index]);
    }
    return inputRules;
  },
});

function changeTone(replacementEmojis, tone) {
  return replacementEmojis.map(item => ({
    find: item.find,
    replace: changeSkinTone(item.replace, tone),
  }));
}

function changeSkinTone(emoji, tone) {
  const skinTones = [
    '\u{1F3FB}', // Light skin tone
    '\u{1F3FC}', // Medium-light skin tone
    '\u{1F3FD}', // Medium skin tone
    '\u{1F3FE}', // Medium-dark skin tone
    '\u{1F3FF}', // Dark skin tone
  ];

  const modifier = skinTones[tone - 1];

  // Split the emoji into its individual components
  const components = emoji.split(/(\p{Emoji}|\u{200D})/gu);

  // Modify the components that can have a skin tone modifier
  const modifiedComponents = components.map((component) => {
    if (/\p{Emoji_Modifier_Base}/u.test(component)) {
      // Replace existing modifier or add new one
      const replaced = component.replace(/[\u{1F3FB}-\u{1F3FF}]/gu, '');
      return replaced + modifier;
    }
    return component;
  });

  // Reassemble the modified components
  return modifiedComponents.join('');
}

export { Smilie, Smilie as default };
```

<template v-slot:caption>
  smilies/lib/extension-smilies.js
</template>

</AposCodeBlock>

Let's walk through the most relevant parts of this code.

```javascript
import { textInputRule, Extension } from '@tiptap/core';
```

We start by importing two key methods from the Tiptap core package. The `Extension` method is a foundational component that follows a factory pattern, providing an interface for creating objects without specifying the exact class of objects. It exposes a number of lifecycle methods and hooks that are then available for extending editor functionality.

::: details Some commonly used Tiptap methods and hooks
You can read more about these methods and hooks in the [Tiptap API documentation](https://tiptap.dev/api/introduction) and [ProseMirror reference documentation](https://prosemirror.net/docs/ref/).
1.  **`addInputRules()`**: Used to define input rules that automatically replace or format text as the user types. For example, you could create an input rule to automatically replace `:)` with an emoji smiley face. These rules are useful for adding simple, automated text transformations based on user input.

2.  **`onTransaction()`**: This hook gets called every time a new ProseMirror transaction occurs. It allows you to respond to changes in the editor's state. This will be used in the third extension.

3. **`addCommands()`**: This method allows you to define custom commands that you can later call via the editor's API. Commands are functions that perform actions like changing text, formatting, or even adding/removing nodes. This method is used in the third extension.

4. **`addExtensions()`**: Enables the addition of other extensions as dependencies. This means your extension can rely on features provided by other extensions.

5. **`addKeyboardShortcuts()`**: Enables the addition of keyboard shortcuts to execute specific commands or functionalities. You can define what should happen when a particular key or set of keys is pressed.

6. **`addNodeView()`**: Allows for the customization of how nodes (like paragraphs, headings, etc.) are rendered. This is especially useful if you want to add interactive components within the editor.

7. **`addPasteRules()`**: Defines how the editor should handle pasted content. This is particularly useful if you want to clean up or transform the content that a user pastes into the editor.

8. **`addAttributes()`**: Adds custom attributes to existing nodes or marks. This can be useful for adding data attributes, classes, or inline styles.

9.  **`onCreate()`** and **`onDestroy()`**: Lifecycle hooks that get called when the extension is created or destroyed, respectively. They can be useful for setting up and tearing down anything associated with your extension.

In the Smilies extension, the `addInputRules()` method is used to dynamically create and add a series of `textInputRule` instances to an array.

<AposCodeBlock>

```javascript
const replacementEmojis = [
  { find: /:100 $/, replace: 'üíØ'},
  { find: /:1234 $/, replace: 'üî¢'},
  { find: /:grinning $/, replace: 'üòÄ'},
  { find: /:smiley $/, replace: 'üòÉ'},
  ...
  { find: /:wales $/, replace: 'üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø'},
  { find: /:ashrug $/, replace: '¬Ø\\_(„ÉÑ)_/¬Ø'}
];

export default replacementEmojis;
```
  <template v-slot:caption>
    smilies/lib/replacementEmojis.js
  </template>

</AposCodeBlock>

The `replacementEmojis.js` file in the `lib` folder contains each of those rules as an array of objects. Each object has two properties. The `find` property takes a regular expression pattern matching the characters that should be replaced within the editor as the user types. The `replace` property takes a string that contains the character(s) that should replace the matched string. Note that any special characters, like in the `replace` string need to be escaped.

```javascript
const Smilie = Extension.create({
  name: 'smilie',
  addInputRules() {
    const inputRules = [];
    const tone = this.options.tone || 2;
    const convertedEmojis = changeTone(replacementEmojis, tone);
    for (let index = 0; index < convertedEmojis.length; index++) {
      inputRules[index] = textInputRule(convertedEmojis[index]);
    }
    return inputRules;
  },
});
```
Going back to the `smilies/lib/extension-smilies.js` file, the `Smilie` variable is where all the main Tiptap magic occurs. First, we are using the `Extension.create()` method to instantiate our new extension. This isn't specific to just this extension - your own custom extensions would need to use this. We are passing an object to this method.

First up in this object, there is a `name` property. Adding a unique name allows you to refer to the extension in different editor instances, excluding it, or changing the configuration, for example.

Next, we are using the `addInputRules()` method of the `Extension()`. Again, this helper method is used to define input rules that automatically replace or format text as the user types. It needs to return an array of rules, as we defined in the `replacementEmojis.js` file. For each extension, Tiptap will call this method to compile an array of all the rules.

The remainder of this code uses the `tone` option passed when the extension is instantiated by the `smilies/ui/apos/tiptap-extensions/smilie.js`. A great improvement to this extension would be the addition of an additional UI element to change the emoji skin tone as it is added.

In conclusion, in this tutorial we created a basic text replacement extension that can be used as a template for your custom extensions. This could be as simple as changing out the `replacementEmojis.js` file with your own text strings, or using this extension as a foundation for more complex functionality. The flexibility of this setup allows for a wide range of creative applications, from adding custom emoji sets to implementing unique text transformation features. By leveraging and modifying the concepts presented here, you can create powerful and unique text editing experiences that cater to a diverse array of use cases.

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Customizing Rich Text > Extending the Toolbar
DOC_PATH: tutorials/rich-text-extension-deep-dive.md
URL: https://apostrophecms.com/docs/tutorials/rich-text-extension-deep-dive
================================================================================
# The `@apostrophecms/characterCount` extension
![Screenshot of the insert menu character count modal](../images/character-count.png)

The third Tiptap extension added by our bundle of modules is the `characterCount` extension. While you might find this extension useful in your project, the main point is to show how to add a new button to the toolbar or item to the insert menu. It will also introduce us to some additional Tiptap methods that we touched on briefly in covering the `smilies` extension.

This extension provides us with character and word counts for the content of the rich text editor. Highlighting some text and then activating this tool from the toolbar will give us total characters, total words, highlighted characters, and highlighted words. Activating this extension from the insert menu by typing `/` and then selecting it from the menu will only provide the total characters and words. This extension takes a per-area or project-wide option of `limit` in the `charCountConfig` object. This option can be used to restrict the number of characters that can be added to an editor. See the [repository README](https://github.com/apostrophecms/rich-text-example-extensions/blob/main/README.md) for more detailed information.

### The `index.js` file

<AposCodeBlock>

```javascript
module.exports = {
  improve: '@apostrophecms/rich-text-widget',
  options: {
    charCountConfig: {}
  },
  extendMethods(self) {
    return {
      getBrowserData(_super, req) {
        const initialData = _super(req);
        // This adds the character count to the toolbar
        const finalTools = {
          ...initialData.tools,
          characterCount: {
            component: 'TiptapCharacterCount',
            label: 'CC'
          }
        };

        // This makes the character count available to be added to the insert menu
        const finalInsert = {
          ...initialData.insertMenu,
          characterCount: {
            label: 'CC',
            icon: 'eye-icon',
            description: 'Character count',
            component: 'TiptapCharacterCountBox'
        }
      };

      // Also adds in the configuration options
        const finalData = {
          ...initialData,
          tools: finalTools,
          insertMenu: finalInsert,
          aposCharCountConfig: self.options.charCountConfig
        }
        return finalData;
      }
    }
  }
};
```
  <template v-slot:caption>
    characterCount/index.js
  </template>

</AposCodeBlock>

The main file of this extension is slightly more complex than those of the other two extensions. This is because we are enabling the addition of buttons to both the toolbar and the insert menu. Within the `getBrowserData(_super, req)` of the `extendedMethods(self)` configuration method, we once again get the existing configuration of the rich-text-widget using `const initialData = _super(req);`.

```javascript
const finalTools = {
  ...initialData.tools,
  characterCount: {
    component: 'TiptapCharacterCount',
    label: 'CC'
  }
};
```
Next, we are enhancing the `tools` object, which holds settings for all the tools that can be added to the editor's toolbar. First, we use the spread operator to retain the existing tools in the object. Then, we introduce a new property, `characterCount`. This is the name you add to the rich-text-widget `toolbar` array to enable this tool, as detailed in the [ApostropheCMS documentation](/guide/core-widgets.md#rich-text-widget). The `characterCount` property has an object with two properties.  The `component` property specifies the name of the Vue component (minus its file extension) that generates the user interface modal. This modal appears when the toolbar button is clicked. You'll find the component file in the `characterCount/ui/apos/components` directory. The `label` property determines the text displayed to the user in the button on the toolbar.

```javascript
const finalInsert = {
    ...initialData.insertMenu,
    characterCount: {
      label: 'CC',
      icon: 'eye-icon',
      description: 'Character count',
      component: 'TiptapCharacterCountBox'
  }
};
```
The next block of code adds to the `insertMenu` object. This object contains properties for all the items that can be added to the insert menu. Again, we spread the original object and then add our new property. This time we are passing a `label` and `icon` in the `characterCount` object to be displayed in the menu item. Of note, the [icon has already been registered](/reference/module-api/module-overview.md#icons), so we don't have to do it in this module. Once again, the `component` property passes the name of the Vue component file located in the `characterCount/ui/apos/components/` folder.

```javascript
const finalData = {
  ...initialData,
  tools: finalTools,
  insertMenu: finalInsert,
  aposCharCountConfig: self.options.charCountConfig
}
return finalData;
```
Finally, we construct and return a new object composed of the `intitialData` from the `getBrowserData()` method along with each of our modified properties and our new options object.

### The Vue toolbar component

In order to display our character count modal from either the toolbar or the insert menu we need to create two Vue components. These components share some logic that was moved into a mixin file, but this isn't something that is required.

Looking at the toolbar component first:

<AposCodeBlock>

```javascript
<template>
  <div class="apos-cc-toolbar">
    <AposButton type="rich-text" @click="takeAction" :class="{ 'apos-is-active': buttonActive }" :label="tool.label" :modifiers="['no-border', 'no-motion']" />
    <div v-if="active" v-click-outside-element="close" class="apos-popover apos-cc-toolbar__dialog" x-placement="bottom"
      :class="{
        'apos-is-triggered': active,
        'apos-has-selection': hasSelection
      }">
      <div class="character-count" v-if="editor">
        <h3>Document stats</h3>
        Total characters: {{ totalCharactersCount }}{{ editorLimitText }}
        <br>
        Total words: {{ totalWordsCount }}
        <br>
        <div v-if="hasSelection">
          Highlighted characters: {{ highlightedCharacters }}
          <br>
          Highlighted words: {{ highlightedWords }}
        </div>
      </div>
      <footer class="apos-cc-toolbar__footer">
        <AposButton type="primary" label="apostrophe:close" @click="close" :modifiers="formModifiers" />
      </footer>
    </div>
  </div>
</template>

<script>
import characterCountMixin from '../mixins/characterCountMixin';

export default {
  name: 'RichTextCCToolbar',
  mixins: [characterCountMixin],
  props: {
    tool: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      active: false,
      highlightedCharacters: 0,
      highlightedWords: 0
    };
  },
  computed: {
    buttonActive() {
      return this.active;
    }
  },
  mounted() {
    this.calculateHighlightedWords();
    this.calculateHighlightedCharacters();
  },
  watch: {
    active(newVal) {
      if (newVal) {
        this.calculateHighlightedWords();
        this.calculateHighlightedCharacters();
      }
    },
  },
  methods: {
    close() {
      if (this.active) {
        this.active = false;
        this.editor.chain().focus();
      }
    },
    takeAction() {
      this.active = !this.active;
      if (this.active) {
        this.populateFields();
      };
    },
    calculateHighlightedCharacters() {
      this.highlightedCharacters = this.hasSelection ? this.editor.commands.getHighlightedStats('characters') : 0;
    },
    calculateHighlightedWords() {
      this.highlightedWords = this.hasSelection ? this.editor.commands.getHighlightedStats('words') : 0;
    },
  }
};
</script>
```

  <template v-slot:caption>
    characterCount/ui/apos/components/RichTextCCToolbar.vue
  </template>

</AposCodeBlock>

To conserve space we have left the component style block out of the code above. You can look at the [component code in the GitHub repository](https://github.com/apostrophecms/rich-text-example-extensions/blob/main/modules/%40apostrophecms/characterCount/ui/apos/components/RichTextCCToolbar.vue) if you want to review it. The majority of that code will style the new modal to look like the existing Apostrophe UI components. If you haven't made a lot of custom changes to the admin UI, you should use this "boilerplate" styling with changes to match the classes in your markup.

#### The `template`

```javascript
<div v-if="active" v-click-outside-element="close" class="apos-popover apos-cc-toolbar__dialog" x-placement="bottom"
  :class="{
    'apos-is-triggered': active,
    'apos-has-selection': hasSelection
}">
  <div class="character-count" v-if="editor">
    <h3>Document stats</h3>
    Total characters: {{ totalCharactersCount }}{{ editorLimitText }}
    <br>
    Total words: {{ totalWordsCount }}
    <br>
    <div v-if="hasSelection">
      Highlighted characters: {{ highlightedCharacters }}
      <br>
      Highlighted words: {{ highlightedWords }}
    </div>
  </div>
  <footer class="apos-cc-toolbar__footer">
    <AposButton type="primary" label="apostrophe:close" @click="close" :modifiers="formModifiers" />
  </footer>
</div>
```


Focusing on the `template` markup, the majority is under the control of a div wrapper with a `v-if` directive that controls whether or not the modal HTML is displayed based on the value of `active`. There are two important attributes here. The `v-click-outside-element="close"` is important for triggering the `close()` method of the modal if the user clicks outside of the modal. This is in keeping with the other toolbar modals, but you could prefer to have the user click on the footer cancel button instead. The second attribute is `x-placement="bottom"`. This dictates how the `tippy.js` library handles the arrow placement for the modal.

Within this div, we are creating markup to present the user with the number of characters using the methods in this code and our mixin code. We will cover these methods and the Tiptap `editor.commands` when we dig into the `script` section of this template.

Finally, at the end of this modal markup we use an apostrophe component within a footer. The `AposButton` is taking an `@click="close"` to provide a close button for the modal. Note that for the label we are using the `apostrophe` namespace to translate the `close` string. This will take advantage of the built-in translation strings, but you may wish to provide a namespace and translation of your own.

```javascript
<AposButton type="rich-text" @click="takeAction" :class="{ 'apos-is-active': buttonActive }" :label="tool.label" :modifiers="['no-border', 'no-motion']" />
```

At the very top of the template, there is another `AposButton` component. This is the button that will be displayed to the user on the rich-text editor toolbar. The `@click` directive binds the `takeAction()` method to the button. As we will explore, this method toggles the `active` prop to then cause the modal markup to be added through the `v-if` directive that we covered. In this example, we are only passing in a label for the button. We could also choose to pass an icon. If you want to add icons in your own extensions, please examine the [code for the `link` toolbar item](https://github.com/apostrophecms/apostrophe/blob/main/modules/%40apostrophecms/rich-text-widget/ui/apos/components/AposTiptapLink.vue).

#### The `script`

```javascript
<script>
import characterCountMixin from '../mixins/characterCountMixin';

export default {
  name: 'RichTextCCToolbar',
  mixins: [characterCountMixin],
  props: {
    tool: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      active: false,
      highlightedCharacters: 0,
      highlightedWords: 0
    };
  },
  computed: {
    buttonActive() {
      return this.active;
    }
  },
  mounted() {
    this.calculateHighlightedWords();
    this.calculateHighlightedCharacters();
  },
  watch: {
    active(newVal) {
      if (newVal) {
        this.calculateHighlightedWords();
        this.calculateHighlightedCharacters();
      }
    },
  },
  methods: {
    close() {
      if (this.active) {
        this.active = false;
        this.editor.chain().focus();
      }
    },
    takeAction() {
      this.active = !this.active;
      if (this.active) {
        this.populateFields();
      };
    },
    calculateHighlightedCharacters() {
      this.highlightedCharacters = this.hasSelection ? this.editor.commands.getHighlightedStats('characters') : 0;
    },
    calculateHighlightedWords() {
      this.highlightedWords = this.hasSelection ? this.editor.commands.getHighlightedStats('words') : 0;
    },
  }
};
</script>
```

Moving on to the `script` section of the template. We will only cover this code briefly as the majority is a fairly standard Vue 2 component without much that is specific to Apostrophe or Tiptap, until we get to the methods object. Some code is shared between our two components and has been factored out to a mixin located at `characterCount/ui/apos/mixins/characterCountMixin.js`. This file is imported at the start of our `script` block and we will touch on this file only briefly because the code it contains will largely be explained by covering our two components.

```javascript
name: 'RichTextCCToolbar',
mixins: [characterCountMixin],
props: {
  tool: {
    type: Object,
    required: true
  }
},
```

At the top of our export, we are naming our component and passing the imported mixin. For a toolbar button, we need to pass the `tool` prop to get the label for the button that we set in our `characterCount` object that was passed to the `tools` array. This is the only Apostrophe-specific part of our script.

```javascript
data() {
  return {
    active: false,
    highlightedCharacters: 0,
    highlightedWords: 0
  };
},
```

In our `data()` method we are initializing the `active` computed property that determines if the modal should be displayed. We are also initializing our `highlightedCharacters` and `highlightedWords` properties. These two are specific to the toolbar modal. The other three computed properties used in this component, `totalCharactersCount`, `totalWordsCount`, and `editorLimitText` are used in both components, so they are initialized in the mixin.

```javascript
computed: {
  buttonActive() {
    return this.active;
  }
},
```
In our computed object, we are creating a `buttonActive()` computed property. This will cause the class on toolbar button to reflect whether or not the tool is active and provide modified styling.

```javascript
mounted() {
  this.calculateHighlightedWords();
  this.calculateHighlightedCharacters();
},
```
In the `mounted()` method we invoke our methods to calculate the numbers of highlighted words and characters, as defined in the methods section. In the mixin, we are calling the methods to calculate the overall numbers of words and characters present in the text editor.

```javascript
watch: {
  active(newVal) {
    if (newVal) {
      this.calculateHighlightedWords();
      this.calculateHighlightedCharacters();
    }
  },
},
```
The `watch` object contains a function that monitors changes to the `active` property. When `active` changes to `true`, the number of characters is recalculated using the methods in this script and the mixin.

```javascript
methods: {
  close() {
    if (this.active) {
      this.active = false;
      this.editor.chain().focus();
    }
  },
  takeAction() {
    this.active = !this.active;
    if (this.active) {
      this.populateFields();
    };
  },
  calculateHighlightedCharacters() {
    this.highlightedCharacters = this.hasSelection ? this.editor.commands.getHighlightedStats('characters') : 0;
  },
  calculateHighlightedWords() {
    this.highlightedWords = this.hasSelection ? this.editor.commands.getHighlightedStats('words') : 0;
  },
}
```
There are four method functions. In the `close()` method we are toggling the active state to close the modal and then using the Tiptap `chain()` and `focus()` methods to return focus to the editor box when the dialog box closes. In this case, we don't need the `chain()` method since we are only passing a single additional method, and not a chain of them. But for teaching purposes, it is good to know it exists.

The `takeAction()` method also toggles the `active` state, this time when the toolbar button is clicked. If `active` is true, it then calls the `populateFields()` method that is defined in the mixin. This method increments the `generation` data property, triggering an update of the DOM. This is a common pattern used by components in Apostrophe.

The `calculateHighlightedCharacters()` and `calculateHighlightedWords()` methods both use a method that is defined in our custom Tiptap extension and added to the Tiptap `commands` object. The methods in this object are used for a wide range of text editing functions. This includes basic text formatting (like making text bold or italic), inserting or removing content, creating lists, setting or removing attributes, and much more. For example, `editor.commands.bold()` would toggle bold formatting on the currently selected text. The conditionals in each method called here test whether the user has any text highlighted using the `hasSelection()` computed property defined in the mixin. We will return to this when we cover the mixin, as it is a very common method when creating a Tiptap extension in Apostrophe.

### The Vue insert component

<AposCodeBlock>

```javascript
<template>
  <div v-if="active" v-click-outside-element="close" class="apos-popover apos-cc-insert__dialog"
    x-placement="bottom" :class="{
      'apos-is-triggered': active
    }"
  >
    <AposContextMenuDialog menu-placement="top-start">
      <div class="character-count" v-if="editor">
        <h3>Document stats</h3>
        Total characters: {{ totalCharactersCount }}{{ editorLimitText }} 
        <br>
        Total words: {{ totalWordsCount }}
      </div>
      <footer class="apos-cc-control__footer">
        <AposButton type="primary" label="apostrophe:close" @click="close" :modifiers="formModifiers" />
      </footer>
    </AposContextMenuDialog>
  </div>
</template>

<script>
import characterCountMixin from '../mixins/characterCountMixin';

export default {
  name: 'RichTextCCInsert',
  mixins: [characterCountMixin],
  props: {
    active: {
      type: Boolean,
      required: true
    }
  },
  methods: {
    close() {
      if (this.active) {
        this.$emit('done');
      }
    },
  }
};
</script>
```
  <template v-slot:caption>
    characterCount/apos/ui/components/RichTextCCInsert.vue
  </template>

</AposCodeBlock>

#### The `template`

```javascript
<template>
  <div v-if="active" v-click-outside-element="close" class="apos-popover apos-cc-insert__dialog"
    x-placement="bottom" :class="{
      'apos-is-triggered': active
    }"
  >
    <AposContextMenuDialog menu-placement="top-start">
      <div class="character-count" v-if="editor">
        <h3>Document stats</h3>
        Total characters: {{ totalCharactersCount }}{{ editorLimitText }}
        <br>
        Total words: {{ totalWordsCount }}
      </div>
      <footer class="apos-cc-control__footer">
        <AposButton type="primary" label="apostrophe:close" @click="close" :modifiers="formModifiers" />
      </footer>
    </AposContextMenuDialog>
  </div>
</template>
```

Just like the toolbar component, the insert modal presented to the user is wrapped in a div that is conditionally populated with `v-if="active"` and can trigger the closure of the modal if the user clicks outside. In this case, however, Apostrophe provides us with both the triggering button and a component, `AposContextMenuDialog`, for displaying our modal markup. We are again passing the `x-placement` attribute to position the `tippy.js` tooltip arrow correctly.

Within the `AposContextMenuDialog` component, we specify `menu-placement="top-start"` to determine the placement of the tooltip arrow, typically at the top start since menus usually open downwards. Additionally, we incorporate a sanity check using the `v-if="editor"` condition to ensure that the document statistics are only displayed when the editor instance is properly initialized and available, enhancing the component's reliability. Following the display of our statistics we have a `footer` with an `AposButton` component to close the modal.

#### The `script`

```javascript
<script>
import characterCountMixin from '../mixins/characterCountMixin';

export default {
  name: 'RichTextCCInsert',
  mixins: [characterCountMixin],
  props: {
    active: {
      type: Boolean,
      required: true
    }
  },
  methods: {
    close() {
      if (this.active) {
        this.$emit('close');
      }
    },
  }
};
</script>
```
The script for the insert menu modal is almost completely contained within the mixin file. Once again we import that file and set up our export to use it along with the name of the component. In this case, Apostrophe is supplying the button that toggles the `active` state, so it is passed in with the `props`, rather than being calculated. The only other code in the script is in the `methods` object. The `close()` method is called when the user clicks outside the modal or clicks on the close button. This will emit a `close` event. This is received by the parent `AposRichTextWidgetEditor.vue` component, causing it to close the modal, remove the slash used to open the insert menu, and return focus to the editor. In the case where content is being added to the editor, this will also validate that material and either insert it in place of the slash, or throw an error. There is another event, `cancel` that simply closes the modal and returns the focus to the editor without removing the slash.

### The component mixin

<AposCodeBlock>

```javascript
export default {
  data() {
    return {
      generation: 1,
      triggerValidation: false,
      formModifiers: ['small', 'margin-micro'],
      totalCharactersCount: 0,
      totalWordsCount: 0
    };
  },
  props: {
    options: {
      type: Object,
      required: true
    },
    editor: {
      type: Object,
      required: true
    }
  },
  computed: {
    moduleOptions() {
      return apos.modules[apos.area.widgetManagers['@apostrophecms/rich-text']]
        .aposCharCountConfig;
    },
    widgetOptions() {
      if (this.options?.charCountConfig) {
        return this.options.charCountConfig;
      }
      return {};
    },
    editorLimitText() {
      if (this.moduleOptions?.limit || this.widgetOptions?.limit) {
        const limit = this.widgetOptions.limit
          ? this.widgetOptions.limit
          : this.moduleOptions.limit;
        return `/${limit}`;
      }
      return '';
    },
    hasSelection() {
      const { state } = this.editor;
      const { selection } = this.editor.state;
      const { from, to } = selection;
      const text = state.doc.textBetween(from, to, '');
      return text !== '';
    }
  },
  mounted() {
    this.calculateTotalCharacters();
    this.calculateTotalWords();
  },
  watch: {
    active(newVal) {
      if (newVal) {
        this.calculateTotalCharacters();
        this.calculateTotalWords();
        window.addEventListener('keydown', this.keyboardHandler);
      } else {
        window.removeEventListener('keydown', this.keyboardHandler);
      }
    },
  },
  methods: {
    keyboardHandler(e) {
      if (e.keyCode === 27 || e.keyCode === 13) {
        this.close();
        e.preventDefault();
      }
    },
    async populateFields() {
      this.generation++;
    },
    calculateTotalCharacters() {
      this.totalCharactersCount = this.editor.commands.getTotalCharactersCount();
    },
    calculateTotalWords() {
      this.totalWordsCount = this.editor.commands.getTotalWordsCount();
    }
  }
};
```
  <template v-slot:caption>
    characterCount/ui/apos/mixins/characterCountMixin.js
  </template>

</AposCodeBlock>

Starting with the `data()` method we are returning a number of reactive data properties, some of which are specific to the extension, and some that are specific for the majority of Apostrophe components. 

```javascript
data() {
  return {
    generation: 1,
    triggerValidation: false,
    formModifiers: ['small', 'margin-micro'],
    totalCharactersCount: 0,
    totalWordsCount: 0
  };
},
```

The `totalCharactersCount` and `totalWordsCount` initialize these two properties for extension-specific data. The `generation` property is commonly used in Apostrophe components to trigger a re-render through a watcher. The `triggerValidation` is used to validate any input prior to insertion. For this extension we aren't receiving any input from the user, so we could eliminate this property. In your custom editor extension you might need to include it. Finally, we are passing a `formModifiers` property to keep track of modal styling.

```javascript
props: {
  options: {
    type: Object,
    required: true
  },
  editor: {
    type: Object,
    required: true
  }
},
```

Within the `props` object, we are passing two props from the parent `AposRichTextWidgetEditor.vue` component. This includes the `editor` instance.

```javascript
computed: {
  moduleOptions() {
    return apos.modules[apos.area.widgetManagers['@apostrophecms/rich-text']]
      .aposCharCountConfig;
  },
  widgetOptions() {
    if (this.options?.charCountConfig) {
      return this.options.charCountConfig;
    }
    return {};
  },
  editorLimitText() {
    if (this.moduleOptions?.limit || this.widgetOptions?.limit) {
      const limit = this.widgetOptions.limit
        ? this.widgetOptions.limit
        : this.moduleOptions.limit;
      return `/${limit}`;
    }
    return '';
  },
  hasSelection() {
    const { state } = this.editor;
    const { selection } = this.editor.state;
    const { from, to } = selection;
    const text = state.doc.textBetween(from, to, '');
    return text !== '';
  }
},
```

The `computed` object has two methods, `moduleOptions()` and `widgetOptions()` that retrieve the module options. The first gets the options that are stored in the `apos.modules` object set in the `app.js` file or in a project-level `modules/@apostrophecms/rich-text-widget/index.js` file. The second retrieves any options set on the `rich-text-widget` instance of that specific area, so page- or piece-specific options.

The `editorLimitText()` method takes the options and returns a template literal string that is added in the modal to the 'total characters' string. If no character limit has been set, it returns an empty string.

The `hasSelection()` method is present in the majority of the Apostrophe `rich-text-widget` components. First, we access the current `state` of the editor. This `state` has a variety of information about the entire state of the document. This includes the current selection, the overall document structure (like how many nodes there are), and more. Next, from the `state` object we capture the `selection`. This `selection` includes the starting (`from`) and ending (`to`) cursor position of any selection. This method then uses the ProseMirror `textBetween` method. This will return either the text contained between the `from` and `to` cursor positions, or an empty string. This is then evaluated to return `true` only if `text` is not an empty string indicating there is text selected in the editor.

```javascript
mounted() {
  this.calculateTotalCharacters();
  this.calculateTotalWords();
},
```
The `mounted()` method uses methods defined in this mixin to calculate the statistics presented to the user.

```javascript
watch: {
  active(newVal) {
    if (newVal) {
      this.calculateTotalCharacters();
      this.calculateTotalWords();
      window.addEventListener('keydown', this.keyboardHandler);
    } else {
      window.removeEventListener('keydown', this.keyboardHandler);
    }
  },
},
```
The `watch` object is being set-up to monitor the `active` property that controls whether to modal is displayed. If the value goes from `false` to `true`, it recalculates the current statistics for the editor and adds a listener from the `methods()` to allow the user to close the modal from the keyboard. Otherwise, it removes the listener.

```javascript
methods: {
  keyboardHandler(e) {
    if (e.keyCode === 27 || e.keyCode === 13) {
      this.close();
      e.preventDefault();
    }
  },
  async populateFields() {
    this.generation++;
  },
  calculateTotalCharacters() {
    this.totalCharactersCount = this.editor.commands.getTotalCharactersCount();
  },
  calculateTotalWords() {
    this.totalWordsCount = this.editor.commands.getTotalWordsCount();
  }
}
```
The `methods` object provides the `keyboard()` handler method that we used in the `active()` method just mentioned. It also provides the `populateFields()` method that is commonly used in Apostrophe components to trigger a DOM refresh by updating the `generation` property. The final two methods `calculateTotalCharacters()` and `calculateTotalWords()` utilize commands added to our editor instance through our extension that we will cover next.

### The Tiptap character count extension

Now that we have covered the implementation of our modal components, we need to circle back to how we are interfacing these components with our Tiptap editor. Our `characterCount` module has a file in the `ui/apos/tiptap-extensions` that looks much like the files for the other two modules we have already discussed, so we won't go through it in detail. It collects the project-wide and per-area options and passes them to the instance of our extension. Like the `smilies` module, it also imports the code for the extension from a `lib` folder located in the module. Let's look at the code for that module.

<AposCodeBlock>

```javascript
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';

const CharacterCount = Extension.create({
  name: 'characterCount',

  addOptions() {
    return {
      limit: null
    };
  },

  addCommands() {
    return {
      getHighlightedStats:
        (type = 'characters') =>
        ({ state }) => {
          const { from, to } = state.selection;

          if (from === to) return 0;

          // Extract text for character count (no extra spaces at node boundaries)
          const textForCharacters = state.doc.textBetween(from, to, null, '');
          const charactersCount = textForCharacters.length;

          // Extract text for word count (with spaces at node boundaries)
          const textForWords = state.doc.textBetween(from, to, ' ', ' ');
          let wordsCount = textForWords
            .split(' ')
            .filter((word) => word !== '').length;

            // if selection has an isolated slash at the end, remove it from the count
          if (/\s\/$/.test(textForWords)) {
            wordsCount--;
          }

          return type === 'characters' ? charactersCount : wordsCount;
        },

      getTotalCharactersCount:
        () =>
        ({ state }) => {
          const text = state.doc.textContent;
          return text[text.length - 1] === '/' ? text.length - 1 : text.length;
        },
      getTotalWordsCount:
        () =>
        ({ state }) => {
          let wordCount = 0;

          state.doc.descendants((node) => {
            if (node.isText) {
              const words = node.text.trim().split(/\s+/).filter(Boolean);
              wordCount += words.length;
            }
          });

          const docText = state.doc.textContent;
          const endsWithIsolatedSlash = /\s\/$/.test(docText);

          if (endsWithIsolatedSlash) {
            wordCount = wordCount > 0 ? wordCount - 1 : 0;
          }

          return wordCount;
        }
    };
  },

  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey('characterCount'),
        filterTransaction: (transaction, state) => {
          const limit = this.options.limit;
          if (
            !transaction.docChanged ||
            limit === 0 ||
            limit === null ||
            limit === undefined
          ) {
            return true;
          }

          // Check if the transaction is a paste operation
          const isPaste = transaction.getMeta('paste');

          // Get the total characters count from the new state
          const totalCharacters = transaction.doc.textContent.length;

          // If the total number of characters exceeds the limit, rollback the transaction
          if (totalCharacters > limit) {
            if (isPaste) {
              // For pasted content, try to remove the exceeding content
              const over = totalCharacters - limit;
              const pos = transaction.selection.$head.pos;
              const from = pos - over;
              const to = pos;
              transaction.deleteRange(from, to);
            } else {
              // If the limit will be exceeded, block the transaction
              return false;
            }
          }

          // Allow the transaction if within the limit
          return true;
        }
      })
    ];
  }
});

export default CharacterCount;
```
  <template v-slot:caption>
    characterCount/lib/characterCountExtension.js
  </template>

</AposCodeBlock>

In our journey through creating custom Tiptap extensions, we've already explored how `addInputRules()` can be used to define specific input behaviors. In this extension, we will not only leverage additional configuration methods from the Tiptap API but also the underlying ProseMirror API.

```javascript
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';
```

We are starting by importing the `Extension` construct from the Tiptap API. We used this construct when creating the `smilies` extension. Next, we import the `Plugin` class from the ProseMirror API. When developing Tiptap extensions, ProseMirror `Plugin` instances are often used to create more complex behavior. At the same time, we are also importing the ProseMirror `PluginKey` utility. This utility allows us to uniquely identify each ProseMirror plugin. This can allow us to access and manipulate the state of a plugin within the editor. This also allows us to update or replace a plugin within an editor configuration.

```javascript
const CharacterCount = Extension.create({
  name: 'characterCount',

  addOptions() {
    return {
      limit: null
    };
  },
```

The `addOptions()` method of the Tiptap `Extension` class serves as a setup function where you can specify default values and structures for the options that your extension will use. In this case, we are allowing the user to pass a `limit` option that will restrict the number of characters that can be added to an editor. We are initializing it to `null` to specify that by default, there is no limit. In our `smilies` extension, we could have used `addOptions()` to specify a default skin tone. Instead, we used `const tone = this.options.tone || 2;`. If you have a large number of configuration options, it is usually easier to maintain defaults using `addOptions()`, but it isn't required.

```javascript
addCommands() {
  return {
    // ...
  };
},
```

#### Adding commands
The `addCommands()` method in Tiptap is essential for defining custom commands that enhance or modify the functionality of the editor. These commands have the capability to interact with the editor's state, manipulate the document, or initiate specific actions. The decision to incorporate certain functionalities into `addCommands()`, as opposed to retaining them within a Vue component, hinges on various considerations. If a method is anticipated to be utilized across multiple components, integrating it into `addCommands()` is often more effective. This method is adept at handling complex state transitions and selections, making it a robust choice for intricate functionalities. Additionally, incorporating a method in this manner ensures seamless integration with Tiptap's command API, including features like the undo/redo stack, and fosters interoperability with other extensions and commands. While these methods could have been included in a mixin or individual components, understanding and utilizing `addCommands()` offers valuable insights into advanced functionality implementation within Tiptap.

```javascript
getHighlightedStats:
  (type = 'characters') =>
  ({ state }) => {
    const { from, to } = state.selection;
    if (from === to) return 0;
    // Extract text for character count (no extra spaces at node boundaries)
    const textForCharacters = state.doc.textBetween(from, to, null, '');
    const charactersCount = textForCharacters.length;

    // Extract text for word count (with spaces at node boundaries)
    const textForWords = state.doc.textBetween(from, to, ' ', ' ');
    let wordsCount = textForWords
      .split(' ')
      .filter((word) => word !== '').length;
      // if selection has an isolated slash at the end, remove it from the count
    if (/\s\/$/.test(textForWords)) {
      wordsCount--;
    }

    return type === 'characters' ? charactersCount : wordsCount;
  },
  ```

  The first command that we are adding calculates the number of highlighted characters. It can accept a single argument of `type` that defaults to `characters`, allowing us to calculate either the number of words or characters with this same function. The returned arrow function takes the `state` from the editor. This state object is then destructured to get the starting and ending cursor positions, as was done with the `hasSelection()` method in our toolbar Vue component. If those two positions are the same we then trigger an early return since there isn't anything highlighted.

```javascript
const textForCharacters = state.doc.textBetween(from, to, null, '');
const charactersCount = textForCharacters.length;
```
To get the number of highlighted characters we are using the ProseMirror `textBetween()` helper method. This method takes four arguments and returns a plain text string from a specified range. The first two arguments, `from` and `to`, take integers that indicate the positions in the document we are selecting. In our case, this is the region the user has highlighted. The third argument is the `blockSeparator` argument. It takes a string to be inserted when a new block-level content node is discovered. For example, it would be inserted between two paragraphs or the items in a list. The fourth argument is the `leafText` argument. Like the previous argument, it takes a string to be inserted into the processed text. However, in this case, it is what should be inserted when encountering non-text content in the selection, like inline images. For these last two arguments we are passing `null` and an empty string. We could have passed `null` or an empty string for both. This is just to illustrate that you can use either.

Another approach we could have used here is to use the ProseMirror `slice()` helper method. This method returns an object that includes not just the content itself, but also information about how it can be integrated into another document or another area of the same document, maintaining the original structure and formatting. This is useful when copying or cutting a section from your document. Using this method would be more complex because we would have to loop through each of the returned nodes and subnodes to find those containing text, hence our use of `textBetween` that simplifies the returned content.

```javascript
const textForWords = state.doc.textBetween(from, to, ' ', ' ');
let wordsCount = textForWords
  .split(' ')
  .filter((word) => word !== '').length;
  // if selection has an isolated slash at the end, remove it from the count
if (/\s\/$/.test(textForWords)) {
  wordsCount--;
}
```
In order to get a count of the number of words, we are once again using the `textBetween` helper method to parse over the selected text. This time however, we are adding spaces for the boarders between nodes and in place of non-text content. This then allows us to use `split` and `filter` to create an array of words and get rid of empty spaces. While the highlighted stats will likely only be called from the toolbar, we are also adding a conditional to decrease the word count by one if the last "word" is a slash, as would be used to open the insert menu.

```javascript
return type === 'characters' ? charactersCount : wordsCount;
```
Finally, we are returning the number of characters or words based on the `type` argument supplied to the method.

```javascript
getTotalCharactersCount:
  () =>
  ({ state }) => {
    const text = state.doc.textContent;
    return text[text.length - 1] === '/' ? text.length - 1 : text.length;
  },
```
To calculate the total number of characters in the document we are using the `textContent` property of the entire document. ProseMirror automatically adds this property to all nodes and it contains all the text from the node and its descendants as a plain text string.  This simplifies the process of extracting text from a document node abstracting away the need to manually traverse the node tree and concatenate text from individual text nodes. Here we are also subtracting from the character count if the final character is a slash indicating that the insert menu was opened.

```javascript
getTotalWordsCount:
  () =>
  ({ state }) => {
    let wordCount = 0;
    state.doc.descendants((node) => {
      if (node.isText) {
        const words = node.text.trim().split(/\s+/).filter(Boolean);
        wordCount += words.length;
      }
    });
    const docText = state.doc.textContent;
    const endsWithIsolatedSlash = /\s\/$/.test(docText);
    if (endsWithIsolatedSlash) {
      wordCount = wordCount > 0 ? wordCount - 1 : 0;
    }
    return wordCount;
  }
```
The final command we are adding returns the total word count from the document, again accounting for the slash added when opening the insert menu. We can't use `textContent` in this case, because this property doesn't contain additional characters between nodes, which will cause words to run together. Instead, we are using the `descendants` traversal utility method from ProseMirror. This is a fundamental method for examining or modifying large parts of the document. When called it walks through the supplied node tree, applying the supplied function to each.

In the callback function, we are first checking the `isText` property of the node. If the node is a text node, we add the number of words to the running count of words.

This word count could also have been conducted using the ProseMirror `findTextNode()` utility. This helper is much like `descendants()` in that it traverses the supplied node and child nodes, but it only applies the callback to text nodes. For example:

```javascript
let wordCount = 0;
findTextNodes(state.doc).forEach(node => {
  const words = node.text.trim().split(/\s+/).filter(Boolean);
  wordCount += words.length;
});
```

#### Creating ProseMirror plugins

```javascript
addProseMirrorPlugins() {
    return [
      new Plugin({
        // ...
      })
    ];
  }
  ```
A fundamental aspect of Tiptap's architecture lies in its ability to extend and enhance the underlying ProseMirror framework through the `addProseMirrorPlugins()` method. This method opens the door to a myriad of functionalities, significantly broadening the scope and capability of any Tiptap editor. It enables the integration of complex features like advanced versioning and history management. Additionally, it facilitates the implementation of real-time collaborative editing, allowing multiple users to work on the same document simultaneously seamlessly and interactively. A prime example of its utility is demonstrated in this extension, where `addProseMirrorPlugins()` is leveraged to introduce transaction-level control. This control is crucial for enforcing constraints like character limits within the editor, ensuring that content adheres to specified guidelines or limitations.

The `addProseMirrorPlugins()` function returns an array of individual plugins. There are numerous ProseMirror plugins available that can be imported into your Tiptap extension, but in this case we are using the `new Plugin()` constructor to create a custom plugin. This constructor takes an options object that defines the plugin's behavior and functionality.

```javascript
key: new PluginKey('characterCount'),
```
Within the `Plugin` object, we are passing a `key` property, with another ProseMirror constructor function as value. This will generate an object that can be used to access or replace the plugin's state more easily.

```javascript
filterTransaction: (transaction, state) => {
  // ...
}
```
The `filterTransaction` property allows you to add methods to inspect and modify or prevent transactions from being applied to the editor's state. This includes typing characters or pasting a block of text. It should return a boolean indicating whether the transaction should be allowed. ProseMirror plugin options can also include several other properties not used here. The `props` property can be used to override or extend editor properties, including `handleDOMEvents` to handle browser events, `handleTextInput` to handle direct text input, properties to handle keyboard events, and `decorations` that can be used to add styling or interactive elements to the document. The `appendTransaction` property is also quite useful to add transactions in response to transactions that have just been processed.

```javascript
const limit = this.options.limit;
if (
  !transaction.docChanged ||
  limit === 0 ||
  limit === null ||
  limit === undefined
) {
  return true;
}
```
Within our `filterTransactions` method, we are retrieving the `limit` option that we added at the start of the extension file in the `addOptions()` method. If the document hasn't changed or that limit isn't set to a number greater than 0, then the function returns `true`, meaning that the transaction should be allowed.

```javascript
const isPaste = transaction.getMeta('paste');
```
Next, we check whether the transaction is from the user pasting content by checking the transaction object `getMeta()` method and passing in `paste` as an argument. Other arguments to `getMeta()` are going to depend on what extensions are installed, but include `addToHistory` to indicate if a transaction should be added to the undo/redo history, and `uiEvent` to retrieve which UI event, like a click, triggered the transaction. You can also set your own metadata on a transaction using `transaction.setMeta(customKey, metaDataValue)`. While beyond the scope of this tutorial, you would then have to commit any changes to the transaction back to the editor using `view.dispatch(transaction)`.

```javascript
const totalCharacters = transaction.doc.textContent.length;
```
Next, we retrieve the number of characters the entire document would have if the transaction was allowed by looking at the `textContent` property of the `transaction.doc`. Again, the `textContent` will concatenate all of the text in the entire node being examined.

```javascript
if (totalCharacters > limit) {
  if (isPaste) {
    // For pasted content, try to remove the exceeding content
    const over = totalCharacters - limit;
    const pos = transaction.selection.$head.pos;
    const from = pos - over;
    const to = pos;
    transaction.deleteRange(from, to);
  } else {
    // If the limit will be exceeded, block the transaction
    return false;
  }
}
// Allow the transaction if within the limit
return true;
```
Finally, we use some conditional logic to first test if the final number of characters would be greater than the limit if the transaction is allowed. If not, we return true. If it exceeds the limit and the content is being pasted into the editor we then delete the incoming content to make it fit the limit. The `transaction.selection.$head.pos` is going to get the position of the cursor within the transaction. Given that it was just pasted, this will be the end of the pasted content. We then set the `from` position to the number of characters over the limit back from the end of the pasted content and the `to` to the end of the selection (we could also have used `pos` directly, but the code is clearer using `to`). The `deleteRange()` method is then used to delete the characters between the two positions before returning `true` to allow the transaction. If the transaction is coming from the user typing and going over the limit it won't be permitted by returning `false`.

This extension was created to allow for the counting of both total and highlighted characters in our rich-text editor. There is also an official [Tiptap extension](https://tiptap.dev/api/extensions/character-count) that will return the total number of characters in the editor. This extension takes a slightly different route than the extension that we just covered. It makes use of `storage` to hold the word and character values and updates with every transaction, rather than calculating when the modal is activated. The primary purpose of `storage` in a Tiptap extension is to hold data or state relevant to the extension's functionality. This can include settings, temporary data, or any other information the extension needs to function correctly. The `storage` is tied to the lifecycle of the extension itself. It is created when the extension is instantiated and exists as long as the extension is active. The scope of the storage is limited to the extension, meaning it is not directly accessible by other parts of the Tiptap editor or other extensions unless explicitly designed to be so. This is a very useful Tiptap feature that can be used in your custom extensions.

## Summation
In this tutorial series, we walked through how you can improve and customize the ApostropheCMS `rich-text-widget`. On the Apostrophe side, we learned a little about how to add custom options for your modules that improve the core modules using the `getBrowserData()` extended method. We also learned what is needed to add a new button to the toolbar or an item to the insert menu to activate your new functionality.

On the Tiptap side, we introduced how you can use premade extensions from [Tiptap](https://tiptap.dev/) and other developers. We also demonstrated how to make a simple plugin for adding your own string replacements. Finally, we dug deep into Tiptap and ProseMirror development, creating an extension that added a plugin to ProseMirror.

It should be emphasized that the Tiptap and ProseMirror frameworks have much more to offer than what we touched on here. There are many additional utilities and methods available for document manipulation, each offering unique capabilities for enhancing the Apostrophe `rich-text-widget`. Hopefully, these tutorials will set you down the road to customizing the editor in your projects to provide all the special features that you need!

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Adding a support desk button
DOC_PATH: tutorials/adding-a-support-desk-button.md
URL: https://apostrophecms.com/docs/tutorials/adding-a-support-desk-button
================================================================================
# Integrating a Third-Party Support Desk into ApostropheCMS Admin Bar

## Why This Matters

Customer support is a critical part of any website management experience. By integrating a support desk directly into the ApostropheCMS admin bar, you make it easy for content managers to get help without leaving their workflow. This integration reduces friction, improves the user experience, and ultimately leads to faster issue resolution and higher satisfaction.

## Understanding Third-Party Support Desk Options

Most popular third-party support desk solutions can be easily integrated with ApostropheCMS. Many create buttons that the users can click to trigger the help desk through a simple script embedded in the head of your site. However, using this approach means that you might have to worry that the end reader of your site has the option to open the help desk, which may not be desired. Adding it as a button to the admin bar means that you can allow just logged-in users to access the support desk. But, this also means that you need to disable the automatic button addition.

Common third-party support desk solutions that work well with ApostropheCMS include Zendesk Support Widget (a comprehensive customer service platform with ticketing and knowledge base), Intercom Chat (a conversational relationship platform with chat-based support), Freshdesk Messaging (customer support software with ticketing and automation), Help Scout Beacon (email-based customer support with a clean interface), and Crisp Live Chat (a lightweight customer messaging platform with chatbot capabilities).

## Integration Approach

We'll look at how to integrate your support desk button by creating a Crisp Live Chat integration. This example demonstrates all the key concepts you'll need for any support desk provider.

### Adding the Support Button to the Admin Bar

In ApostropheCMS, you can add a support desk button to the admin bar from the `init` method of any module.

The code is straightforward, using the `self.apos.adminBar.add()` method to register the new button:

<AposCodeBlock>

```javascript
export default {
  init(self) {
    // Add support desk button to the admin bar
    self.apos.adminBar.add(
      'support-desk',           // Unique identifier
      'Get Support',            // Button label
      false,                    // Available to all users with admin access
      {
        contextUtility: true,   // Places button in the right side utility area
        icon: 'phone-icon', // Icon for the button
        tooltip: 'supportDesk:supportDesk' // Namespaced tooltip text for translation
      }
    );
  }
};
```
  <template v-slot:caption>
    modules/support-desk/index.js
  </template>
</AposCodeBlock>

Here we are creating a new project-level module named `support-desk`. We don't have an `extend` property, so it will implicitly extend the core `@apostrophecms/module`. Since it is a new project-level module, we also need to register it in the project `app.js` file.

<AposCodeBlock>

```javascript
import apostrophe from 'apostrophe';

apostrophe({
  root: import.meta,
  shortName: 'my-website',
  modules: {
    'support-desk': {},
    // other modules
  }
});
```
  <template v-slot:caption>
    app.js
  </template>
</AposCodeBlock>

In this example we have added the button to the context menu, but you may choose to add it as a main navigation item or the user drop-down menu. See the [reference documentation for other placement options](/reference/modules/admin-bar.html#add-name-label-permission-options).

This single method call is all you need to add the button to the admin bar. The first parameter is a unique identifier that you'll reference in your event handler. The second parameter is the visible label (ideally using a [translation string](/guide/localization/static.html#localizing-schema-field-labels) in production). The third parameter controls permissions, where `false` makes it available to all users with admin access. The final parameter is an options object that determines the button's placement and appearance.

### Handling the Button Click Event

Once you've added the support button to the admin bar, you need to create a browser-side component to handle clicks. This is where you'll connect your admin bar button to the API for the Crisp chat widget or other selected support desk.

In your project's UI JavaScript file, add an event listener for the admin bar button click and trigger the Crisp widget:

<AposCodeBlock>

```javascript
export default () => {
  // Only proceed for logged-in users
  if (!apos.user) {
    return;
  }

  // Listen for admin bar button clicks once ApostropheCMS is loaded
  apos.util.onReady(() => {
    apos.bus.$on('admin-menu-click', (item) => {
      // Check if our support desk button was clicked
      if (item === 'support-desk') {
        openCrispChat();
      }
    });
  });

  function openCrispChat() {
    // Call the Crisp API to open the chat widget
    if (window.$crisp) {
      window.$crisp.push(['do', 'chat:open']);
      window.$crisp.push(['do', 'chat:show']);

      // Set user information
      if (apos.user) {
        window.$crisp.push(['set', 'user:email', apos.user.email || '']);
        window.$crisp.push(['set', 'user:nickname', apos.user.title || '']);
      }
    }

    // Add an announcement for screen readers (accessibility improvement)
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.textContent = 'Support desk is now open';
    document.body.appendChild(announcement);

    // Remove after announcement is read
    setTimeout(() => {
      document.body.removeChild(announcement);
    }, 3000);
  }

  // Initialize Crisp chat
  initCrispChat();

  function initCrispChat() {
    window.$crisp = [];
    window.CRISP_WEBSITE_ID = "YOUR_WEBSITE_ID"; // Replace with your actual ID as assigned by Crisp

    // Load Crisp script
    const script = document.createElement('script');
    script.src = 'https://client.crisp.chat/l.js';
    script.async = true;
    document.head.appendChild(script);

    // Hide default button and handle close events
    window.$crisp.push(['do', 'chat:hide']);
    window.$crisp.push(['on', 'chat:closed', function() {
      window.$crisp.push(['do', 'chat:hide']);
    }]);
  }
};
```
  <template v-slot:caption>
    modules/support-desk/ui/apos/apps/SupportDesk.js
  </template>
</AposCodeBlock>

> [!IMPORTANT]
> Note the location of this script. It should be placed in the `ui/apos/apps` folder of your module so that it has access to the `apos.bus.$on()` method and only loads for logged-in users who need this functionality.

This approach ensures that when a content manager clicks the support button in the admin bar, the third-party support desk widget appears, allowing them to get help without leaving the CMS interface.

> **Note**: For other support desk solutions, you'll need to replace the Crisp-specific API calls (like `window.$crisp.push(['do', 'chat:open'])`) with the appropriate method provided by your support desk solution. Check their developer documentation for the correct method name and parameters.

### Including the Support Desk Script

The Crisp integration above includes the script loading in the `initCrispChat()` method, but you may want to understand the different approaches available for other support desk solutions. This can be done in your layout template or in your UI JavaScript file as we demonstrated above, depending on your preference and the support tool's requirements.

#### General Pattern

Regardless of which support desk solution you use, the implementation typically follows this pattern:

1. Only load the support desk for authenticated users
2. Include the vendor's JavaScript
3. Configure the widget to hide the default launcher
4. Pass user information when available

#### Template-Based Implementation

This approach works well for simpler implementations:

<AposCodeBlock>

```nunjucks
{% block extraBody %}
  {{ super() }}

  {% if data.user %}
    {# Load the support desk script only for logged-in users #}
    <script src="https://cdn.example.com/support-desk.js?key=YOUR_API_KEY" async></script>
    <script>
      // Configure your support desk
      // This example is generic - check your provider's documentation for specifics
      window.supportDeskConfig = {
        // Common configurations:
        hideLauncher: true,
        user: {
          name: '{{ data.user.title }}',
          email: '{{ data.user.email }}'
        }
      };
    </script>
  {% endif %}
{% endblock %}
```
  <template v-slot:caption>
    views/layout.html
  </template>
</AposCodeBlock>

## Hiding the Default Widget Button

Most support desk widgets automatically add their own button to the page. You'll need to hide this default button to avoid duplication with your admin bar integration. This is a crucial step in creating a clean, professional interface that only shows the support option to authenticated users through the admin bar.

This can usually be accomplished in one of two ways:

### Configuration-Based Approach (Preferred)

Most support desk services provide configuration options to hide their default launcher. The Crisp chat widget API provides a workaround through the `chat:hide` and `chat:show`. The exact property names will vary by provider, but the pattern is usually similar:

```javascript
// Generic example - refer to your provider's documentation
window.supportDeskConfig = {
  // Common configuration names for hiding the default launcher
  hideLauncher: true,
  // OR
  hideDefaultLauncher: true,
  // OR
  launcher: {
    visible: false
  }
};
```

### CSS-Based Approach (Fallback)

If configuration doesn't work, you can use CSS as a fallback. You'll need to inspect the page to find the specific CSS selector for your support desk's button:

```css
/* Generic example - you'll need to find the actual selector */
.support-widget-launcher {
  display: none !important;
}
```

Check your support desk provider's documentation for specific guidance on hiding the default launcher through configuration or CSS.

## Conclusion

Integrating a third-party support desk into the ApostropheCMS admin bar provides an immediate help channel for your content managers without creating a custom module. By leveraging the `apos.adminBar.add()` method and the third-party widget's JavaScript API, you can create a seamless support experience that feels like a natural part of the CMS.

---

**Related Resources:**
- [ApostropheCMS Admin-bar Module Documentation](/reference/modules/admin-bar.md)

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Adding an Admin Bar External Link
DOC_PATH: tutorials/adding-admin-bar-external-links.md
URL: https://apostrophecms.com/docs/tutorials/adding-admin-bar-external-links
================================================================================
# Adding External Link Buttons to the ApostropheCMS Admin Bar

## Why This Matters

Content editors often need quick access to external resources like style guides, analytics dashboards, or a company intranet while working in the CMS. By adding a custom button to the ApostropheCMS admin bar that opens external URLs, you create a seamless workflow that keeps essential tools just one click away, improving efficiency and reducing context switching.

## When to Use This Approach

This pattern works best for:
- Documentation sites or style guides
- Analytics dashboards
- Company intranets or wikis
- Support ticket systems
- Any frequently-accessed external tool that complements content creation

For tools that need to pass data from the CMS or deeply integrate with ApostropheCMS workflows, consider building custom modules instead.

## Integration Approach

Adding a URL-opening button to the admin bar requires two main components:
1. Server-side configuration to add the button to the admin bar
2. Browser-side code to handle the button click and open the URL

### Adding the Button to the Admin Bar

In ApostropheCMS, you can add a custom button to the admin bar from the `init` method of any module.

<AposCodeBlock>

```javascript
export default {
  init(self) {
    // Add URL-opening button to the admin bar
    self.apos.adminBar.add(
      'external-resource',        // Unique identifier
      'Documentation',            // Button label
      false,                      // Available to all users with admin access
      {
        // This options object controls button placement
        contextUtility: true,     // Places button in the right side utility area
        icon: 'book-open',        // Icon for the button
        tooltip: 'myProject:openDocs' // Namespaced tooltip text for translation
      }
    );
  },
  icons: {
    'book-open': 'BookOpen'
  }
};
```
  <template v-slot:caption>
    modules/external-links/index.js
  </template>
</AposCodeBlock>

> [!NOTE]
> The `tooltip` property uses a namespaced localization key (`myProject:openDocs`) to support multiple languages in the admin UI. To set up translations for admin interface elements like tooltips, button labels, and schema field labels, see the guide on [localizing schema field labels](/guide/localization/static.html#localizing-schema-field-labels).
 
> [!TIP]
> The `book-open` icon isn't already registered as an ApostropheCMS icon, but is in the version of the [vue-material-design-icons](https://gist.github.com/BoDonkey/a28419ed8954b57931f80061e5e6a3dd) that is present in core. You can register the new icon using the top-level `icons` configuration property. To do so, you pass the name you want to use, in this case `book-open`, as a key and the icon name in the package as value. You can read more [here](/reference/module-api/module-overview.md#icons).

This method call registers a new button in the admin bar. The parameters are:

1. A unique identifier that you'll reference in your event handler
2. The visible label (ideally using a translation string in production)
3. Permissions control (where `false` makes it available to all admin users)
4. Options object determining placement and appearance

### Button Placement Options

You have several options for where to place your URL-opening button:

- **Context Utility Area** (shown above): Place the button on the right side of the admin bar alongside other utility tools by setting `contextUtility: true`
- **Main Menu**: Place the button main navigation by omitting the options object
- **User Menu**: Place the button in the user dropdown menu by setting `user: true` in the options object

Choose the placement based on the importance and frequency of use. Context utility is best for frequently used external tools, while the user menu might be better for less common resources.

### Handling the Button Click Event

Once you've added the button to the admin bar, you need to create a browser-side component to handle clicks. This is where you'll open the external URL.

<AposCodeBlock>

```javascript
export default () => {
  // Use apos.util.onReady to ensure ApostropheCMS is fully initialized
  apos.util.onReady(() => {
    // Check if bus is available 
    if (!apos.bus || !apos.bus.$on) {
      console.error('Event bus not available, cannot register handler');
      return;
    }

    // Now listen for admin bar button clicks
    apos.bus.$on('admin-menu-click', (item) => {
      // Check if our custom external resource button was clicked
      if (item === 'external-resource') {
        openExternalURL();
      }
    });
  });

  function openExternalURL() {
    // Create an accessible link element with appropriate attributes
    const link = document.createElement('a');
    link.href = 'https://apostrophecms.com';
    link.target = '_blank';
    link.rel = 'noopener noreferrer';
    link.setAttribute('aria-label', 'Opening documentation in a new tab');
    // Briefly add to the DOM and trigger the click programmatically
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
};
```
  <template v-slot:caption>
    modules/external-links/ui/apos/apps/index.js
  </template>
</AposCodeBlock>

> [!IMPORTANT]
> Make sure to add this to the `ui/apos/apps/` folder, or import it into a file located there. If you try to load this code by adding it to `ui/src` you will get an error in the console because the admin functions won't be available, yet.
> 
> **Why this path matters**: The `ui/apos/apps/` directory ensures your code loads in the admin interface context where `apos.bus` and other admin APIs are available. Code in `ui/src/` loads in the public site context where these APIs don't exist.

This code uses `apos.util.onReady` to ensure our event listener is only registered after ApostropheCMS is fully initialized. It then listens to the `apos.bus` for the admin-bar to emit the `admin-menu-click` event, that will also provide our button name. If it was our button that was clicked a link is added to the page and then triggered. This ensures that screen readers are signalled that we are navigating to a new page.

## Conclusion

Adding external link buttons to the ApostropheCMS admin bar provides content editors with quick access to external resources without requiring complex custom modules. By leveraging the `apos.adminBar.add()` method and browser-side event handling, you can create a seamless integration between your CMS and external tools.

For more complex integrations with external services, consider exploring deeper integration patterns that leverage the ApostropheCMS REST API or custom modules.

---

**Related Resources:**
- [ApostropheCMS 4.x Admin-bar Module Documentation](/reference/modules/admin-bar.md)
- [Integrating a Third-Party Support Desk](/tutorials/adding-a-support-desk-button.md)

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Admir Bar Best Practices
DOC_PATH: tutorials/admin-bar-best-practices.md
URL: https://apostrophecms.com/docs/tutorials/admin-bar-best-practices
================================================================================
# Best Practices for Admin Bar Setup in ApostropheCMS

## Why This Matters & Core Principles

The admin bar is the primary navigation tool content managers use daily. A thoughtfully configured admin bar reduces friction in content workflows, decreases training time, and increases overall satisfaction with the CMS. Remember: developers configure the site once, but content managers use it every day.

When configuring your admin bar, prioritize:
- **Content managers first**: Organize for their workflows, not technical structure
- **Consistency**: Maintain predictable patterns aligned with core ApostropheCMS experiences
- **Clarity**: Use clear labels and intuitive groupings
- **Efficiency**: Minimize clicks needed to accomplish common tasks

<!-- VIDEO: Admin Bar Overview Tutorial -->

## Understanding the Admin Bar Components

![The basic ApostropheCMS admin-bar with markup](../images/admin-bar-base-markup.png)

The ApostropheCMS admin bar consists of four key components:
1.  **Main menu items**: Primary navigation links in the left section
    * Pages menu (always present and always appears first - cannot be grouped or reordered)
    * Piece-type modules (each registered piece type gets its own menu item by default)
2. **Quick create menu**: The "+" button providing shortcuts to create new content
3. **Utility context items**: Right-side icons for universal tools 
4. **User Dropdown**: Profile menu for log-out, account settings and personalization

Each component can be customized to better serve your editors' needs.

## Configuration Best Practices

### Logical Grouping & Naming

**Groups are your primary tool for organizing admin bar items.** They allow you to categorize related functionality together, making navigation intuitive for content managers. Instead of having a flat list of menu items, groups create logical sections that mirror your editors' workflows.

> [!NOTE]
> The `@apostrophecms/page` menu item always appears first in the admin bar and cannot be grouped or reordered. All other menu items can be organized using groups.

Configure your admin bar to group related functionality together - for example: content creation tools, media organization, user management, etc. This reduces cognitive load and helps editors find what they need quickly.

**Using Clear, Action-Oriented Labels:**
Use clear, action-oriented labels and maintain consistent naming patterns across modules. Avoid technical jargon in menu labels visible to content managers.

**Using Translation Strings for Admin UI:**
For all user-facing text in the admin interface, we recommend to use translation strings rather than hard-coded English text. This ensures your CMS can be properly internationalized and maintains consistency. For a complete guide including schema field localization and advanced techniques, see [Localizing schema field labels](/guide/localization/static.html#localizing-schema-field-labels).

> [!IMPORTANT]
> For admin UI translations, [you must use a custom namespace prefix](/guide/localization/static.html#adding-and-using-localization-files) (like `myproject`). Never use the `apos` namespace for your custom strings, as this could conflict with existing or future core translations.

> [!WARNING]
> **Common pitfall**: Forgetting to set `browser: true` is the most common reason admin UI translations don't work. Without this setting, your translations are only available server-side (for Nunjucks templates) but not in the browser-based admin interface.

**Example Configuration:**
Here's how to organize several custom pieces that editors constantly use, with media-related content in a separate menu:

<AposCodeBlock>

``` javascript
export default {
  i18n: {
    myproject: {
      browser: true
    }
  },
  options: {
    groups: [
      {
        // Prioritize content creation - the most common task
        name: 'content',
        label: 'myproject:content', // User-friendly label
        items: [
          'article',
          'event',
          'collection'
        ]
      },
      {
        // Group media items together
        name: 'media',
        label: 'myproject:media', // Clear category label
        items: [
          '@apostrophecms/image',
          '@apostrophecms/image-tag',
          '@apostrophecms/file',
          '@apostrophecms/file-tag'
        ]
      }
    ]
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/admin-bar/index.js
  </template>
</AposCodeBlock>

### Menu Priority and Organization

Most developers will find organizing their menus using `groups` to be sufficient. However, you can also add an `order` array for finer control.

<AposCodeBlock>

  ```javascript
  export default {
    options: {
      // Items appear in the exact order specified here
      order: ['event', 'article', '@apostrophecms/image']
    }
  };
  ```
  <template v-slot:caption>
    modules/@apostrophecms/admin-bar/index.js
  </template>
</AposCodeBlock>

Additional positioning can be achieved using the `last` and `after` options of the [`@apostrophecms/admin-bar` module](https://github.com/apostrophecms/apostrophe/blob/42e2074f68d407fafac5106d4b02093da6d305e3/modules/%40apostrophecms/admin-bar/index.js#L166). You can read about this method in the [documentation reference section](/reference/modules/admin-bar.html#add-name-label-permission-options).

**How Grouped and Ungrouped Items Work Together:**

When mixing groups of items and ungrouped menu items, the system:
1. Positions all items first (based on `order` or module initialization order in the `app.js` file)
2. Then ensures grouped items stay together, with their position determined by their first item

<AposCodeBlock>

```javascript
// Group position is determined by its first item's position
export default {
  options: {
    // The content group will appear between image and file modules
    order: ['@apostrophecms/image', 'content-group-leader', '@apostrophecms/file'],
    groups: [
      {
        name: 'content',
        label: 'myproject:content',
        // These stay together and appear where content-group-leader is positioned
        items: ['content-group-leader', 'article', 'event']
      }
    ]
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/admin-bar/index.js
  </template>
</AposCodeBlock>

> [!TIP]
> Place frequently-used items at the beginning of the admin bar for quick access.

## Managing the Quick Create Menu

The Quick Create menu (the "+" icon) should only contain frequently created content types. Remove items to streamline the experience:

<AposCodeBlock>

```javascript
export default {
  options: {
    // Prevent this content type from appearing in the quick create menu
    quickCreate: false
  }
};
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

**When to remove items:**
- Rarely created content types
- Specialized content for specific roles only (even if only selected roles can create a specific piece-type, the menu shouldn't be over-cluttered)
- When you have many piece types and need to reduce options
- Content types requiring careful setup that should use the full content manager

## Customizing the Context Utility Menu

Add custom utilities to the right side of the admin bar from the `init` method of any module:

```javascript
export default {
  init(self) {
    // Add item to the context utility menu (right side of admin bar)
    self.apos.adminBar.add(
      'custom-module:help', // Unique id
      'myproject:getSupport', // Label
      false,                 // Permissions (false = available to all)
      {
        contextUtility: true,  // This makes it appear in the right side
        icon: 'question-circle', // Icon to display (required)
      }
    );
  }
};
```
> [!NOTE]
> Custom actions or link navigation need to be added through browser-side scripting as shown in the [Adding External Link Buttons](/tutorials/adding-admin-bar-external-links.html#handling-the-button-click-event) tutorial.

> [!TIP]
> The `icon` property requires a registered icon name. See the [Icons documentation](/reference/module-api/module-overview.html#icons) for available icons and how to register custom ones.

**Best uses for context utilities:**
- Universal features needed from any context
- Support tools that should never be more than one click away
- Project-specific tools that don't fit the standard content workflow

## Customizing the User Dropdown Menu

### Adding Items to the Menu

You can add custom items to the user dropdown menu (where "Log Out" appears) using the `adminBar.add()` method with the `user: true` option:

<AposCodeBlock>

```javascript
export default {
  init(self) {
    // Add a custom item to the user menu
    self.apos.adminBar.add(
      'custom-module:user-dashboard',             // Unique identifier
      'myproject:userDashboard',    // Label
      false,                        // Permissions (false = available to all)
      {
        user: true,                 // Places this in the user menu
      }
    );
  }
};
```
  <template v-slot:caption>
    modules/my-custom-module/index.js
  </template>
</AposCodeBlock>

> [!NOTE]
> Items added to the user menu cannot be grouped further. When a user clicks this menu item, an event will be emitted on `apos.bus` with the name you provided (`custom-module:user-dashboard` in this example). You'll need to add a corresponding event handler in your frontend code to respond when the item is clicked.

### Modifying the User Preferences Menu

Give content managers control over their experience through customized preferences:

<AposCodeBlock>

```javascript
module.exports = {
  options: {
    subforms: {
      themePreference: {
        label: 'myproject:uiTheme',
        fields: ['theme'],
        reload: true // Refreshes the page when this setting changes
      },
      textSize: {
        label: 'myproject:textSize',
        fields: ['textScale'],
        reload: true // UI needs to refresh to apply new text size
      },
      notifications: {
        label: 'myproject:notifications',
        fields: ['notificationLevel']
      },
      adminLocale: {
        fields: ['adminLocale'] // Requires adminLocales in i18n module
      }
    },
    groups: {
      accessibility: {
        label: 'myproject:accessibility',
        subforms: ['themePreference', 'textSize']
      },
      preferences: {
        label: 'myproject:preferences',
        subforms: ['notifications', 'adminLocale']
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/settings/index.js
  </template>
</AposCodeBlock>

> [!NOTE]
> You can read more about configuring this menu in the [main documentation](/reference/modules/settings.md). You must add any custom fields (like `theme`, `textScale`, and `notificationLevel`) to the `@apostrophecms/user` module schema. For language preferences, configure the [`adminLocales` option](/reference/modules/i18n.html#adminlocales) in the `@apostrophecms/i18n` module. The `reload: true` property is particularly useful for settings that need to take effect immediately, causing the page to refresh when the setting is changed.

## Controlling Menu Visibility

Hide modules from the admin bar to reduce clutter and focus attention:

**Why remove modules:**
- Creates a cleaner interface focused on what editors actually need
- Reduces cognitive load and training time
- Prevents confusion between similar content types
- Keeps specialized modules from cluttering navigation

Real-world example: If you have multiple tag types in your project (e.g., product tags, blog tags, event tags), you might consider:

* Placing them all in a single "Tags" group in the admin bar
* Removing them from the admin bar entirely if they're only used within relationship fields when editing other content (they can be created and edited from the relationship manager)
* Keeping only the most frequently edited tag types visible

This approach prevents your admin bar from becoming cluttered with rarely-accessed supporting content types while maintaining an efficient workflow for content editors.

**Implementation example:**
```javascript
// Correct implementation for removing a module from the admin bar
// in modules/article/index.js
export default {
  methods(self) {
    return {
      // Empty method prevents this module from appearing in the admin bar
      addToAdminBar() {
        return;
      }
    };
  }
};
```

> [!TIP]
> You can also customize the `addToAdminBar()` method to control exactly how a module appears in the admin bar, rather than just hiding it completely.

## Conclusion

A thoughtfully configured admin bar is fundamental to a positive content management experience. By focusing on content managers' actual workflows, and using consistent translation strings, you create an environment where they can work efficiently and confidently. Small UX improvements in frequently used interfaces like the admin bar can significantly impact overall satisfaction with your CMS implementation.

---

**Related Resources:**
- [ApostropheCMS 4.x Admin-bar Module Documentation](/reference/modules/admin-bar.md)
- [ApostropheCMS Settings Module Documentation](/reference/modules/settings.md)
- [How to Integrate a Support Desk into Admin Bar](/tutorials/adding-a-support-desk-button.html)
- [Adding a Custom Admin Bar Button](/tutorials/adding-admin-bar-external-links.html)
- [Admin-bar Customization in Our Tutorial Project](/tutorials/admin-ui.md)

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Building Navigation
DOC_PATH: tutorials/building-navigation.md
URL: https://apostrophecms.com/docs/tutorials/building-navigation
================================================================================
# Building site navigation

Almost every website needs some kind of primary navigation. For Apostrophe sites there are two main approaches to adding and maintaining site navigation:

1. **Use the page tree** to automatically generate navigation for pages
2. **Manually build the site nav** using an array field

::: info
This code recipe discusses specifically how to build site-wide navigation. Keep in mind that the same concepts can be applied to build other kinds of navigation, including nav for certain sections of at website or contextual nav for a page's children.

## Generating site navigation from the page tree

One of the defining features of pages in Apostrophe is that they exist in a hierarchy. Even if we added all pages on a website as siblings (the same hierarchy level) they would still all be children of the home page. This structure is expressed through the [page tree](/guide/pages.md#connecting-pages-with-page-tree-navigation).

The Apostrophe demo site is a small example of common page tree structure. Under the home page there are two **top-level pages**. One of those pages, "Editor Experience," has three additional **child pages**, making it their **parent page**. These pages can all be rearranged through drag-and-drop interaction.

![Screenshot of the Apostrophe demo page structure in the page manager UI](/images/recipes/demo-page-tree.png)

Apostrophe templates have access to this page tree using `data.home._children`, an array of top-level page data objects. Templates also have access to the children of the page a visitor is on, but since we're focused on the main site navigation, we want to use the home page's children. Home page children do not change as visitors move around the website.

As explained on the [pages guide](/guide/pages.md#connecting-pages-with-page-tree-navigation), we can loop over `data.home._children` and print the pages' URLs and titles in a list. Once you add some classes and CSS, this can work great as site navigation. And since it is based on the page tree structure **it will automatically stay up to date as editors update page content**.

<AposCodeBlock>

  ``` nunjucks
  <header>
    <nav>
      <ul>
        {# üëá Referencing `data.home._children` and looping over them. #}
        {% for page in data.home._children %}
          <li>
            <a href="{{ page._url }}">{{ page.title }}</a>
          </li>
        {% endfor %}
      </ul>
    </nav>
  </header>
  ```
  <template v-slot:caption>
    views/layout.html
  </template>
</AposCodeBlock>

### Change page tree data in templates

The example above is a very simple site navigation. It includes only the top-level pages and the basic data available for each page. In some cases you may want different data from the page tree for your navigation. The direct way to do this is to alter the **query builders** that the core page module uses to get that data.

The *default* query builder options for the page module look like this:

<AposCodeBlock>

  ``` javascript
  module.exports = {
    options: {
      builders: {
        children: true,
        ancestors: {
          children: true
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

For example, **to include two levels of pages in template ancestor data** we would add to the `builders` option that ancestors (such as the home page) should include two levels of child pages (`depth: 2`).

<AposCodeBlock>

  ```javascript
  module.exports = {
    options: {
      builders: {
        children: true,
        // `ancestors` includes the home page, so we adjust things there.
        ancestors: {
          children: {
            depth: 2
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

::: info
If using the `depth: 2` builder option, the each page in the `data.home._children` array will include their own `_children` array with any child pages, if they have any.

By default the page data object includes all properties from the database document. We can **limit that returned data** (for a minor speed improvement and clearer logging). One good approach to this is to set `areas: false` and `relationships: false` to remove area and relationship field data, which can get large.

<AposCodeBlock>

  ``` javascript
  module.exports = {
    options: {
      builders: {
        children: true,
        ancestors: {
          children: {
            depth: 2,
            areas: false,
            relationships: false
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

If pages had **thumbnail images we wanted to show in the navigation**, we can include that as well. If we had added an area field called `thumbnail` to the page schema, we could adjust our `areas` option to only include that one area field by name. (The relationship field data from the image widget isn't stored directly on the page.)

<AposCodeBlock>

  ``` javascript
  module.exports = {
    options: {
      builders: {
        children: true,
        ancestors: {
          children: {
            depth: 2,
            // üëá Now including the area data
            areas: [ 'thumbnail' ],
            relationships: false
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/page/index.js
  </template>
</AposCodeBlock>

We would then display the image [using an `area` tag](/guide/media.html#the-image-widget-option) or [the template methods for accessing the image attachment](/guide/media.html#the-relationship-field-option).

As you can see, page templates come ready with page tree data that is ready to become site navigation. With additional configuration, we can customize the data that templates give us. The examples above are only a few such ways to configure it.

## Add fields for manual nav building

The other common approach to site navigation is to let editors build it manually. They would be able to choose the specific page links and the order in which the links should appear. Since the site nav is the same across every page (in most cases), we store the navigation data in [global settings](/guide/global.md).

Before we look at a code example, let's think about how we would want to define fields for site navigation.

- Website navigation is an ordered list of links, some of which might contain their own list of links (second-level navigation). This translates well to an array structure, so **we use an [`array` field](/reference/field-types/array.md)**.
- Navigation items might usually be pages on the website, but they also might be external links, links to files, or even might not be links at all in order to prioritize a second-level navigation. We won't get into all of those cases, but this means that we want to **let editors choose the navigation item type**.
- Finally, each type of navigation item works differently. We will **use conditional logic to only show the correct fields** based on the chosen nav item type.

With those ideas in mind, we can look at an example of project-level global module configuration that adds a navigation array field. To keep this relatively simple this will only include two navigation item types.

<AposCodeBlock>

  ``` javascript
  module.exports = {
    fields: {
      add: {
        // Adding our array field, `primaryNav`
        primaryNav: {
          label: 'Primary site navigation',
          type: 'array',
          titleField: 'label',
          // The array schema for each item
          fields: {
            add: {
              label: {
                label: 'Nav item label',
                type: 'string'
              },
              type: {
                label: 'Link type',
                type: 'select',
                choices: [
                  {
                    label: 'Page',
                    value: 'page'
                  },
                  {
                    label: 'Custom URL',
                    value: 'custom'
                  }
                ]
              },
              _page: {
                label: 'Page to link',
                type: 'relationship',
                withType: '@apostrophecms/page',
                max: 1,
                required: true,
                builders: {
                  project: {
                    title: 1,
                    _url: 1
                  }
                },
                // Only if it's a page link
                if: {
                  type: 'page'
                }
              },
              customUrl: {
                label: 'URL for custom link',
                type: 'url',
                required: true,
                // Only if it's a custom link
                if: {
                  type: 'custom'
                }
              },
              // A nice option to have the link open in a new tab
              target: {
                label: 'Will the link open a new browser tab?',
                type: 'checkboxes',
                choices: [
                  {
                    label: 'Open in new tab',
                    value: '_blank'
                  }
                ]
              }
            }
          }
        }
      }
    }
  }
  ```
  <template v-slot:caption>
    modules/@apostrophecms/global/index.js
  </template>
</AposCodeBlock>

The field schema above adds an array field whose schema has five additional fields (remember: array fields have their own field schema for each array item):

1. The nav item label, which is also the array field's `titleField` for the user interface
2. The link type (linking to an internal page or external URL)
3. A relationship field to an internal page, if the page link option is chosen
4. A URL field, if the custom URL option is chosen
5. An option to mark the link to open in a new tab (a nice option for editors to have)

![The global settings editor with nav array field](/images/recipes/nav-array-field.png)

![The nav items array editor showing custom URL fields](/images/recipes/nav-array-schema.png)

The final step is to turn the array data from this into template markup. We will loop over the array of links and render the links based on what type they are. Page links are relationship data, so they are constructed differently from custom URL links, which are simply string values.


<AposCodeBlock>

  ``` nunjucks
  <header>
    <nav>
      <ul>
        {# üëá Referencing the global doc `primaryNav` property #}
        {% for item in data.global.primaryNav %}
          <li>
            {% set path = '' %}
            {% set pageTitle = '' %}
            {% set selectedClass = '' %}
            {% if item.type === 'page' and item._page and item._page[0] %}
              {% set path = item._page[0]._url %}
              {% set pageTitle = item._page[0].title %}
              {% if data.page.title == pageTitle %}
                {% set selectedClass = 'selected' %}
              {% endif %}
            {% elif item.type === 'custom' %}
              {% set path = item.customUrl %}
            {% endif %}
            <a href="{{ path }}" class="{{ selectedClass }}"
              {% if item.target[0] === '_blank' %} target="_blank" {% endif %}
            >{{ item.label or pageTitle }}</a>
          </li>
        {% endfor %}
      </ul>
    </nav>
  </header>
  ```
  <template v-slot:caption>
    views/layout.html
  </template>
</AposCodeBlock>

In addition to adding more link types to the schema, the template example can be changed depending on the project needs.

## Constructing breadcrumb navigation

Breadcrumb navigation shows visitors the series of pages from the page they are on back to the home page. It could end with some other major landing page, but our example will lead back to the home page. To add bread crumbs to a page we use very similar techniques to those shown above for a website's primary navigation. Instead of using `data.home`, we use `data.page._ancestors`.

**What is breadcrumb navigation, really?** If we think through the pieces of breadcrumb nav, we are looking at: *A series of links, usually starting with the home page, proceeding through the page tree, down to the page we are on.*

`data.page._ancestors` perfectly matches this goal. It is an array of page objects, starting with the home page, continuing through the page tree and ending with the parent of the rendered page. Perfect! To turn that into a breadcrumb navigation, we simply need to **loop through `data.page._ancestors`, add a link for each ancestor**.

The only tricky part comes at the end. If a visitor is on a piece's [show page](/guide/piece-pages.md#the-show-page-template), then `data.page` will actually be the index page. If `data.piece` exists (indicating we're rendering a show page), we will link to the index page (`data.page`) in the breadcrumbs, otherwise we'll simply print the current page's title.

<AposCodeBlock>

  ``` nunjucks
  {# Breadcrumb trail to the current page or piece. Not on the home page #}
  {% if data.page and data.page._ancestors.length %}
    <nav class="breadcrumb">
      {# Loop over the ancestors. #}
      {% for page in data.page._ancestors %}
        <a href="{{ page._url }}">{{ page.title }}</a> ‚û°
      {% endfor %}
      {% if data.piece %}
        {# We're rendering a show page. #}
        <a href="{{ data.page._url }}">{{ data.page.title }}</a>  ‚û°
        <span>{{ data.piece.title }}</span>
      {% else %}
        {# We're rendering a normal page. #}
        <span>{{ data.page.title }}</span>
      {% endif %}
    </nav>
  {% endif %}
  ```
  <template v-slot:caption>
    views/layout.html
  </template>
</AposCodeBlock>

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Harnessing Dynamic Routing
DOC_PATH: tutorials/dynamic-routing.md
URL: https://apostrophecms.com/docs/tutorials/dynamic-routing
================================================================================
# Dynamic Routing with dispatch() and dispatchAll()
![Screen capture of the dog breed images page created in the tutorial](../images/dispatch-dog-breeds.png)
In many of our projects, accessing dynamic data from an API is a key requirement, whether it's a list of products or customer support tickets. In this tutorial, we will learn how to harness the power of built-in Apostrophe methods to create a dynamic module for fetching and displaying content. To add an element of fun, we'll use DaaS (dogs as a service) to fetch info about our beloved canine companions! Our goal is to develop a module where each dog breed is featured on its own page, dynamically generated and populated with data from an API. This means no manual data entry, just seamless integration and display of information about Fido, Milou, Hachiko, or your favorite canine.

One solution to this task might be to use pieces and the `@apostrophecms/piece-page-type` module. This module utilizes the `dispatch()` and `dispatchAll()` methods from the `@apostrophecms/page-type` module for rendering templates for all pieces (`index.html`) and individual pieces (`show.html`). While effective, this approach requires manual data entry, a time-consuming task, especially with extensive datasets like dog breed information.

In this tutorial, we'll introduce a more efficient method. We'll demonstrate how to fetch and cache data from an API, and then use the `dispatch()` and `dispatchAll()` methods in a custom module to dynamically present this content. This strategy not only conserves time but also ensures your site remains current with the latest data from the API. Let's get started! üêïüåüüêæ

::: info
As we dive into our tutorial, we are assuming that you have an existing ApostropheCMS project set up. If you're just starting and need to create a project, no worries! Simply follow the [instructions](/guide/development-setup.html#creating-a-project) provided in our documentation to get up and running with the ApostropheCMS CLI tool.

## Creating the `index.js` file
Our first step will be to introduce a new page type into our project, specifically designed to showcase our dog API information. Inside the project `modules` folder create a `dog-page` folder with an `index.js` file inside. Edit that file to contain the following:

<AposCodeBlock>

```javascript
module.exports = {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Dogs Page'
  }
};
```
  <template v-slot:caption>
    modules/dog-page/index.js
  </template>

</AposCodeBlock>

This module also needs to be registered in your project `app.js` file and added to the `modules/@apostrophecms/page/index.js` in the `types` array of the `options`. Check out the [documentation page](/guide/pages.html#creating-a-page-type) for detailed instructions.

We are just going to construct a simple page for our tutorial, so we aren't going to add any additional fields to our page schema. Instead, we will be using a module customization function, `methods(self)`, to extend the page-type methods to fetch and cache our data, and then add our new routes.

### Fetching data from the API

To start, we will add a new method for fetching data from an endpoint passed in as an argument. We are also using the Apostrophe cache to store the data so that we don't have to repeatedly hit the API for data that we have already accessed.

<AposCodeBlock>

```javascript
...
methods(self) {
  return {
    // Generic method to fetch and cache data
    async fetchAndCacheData(apiUrl, cacheNamespace, cacheKey) {
      try {
        // Attempt to retrieve from cache
        let data = await self.apos.cache.get(cacheNamespace, cacheKey);
        if (!data) {
          // Fetch from API if not in cache
          const response = await fetch(apiUrl);
          data = await response.json();
          // Cache the data for 1 hour
          await self.apos.cache.set(cacheNamespace, cacheKey, data, 3600);
        }
        // We are returning the 'message' object, not the whole result
        return data.message;
      } catch (error) {
        console.error(`Error fetching data from ${apiUrl}:`, error);
        return {};
      }
    }
  }
}
```

  <template v-slot:caption>
    modules/dog-page/index.js
  </template>

</AposCodeBlock>

This method is relatively generic and could be used for most data APIs. It has a `try...catch` block to either return the API data or catch any errors. In the `try` block, we first attempt to set the value of the `data` variable to any cached data. The `@apostrophecms/cache` module [`get()` method](/reference/modules/cache.html#async-get-namespace-key) takes a cache namespace string as the first argument and returns any data in that namespace associated with the key string passed in the second argument.

In this case, if the data isn't cached, we fetch the data from the passed endpoint and then use the cache module [`set()` method](/reference/modules/cache.html#async-set-namespace-key-value-lifetime) to make it accessible if it is requested again. Note that we are setting that cache to expire after 3600 seconds (1 hour).

Finally, we are returning the `message` object from the response. This is specific to the [Dog API](https://dog.ceo/dog-api/documentation) that I'm using in this example, so this line might need to be altered when using other APIs.

::: info A Request
The API that we are using is being hosted by a kind individual at [dog.ceo](https://dog.ceo/). If you find this tutorial useful and have hit his endpoint repeatedly, we encourage you to check out his site and maybe buy him some dog treats to support his hosting costs.

### Dynamic Routing with `dispatch()` and `dispatchAll()`
Now that we have set up our module and integrated a method for fetching and caching data from our dog breed API, it's time to explore the heart of dynamic routing in ApostropheCMS - the `dispatch()` and `dispatchAll()` methods. These methods allow you to create routes that respond dynamically to various URL patterns.

The [`dispatch(pattern, ...middleware, handler)` method](/reference/modules/page-type.html#dispatch-pattern-middleware-handler) provides a way to add Express-style routing for ApostropheCMS pages. The `pattern` argument is a string that can contain a mix of static and dynamic values, where dynamic values are preceded with a `:`. For example, in the pattern `/user/:userId`, `:userId` is a dynamic segment that will match any string in its place. When a URL matches the pattern, the dispatch function then passes the req to optional middleware and then the final handler. In an ApostropheCMS project, this handler often includes the `setTemplate()` helper method that selects which template will be rendered.

The `dispatchAll()` method is a utility for registering multiple `dispatch()` routes at once. This method is invoked during project startup within the `init` method of the `@apostrophecms/page-type` module. This allows for all of your dynamic routes to be ready as soon as your project is fully spun up.

Add the following to the methods section of your `dog-page` module `index.js` file.

<AposCodeBlock>

```javascript
dispatchAll() {
  // Route for all breeds
  self.dispatch('/', async (req) => {
    // API-specific endpoint for listing all breeds
    const apiUrl = 'https://dog.ceo/api/breeds/list/all';
    req.data.breeds = await self.fetchAndCacheData(
      apiUrl,
      'breedData',
      'all'
    );
    return self.setTemplate(req, 'breedList');
  });
  // Route for specific breeds and varieties
  self.dispatch('/:breed/:variety?', async (req) => {
    const { breed, variety } = req.params;

    // Build the API URL and cache key
    const apiUrl = variety
      ? `https://dog.ceo/api/breed/${breed}/${variety}/images`
      : `https://dog.ceo/api/breed/${breed}/images`;
    const cacheKey = variety ? `${breed}-${variety}` : breed;

    // Fetch and cache breed images
    req.data.images = await self.fetchAndCacheData(
      apiUrl,
      'breedData',
      cacheKey
    );
    req.data.breed = variety ? `${variety} ${breed}` : breed;
    return self.setTemplate(req, 'breedImages');
  });
}
```
  <template v-slot:caption>
    modules/dog-page/index.js
  </template>

</AposCodeBlock>

#### Fetching the breed list
The first `dispatch()` method has a pattern of `/`. This means that it will match the base slug for each page of this type. So, if your page has a slug of `dogs`, it will match, `https://mysite.com/dogs`. When a user makes a request to this page, this method will intercept the rquest and make a call to the `fetchAndCacheData()` method. It will pass the namespace `breedData` and the key `all` to check for cached data. The returned data will be added to the `req` object as `data.breed` for retrieval in our template. Finally, the modified `req` will be passed to the `setTemplate()` helper method to designate that the `breedList.html` template from the module `views` folder should be rendered in the browser.

#### Fetching the breed images
Looking at the [breed list returned by the API](https://dog.ceo/dog-api/documentation/), we can see that for some of the breeds, there are multiple varieties, while for others there is only a single. This means that we need to come up with a strategy to provide routes for both. The second `dispatch()` method has a more complicated pattern, `/:breed/:variety?` to deal with this situation. It will match the base slug for the page, plus at least one additional dynamic parameter that specifies the breed and an optional parameter for the variety as indicated by the appended question mark. So this pattern would match both `https://mysite.com/dogs/pug` and `https://mysite.com/dogs/bulldog/boston`.

An alternative to combining these two routes in one pattern is to create two separate `dispatch()` methods. The first would set the template based on breed and the second on variety.

```javascript
self.dispatch('/:breed', async req => { ... })
self.dispatch('/:breed/:variety', async req => { ... })
```
Separation of the routes makes sense when the handling of the dynamic parameters differs significantly.

The handler in this case is also a little more complicated in order to construct the correct endpoint for whether there is a variety included or not. The returned data is again added to the `req` object and then used to designate that the `breedImages.html` template should be rendered in the browser.

## Creating the template files
Now that we have set up our dispatch routes, we need to create the templates that will be used for each route. To keep the tutorial simple, we will only cover the parts of the templates that are specific to dealing with data returned by the dispatch callbacks. However, these templates also have some custom styling to create a lightbox for the images and allow the user to return to the list of all breeds.

### The `breedList.html` template
Create a `views` folder in your custom module and add a `breedList.html` file inside. This is the file that will display a list of all our breeds returned by the API. Add the following code:

<AposCodeBlock>

```nunjucks
{% extends 'layout.html' %}

{% block main %}
  <h1>Dog Breeds</h1>
  <div class="divider"></div>
  <div class="breed-columns">
    {% for breed, varieties in data.breeds %}
      <div class="breed-column">
        <h2>{{ breed | capitalize }}</h2>
        {% if varieties and varieties.length > 0 %}
          <ul>
            {% for variety in varieties %}
              <li>
                <a href="{{ data.page._url }}/{{ breed }}/{{ variety }}">{{ variety | capitalize }} {{ breed | capitalize }}</a>
              </li>
            {% endfor %}
          </ul>
        {% else %}
          <a href="{{ data.page._url }}/{{ breed }}">{{ breed | capitalize }}</a>
        {% endif %}
      </div>
    {% endfor %}
  </div>
{% endblock %}
```
  <template v-slot:caption>
    modules/dog-page/views/breedList.html
  </template>

</AposCodeBlock>

This template is a straightforward Nunjucks template. It retrieves the API data from the `data` object. For each breed, it creates a block of markup with either a single link if there is a single variety, or multiple links if there is more than one. We will use CSS to arrange these blocks of code into a responsive grid. The links themselves will create the pattern for our second `dispatch()` method, either `/:breed` or `/:breed/:variety`.

### The `breedImage.html` template
To display the breed images to the user we need a separate template that parses all of the image links passed back from the API. Create a `breedImage.html` file in the `views` folder of your module and add the following:

<AposCodeBlock>

```nunjucks
{% extends 'layout.html' %}

{% block main %}
<h1>Dog Breed Gallery</h1>
<h2>Images of {{data.breed | capitalize}}</h2>
<div class="image-grid">
  {% for imageUrl in data.images %}
  <a href="#img{{ loop.index }}" class="image-container">
    <img src="{{ imageUrl }}" alt="Dog image" />
  </a>
  <div id="img{{ loop.index }}" class="lightbox">
    <div class="lightbox-content">
      <a href="#close" class="close">&times;</a>
        <img src="{{ imageUrl }}" />
        <p>Image {{ loop.index }}</p>
    </div>
  </div>
  {% endfor %}
</div>
<a href="{{ data.page._url }}" role="button" class="back-to-list-button">Back to Breed List</a>
{% endblock %}
```
  <template v-slot:caption>
    modules/dog-page/views/breedImages.html
  </template>

</AposCodeBlock>

Again, this is a straightforward Nunjucks template. We are using a loop to display each of the images sent back from the API. To allow for lightbox functionality when the user clicks an image, we have enclosed each in a link with a `href` created from the `loop.index`. We have also created a div with an `id` constructed from this same index.

Finally, since clicking on an image to open a lightbox will alter the browser history and the functionality of the back button, we are providing a button to go back to the breed list. Individual breed pages, like `/dogs/pug`, aren't stored in the database but are dynamically generated. As such, navigating to one of these breed-specific pages is still technically a request for the parent `/dogs` page, so the URL for the breed list page will be contained in `data.page._url`.

### Adding styling
The only thing left to do on this project is to add a bit of styling. There are a number of locations in your ApostropheCMS project where you can add styling. If you prefer to keep your styling all in one place you can add it to a folder like `modules/asset/ui/src` or you can add it to a similar location on a per-module level. We are going to do the later, so create a `modules/dog-page/ui/src/index.scss` file. In general, I prefer to add my styling into individual files within a `scss` folder and then import them through the `index.scss` file. In this case, we will take the simple route of adding the styling directly to the index. Add the following code:

<AposCodeBlock>

```scss
// General styles
main {
  max-width: unset;
  width: 90%;
}
a[name="main"] {
  display: none;
}
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 20px;
  background-color: #f4f4f4;
  color: #333;
}
h1 {
  text-align: center;
  margin-bottom: 20px;
  color: #0056b3;
  background-color: #fff;
  padding: 10px;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
a {
  display: block;
  padding: 10px;
  background-color: #4b21e3;
  border-radius: 5px;
  text-decoration: none;
  color: #fff;
  font-weight: bold;
  text-align: center;
  transition: background-color 0.3s ease;

  &:hover {
    background-color: #0275d8;
  }
}

// Styling for the breed list page
.divider {
  border-top: 5px solid #0056b3;
  margin: 20px 0;
}
.breed-columns {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}
.breed-column {
  flex-basis: calc(33% - 50px);
  margin: 10px;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  padding: 15px;

  > h2 {
    justify-content: left;
  }

  & a:visited {
    color: #fff;
  }
}
@media screen and (max-width: 880px) {
  .breed-column {
      flex-basis: calc(50% - 50px);
  }
}
@media screen and (max-width: 480px) {
  .breed-column {
      flex-basis: 100%;
  }
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  margin-bottom: 10px;
}

// Styling for the breed pages
.image-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 15px;
  padding: 15px;
}
.image-container {
  overflow: hidden;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  img {
    width: 100%;
    height: 100%;
    object-fit: cover; // This ensures images cover the area without distortion
    transition: transform 0.3s ease;

    &:hover {
        transform: scale(1.05);
    }
  }
}

/* Lightbox styles */
.lightbox {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  align-items: center;
  justify-content: center;
}
.lightbox:target {
  display: flex;
}
.lightbox-content {
  position: relative;
  max-width: 80%;
  max-height: 80%;
  margin: auto;
  padding: 10px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.lightbox-content img {
  max-width: 100%;
  max-height: 100%;
  display: block;
  margin: auto;
}
.close {
  position: absolute;
  top: 10px;
  right: 15px;
  text-decoration: none;
  font-size: 30px;
  color: black;
}

/* Back to list button */
.back-to-list-button, .back-to-list-button:visited {
  position: fixed; /* Fixed position relative to the viewport */
  bottom: 20px; /* 20px from the bottom */
  right: 20px; /* 20px from the right */
  background-color: #007bff; /* Background color */
  color: white; /* Text color */
  padding: 10px 15px; /* Padding around the text */
  text-decoration: none; /* Remove underline from link */
  border-radius: 5px; /* Rounded corners */
  font-size: 16px; /* Font size */
  z-index: 1100; /* Ensure it's above other elements */
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); /* Shadow for a "floating" effect */
  transition: background-color 0.3s; /* Transition for hover effect */

  &:hover {
    background-color: #0056b3; /* Darker shade when hovered */
  }
}
```
  <template v-slot:caption>
    modules/dog-page/ui/src/index.scss
  </template>

</AposCodeBlock>

Congratulations on reaching the end of this tutorial! We've covered a lot of ground, delving into dynamic routing in ApostropheCMS using the `dispatch()` and `dispatchAll()` methods. By now, you should have a good understanding of how to create dynamic modules for fetching and displaying content from an API. It's worth noting that `dispatch()`
 is versatile and not limited to API use cases. You can also use it for dynamically serving content from local files, perfect for static datasets, mock data during development, or offline functionality.

We hope you found this tutorial enlightening and enjoyable. Happy coding, and may your projects be as dynamic and lively as the dog breeds we explored! üéâüêïüåê

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Creating Better Help Text
DOC_PATH: tutorials/help-and-placeholder-text-best-practices.md
URL: https://apostrophecms.com/docs/tutorials/help-and-placeholder-text-best-practices
================================================================================
# Help and Placeholder Text Best Practices in ApostropheCMS

::: tip Howdy! üëãüèª
This tutorial is available in textual and video forms. Watch the video and use this page to copy code into your project, or continue reading if you prefer. Of course, you can also do both!

<iframe width="560" height="315" src="https://www.youtube.com/embed/Zuj-_UDMzNU?si=Bw1DoQ-2knJSfLZW" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Why This Matters & Core Principles

Ever had a content editor ask, ‚ÄúWhat does this field mean?‚Äù You‚Äôre not alone.

In ApostropheCMS, how you label fields ‚Äî and the help you give editors through placeholders and help text ‚Äî directly shapes their experience. Clear, consistent field guidance doesn‚Äôt just reduce errors and support accessibility; it builds trust and confidence for anyone using the CMS.

This short guide shows you how to write helpful labels, implement localized help text, and use placeholders where appropriate ‚Äî so your projects are easier to use and faster to train people on.

When implementing field guidance in your ApostropheCMS project, prioritize:
- **Clarity**: Use concise, straightforward language that avoids technical jargon
- **Consistency**: Maintain a uniform style and tone across all help elements
- **Context**: Provide guidance that anticipates common questions in each specific situation
- **Localization**: Design all text to support multiple languages via translation strings
- **Accessibility**: Ensure guidance is available to all users including those with assistive technologies

<!-- VIDEO: Field Help Text Best Practices Tutorial -->

## Types of Field Guidance in ApostropheCMS

ApostropheCMS provides several ways to guide content editors through their work:

1. **Help text**: Explanatory text below a field label that provides context or instructions
2. **Placeholder text**: Hint text inside selected empty schema fields that suggests the expected input
3. **Field labels**: The primary identifier for each field (always required)

Each component serves a specific purpose in guiding editors through content creation.

## Implementing Effective Help Text

Help text appears directly below the field label, providing context about a field's purpose or usage guidelines. This is the primary method for delivering guidance to content editors.

### Basic Implementation

Always use [translation strings](/guide/localization/static.html#localizing-schema-field-labels) for help text to support localization:

<AposCodeBlock>

```javascript
export default {
  i18n: {
    myproject: {
      browser: true
    }
  },
  fields: {
    add: {
      metaDescription: {
        type: 'string',
        label: 'myproject:metaDescription',
        help: 'myproject:metaDescriptionHelp',
        textarea: true,
        max: 160
      }
    }
  }
};
```
<template v-slot:caption>
  modules/article/index.js
</template>
</AposCodeBlock>

Then define your translated strings in a localization file:

<AposCodeBlock>

```json
{
  "metaDescription": "Meta Description",
  "metaDescriptionHelp": "A brief summary (max 160 characters) describing the page content for search engines. This text may appear in search results."
}
```
<template v-slot:caption>
  modules/localization/i18n/myproject/en.json
</template>
</AposCodeBlock>

### Using HTML in Help Text

For more complex guidance that requires formatting, ApostropheCMS provides the `htmlHelp` option. This allows you to include HTML markup in your help text. You should only include either `help` or `htmlHelp`, not both:

<AposCodeBlock>

```javascript
export default {
  i18n: {
    myproject: {
      browser: true
    }
  },
  fields: {
    add: {
      imageAltText: {
        type: 'string',
        label: 'myproject:imageAltText',
        htmlHelp: 'myproject:imageAltTextHtmlHelp'
      }
    }
  }
};
```
<template v-slot:caption>
  modules/article-image/index.js
</template>
</AposCodeBlock>

With corresponding translation strings:

<AposCodeBlock>

```json
{
  "imageAltText": "Alt Text",
  "imageAltTextHtmlHelp": "<p>Good alt text should:</p><ul><li>Be specific and descriptive</li><li>Convey the image's purpose</li><li>Be under 125 characters</li><li>Not start with 'Image of' or 'Picture of'</li></ul>"
}
```
<template v-slot:caption>
  modules/localization/i18n/myproject/en.json
</template>
</AposCodeBlock>

Some effective uses for `htmlHelp`:
- Providing step-by-step instructions
- Displaying formatted lists of best practices or requirements
- Including multiple paragraphs of guidance for complex fields
- Highlighting important warnings or recommendations

### Best Practices for Writing Help Text

1. **Keep it concise**: Aim for 1-2 short sentences that provide immediate clarity
2. **Include technical constraints**: Mention character limits, formatting requirements, or other constraints
3. **Explain the purpose**: State why this field matters and how it will be used
4. **Avoid technical jargon**: Use terminology familiar to your content editors
5. **Use active voice**: "Enter your headline" is clearer than "Headline should be entered"

> [!TIP]
> When a field has both character limits and guidance, combine them in the help text rather than relying solely on the UI character counter: "Brief description for social sharing (5-10 words recommended, 30 words maximum)."

## Using Placeholder Text Effectively

Placeholder text appears inside empty fields, suggesting the type of content expected. It disappears when the user begins typing.

> [!NOTE]
> Placeholders are only supported for specific field types: email, float, integer, string, and url.

### Implementation Example

<AposCodeBlock>

```javascript
export default {
  i18n: {
    myproject: {
      browser: true
    }
  },
  fields: {
    add: {
      ctaButtonText: {
        type: 'string',
        label: 'myproject:ctaButtonText',
        help: 'myproject:ctaButtonTextHelp',
        placeholder: 'myproject:ctaButtonTextPlaceholder'
      }
    }
  }
};
```
<template v-slot:caption>
  modules/call-to-action/index.js
</template>
</AposCodeBlock>

With corresponding translation strings:

<AposCodeBlock>

```json
{
  "ctaButtonText": "Button Text",
  "ctaButtonTextHelp": "The text displayed on the action button.",
  "ctaButtonTextPlaceholder": "Learn More"
}
```
<template v-slot:caption>
  modules/localization/i18n/myproject/en.json
</template>
</AposCodeBlock>

### When to Use Placeholder Text

Placeholder text works best in these scenarios:
- **Showing format examples**: Phone numbers, dates, product codes
- **Suggesting common values**: "Learn More", "Subscribe", "Download"
- **Illustrating syntax**: How hashtags or other special formatting should look

### Placeholders and Accessibility

While placeholders can be helpful, they have accessibility limitations:
- They disappear when typing begins
- They may have insufficient color contrast
- Screen readers handle them inconsistently

**For this reason, never use placeholders as the only way to convey essential information.** Always include critical guidance in the help text or label.

## Field Label Writing Tips

Although labels are required for all fields, their quality significantly impacts the editing experience:

<AposCodeBlock>

```javascript
export default {
  fields: {
    add: {
      // Less helpful label
      img: {
        type: 'attachment',
        label: 'Image'
      },
      // More helpful label
      heroImage: {
        type: 'attachment',
        label: 'Hero image',
        help: 'Large banner image displayed prominently at the top of the page. Recommended size: 1920x1080 pixels for best quality across devices.'
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms/home-page/index.js
  </template>
</AposCodeBlock>

### Field Label Guidelines

1. **Be specific**: Use precise terms that indicate the field's purpose ("Hero image" vs. "Image")
2. **Maintain consistency**: Use the same terminology across similar fields
3. **Avoid technical terms**: Write labels from the content editor's perspective
4. **Keep it concise**: Aim for 1-3 words that clearly identify the field
5. **Use sentence case**: Capitalize the first word only, unless using proper nouns

## Conclusion

Thoughtful implementation of help text, placeholders, and labels transforms the content editing experience from confusing to intuitive. This reduces training time, prevents errors, and ultimately leads to higher quality content on your site. Remember that small improvements to frequently used interfaces can significantly impact overall satisfaction with your CMS implementation.

---

**Related Resources:**
- [ApostropheCMS schema field types](/reference/field-types/index.md)
- [ApostropheCMS localization namespacing](/guide/localization/static.html#using-namespaces)

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Converting a Static Template
DOC_PATH: tutorials/html-conversion.md
URL: https://apostrophecms.com/docs/tutorials/html-conversion
================================================================================
# Converting a premade HTML template for use in an Apostrophe Project

Creating a web site from scratch can be a daunting process. Not only do you have to create the HTML markup, but also the styling to make it all look good. One way to get started quickly is to use one of the numerous premade templates available on the internet. In this tutorial, we will walk through the steps to convert the ["Start Bootstrap Clean Blog"](https://startbootstrap.com/theme/clean-blog) template into an Apostrophe template. While we are starting with a specific template, these steps can be generalized to any template you might download.

### Prefer to read? Scroll past the video.

::: tip
This tutorial is available in video and textual forms. Watch the video, or continue reading if you prefer. Of course, you can do both!

### Video - Converting an HTML template for use in Apostrophe

<iframe src="https://www.youtube.com/embed/KqzKrbCv5G4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

## Overview

Let's outline the steps that we need to perform.

1. Create a new starter kit project
2. Add the styling and scripts from the template to our project
3. Identify sections found on each page that can be converted into [fragments](/guide/fragments.md)
   - Navigation
   - Header
   - Footer
4. Modify the project core layout in `views/layout.html`
5. Create the apostrophe default page type
6. Add the blog pages using `apostrophecms/page`
   - create the index.html page
   - create the show.html page

## Template Introduction

This recipe is based on the Clean Blog template which is a free [download](https://startbootstrap.com/theme/clean-blog) from Start Bootstrap. This template contains 4 simple pages.

The "Home" page contains a listing of all the blog articles on the site.
![The template home page](../images/home-page.png)

This has an accompanying page to show the individual articles.

![The template 'show.html' page](../images/show-page.png)

This structure matches up nicely with the structure of the apostrophe `piece-page-type` with an `index.html` template to list all of the pieces and a `show.html` template to show each individual piece.

The final two pages are an "About" page and a "Contact Me" page, which have identical structures, just content differences.

![The 'Contact-me" page.'](../images/contact-me.png)

All of these pages have very similar headers containing fixed navigation, a large header image, and some text over the image.

They also all display an identical footer containing social links and some copyright text.

The styling of the template is a combination of the popular Bootstrap frontend styling framework and custom CSS.

Let's get started converting this template to an Apostrophe project!

## Creating a new project

If you don't already have the apostrophe CLI installed, follow the instructions [here](/guide/setting-up.md#the-apostrophe-cli-tool). Next, create a new project from the command line. Make sure you are in the directory where you want to create your new project folder and run the following command:

<AposCodeBlock>

``` sh
apos create template-app
```

</AposCodeBlock>

The CLI app will create the new project and an admin user. At the end of the installation, it will ask for an administrator password - make sure to remember this password for login.

## Adding Bootstrap and project styling

### Adding the styling

This particular template comes with both `dist` and `src` folders. Within the dist folder is a `css` folder that contains all of the compiled styling for the site. We could use this as the source for the styling of our project, but this wouldn't be as easy to modify with additional or custom styling variables.

Alternatively, the `src` folder contains an `scss` folder with all of the styling sheets and imports. Since this template utilizes Bootstrap, which has a npm package, we are going to install and then include the main styling from the `node-modules` folder. Open a terminal at the root of your project and install Bootstrap using:

``` sh
npm install bootstrap
```

::: info
This template uses Bootstrap 5, which is the latest version as of this writing. If you need another version for your template, make sure to specify it during the install.

The next thing we will do is copy the contents of the `scss` folder that contains all of the theme-specific styling into our project. While these files could be added to any Apostrophe module, we recommend creating an "asset" module just for your project. If you are using the CLI-created starter kit project, this module will already exist. If not, create a `modules/asset` folder and add the `asset` module to your `app.js` file. Next, within the `modules/asset` folder create a `ui/src` folder and copy the entirety of the `dist/scss` folder.

For the HTML template, the `styles.scss` file is the entry point for loading all of the individual scss sheets. For our Apostrophe project, we are going to move this sheet up one level from the `/scss` folder into the `ui/src` folder and rename it `index.scss`. If an Apostrophe module has a `ui/src/index.js` file it is automatically recognized and loaded. Other Sass files won't be loaded unless imported by such a file. Next, we need to edit this file to point to all of the theme-specific [partials](https://sass-lang.com/guide#topic-4). Looking at the file path for each `@import` statement, each partial or folder of partials is expected to be found in the same folder as the entry sheet. After copying it into our project, this is no longer true. Instead, all of the partials are located within the `scss` folder of the same directory. Modify all of the `@import` statements (except for the Bootstrap import) to point to the correct location by prefixing the path with the folder name:

<AposCodeBlock>

``` scss
// Import variables
@import './scss/variables';

// import bootstrap
// This path is pointing to the Bootstrap package in the node_module folder
@import 'bootstrap/scss/bootstrap';

// Global CSS
@import './scss/global';

// Components
@import './scss/components/buttons';
@import './scss/components/forms';
@import './scss/components/navbar';

// Sections
@import './scss/sections/footer';
@import './scss/sections/masthead';
@import './scss/sections/post';
```

<template v-slot:caption>
modules/asset/ui/src/index.scss
</template>
</AposCodeBlock>

The main Bootstrap components are loaded in from the `node_modules` where they were installed. An alternative to directly loading from the `node-modules`, which will load in every Bootstrap component, would be to import only those components needed for the project using `@import 'bootstrap/scss/_buttons';`, for example.

### Adding the Bootstrap and project JavaScript

Bootstrap has its own bundle of JavaScript. In addition, this template has a small, custom script that modifies the navigation based on scroll direction. We have multiple choices for adding the Bootstrap code to the page. We could elect to bring it in from a CDN. However, we have already installed the Bootstrap NPM package and are going to make a server call to load custom JavaScript, so instead, we can bundle all of our scripts into a single call.

Create another file named `index.js` within the `modules/asset/ui/src` folder. Within this file, we can import the main Javascript bundle and add the custom script from the template `src/js/scripts.js` file.

<AposCodeBlock>

``` javascript
// import the bootstrap.js and popper.js files from the node_modules
import bootstrap from 'bootstrap';

export default () => {
  //code from the template
  window.addEventListener('DOMContentLoaded', () => {
    let scrollPos = 0;
    const mainNav = document.getElementById('mainNav');
    const headerHeight = mainNav.clientHeight;
    window.addEventListener('scroll', function () {
      const currentTop = document.body.getBoundingClientRect().top * -1;
      if (currentTop < scrollPos) {
        // Scrolling Up
        if (currentTop > 0 && mainNav.classList.contains('is-fixed')) {
          mainNav.classList.add('is-visible');
        } else {
          mainNav.classList.remove('is-visible', 'is-fixed');
        }
      } else {
        // Scrolling Down
        mainNav.classList.remove(['is-visible']);
        if (
          currentTop > headerHeight &&
          !mainNav.classList.contains('is-fixed')
        ) {
          mainNav.classList.add('is-fixed');
        }
      }
      scrollPos = currentTop;
    });
  });
};
```

<template v-slot:caption>
  modules/asset/ui/src/index.js
</template>

</AposCodeBlock>

## Identifying common areas

Each of the four pages included in this template has some common areas that can be converted into [fragments](../guide/fragments.md). While all of the pages have both navigation and main header areas that occupy the same general area, we are going to split these into two fragments. That is because the navigation can get all of its settings from global, whereas the rest of the header area is going to get settings on a per-page basis. We will add each of the three fragments in the `views` folder at the project level.

### Adding the navigation

Inside the `views` folder create another folder named `fragments` and a file named `navigation.html`. To turn this page into a fragment, add opening and closing fragment block tags - `{% fragment navigationArea() %}` and `{% endfragment %}`.

Open one of the template pages and copy the navigation section. Paste this between the two fragment tags. To add the website brand to the navigation, we will replace the `href` with the homepage URL from `data.home._url`, which is available to all [templates](/guide/pages.md). We will add a simple text logo from user input in the apostrophe global settings.

Next, within the unordered list, delete the last three `<li>` items. To populate the list with each of the pages selected in the global settings we will use a `for` loop.

<AposCodeBlock>

``` nunjucks
{% fragment navigationArea() %}
<!-- Navigation-->
<nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
  <div class="container px-4 px-lg-5">
    <a class="navbar-brand" href="{{ data.home._url }}">{{ data.global.brand }}</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">Menu<i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ms-auto py-4 py-lg-0">
        {% for page in data.global.pages %}
        <li class="nav-item">
          <a class="nav-link px-lg-3 py-3 py-lg-4" href="{{ page._page[0]._url }}">{{ page.label }}</a>
        </li>
        {% endfor %}
      </ul>
    </div>
  </div>
</nav>
{% endfragment %}
```

<template v-slot:caption>
  views/fragments/navigation.html
</template>
</AposCodeBlock>

In this code block, we are surrounding one of the list items with our `for` loop. For each selected page we are adding a list item containing a link and label. This data will come from an `array` field schema field containing a `string` input for the label and a `relationship` field for the page link. Note that since this URL is populated from a `relationship` field, data will be delivered to the page in an array. So, we need to specify that we are getting the `_url` from the first array item.

All of the styling for our menu and each of the items will come from the Bootstrap class names we copied over with the HTML markup.

Next, we need to add the schema fields to populate our navigation menu. If your project doesn't already contain one, create a `modules/@apostrophecms/global/index.js` file. Our [tutorial](/tutorials/building-navigation.md) section has some more complicated methods for adding navigation. In this case, we are going to add a simple array schema field with a relationship to our pages.

<AposCodeBlock>

``` javascript
module.exports = {
  fields: {
    add: {
      brand: {
        type: 'string',
        label: 'Brand name',
        required: true
      },
      pages: {
        type: 'array',
        titleField: 'Pages',
        fields: {
          add: {
            label: {
              type: 'string',
              label: 'Page label'
            },
            _page: {
              label: 'Page to link',
              type: 'relationship',
              withType: '@apostrophecms/page',
              max: 1,
              required: true,
              builders: {
                project: {
                  title: 1,
                  _url: 1
                }
              }
            }
          }
        }
      }
    },
    group: {
      navigation: {
        label: 'Navigation links',
        fields: [ 'brand', 'pages' ]
      }
    }
  }
};
```

<template v-slot:caption>
  modules/@apostrophecms/global/index.js
</template>
</AposCodeBlock>

### Adding the footer

Much like we constructed the navigation, we are going to use a fragment populated with data from the apostrophe global settings for the footer. Create a `views/fragments/footer.html` file with a fragment block and paste the navigation area from any of the template pages between the blocks. In this case, we are going to replace each of the social links and the copyright text. You can choose to make the link for each social media account be required, or wrap each of the list items in an `if` block to make them optional.

<AposCodeBlock>

``` nunjucks
{% fragment footerArea() %}
<!-- Footer-->
<footer class="border-top">
  <div class="container px-4 px-lg-5">
    <div class="row gx-4 gx-lg-5 justify-content-center">
      <div class="col-md-10 col-lg-8 col-xl-7">
        <ul class="list-inline text-center">
          {% if data.global.twitterUrl %}
            <li class="list-inline-item">
              <a href="{{ data.global.twitterUrl }}">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          {% endif %}
          {% if data.global.facebookUrl %}
            <li class="list-inline-item">
              <a href="{{ data.global.facebookUrl }}">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-facebook-f fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          {% endif %}
          {% if data.global.githubUrl %}
            <li class="list-inline-item">
              <a href="{{ data.global.githubUrl }}">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          {% endif %}
        </ul>
        <div class="small text-center text-muted fst-italic">Copyright &copy; {{ data.global.copyright }}</div>
      </div>
    </div>
  </div>
</footer>
{% endfragment %}
```

<template v-slot:caption>
  views/fragments/footer.html
</template>
</AposCodeBlock>

Modify the global settings file to include the new footer schema fields.

<AposCodeBlock>

``` javascript
module.exports = {
  fields: {
    add: {
      // ...
      twitterUrl: {
        type: 'url',
        label: 'Twitter URL'
      },
      facebookUrl: {
        type: 'url',
        label: 'Facebook URL'
      },
      githubUrl: {
        type: 'url',
        label: 'Github URL'
      },
      copyright: {
        type: 'string',
        label: 'Copyright text',
        required: true
      }
    },
    group: {
      // ...
      footer: {
        label: 'Footer URLs and text',
        fields: [ 'twitterUrl', 'facebookUrl', 'githubUrl', 'copyright' ]
      }
    }
  }
};

```

<template v-slot:caption>
  modules/@apostrophecms/global/index.js
</template>
</AposCodeBlock>

::: info
An alternative way to add the social links would be to use an `array` schema field to collect the URL and logo class information. Then within the template loop over each item in the array to add them to the page. This would make the template code and logic a little cleaner.

### Adding the header

The headers of each page have an image and headline in common. They also each have a subheading, but the styling of that subheading depends on the type of page that is being displayed. Additionally, the header for the page displaying the individual blog articles also has metadata about the author and publication date. While we could have separate header template fragments, we can also use a conditional block to add the needed markup.

Create a `views/fragments/header.html` file and add the fragment block tags. Unlike the navigation and footer fragments that got their data from apostrophe's global settings, the header will get its data from the page. This means that we will have to pass data into our fragment within the block tags - `{% fragment headerArea(data) %}`.

Paste the page header section from the `index.html` template page in between the tags. This markup is present on the home, about, and contact pages. Once we create the blog article page we will come back and add the conditional block. Modify the heading and subheading to get field schema data from the page settings.

Adding an image as a background for the header will take some more complex modifications of the fragment. First, when we create the page settings, we will add a `headerImage` area that requires a maximum of one image through the `@apostrophe/image` widget. Within the template fragment we will retrieve that image using the `apos.image.first` and `apos.attachment.url` helpers.

<AposCodeBlock>

``` nunjucks
{% fragment headerArea(data) %}
{% set background = apos.image.first(data.headerImage) %}

<!-- Page Header-->
{% if background %}
  {% set backgroundUrl = apos.attachment.url(background, { size: 'max' }) %}
  <header class="masthead" style="background-image: url('{{ backgroundUrl }}')">
{% else %}
  <header class="masthead" style="background-color: blue;">
{% endif %}
    <div class="container position-relative px-4 px-lg-5">
      <div class="row gx-4 gx-lg-5 justify-content-center">
        <div class="col-md-10 col-lg-8 col-xl-7">
          <div class="site-heading">
            <h1>{{ data.heading }}</h1>
            <span class="subheading">{{ data.subheading }}</span>
          </div>
        </div>
      </div>
    </div>
  </header>
{% endfragment %}
```

<template v-slot:caption>
  views/fragments/header.html
</template>
</AposCodeBlock>

We will revisit the field schema for the header when we create our default page.

## Modifying the `layout.html` file

Now that we have our three common fragments setup, we need to start adding them to our pages. Again, the navigation and footer fragments are populated with data from the global settings. Therefore, we can add those fragments to our base layout file - `views/layout.html`. In addition, looking at the head section of the template files, we can see that the `fontawesome` and Google `Lora` and `Open Sans` fonts are being added. We can alter this same file to load those files into the head section

::: info
If your pages are being loaded and viewed in an EU country, serving fonts from Google might violate GDPR. There are multiple articles on the internet detailing how to download the files and host them locally in order to comply with GDPR.

The first modification we are going to make is to import our two fragments.

<AposCodeBlock>

``` nunjucks
{% import 'fragments/navigation.html' as navigation %}
{% import 'fragments/footer.html' as footer %}
```

</AposCodeBlock>

This will bring our fragments into the template and name them `navigation` and `footer`.

To load our font files we are going to take advantage of the `extraHead` section of the `outerLayout` template that our `layout.html` is extending. You can read the [documentation](/guide/layout-template.html) to learn about other sections of this template that can be extended. Add the `{% block extraHead %}{% endblock %}` tags after the `{% block title %}` section. Within those tags copy the fonts section of the head from any of the template pages. You can also see that there are links for the site favicon and some other meta tags in this section of the template. You can elect to add those if you desire.

Finally, delete all of the markup in the `beforeMain` and `afterMain` sections. into the `beforeMain` block render the navigation - `{% render navigation.navigationArea() %}`. In the `afterMain` block render the footer fragment = `{% render footer.footerArea() %}`. The final modification we can make to the template is to add the semantic `<main></main>` tags. Looking at the original template pages, we can see that the main section has a class of `mb-4`. This markup can be added around the `{% block main %}{% endblock %}` tags.

<AposCodeBlock>

``` nunjucks
{% import 'fragments/navigation.html' as navigation %}
{% import 'fragments/footer.html' as footer %}

{# Automatically extends the right outer layout and also handles AJAX siutations #}
{% extends data.outerLayout %}

{% set title = data.piece.title or data.page.title %}
{% block title %}
  {{ title }}
  {% if not title %}
    {{ apos.log('Looks like you forgot to override the title block in a template that does not have access to an Apostrophe page or piece.') }}
  {% endif %}
{% endblock %}

{% block extraHead %}
  <!-- Font Awesome icons (free version)-->
  <script src="https://use.fontawesome.com/releases/v6.1.0/js/all.js" crossorigin="anonymous"></script>
  <!-- Google fonts-->
  <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
{% endblock %}

{% block beforeMain %}
  {% render navigation.navigationArea() %}
{% endblock %}

<main class="mb-4">
{% block main %}
  {#
    Usually, your page templates in the @apostrophecms/pages module will override
    this block. It is safe to assume this is where your page-specific content
    should go.
  #}
{% endblock %}
</main>

{% block afterMain %}
  {% render footer.footerArea() %}
{% endblock %}

```

<template v-slot:caption>
  views/layout.html
</template>
</AposCodeBlock>

Note the use of `navigationArea()` and `footerArea()` in the `render` calls. If you look at the fragment files, you will see that the fragment blocks use these names. This is to allow for a single fragment file to have multiple fragments. We are using these names just to be a little clearer in our calls for this tutorial, but this could be cleaned up and both be called `area()` resulting in `{% render header.area() %}` and `{% render footer.area() %}`.

## Creating a default page

Now all of our pages will have our navigation and footer areas, but we need to add our header and all of the body content. We could make a separate file for each page of our site, but it makes sense to have a default page that will be used for the non-blog pages. We can use the existing `modules/default-page`.

We need to make two major modifications to the existing `default-page`. First, we need to import and display our header fragment. In this case, we want to add the header into the `beforeMain` block. In order to accomplish this we need to add the 
::: v-pre
`{{ super() }}`
call to include all of the `beforeMain` content from our layout template.

Second, we need to add the template styling and the main content area to the `main` block.

<AposCodeBlock>

``` nunjucks
{% extends "layout.html" %}

{% import "fragments/header.html" as header %}

{% block beforeMain %}
  {{ super() }}
  {% render header.headerArea(data.page) %}
{% endblock %}

{% block main %}
  <div class="container px-4 px-lg-5">
    <div class="row gx-4 gx-lg-5 justify-content-center">
      <div class="col-md-10 col-lg-8 col-xl-7">
        {% area data.page, 'main' %}
      </div>
    </div>
  </div>
{% endblock %}
```

<template v-slot:caption>
  modules/default-page/views/page.html
</template>
</AposCodeBlock>

Next, we need to modify the schema fields of the `default-page/index.js` file to add the data to the header and the main body of the page. For a number of the schema fields below, I'm choosing to make them required. You could instead leave them optional, but then wrap the areas where they are added to the templates in conditional statements in case the editor leaves the fields empty.

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Default Page'
  },
  fields: {
    add: {
      heading: {
        type: 'string',
        label: 'Heading',
        required: true
      },
      subheading: {
        type: 'string',
        label: 'Subheading',
        required: true
      },
      headerImage: {
        type: 'area',
        required: true,
        options: {
          widgets: {
            '@apostrophecms/image': {}
          },
          max: 1
        }
      },
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {
              toolbar: [
                'styles',
                '|',
                'bold',
                'italic',
                'strike',
                'link',
                '|',
                'bulletList',
                'orderedList'
              ],
              styles: [
                {
                  tag: 'p',
                  label: 'Paragraph (P)'
                },
                {
                  tag: 'h3',
                  label: 'Heading 3 (H3)'
                },
                {
                  tag: 'h4',
                  label: 'Heading 4 (H4)'
                }
              ]
            },
            '@apostrophecms/image': {},
            '@apostrophecms/video': {}
          }
        }
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [
          'title',
          'heading',
          'subheading',
          'headerImage',
          'main'
        ]
      }
    }
  }
};

```

<template v-slot:caption>
  modules/default-page/index.js
</template>
</AposCodeBlock>

Since we are modifying the project's existing `default-page/index.js` file, we don't need to modify either the `app.js` or `modules/@apostrophecms/page/index.js` files.

To accommodate the content on the 'Contact Us' page, we could also add the widgets from the [form extension](https://apostrophecms.com/extensions/form-builder-3-x) in the `main` area. 

### Modifying the logged-in page display
If we were to take a look at our page right now while logged-in as an editor, we would see a couple of problems. First, the navigation section is styled to be added at the top of the page using a `postion: absolute` CSS rule. The problem with this is that this ends up putting our navigation *over* the ApostropheCMS admin-bar. Not only can we not see the navigation, but this also blocks access to the admin-bar menus. So, we need to add some code onto the page that will move our navigation below the admin-bar in the page flow.

There are several areas in our project where we could add code to solve this problem. In this case, we will add a small script to our asset module again. While we could add it to `modules/asset/ui/src/index.js` along with the template code, this would result in the delivery of extra unnecessary JavaScript to all users. Instead, we will add the code into `modules/asset/ui/apos/apps`. This folder is commonly used in projects to add new custom Vue UI components and is only served to logged-in users.

<AposCodeBlock>

``` javascript
export default () => {
  // check that the admin-bar module exists
  const loggedIn = !!window.apos.modules['@apostrophecms/admin-bar'];
  if (loggedIn) {
    // wrap in `apos.util.onReady()` that fires when the page is loaded and at every refresh
    apos.util.onReady(() => {
      //get the admin-bar height
      const adminBarHeight =
        window.apos.modules['@apostrophecms/admin-bar'].height;
        // get the navigation ID - if you are using a different template, adjust accordingly
      const pageNav = document.getElementById('mainNav');
      // set the absolute position of the navigation to after the admin-bar
      pageNav.style.top = adminBarHeight + 'px';
    });
  }
};

```

<template v-slot:caption>
  modules/asset/ui/apos/apps/AdminBarHeight.js
</template>
</AposCodeBlock>


## Add the blog pages

The last two pages from the template are blog index and article pages. We could use the [blog module](https://apostrophecms.com/extensions/blog), but it has features we don't necessarily need for this template. So, to simplify this tutorial we will just create our blog `piece-type` and `piece-page-type`. We can do this using the CLI tool.

``` sh
apos add piece blog --page
```

Once we have these added to our project we need to modify the `app.js` file to include both.

<AposCodeBlock>

``` javascript
require('apostrophe')({
  modules: {
    // ...
    blog: {},
    'blog-page': {}
  }
});

```

<template v-slot:caption>
  app.js
</template>
</AposCodeBlock>

Additionally, the `blog-page` needs to be added to the `modules/@apostrophecms/page/index.js` file so that it is available in our page manager.

Next, we will modify the `modules/blog/index.js` file to include the necessary field schema. We need to add the header image and text, plus the actual blog content. This is essentially identical to the index for the `default-page`. We can copy the contents of that file and then add two additional schema fields - `author` and `publicationDate`.

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/piece-type',
  fields: {
    add: {
      headerImage: {
        type: 'area',
        label: 'Header image',
        required: true,
        options: {
          widgets: {
            '@apostrophecms/image': {}
          },
          max: 1
        }
      },
      heading: {
        type: 'string',
        label: 'Heading',
        required: true
      },
      subheading: {
        type: 'string',
        label: 'Subheading',
        required: true
      },
      author: {
        type: 'string',
        label: 'Author',
        required: true
      },
      publicationDate: {
        type: 'date',
        label: 'Publication date',
        required: true
      },
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {
              toolbar: [
                'styles',
                '|',
                'bold',
                'italic',
                'strike',
                'link',
                '|',
                'bulletList',
                'orderedList'
              ],
              styles: [
                {
                  tag: 'p',
                  label: 'Paragraph (P)'
                },
                {
                  tag: 'h3',
                  label: 'Heading 3 (H3)'
                },
                {
                  tag: 'h4',
                  label: 'Heading 4 (H4)'
                }
              ]
            },
            '@apostrophecms/image': {},
            '@apostrophecms/video': {}
          }
        }
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [ 'title', 'headerImage', 'heading', 'subheading', 'author', 'publicationDate', 'main' ]
      }
    }
  }
};

```

<template v-slot:caption>
  modules/blog/index.js
</template>
</AposCodeBlock>

The `index.js` file for the `blog-page` will also be quite similar. Again, it will have a header image, heading, and subheading.

<AposCodeBlock>

``` javascript
module.exports = {
  extend: '@apostrophecms/piece-page-type',
  options: {
    perPage: 5
  },
  fields: {
    add: {
      headerImage: {
        type: 'area',
        label: 'Header image',
        required: true,
        options: {
          widgets: {
            '@apostrophecms/image': {}
          },
          max: 1
        }
      },
      heading: {
        type: 'string',
        label: 'Heading',
        required: true
      },
      subheading: {
        type: 'string',
        label: 'Subheading',
        required: true
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [
          'title',
          'headerImage',
          'heading',
          'subheading'
        ]
      }
    }
  }
};

```

<template v-slot:caption>
  modules/blog-page/index.js
</template>
</AposCodeBlock>

In the code above we are adding a `perPage` option of `5`. This will limit the number of blog articles shown on the "Home" page. This can be adjusted to best serve your needs.

### The blog index.html page

The "Home" page of the template is essentially an `index.html` page that lists all of the blog articles. Just like with the default page, we are going to add our header to a `beforeMain` block. Within the `main` block, we will copy the `<!-- Main Content -->` section from the `index.html` HTML template. To convert it to dynamically show all of the blog articles from our site we will delete all of the code in each of the `<!-- Post preview -->` sections except the first. Then, we will wrap the first  `<!-- Post preview -->` section in a `for` loop. Finally, we will modify the `<!-- Pager -->` section to show both newer and older posts.

<AposCodeBlock>

``` nunjucks
{% extends 'layout.html' %}

{% import 'fragments/header.html' as header %}

{% block beforeMain %}
  {{ super() }}
  {% render header.headerArea(data.page) %}
{% endblock %}

{% block main %}
  <!-- Main Content-->
  <div class="container px-4 px-lg-5">
    <div class="row gx-4 gx-lg-5 justify-content-center">
      <div class="col-md-10 col-lg-8 col-xl-7">
        {% for piece in data.pieces %}
          <!-- Post Preview -->
          <div class="post-preview">
            <a href="{{ piece._url }}">
              <h2 class="post-title">{{ piece.heading }}</h2>
              <h3 class="post-subtitle">{{ piece.subheading }}</h3>
            </a>
            <p class="post-meta"> Posted by {{ piece.author }} on {{ piece.publicationDate | date('MMMM D, YYYY') }}</p>
          </div>
          <!-- Divider-->
          <hr class="my-4" />
        {% endfor %}
        <!-- Pager-->
        <div class="d-flex mb-4">
          {% if data.currentPage > 1 %}
          <a href="{{ data.slug }}?page={{data.currentPage - 1}}" class="btn btn-primary text-uppercase me-auto">newer posts</a>
          {% endif %}
          {% if data.totalPages > data.currentPage %}
          <a href="{{ data.slug }}?page={{data.currentPage + 1}}" class="btn btn-primary text-uppercase ms-auto">older posts</a>
          {% endif %}
        </div>
      </div>
    </div>
  </div>

{% endblock %}
```

<template v-slot:caption>
  modules/blog-page/index.html
</template>
</AposCodeBlock>

Focusing on the `for` loop in the code. We are stepping through all of the articles returned in `data.pieces` and outputing the relevant data. Again, since we specified a `perPage` value of `5` in the options, this will return the five newest blog articles. This can be further configured within the `blog-page` module options, for example with the [`sort` option](/reference/modules/piece-type.md#sort).

The "Pager" section is expanded to conditionally show newer and older blog articles, unlike the original template, which only shows older articles. Within the section, we are taking advantage of some additional data that is being delivered to the `index.html` page. Within the `data` payload are `data.currentPage` and `data.totalPages`. The `data.totalPages` is how many individual data sets are present for the particular piece type if divided into groups based on the `perPage` option (the default is `10`).

By default, we are showing the newest blog articles first. Therefore, if the `data.currentPage` is equal to `1` then we shouldn't display the button to load newer articles. If we are on any other page we want the button displayed, with a URL that adds a query to go to the previous page -
::: v-pre
`{{data.currentPage - 1}}`.

We are only displaying the button to go to older posts if we aren't at the last set of pieces - `data.totalPages > data.currentPage`. If this is true we display a button that points to the URL with a query that goes to the next set of pieces - 
::: v-pre
`{{data.currentPage + 1}}`.

### The blog show.html page

The `show.html` page will display each of the individual blog articles and will be based on the original HTML template `post.html` page. Like the other pages, we start by rendering the header fragment in the `beforeMain` block. If we look at the `post.html` page we can see that the header looks slightly different from the other pages. It contains metadata not found on the other pages. After setting up the main part of the page we will alter the `header.html` fragment to address this.

Open the `post.html` template file and copy the `<!-- Post Content -->` section into the `main` block of the `show.html` page. All of the content in `p` tags can be deleted because we will replace it with the content added to the `main` area of our blog pieces.

<AposCodeBlock>

``` nunjucks
{% extends "layout.html" %}

{% import 'fragments/header.html' as header %}

{% block beforeMain %}
    {{ super() }}
    {% render header.headerArea(data.piece) %}
{% endblock %}

{% block main %}
    <!-- Post Content-->
    <article class="mb-4">
        <div class="container px-4 px-lg-5">
            <div class="row gx-4 gx-lg-5 justify-content-center">
                <div class="col-md-10 col-lg-8 col-xl-7">
                    {% area data.piece, 'main' %}
                </div>
            </div>
        </div>
    </article>
{% endblock %}
```

<template v-slot:caption>
  modules/blog-page/views/show.html
</template>
</AposCodeBlock>

As outlined above, the header of the blog piece pages is different from the other pages. There are two ways that we could approach this. We could create a dedicated blog header fragment and add it into our `views/fragments/header.html` file with a new name. The other approach is to add some conditional markup to our existing header fragment. In this case, we will do the latter.

<AposCodeBlock>

``` nunjucks
{% fragment headerArea(data) %}
{% set background = apos.image.first(data.headerImage) %}

{% set type = data.type %}

{% if type === 'default-page' %}
  {% set pageClass = 'page-heading' %}
{% elif type === 'blog-page' %}
  {% set pageClass = 'site-heading' %}
{% else %}
  {% set pageClass = 'post-heading' %}
{% endif %}

<!-- Page Header-->
{% if background %}
  {% set backgroundUrl = apos.attachment.url(background, { size: 'max' }) %}
  <header class="masthead" style="background-image: url('{{ backgroundUrl }}')">
{% else %}
  <header class="masthead" style="background-color: blue;">
{% endif %}
    <div class="container position-relative px-4 px-lg-5">
        <div class="row gx-4 gx-lg-5 justify-content-center">
            <div class="col-md-10 col-lg-8 col-xl-7">
                <div class="{{ pageClass }}">
                    <h1>{{ data.heading }}</h1>
                    {% if type != 'blog' %}
                    <span class="subheading">{{ data.subheading }}</span>
                    {% else %}
                    <h2 class="subheading">{{ data.subheading }}</h2>
                    <span class="meta">
                        Posted by {{ data.author }} on {{ data.publicationDate | date('MMMM D, YYYY') }}
                    </span>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
  </header>
{% endfragment %}
```

<template v-slot:caption>
  views/fragments/header.html
</template>
</AposCodeBlock>

So, what did we change? First, at the top, we created a new variable, `type`, and set it to the value of `data.type`. This is going to give us the type of page or piece that is being loaded. Looking at the code differences in the header section of each of the three pages, we can see that the container for the header text has a different class depending on the template page type. In our header fragment, we conditionally set the `pageClass` variable based on the page type, either 'default-page', 'blog-page', or 'blog'. Next, within the code, we use this variable and wrap the HTML below the `h1` tag with a conditional statement to only add the metadata if we are on a blog page.

Now we need to add our pages to the site and give them some content. The "About Me" and "Contact Me" both use the `default-page` template. The existing "Home" page should be swapped out for a `blog-page` template. All that is left to do is create your blog articles!

## Summary

Any pre-made HTML template can be converted for use in Apostrophe through some simple steps.

- Add the front end assets to your Apostrophe project
- Create an Apostrophe page type for each of the template pages that substitutes data from the schema fields into each area of the page that you want to edit.
- Add special piece types and piece page types

In this tutorial, we took extra steps to create reusable navigation, header, and footer fragments. While this makes the overall project more compact it is completely optional. Hopefully, this will help you get your Apostrophe project up and running a little more quickly!

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Managing Brand Colors
DOC_PATH: tutorials/managing-brand-colors.md
URL: https://apostrophecms.com/docs/tutorials/managing-brand-colors
================================================================================
# Managing Brand Colors in ApostropheCMS Color Fields
Brand consistency is critical for professional websites, but managing colors across a CMS can be challenging. Content editors need quick access to approved brand colors without memorizing hex codes, while developers need a system that scales and adapts when brand guidelines change.

ApostropheCMS color fields support preset color swatches that give editors one-click access to approved colors. This tutorial shows you how to create a centralized brand color system that works across all your color fields and automatically updates existing content when colors change. For teams that need content managers to adjust brand colors without code changes, we'll also explore how the Palette extension provides a complete brand management interface.

::: tip Watch & Learn! üé•
This tutorial is available in both text and video formats. The video cover the key highlights, while this page provides additional details and references. Watch the video for a guided introduction, then read on for deeper insights!

<iframe width="560" height="315" src="https://www.youtube.com/embed/7l20E1CrNNs?si=a6D4m7In6dG_ats-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Why This Matters

Content editors need quick access to approved brand colors without memorizing hex codes or risking off-brand color choices. More importantly, when brand colors change (and they will), you want those changes to flow through your entire site automatically‚Äîincluding content that's already been created.

By using CSS variables with a centralized color configuration, you get true site-wide color management where updating a single value instantly changes colors across all templates, existing content, and future content.

## The CSS Variables Approach (Recommended)

The most powerful approach uses CSS custom properties (CSS variables) that create a true single source of truth for your brand colors. When you update the value of a CSS variable, the change appears instantly everywhere it's used‚Äîincluding in previously saved content.

> [!NOTE]
> **Understanding Mixed Color Usage**: When you configure `presetColors` with CSS variables, content editors see those variables as color swatches in the picker alongside the option to choose custom colors. If an editor selects a preset swatch, the stored value is the CSS variable name (like `--brand-primary`). If they choose a custom color, the stored value is the actual color (like `#ff0000` or `rgb(255, 0, 0)`). Your templates need to handle both cases‚Äîwe'll show you how in [Step 4](/tutorials/managing-brand-colors.html#step-4-using-colors-in-your-templates).

### Step 1: Define Your Brand Colors as CSS Variables

Add your brand colors as CSS custom properties to your main stylesheet:

<AposCodeBlock>

```css
/* Define your brand colors as CSS variables */
:root {
  --brand-primary: #2563eb;
  --brand-secondary: #64748b;
  --brand-accent: #f97316;
  --brand-success: #10b981;
  --brand-warning: #f59e0b;
  --brand-error: #ef4444;
}
```
  <template v-slot:caption>
    ui/src/variables.scss
  </template>
</AposCodeBlock>

### Step 2: Create Your JavaScript Configuration

Create a shared configuration file that references your CSS variables. This makes them available as preset colors in all your color fields and easily imported across modules:

<AposCodeBlock>

```javascript
export default [
  '--brand-primary',   // Primary Blue
  '--brand-secondary', // Secondary Gray
  '--brand-accent',    // Accent Orange
  '--brand-success',   // Success Green
  '--brand-warning',   // Warning Yellow
  '--brand-error'      // Error Red
];
```
  <template v-slot:caption>
    lib/brand-colors.js
  </template>
</AposCodeBlock>

> [!IMPORTANT]
> Using CSS Variables in Color Fields: When setting up `presetColors` with CSS variables, use just the variable name (`--brand-primary`) without the `var()` wrapper. The color field handles the CSS function internally.

### Step 3: Apply to Your Schemas

Import your brand colors and apply them to any color field. Content editors will see these as preset color swatches in the color picker interface:

<AposCodeBlock>

```javascript
import brandColors from '../../lib/brand-colors.js';

export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Card'
  },
  fields: {
    add: {
      accentColor: {
        type: 'color',
        label: 'Accent Color',
        help: 'Choose a color to highlight this article title',
        options: {
          presetColors: brandColors
        }
      },
      backgroundColor: {
        type: 'color',
        label: 'Background Color',
        options: {
          presetColors: brandColors
        }
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

> [!TIP]
> **Enforcing Brand Compliance**: To prevent editors from straying from approved colors, you can restrict the color picker interface by disabling custom color options. Set `options.disableSpectrum: true` to remove the color spectrum, `options.disableAlpha: true` to disable transparency controls, and `options.disableFields: true` to hide hex/RGB input fields. This leaves only your preset swatches available, ensuring perfect brand compliance. See the [documentation](/reference/field-types/color.html) for more info.

### Step 4: Using Colors in Your Templates

When using CSS variables as preset swatches, content editors can choose either:
- A preset swatch (stored as `--brand-primary`)
- A custom color (stored as `#ff0000` or `rgb(255, 0, 0)`)

Your templates need to handle both cases. Check if the value starts with `--` to determine if it's a CSS variable:

<AposCodeBlock>

```nunjucks
<div class="article-card" 
     style="background-color: {% if data.piece.backgroundColor.startsWith('--') %}var({{ data.piece.backgroundColor }}){% else %}{{ data.piece.backgroundColor }}{% endif %};">
  <h2 style="color: {% if data.piece.accentColor.startsWith('--') %}var({{ data.piece.accentColor }}){% else %}{{ data.piece.accentColor }}{% endif %};">
    {{ data.piece.title }}
  </h2>
  <p>{{ data.piece.content }}</p>
</div>
```
  <template v-slot:caption>
    modules/article/views/show.html
  </template>
</AposCodeBlock>

For cleaner templates, you can create a macro to handle this logic:

<AposCodeBlock>

```nunjucks
{# Create a reusable macro for color values #}
{% macro colorValue(color) %}
  {%- if color and color.startsWith('--') -%}
    var({{ color }})
  {%- else -%}
    {{ color }}
  {%- endif -%}
{% endmacro %}

<div class="article-card" style="background-color: {{ colorValue(data.piece.backgroundColor) }};">
  <h2 style="color: {{ colorValue(data.piece.accentColor) }};">
    {{ data.piece.title }}
  </h2>
  <p>{{ data.piece.content }}</p>
</div>
```
  <template v-slot:caption>
    modules/article/views/show.html
  </template>
</AposCodeBlock>

**How This Works:**
- CSS variable swatches: `--brand-primary` becomes `var(--brand-primary)`
- Custom colors: `#ff0000` or `rgb(255, 0, 0)` remain unchanged
- The conditional ensures both types work correctly in your CSS

### The Power of This Approach

Now when you need to update colors, change a single CSS variable:

```css
:root {
  --brand-primary: #1d4ed8; /* Updated from #2563eb */
}
```

This instantly updates the color everywhere it appears across your site‚Äîin new content, existing content, and any CSS that references the variable.

> [!IMPORTANT]
> **Managing Complexity**: Using CSS variables creates a dependency between your CSS and JavaScript configurations. Your JavaScript config references the variable names (like `--brand-primary`) while your CSS defines their values. Changes to CSS variable names must be coordinated with your JavaScript config. We recommend establishing team conventions for managing this coupling and documenting the relationship clearly.

## Filtering Colors for Specific Use Cases

You can still filter your brand colors for specific fields while maintaining the central configuration. This works the same way whether you're using CSS variables or hex codes:

<AposCodeBlock>

```javascript
import brandColors from '../../lib/brand-colors.js';

export default {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Event'
  },
  fields: {
    add: {
      statusColor: {
        type: 'color',
        label: 'Status Color',
        help: 'Color for event status indicators',
        options: {
          // Only show status-related colors
          presetColors: brandColors.filter(color =>
            color.includes('--brand-success') || // Success Green
            color.includes('--brand-warning') ||  // Warning Yellow
            color.includes('--brand-error')    // Error Red
          )
        }
      },
      themeColor: {
        type: 'color',
        label: 'Theme Color',
        options: {
          // Only show primary brand colors
          presetColors: brandColors.slice(0, 3) // Primary, Secondary, Accent
        }
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/event/index.js
  </template>
</AposCodeBlock>

## Advanced: Using Semantic Tokens for Better Organization

As your project grows, you can make color management more maintainable by storing both names and values. This makes filtering more explicit and less brittle:

<AposCodeBlock>

```javascript
export const brandColors = [
  { name: 'primary', value: '--brand-primary' },
  { name: 'secondary', value: '--brand-secondary' },
  { name: 'accent', value: '--brand-accent' },
  { name: 'success', value: '--brand-success' },
  { name: 'warning', value: '--brand-warning' },
  { name: 'error', value: '--brand-error' }
];

export const brandColorValues = brandColors.map(c => c.value);
```
  <template v-slot:caption>
    lib/brand-colors.js
  </template>
</AposCodeBlock>

For fields that allow all brand colors:

```javascript
import { brandColorValues } from '../../lib/brand-colors.js'
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Card'
  },
  fields: {
    add: {
      accentColor: {
        type: 'color',
        label: 'Accent Color',
        help: 'Choose a color to highlight this article title',
        options: {
          presetColors: brandColorValues
        }
      },
      // ...remainder of code
```

### Filtering using names

Now you can filter by semantic names rather than array positions:

<AposCodeBlock>

```javascript
import { brandColors } from '../../lib/brand-colors.js';

export default {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Event'
  },
  fields: {
    add: {
      statusColor: {
        type: 'color',
        label: 'Status Color',
        help: 'Color for event status indicators',
        options: {
          presetColors: brandColors
            .filter(c => ['success', 'warning', 'error'].includes(c.name))
            .map(c => c.value)
        }
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/event/index.js
  </template>
</AposCodeBlock>

## Alternative: Static Color Values

In some cases, you might prefer using static hex codes instead of CSS variables. This approach is simpler to manage but doesn't provide automatic updates to existing content.

**Use static colors when:**
- Colors truly never change after launch
- You need email template compatibility
- You're integrating with third-party tools that need actual color values
- You want to avoid the CSS/JavaScript coordination complexity

<AposCodeBlock>

```javascript
export default [
  '#2563eb', // Primary Blue
  '#64748b', // Secondary Gray
  '#f97316', // Accent Orange
  '#10b981', // Success Green
  '#f59e0b', // Warning Yellow
  '#ef4444'  // Error Red
];
```
  <template v-slot:caption>
    lib/static-brand-colors.js
  </template>
</AposCodeBlock>

> [!NOTE]
> With static colors, changing the hex values in your configuration will update the available swatches for editors going forward, but documents that already have color values saved will not automatically update.

## Taking Brand Colors Further with Palette

While the centralized configuration approach works great for developer-defined brand colors, you might want to give content managers the ability to adjust brand colors site-wide without code changes. The [ApostropheCMS Palette extension](https://apostrophecms.com/extensions/palette-extension) makes this possible by creating an in-context interface for editing CSS variables that automatically update across your entire site.

When combined with CSS variables, Palette allows content managers to safely update brand colors site-wide without code changes or manually republishing content.

You brand colors config file remains the same, exporting an array of either the values alone, or the named values. Your Nunjucks template and schema fields using the `brandColorValues` also remain the same.

In the Palette configuration, you add a field for each CSS variable you want to set with `:root` as the `selector`:

<AposCodeBlock>

```javascript
export default {
  fields: {
    add: {
      brandPrimary: {
        type: 'color',
        label: 'Primary Brand Color',
        selector: ':root',
        property: '--brand-primary'
      },
      brandSecondary: {
        type: 'color',
        label: 'Secondary Brand Color',
        selector: ':root',
        property: '--brand-secondary'
      },
      brandAccent: {
        type: 'color',
        label: 'Accent Brand Color',
        selector: ':root',
        property: '--brand-accent'
      }
    },
    group: {
      brandColors: {
        label: 'Brand Colors',
        fields: ['brandPrimary', 'brandSecondary', 'brandAccent']
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/@apostrophecms-pro/palette/index.js
  </template>
</AposCodeBlock>

> [!TIP]
> To prevent CSS variables from being undefined before content managers edit them in Palette, add fallback values to your `/ui/src/index.scss` file. Palette's styles will override these defaults through CSS cascade.

## Best Practices

**Document Dependencies**: When using CSS variables, clearly document the relationship between your CSS and JavaScript configurations. Establish team conventions for managing changes.

**Use Descriptive Names**: Whether using CSS variables or hex codes, use clear, semantic names that communicate purpose, not just appearance.

**Keep It Focused**: Include only the colors content editors actually need. Too many options can be overwhelming.

**Plan for Change**: Even if you start with static colors, structure your configuration to make upgrading to CSS variables straightforward later.

## Conclusion

CSS variables provide the most powerful approach to brand color management in ApostropheCMS, enabling true site-wide color control where changes instantly flow through all content‚Äîpast, present, and future. While this approach requires coordinating CSS and JavaScript configurations, the benefits of automatic content updates typically outweigh the additional complexity.

For simpler projects or specific constraints, static color values remain a valid choice. The key is choosing the approach that best fits your project's needs and team capabilities.

---

**Related Resources:**
- [ApostropheCMS Color Field Documentation](/reference/field-types/color.html)
- [ApostropheCMS Palette Extension](https://apostrophecms.com/extensions/palette-extension)

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Responsive Widget Visibility
DOC_PATH: tutorials/responsive-widget-visibility.md
URL: https://apostrophecms.com/docs/tutorials/responsive-widget-visibility
================================================================================
# Responsive Widget Visibility Best Practices in ApostropheCMS

## Why This Matters & Core Principles

Content editors regularly need to control how widgets appear across different devices. A hero image that works beautifully on desktop might overwhelm a mobile screen, or detailed charts might be unreadable on small displays. Rather than forcing editors to create duplicate content or compromise their design vision, thoughtful responsive visibility controls let them optimize the experience for each screen size.

The key is providing editor-friendly controls that translate to clean, accessible, and performant CSS‚Äînot forcing editors to understand technical concepts like breakpoint pixels or CSS classes.

When implementing responsive widget visibility, prioritize:
- **Editor clarity**: Use device-based language ("Hide on mobile") rather than technical terms
- **Performance**: Generate clean CSS that doesn't impact page load
- **Accessibility**: Ensure hidden content doesn't interfere with screen readers
- **Consistency**: Maintain predictable patterns across all widgets that need responsive behavior

<!-- VIDEO: Responsive Widget Visibility Tutorial -->

## Implementation Philosophy

This tutorial uses a CSS class-based approach rather than inline styles or JavaScript-based solutions for several important reasons:

**Performance and Caching**: CSS classes defined in your stylesheet can be cached by browsers and shared across all widget instances, while inline styles create unique code for every widget occurrence.

**Maintainability**: Centralized CSS rules in your stylesheet are easier to debug, update, and maintain than scattered inline styles throughout your templates.
Editor Predictability: CSS classes create consistent, reliable behavior that editors can depend on, while JavaScript-based solutions can fail or behave unpredictably.

**Accessibility**: CSS-based hiding using `display: none` properly removes content from the accessibility tree, ensuring screen readers and other assistive technologies handle hidden content correctly.

This approach aligns with the principle of configuring robust systems once that content managers can use confidently every day.

## Responsive Design for Content Managers

One approach to responsive design uses CSS media queries to conditionally apply styles based on screen characteristics. A common approach uses viewport width breakpoints that correspond to typical device categories:

- **Mobile**: Up to 768px width
- **Tablet**: 769px to 1024px width
- **Desktop**: 1025px and above

### Defining Consistent Breakpoints

Define your breakpoints once using CSS custom properties to maintain consistency across your entire project:

<AposCodeBlock>

```css
:root {
  --breakpoint-mobile-max: 768px;
  --breakpoint-tablet-min: 769px;
  --breakpoint-tablet-max: 1024px;
  --breakpoint-desktop-min: 1025px;
}
```
  <template v-slot:caption>
    ui/src/scss/variables/_breakpoints.scss
  </template>
</AposCodeBlock>

These variables ensure all your responsive CSS uses identical breakpoint values, preventing inconsistencies that confuse editors and users.

> [!TIP]
> **Pro Extension Integration**: If you're using the [ApostropheCMS Palette extension](https://apostrophecms.com/extensions/palette-extension), you can make these breakpoint values editable by content managers. Add fields to your Palette configuration with `selector: ':root'` and for example, `property: '--breakpoint-mobile-max'` to allow site-wide breakpoint adjustments without code changes.

## Recommended Implementation Pattern

### Schema Configuration

Provide editors with intuitive device-based visibility controls using clear, non-technical language:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Hero Banner'
  },
  i18n: {
    myProject: {
      browser: true
    }
  },
  fields: {
    add: {
      title: {
        type: 'string',
        label: 'myProject:heroTitle',
        required: true
      },
      _image: {
        type: 'relationship',
        label: 'myProject:heroImage'
      },
      // Responsive visibility controls
      hideOnMobile: {
        type: 'boolean',
        label: 'myProject:hideOnMobile',
        help: 'myProject:hideOnMobileHelp'
      },
      hideOnTablet: {
        type: 'boolean',
        label: 'myProject:hideOnTablet',
        help: 'myProject:hideOnTabletHelp'
      },
      hideOnDesktop: {
        type: 'boolean',
        label: 'myProject:hideOnDesktop',
        help: 'myProject:hideOnDesktopHelp'
      }
    },
    group: {
      basics: {
        label: 'myProject:basics',
        fields: ['title', '_image']
      }
      visibility: {
        label: 'myProject:deviceVisibility',
        fields: ['hideOnMobile', 'hideOnTablet', 'hideOnDesktop']
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/hero-banner-widget/index.js
  </template>
</AposCodeBlock>

### Translation Strings

Always use [translation strings](/guide/localization/static.html#localizing-schema-field-labels) for user-facing text to support internationalization:

<AposCodeBlock>

```json
{
  "heroTitle": "Hero text",
  "heroImage": "Background image",
  "hideOnMobile": "Hide on mobile devices",
  "hideOnMobileHelp": "Widget will not display on phones and small screens (under 768px)",
  "hideOnTablet": "Hide on tablets",
  "hideOnTabletHelp": "Widget will not display on tablet-sized screens (769px - 1024px)",
  "hideOnDesktop": "Hide on desktop",
  "hideOnDesktopHelp": "Widget will not display on desktop computers and large screens (1025px and above)",
  "deviceVisibility": "Device Visibility"
}
```
  <template v-slot:caption>
    modules/hero-banner-widget/i18n/myProject/en.json
  </template>
</AposCodeBlock>

### Template Implementation

Generate responsive CSS classes based on editor selections, keeping the template clean and semantic:

<AposCodeBlock>

```nunjucks
{% set responsiveClasses = [] %}
{% if data.widget.hideOnMobile %}
  {% set responsiveClasses = (responsiveClasses.push('hide-mobile'), responsiveClasses) %}
{% endif %}
{% if data.widget.hideOnTablet %}
  {% set responsiveClasses = (responsiveClasses.push('hide-tablet'), responsiveClasses) %}
{% endif %}
{% if data.widget.hideOnDesktop %}
  {% set responsiveClasses = (responsiveClasses.push('hide-desktop'), responsiveClasses) %}
{% endif %}

<section class="hero-banner {{ responsiveClasses | join(' ') }}"
  <!-- widget content -->
</section>
```
  <template v-slot:caption>
    modules/hero-banner/views/widget.html
  </template>
</AposCodeBlock>

### Alternative: Single Checkboxes Field

For a more streamlined approach, you can use a single checkboxes field that outputs CSS class names directly:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Hero Banner'
  },
  i18n: {
    myProject: {
      browser: true
    }
  },
  fields: {
    add: {
      // other fields
      hideOn: {
        type: 'checkboxes',
        label: 'myProject:hideOn',
        help: 'myProject:hideOnHelp',
        choices: [
          { label: 'myProject:hideOnDesktop', value: 'hide-desktop' },
          { label: 'myProject:hideOnTablet', value: 'hide-tablet' },
          { label: 'myProject:hideOnMobile', value: 'hide-mobile' }
        ]
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/hero-banner-widget/index.js
  </template>
</AposCodeBlock>

This approach simplifies the template significantly since the field value is already an array of CSS class names:

<AposCodeBlock>

```nunjucks
<section class="hero-banner {{ data.widget.hideOn | join(' ') }}"
  <!-- widget content -->
</section>
```
  <template v-slot:caption>
    modules/hero-banner/views/widget.html (Alternative template)
  </template>
</AposCodeBlock>

**Benefits of the checkboxes approach:**
- Cleaner template code with no conditional logic
- Easier to extend with additional breakpoints
- Better editor UX with grouped options
- More maintainable schema

**When to use each approach:**
- Use **separate boolean fields** when you need specific help text for each option or complex conditional grouping
- Use **checkboxes field** for simpler implementations and when you might add more breakpoints later

### CSS Implementation

Define your responsive visibility classes using the CSS variables established earlier:

<AposCodeBlock>

```scss
// Import your breakpoint variables
@import '../variables/breakpoints';

// Responsive visibility utilities using consistent breakpoints
@media screen and (max-width: var(--breakpoint-mobile-max)) {
  .hide-mobile {
    display: none !important;
  }
}

@media screen and (min-width: var(--breakpoint-tablet-min)) and (max-width: var(--breakpoint-tablet-max)) {
  .hide-tablet {
    display: none !important;
  }
}

@media screen and (min-width: var(--breakpoint-desktop-min)) {
  .hide-desktop {
    display: none !important;
  }
}
```
  <template v-slot:caption>
    ui/src/scss/utilities/_responsive-visibility.scss
  </template>
</AposCodeBlock>

> [!IMPORTANT]
> Using `!important` in utility classes like these is acceptable and sometimes necessary. These classes represent explicit editor intent to hide content, and should override any other display properties that might conflict.

## Accessibility Considerations

### Screen Reader Compatibility

Hidden content should be properly excluded from screen readers. The `display: none` approach correctly removes content from the accessibility tree, unlike `visibility: hidden` or `opacity: 0` which can still be announced by assistive technology.

### Alternative Content Patterns

Consider providing alternative content for different screen sizes rather than simply hiding:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'Adaptive Content'
  },
  fields: {
    add: {
      desktopContent: {
        type: 'area',
        label: 'Desktop Content',
        options: {
          widgets: ['@apostrophecms/rich-text', 'image-gallery']
        }
      },
      mobileContent: {
        type: 'area',
        label: 'Mobile Content',
        options: {
          widgets: ['@apostrophecms/rich-text', 'simple-image']
        }
      }
    }
  }
};
```
  <template v-slot:caption>
    modules/adaptive-content/index.js
  </template>
</AposCodeBlock>

## Performance Considerations

### CSS Organization

Group all responsive visibility utilities in a single file to minimize redundancy and improve caching:

<AposCodeBlock>

```scss
// Import responsive utilities early in your main stylesheet
@import 'utilities/responsive-visibility';

// This ensures the utilities load before component styles
// that might conflict with the visibility rules
```
  <template v-slot:caption>
    ui/src/scss/index.scss
  </template>
</AposCodeBlock>

### Avoiding Inline Styles

Avoid generating responsive CSS as inline styles in widget templates. This creates performance problems and prevents effective caching:

```nunjucks
{# ‚ùå DON'T: Inline responsive styles #}
<div style="@media screen and (max-width: 768px) { display: none; }">
  
{# ‚úÖ DO: Use CSS classes #}
<div class="hide-mobile">
```

## Framework Integration

### Tailwind CSS

If your project uses Tailwind CSS, leverage its responsive utilities instead of custom classes:

<AposCodeBlock>

```nunjucks
{% set responsiveClasses = [] %}
{% if data.widget.hideOnMobile %}
  {% set responsiveClasses = (responsiveClasses.push('hidden md:block'), responsiveClasses) %}
{% endif %}
{% if data.widget.hideOnTablet %}
  {% set responsiveClasses = (responsiveClasses.push('md:hidden lg:block'), responsiveClasses) %}
{% endif %}
{% if data.widget.hideOnDesktop %}
  {% set responsiveClasses = (responsiveClasses.push('lg:hidden'), responsiveClasses) %}
{% endif %}

<section class="hero-banner {{ responsiveClasses | join(' ') }}">
  <!-- widget content -->
</section>
```
  <template v-slot:caption>
    modules/hero-banner/views/widget.html (Tailwind version)
  </template>
</AposCodeBlock>

### Bootstrap

For Bootstrap projects, use its responsive display utilities:

<AposCodeBlock>

```nunjucks
{% set responsiveClasses = [] %}
{% if data.widget.hideOnMobile %}
  {% set responsiveClasses = (responsiveClasses.push('d-none d-md-block'), responsiveClasses) %}
{% endif %}
{% if data.widget.hideOnTablet %}
  {% set responsiveClasses = (responsiveClasses.push('d-md-none d-lg-block'), responsiveClasses) %}
{% endif %}
{% if data.widget.hideOnDesktop %}
  {% set responsiveClasses = (responsiveClasses.push('d-lg-none'), responsiveClasses) %}
{% endif %}

<section class="hero-banner {{ responsiveClasses | join(' ') }}">
  <!-- widget content -->
</section>
```
  <template v-slot:caption>
    modules/hero-banner/views/widget.html (Bootstrap version)
  </template>
</AposCodeBlock>

## Common Pitfalls to Avoid

### Technical Language in Editor Interface

```javascript
// ‚ùå DON'T: Use technical terms
breakpoint: {
  type: 'select',
  label: 'Media Query Breakpoint',
  choices: [
    { label: 'max-width: 768px', value: '768' },
    { label: 'min-width: 1024px', value: '1024' }
  ]
}

// ‚úÖ DO: Use clear, device-based language
hideOnMobile: {
  type: 'boolean',
  label: 'Hide on mobile devices',
  help: 'Widget will not display on phones and small screens'
}
```

### Complex Conditional Logic

```javascript
// ‚ùå DON'T: Force editors to understand relationships
visibility: {
  type: 'select',
  label: 'Visibility Rules',
  choices: [
    { label: 'Mobile only (hide > 768px)', value: 'mobile-only' },
    { label: 'Desktop only (hide < 1024px)', value: 'desktop-only' }
  ]
}

// ‚úÖ DO: Use independent, clear options
hideOnMobile: { type: 'boolean', label: 'Hide on mobile' },
hideOnDesktop: { type: 'boolean', label: 'Hide on desktop' }
```

### Inconsistent Breakpoints

Maintain consistent breakpoint definitions across your entire project by using the CSS custom properties established earlier:

<AposCodeBlock>

```scss
// ‚ùå DON'T: Hardcode different breakpoints
@media screen and (max-width: 768px) { /* some widgets */ }
@media screen and (max-width: 767px) { /* other widgets */ }

// ‚úÖ DO: Use consistent variables  
@media screen and (max-width: var(--breakpoint-mobile-max)) {
  .hide-mobile { display: none !important; }
}
```
  <template v-slot:caption>
    ui/src/scss/utilities/_responsive-visibility.scss
  </template>
</AposCodeBlock>

## Modern CSS Considerations

While viewport-width breakpoints remain the most editor-friendly approach for general widget visibility, modern CSS offers additional responsive techniques for specific use cases:

**Resolution-based visibility** for detailed graphics:
```css
/* Hide complex charts on low-resolution displays */
@media (max-resolution: 1dppx) {
  .hide-low-resolution { display: none; }
}
```

**User preference-based visibility** for accessibility:
```css
/* Hide animation-heavy widgets for users who prefer reduced motion */
@media (prefers-reduced-motion: reduce) {
  .hide-reduced-motion { display: none; }
}
```

**Intrinsic responsive design** using modern layout properties like `flex`, `grid`, `clamp()`, and `min()` and `@container` queries often eliminates the need for breakpoint-based hiding entirely. However, when explicit editor control over widget visibility is needed, the breakpoint approach provides the clearest interface for content managers.

For most ApostropheCMS projects, start with the viewport-based approach outlined above, then consider these advanced techniques for widgets with specific requirements like data visualizations, animations, or high-detail graphics.

## Conclusion

Thoughtful responsive visibility controls transform the content editing experience from frustrating compromises to empowering design choices. By using device-based language, maintaining consistent breakpoints, and generating clean CSS, you give editors the tools they need to create optimal experiences across all screen sizes.

Remember that responsive design is about more than hiding content‚Äîit's about crafting intentional experiences for each device context. The best implementations give editors clear control while maintaining excellent performance and accessibility.

---

**Related Resources:**
- [CSS Media Queries (MDN)](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries)
- [CSS Container Queries (MDN)](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_container_queries)
- [Help and Placeholder Text Best Practices](/tutorials/help-and-placeholder-text-best-practices.html)

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Composing Custom Fields
DOC_PATH: tutorials/reusing-standard-fields.md
URL: https://apostrophecms.com/docs/tutorials/reusing-standard-fields
================================================================================
# Composing custom schema fields from standard fields

![A composite screenshot of the two custom schema fields being built in this recipe.](../images/recipes/composite-schema.png)
## Introduction
Apostrophe comes with a large number of [schema field types](/reference/field-types/index.md). If these field types aren't sufficient for your project, Apostrophe makes adding a new custom schema field relatively easy and you can read more about it in the [documentation](/guide/custom-schema-field-types.html). However, many times when we need a custom field type, it is simply a combination of existing field types working together for a new outcome. Luckily, Apostrophe was designed to allow you to reuse existing field types to create new fields with a custom look.

In this recipe, we are going to build two different customized schema fields. The first will be a simple set of `integer` fields to collect grade information. The second will be a gradient background creator with `integer` and `color` fields, within an `array`. Overall, the steps to building both will be almost identical. However, we are going to build the grade field as part of a piece and the gradient as a stand-alone module. This will demonstrate the changes you need to make when building your custom schema field in a module that doesn't extend another core module and changes that need to be made to `object` and `array` schema input fields when you use them this way.

## Structure of a schema field

A schema input field has two parts: a server-side part and a browser-side part.

The server-side code handles registering the schema field type, plus sanitizing and storing the data in the database. Most of this code will be the same for each custom field. We can take advantage of the same code that the Apostrophe core uses for sanitization and storage.

The browser-side code provides the admin UI and is where we will take advantage of the built-in fields to lighten the programming load. Apostrophe has two Vue components and a mixin file to assist with schema creation. The first component is the `AposInputWrapper`. This component helps with field validation and appearance. The other is the `AposSchema` component. This Vue component parses through a supplied schema of fields and implements the v-model that allows two-way data binding between a value in our template and a value in our data properties. Apostrophe provides the `AposInputMixin` mixin to facilitate passing props, display modifications, and event listeners.

## Building the custom grade field type
![Bo Donkey's grades recorded in the new custom field](../images/recipes/student-grades-field.png)
This custom field makes it easier for our CMS user, a teacher, to enter the grades for a student. Each set of grades is stored as a piece with the student's name as the `Title` field. Our custom schema makes it easy for the teacher to keep the mid-term and final grades organized for each class. In addition, the field will calculate the letter grade based on the student's scores. Obviously, this example is overly simplistic. We could just as easily have added a `string` and two `integer` fields into an `array` field to achieve almost the same thing, but that poor teacher would have had to average the grades and convert it to a letter themselves!

### Implementing the server-side code
For this example, we are creating a new `piece-type` module.

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Student'
  },
  fields: {
    add: {
      title: {
        label: 'Student Name',
        type: 'string',
        required: true
      }
      grades: {
        label: 'Grades',
        type: 'array',
        inline: true,
        table: true,
        fields: {
          add: {
            className: {
              label: 'Class Name',
              type: 'string',
              required: true
            },
            grades: {
              label: 'Class Grades',
              type: 'grades'
            }
          }
        }
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [ 'title', 'gradesArray' ]
      }
    }
  },
  init(self) {
    self.addGradeFieldType();
  },
  methods(self) {
    return {
      addGradeFieldType() {
        self.apos.schema.addFieldType({
          name: 'grades',
          convert: self.convertInput,
          vueComponent: 'InputGradeField'
        });
      },
      exposeSchema() {
        const schema = [
          {
            type: 'integer',
            name: 'midterm',
            label: 'Midterm Test',
            required: true
          },
          {
            type: 'integer',
            name: 'final',
            label: 'Final Test',
            required: true
          }
        ];
        return schema;
      },
      async convertInput(req, field, data, object) {
        data = data[field.name];
        const schema = self.exposeSchema();
        const errors = [];
        const result = {};
        if (data == null || typeof data !== 'object' || Array.isArray(data)) {
          data = {};
        }
        try {
          await self.apos.schema.convert(req, schema, data, result);
        } catch (e) {
          for (const error of e) {
            errors.push({
              path: error.path,
              error: error.error
            });
          }
        }
        object[field.name] = result;
        if (errors.length) {
          throw errors;
        }
      }
    };
  },
  extendMethods(self) {
    return {
      getBrowserData(_super, req) {
        const browserData = _super(req);
        browserData.gradeSchema = self.exposeSchema();
        return browserData;
      }
    };
  }
};

```
  <template v-slot:caption>
    /modules/student/index.js
  </template>
</AposCodeBlock>

This piece has two schema fields. In addition to the required title which we have re-labeled as `Student Name`, this piece contains a single `array` type schema field. That `array` in turn has a `string` field for the class name and the new schema field, `grades`.

Within the `init(self)` function, we make a call to the method that will register and create our new schema field type.

```javascript
init(self) {
  self.addGradeFieldType();
}
```

The `methods(self)` configuration function is a bit more complicated. There are three methods. The first of these registers the new custom field.

```javascript
addGradeFieldType() {
  self.apos.schema.addFieldType({
    name: 'grades',
    convert: self.convertInput,
    vueComponent: 'InputGradeField'
  });
}
```

We are passing the `addFieldType()` method of the `@apostrophecms/schema` module an object with three properties. The first is the name that will be used within any schema utilizing this field, `grades`. The `convert` key points to the method that will be used to sanitize and store the data. Finally, the `vueComponent` key takes the file name for our Vue component located in the `modules/student/ui/apos/components` folder.


```javascript
exposeSchema() {
  const schema = [
  üëâüèª{
    üëâüèªname: 'midterm',
      type: 'integer',
      label: 'Midterm Test',
      required: true
    },
    {
      name: 'final',
      type: 'integer',
      label: 'Final Test',
      required: true
    }
  ];
  return schema;
}
```

The next method, `exposeSchema()`, allows us to reuse the schema for our component in the convert method, as well as in our Vue component.

The schema should be passed as an *array* of objects. This is slightly different from how we often format our schema as an object composed of named objects, like we did in the `fields.add`, so the `name` field moves inside the object.

```javascript
async convertInput(req, field, data, object) {
  data = data[field.name];
  const schema = self.exposeSchema();
  const errors = [];
  const result = {};
  if (data == null || typeof data !== 'object' || Array.isArray(data)) {
    data = {};
  }
  ...
}
```
The final method, `convertInput()`, accepts the data from the component inputs, makes sure the data is in an expected form, and then passes each data field through a `launder` method. The final data is returned as an object that gets stored by Apostrophe in the database. The first section of this method prepares the data for sanitization and storage.

This method takes four arguments from the Vue component. The two most important for this recipe are the `data` and `object` arguments. `data` is going to contain all the data being delivered from the input fields. We are only interested in managing the data from our new custom field, so in the very first line of the method we reassign `data` as being equal to only the data coming from our field using `data = data[field.name]`.

We next pull in the schema we defined above using the `exposeSchema()` method. This schema is used to inform the `convert()` method of what types of data laundering methods to use.

The `errors` and `results` variables are next initialized so that they can take values returned from the `@apostrophecms/schema` module `convert()` method.

Before passing our data to the `convert()` method we ensure that it is a non-array object. If not, the data coming back from the component can't be sanitized and instead is discarded.

```javascript
try {
  await self.apos.schema.convert(req, schema, data, result);
} catch (e) {
  for (const error of e) {
    errors.push({
      path: error.path,
      error: error.error
    });
  }
}
object[field.name] = result;
if (errors.length) {
  throw errors;
}
```

After prepping the argument data, we invoke the `@apostrophecms/schema` module `convert()` method within a try-catch block.

This either populates our `result` variable with the sanitized data or throws errors that are pushed to the `errors` variable.

Lastly, we assign those results to the `object` parameter. If no errors came back from the `convert()` method this object is saved to the database.

```javascript
extendMethods(self) {
  return {
    getBrowserData(_super, req) {
      const browserData = _super(req);
      browserData.gradeSchema = self.exposeSchema();
      return browserData;
    }
  };
}
```

The last module configuration function that we are setting for this module is `extendMethods(self)`. In order to expose our schema to the Vue component, we need to add it to the data made available by this module in the browser-side JavaScript. This is accomplished through the `getBrowserData()` method. In this case, we don't want to replace the base `@apostrophecms/piece-type` method, only extend it.

The `_super` argument is passing the original function (you can read more about this pattern in the [documentation](/reference/module-api/module-overview.html#the-extension-pattern)). The original method takes a single argument, `req`, that is passed as the second argument.

The `browserData` variable is set to the return value of the original function by invoking the original method with the `req` argument. That object is then updated with the custom schema array and returned.

### Creating the Vue component

The custom field browser-side code should be added to your module's `ui/apos/components` folder. The file name should match the value of the `vueComponent` property of the object passed to the `self.apos.schema.addFieldType()` method.

<AposCodeBlock>

```vue
<template>
  <AposInputWrapper :field="field" :error="null" :uid="uid" :modifiers="modifiers">
    <template #body>
      <div class="custom-input-object">
        <div class="custom-input-wrapper">
          <!-- Schema form for entering grade values -->
          <AposSchema
            :schema="gradeSchema"
            :trigger-validation="triggerValidation"
            :generation="generation"
            v-model="gradeSchemaInput"
          >
          </AposSchema>
          <!-- Display calculated letter grade -->
          <span class="letter-grade">{{ letterGrade }}</span>
        </div>
      </div>
    </template>
  </AposInputWrapper>
</template>

<script>
import { ref, computed, watch, onMounted, nextTick } from 'vue';
import AposInputMixin from 'apostrophe/modules/@apostrophecms/schema/ui/apos/mixins/AposInputMixin';
import AposInputWrapper from 'apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposInputWrapper.vue';
import AposSchema from 'apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposSchema.vue';

export default {
  name: 'InputGradeField',
  components: {
    AposInputWrapper,
    AposSchema
  },
  mixins: [ AposInputMixin ],
  props: {
    generation: {
      type: Number,
      required: false,
      default: null
    },
    modelValue: {
      type: Object,
      required: true
    }
  },
  setup(props, { emit }) {
    /**
     * Extract initial data from props or use defaults
     * This function handles both initialization and resets
     */
    const getNext = () => {
      return props.modelValue?.data ?? (props.field.def || {});
    };

    // Create reactive state for the grade data
    const next = ref(getNext());

    // Get the schema from Apostrophe modules
    const gradeSchema = apos.modules['student'].gradeSchema;

    // Create the input for the schema form
    const gradeSchemaInput = ref({ data: next.value });

    /**
     * Ensure reactivity on initial render
     * This is important in Vue 3 where the reactivity system 
     * might not trigger for initial values
     */
    onMounted(() => {
      nextTick(() => {
        // Create a new object reference to force reactivity
        next.value = { ...next.value };
      });
    });

    // Watch for generation changes from parent component
    watch(() => props.generation, () => {
      next.value = getNext();
      gradeSchemaInput.value = {
        data: next.value
      };
    });

    // Watch for internal schema input changes
    watch(gradeSchemaInput, (newValue) => {
      if (!newValue.hasErrors) {
        next.value = newValue.data;
        emit('update:modelValue', { data: next.value });
      }
    }, { deep: true });

    /**
     * Validate the grade data
     * Return 'invalid' if there are errors, false otherwise
     */
    function validate(value) {
      if (gradeSchemaInput.value.hasErrors) {
        return 'invalid';
      }
      return false;
    }

    /**
     * Calculate letter grade based on midterm and final scores
     * This is a computed property to ensure reactive updates
     */
    const letterGrade = computed(() => {
      if (!next.value.midterm && !next.value.final) {
        return '';
      }

      const midterm = next.value.midterm;
      const final = next.value.final;

      // Calculate average, handling cases where only one score exists
      let average = (midterm !== undefined && final !== undefined) 
        ? (midterm + final) / 2 
        : (midterm !== undefined ? midterm : final);

      // Cap the average at 100
      average = Math.min(average, 100);

      // Define grade ranges
      const gradeRanges = [
        { min: 90, max: 100, letter: 'A' },
        { min: 80, max: 89, letter: 'B' },
        { min: 70, max: 79, letter: 'C' },
        { min: 60, max: 69, letter: 'D' },
        { min: 0, max: 59, letter: 'F' },
      ];

      // Find the matching grade range
      const matchingRange = gradeRanges.find(
        ({ min, max }) => average >= min && average <= max
      );

      return matchingRange ? matchingRange.letter : '';
    });

    // Return values and functions for the template
    return {
      next,
      gradeSchemaInput,
      gradeSchema,
      getNext,
      validate,
      letterGrade
    };
  }
};
</script>

<style lang="scss" scoped>
.custom-input-object {
  .custom-input-wrapper {
    display: flex;
    flex-direction: row;

    .apos-schema {
      flex: 2;
      margin-right: 10px;
      display: flex;
      flex-direction: row;

      [data-apos-field] {
        margin-left: 10px;

        &:first-child {
          margin-left: 0;
        }
      }
    }

    .letter-grade {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      font-weight: bold;
      margin-bottom: 30px;
      transition: all 0.3s ease;
      color: var(--a-primary);
    }
  }
}
</style>
```
<template v-slot:caption>
/modules/student/ui/apos/components/InputGradeField.vue
</template>
</AposCodeBlock>

**The schema field markup**

```vue
<AposInputWrapper :field="field" :error="null" :uid="uid" :modifiers="modifiers">
...
</AposInputWrapper>
```

For our custom schema field, we are utilizing two helper components from the `@apostrophecms/schema` module. The first is the `AposInputWrapper`. This component is used for error handling and input appearance, as well as behind-the-scenes housekeeping. It wraps the entire code block where the Apostrophe schema fields are being used. Four props are typically passed to this component.

The only one that we might want to change the value of is `:error`. It can take values of either `"null"` or `"effectiveError"`. If you are making a component that has multiple schema fields and set `:error` to `"null"`, errors will only be shown for the individual fields, not the top-level component. Setting it to `"effectiveError"` will show errors in the individual fields, as well as the entire custom schema field. It is a judgment call to determine which will result in a better user experience.

> [!NOTE]
> As a guide for selecting error type, the Apostrophe `array` and `object` fields use `:error="null"`. This provides clear guidance on which field is in error, without a second error message being displayed for the entire component. You may want to change this if your custom field has a requirement such as `min: 1`.

```vue
<template #body>
  <div class="custom-input-object">
    <div class="custom-input-wrapper">
      <AposSchema :schema="gradeSchema" :trigger-validation="triggerValidation" :generation="generation" v-model="gradeSchemaInput">
      </AposSchema>
      <span class="letter-grade">{{ letterGrade }}</span>
    </div>
  </div>
</template>
```

The `AposSchema` component does the majority of work constructing and displaying our schema fields, as well as passing data.

In this case, we are wrapping it in some additional markup to allow for customized styling. In making your components, this may not be necessary. To return the letter grade we are adding a span after the `AposSchema` with content set by the computed `letterGrade`.

The `AposSchema` component takes the array of schema fields passed to `:schema`, renders their inputs and emits a new object with `value` and `hasErrors` sub-properties when changes occur.

The `:trigger-validation` and `:generation` prop bindings are used by Apostrophe to manage field validation, control how fields are displayed, and update the form when schema changes occur.

Finally, to keep track of state within our component, we are using the `ref` function to create a reactive `gradeSchemaInput` object and binding it to `v-model`.

**The schema field JavaScript**

At the top of our script, we import all the mixins and component files that we will be using in our custom component. We are also importing the Vue `ref` and `watch` functions to be used in our component.

```vue
import { ref, watch, onMounted, nextTick } from 'vue';
import AposInputMixin from 'apostrophe/modules/@apostrophecms/schema/ui/apos/mixins/AposInputMixin';
import AposInputWrapper from 'apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposInputWrapper.vue';
import AposSchema from 'apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposSchema.vue';
```

In this case, we are bringing the `AposInputMixin` mixin into our script. This provides prop declarations for several of the props used in both the `AposInputWrapper` and `AposSchema` components. We could set up and use a Vite shortcut, but since not everyone will necessarily have the same Vite config, the imports are using the entire path within the `node_modules` folder of the project.

We are also importing the files for the actual components. While not shown here, button controls can be added by bringing in the `<AposButton>` component from `apostrophe/modules/@apostrophecms/ui/ui/apos/components/AposButton.vue`.

```vue
export default {
  name: 'InputGradeField',
  components: {
    AposInputWrapper,
    AposSchema
  },
  mixins: [ AposInputMixin ],
```

The main script starts with the `name` property, which is set by convention to the same value as the name of the file. This is followed by the `components` property, with an object of the components that we just loaded. If your component uses the button component, you would add `AposButton` to this object. Similarly, the `mixins` property takes an array of the mixins we just imported.

```vue
props: {
  generation: {
    type: Number,
    required: false,
    default: null
  },
  modelValue: {
    type: Object,
    required: true
  }
},
```

Next, we declare two props. First is the `generation` prop that Apostrophe uses for triggering the re-render of the component, such as when the user changes page-type. The second is the `modelValue` prop, which is used for two-way binding between the parent and child components, allowing the component to receive and update the value from the parent.

```vue
setup(props, { emit }){
  ...
}
```

The setup function is the entry point for using the Composition API in Vue 3. It replaces the data, methods, computed, and watch options in the Options API, providing a more concise and flexible way to manage component logic. In this function, `props` provides access to the component's props, allowing us to use and manipulate the data passed from the parent component. The `{ emit }` object allows us to emit events from the component, enabling communication with the parent component by sending updates or triggering actions.

```vue
const getNext = () => {
  return props.modelValue && props.modelValue.data ? props.modelValue.data : (props.field.def || {});
};
```

The `getNext()` function returns either the stored input field values, the individual field defaults set in the schema if there are no stored values, or an empty object in the absence of a stored value or field default value. As we will see for the color gradient custom field section, you can pre-populate your schema with input using this function.

```vue
const next = ref(getNext());
const gradeSchema = apos.modules['student'].gradeSchema;
const gradeSchemaInput = ref({ data: next.value });
```
In this code, we are creating a reactive reference called `next` and initializing it using the `getNext()` method we just created. Again, this will bring in any saved values or default values if they exist, to populate the schema fields.

Next, we access the schema we used in our `student` piece through the `apos.modules` object. Remember that we extended the `getBrowserData()` method to make the schema available as `gradeSchema`.

Finally, we create another reactive reference called `gradeSchemaInput`, initialized with an object containing the `next.value`. This object will be used to bind the data to the `AposSchema` component via `v-model`, ensuring that the form inputs are reactive and synchronized with the component's state.

```vue
onMounted(() => {
  nextTick(() => {
    // Create a new object reference to force reactivity
    next.value = { ...next.value };
  });
});
```

The Vue `onMounted()` lifecycle hook runs after the component has been mounted to the DOM. In this case, it's combined with `nextTick()` to ensure that the DOM and reactivity system are fully updated before performing changes. Reassigning `next.value` to a new object using the spread operator (`{ ...next.value }`) creates a new reference, which forces Vue to recognize the change and trigger reactivity.

```vue
watch(() => props.generation, () => {
  next.value = getNext();
  gradeSchemaInput.value = {
    data: next.value
  };
});

watch(gradeSchemaInput, (newValue) => {
  if (!newValue.hasErrors) {
    next.value = newValue.data;
    emit('update:modelValue', { data: next.value });
  }
}, { deep: true });

```

The next two blocks of code sets up watchers to monitor and trigger an update if either the `generation` prop or the input fields are changed.

The first watcher is on the `generation` prop. This method will fire if the `generation` prop is either updated within the component or by Apostrophe. This causes the component and all of its sub-fields to re-render, which is needed if a parent component needs to change the schema itself, e.g. when a field type is used in a page and the page type changes. Note that you can utilize this watcher to trigger an update of the component. But, you should avoid mutating the passed prop by setting ``:generation="`${generation}:${innerGeneration}`"``, and then triggering the update by incrementing the `innerGeneration` value.

The `gradeSchemaInput` handler will be called any time there is a change to one of our schema input fields. As long as there aren't errors in any of the schema fields, this will update the state values for our input fields.

``` vue
function validate(value) {
  if (this.gradeSchemaInput.hasErrors) {
    return 'invalid';
  }
  return false;
}
```

Every input field requires a `validate()` function. In this case, the code checks whether the `hasErrors` sub-property of the `gradeSchemaInput` object is true. If so, it returns the `invalid` error string. Otherwise, it returns `false`.

You can also choose to add further custom field validation that doesn't exist in the normal field schema to this method. For example, you might require that the `class` string always have a prefix that is added from a `following` field. You could access the value of the field using `value.class` and check it using `.startsWith()`. You could then return a custom error string like, `needs prefix` to the user.

```javascript
const letterGrade = computed(() => {
      if (!next.value.midterm && !next.value.final) {
        return '';
      }

      const midterm = next.value.midterm;
      const final = next.value.final;

      // Calculate average, handling cases where only one score exists
      let average = (midterm !== undefined && final !== undefined) 
        ? (midterm + final) / 2 
        : (midterm !== undefined ? midterm : final);

      // Cap the average at 100
      average = Math.min(average, 100);

      // Define grade ranges
      const gradeRanges = [
        { min: 90, max: 100, letter: 'A' },
        { min: 80, max: 89, letter: 'B' },
        { min: 70, max: 79, letter: 'C' },
        { min: 60, max: 69, letter: 'D' },
        { min: 0, max: 59, letter: 'F' },
      ];

      // Find the matching grade range
      const matchingRange = gradeRanges.find(
        ({ min, max }) => average >= min && average <= max
      );

      return matchingRange ? matchingRange.letter : '';
    });
```

The final computed property, `letterGrade`, takes the value from the two inputs and returns a letter grade for our imaginary teacher. You can't do that with a standard Apostrophe schema!

```vue
return {
  next,
  gradeSchemaInput,
  gradeSchema,
  getNext,
  validate,
  letterGrade
};
```
Lastly, we have a final `return` statement from the `setup` function that exposes all the variables and methods for use in the template.

The remainder of this file is styling and will be highly variable between custom schema fields. You can use styling from the `@apostrophecms/schema/ui/apos/components/` files as a good starting point.

## Building the custom color gradient field type

![Screenshot of the custom color gradient picker schema field in the editor](../images/recipes/custom-schema-color-gradient.png)
This custom schema field lets the editor create linear color gradients using any number of colors by taking advantage of an inline array schema field. The output from this could be used for the background of a hero or text with a gradient of color.

Just like with our first example, we need to create server-side code to handle registering the schema field type, plus sanitizing and storing the data in the database. We also need to create the browser-side Vue component to display our fields to the editor.

### Creating the server-side code

<AposCodeBlock>

```javascript
export default {
  init(self) {
    self.enableBrowserData();
    self.getBrowserData();
    self.addColorGradientFieldType();
  },
  methods(self) {
    return {
      exposeSchema() {
        const schema = [
          {
            name: 'angle',
            label: 'Angle',
            type: 'range',
            min: 0,
            max: 360,
            unit: 'deg',
            def: 0
          },
          {
            name: 'colors',
            label: 'Colors',
            type: 'array',
            draggable: true,
            inline: true,
            schema: [
              {
                name: 'color',
                label: 'Add Color',
                type: 'color'
              },
              {
                name: 'stop',
                label: 'Stop',
                type: 'range',
                min: 0,
                max: 100,
                unit: '%'
              }
            ]
          }
        ];
        return schema;
      },
      addColorGradientFieldType() {
        self.apos.schema.addFieldType({
          name: 'colorGradient',
          convert: self.convertInput,
          vueComponent: 'InputColorGradientField'
        });
      },
      async convertInput(req, field, data, object) {
        data = data[field.name];
        const schema = self.exposeSchema();
        const errors = [];
        const result = {};
        if (data == null || typeof data !== 'object' || Array.isArray(data)) {
          data = {};
        }
        try {
          await self.apos.schema.convert(req, schema, data, result);
        } catch (e) {
          for (const error of e) {
            errors.push({
              path: error.path,
              error: error.error
            });
          }
        }
        object[field.name] = result;
        if (errors.length) {
          throw errors;
        }
      },
      getBrowserData(req) {
        return {
          gradientSchema: self.exposeSchema()
        };
      }
    };
  }
};
```
  <template v-slot:caption>
    /modules/color-gradient/index.js
  </template>
</AposCodeBlock>

For this example, we aren't going to explain every single line of the code. We are only going to point out major differences from the first example.

```javascript
init(self) {
  self.enableBrowserData();
  self.getBrowserData();
  self.addColorGradientFieldType();
},
```

Rather than adding this custom schema field for a specific piece, we are adding this field through a stand-alone module that extends core `@apostrophecms/module`. This is a useful case for providing a schema field that may be used in several projects that don't have overlapping piece, widget, or page types.

Because it is a stand-alone module, within the `init(self)` method, we have to call the `self.enableBrowserData()` method to give access to the browser data. We then use a call to a `getBrowserData()` method that we define in our `methods(self)`. While the core module has a `getBrowserData()` that we could extend, it only returns an empty object, so it isn't necessary. Finally, we are calling the function to add our custom field type, just like we did in the first example.

```javascript
methods(self) {
  return {
    exposeSchema() {
      const schema = [
        {
          name: 'angle',
          label: 'Angle',
          type: 'range',
          min: 0,
          max: 360,
          unit: 'deg',
          def: 0
        },
        {
          name: 'colors',
          label: 'Colors',
          type: 'array',
          draggable: true,
          inline: true,
        üëâüèªschema: [
            {
              name: 'color',
              label: 'Add Color',
              type: 'color'
            },
            {
              name: 'stop',
              label: 'Stop',
              type: 'range',
              min: 0,
              max: 100,
              unit: '%',
              def: 0
            }
          ]
        }
      ];
      return schema;
    }
```
Once again, we are creating a function to return the schema we want to use. The overall schema should be an array of objects, with the name property included within the object. An additional change from our normal schema is that our `array` schema field should receive an array of schema field objects passed to the `schema` property. Remember that in a normal module schema the `array` field gets the schema through a `fields` property that receives an `add` property with an object of named objects. If you elect to use an `object` schema field you will need to make the same alteration.

```javascript
getBrowserData(req) {
  return {
    schema: self.exposeSchema()
  };
},
```

As explained for the `init(self)` section of code, we are creating a `getBrowserData(req)` method within the `methods(self)` section, rather than the `extendMethods(self)` section. This adds the schema to the browser data so that we can access it within the Vue component.

```javascript
addColorGradientFieldType() {
  self.apos.schema.addFieldType({
    name: 'colorGradient',
    convert: self.convertInput,
    vueComponent: 'InputColorGradientField'
  });
},
async convertInput(req, field, data, object) {
  data = data[field.name];
  const schema = self.exposeSchema();
  const errors = [];
  const result = {};
  if (data == null || typeof data !== 'object' || Array.isArray(data)) {
    data = {};
  }
  try {
    await self.apos.schema.convert(req, schema, data, result);
  } catch (e) {
    for (const error of e) {
      errors.push({
        path: error.path,
        error: error.error
      });
    }
  }
  object[field.name] = result;
  if (errors.length) {
    throw errors;
  }
}
```
The remainder of the `methods(self)` section is nearly identical to the first example. We add our custom field type using `self.apos.schema.addFieldType()` and the appropriate property values. Then we provide the `convertInput()` method to sanitize and store the data.

### Creating the Vue component


<AposCodeBlock>

```vue
<template>
  <AposInputWrapper :field="field" :error="effectiveError" :uid="uid" :display-options="displayOptions" :modifiers="modifiers">
    <template #body>
      <div class="apos-input-object">
        <div class="apos-input-wrapper">
          <!-- Gradient preview section -->
          <div
            id="color-square"
            :style="{ background: gradient }"
            class="gradient-preview"
          />
          <!-- Schema form for editing gradient properties -->
          <AposSchema
            :schema="gradientSchema"
            :trigger-validation="triggerValidation"
            :generation="generation"
            v-model="gradientSchemaInput"
          >
          </AposSchema>
        </div>
      </div>
    </template>
  </AposInputWrapper>
</template>

<script>
import { ref, computed, watch, onMounted, nextTick } from 'vue';
import AposInputMixin from 'apostrophe/modules/@apostrophecms/schema/ui/apos/mixins/AposInputMixin';
import AposInputWrapper from 'apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposInputWrapper.vue';
import AposSchema from 'apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposSchema.vue';

export default {
  name: 'InputColorGradientField',
  components: {
    AposInputWrapper,
    AposSchema
  },
  mixins: [AposInputMixin],
  props: {
    // The generation prop is used to trigger validation in parent components
    generation: {
      type: Number,
      required: false,
      default: null
    },
    // The model value containing our gradient data
    modelValue: {
      type: Object,
      required: true
    }
  },
  setup(props, { emit }) {
    // Get initial gradient data from props or use defaults
    const getNext = () => {
      return props.modelValue.data ?? (props.field.def || {
        angle: 90,
        colors: [
          { color: '#d0021bff', stop: 0 },
          { color: '#4a11ffff', stop: 100 }
        ]
      });
    };

    // Create reactive state for the gradient data
    const next = ref(getNext());

    // Get the schema from Apostrophe modules
    const gradientSchema = apos.modules['color-gradient'].gradientSchema;

    // Create the input for the schema form
    const gradientSchemaInput = ref({ data: next.value });

    /**
     * Vue 3 Reactivity Note:
     * In Vue 3, reactivity for initial values sometimes needs an explicit trigger.
     * The onMounted hook with nextTick ensures our gradient is properly rendered
     * after the component is fully mounted.
     */
    onMounted(() => {
      nextTick(() => {
        // Create a new object reference to force reactivity
        next.value = { ...next.value };
      });
    });

    // Watch for generation changes from parent component
    watch(() => props.generation, () => {
      next.value = getNext();
      gradientSchemaInput.value = { data: next.value };
    });

    // Watch for internal schema input changes
    watch(gradientSchemaInput, (newValue) => {
      if (!newValue.hasErrors) {
        next.value = newValue.data;
        // Emit update to parent component
        emit('update:modelValue', { data: next.value });
      }
    }, { deep: true });

    // Validator function for the gradient data
    function validate(value) {
      if (gradientSchemaInput.value.hasErrors) {
        return 'invalid';
      }
      return false;
    }

    /**
     * Compute the CSS gradient string from our data
     * This dynamically creates a linear-gradient CSS function
     * based on the angle and colors in our data.
     */
    const gradient = computed(() => {
      // Ensure we have valid data before creating gradient
      if (!next.value.colors || !next.value.angle) {
        return '';
      }

      // Build the gradient string from the angle and color stops
      const gradientString = next.value.colors.reduce((acc, curr, i, colors) => {
        acc += `${curr.color} ${curr.stop}%`;
        // Add comma between color stops, or close parenthesis for the last stop
        if (i !== colors.length - 1) {
          acc += ', ';
        } else {
          acc += ')';
        }

        return acc;
      }, `linear-gradient(${next.value.angle}deg, `);

      return gradientString;
    });

    // Return values for the template
    return {
      next,
      gradientSchema,
      gradientSchemaInput,
      getNext,
      gradient,
      validate
    };
  }
};
</script>

<style lang="scss" scoped>
.gradient-preview {
  height: 200px;
  width: 100%;
  border-radius: 4px;
  margin-bottom: 20px;
  transition: background 0.3s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

li {
  list-style: none;
}

.apos-input-object {
  border-left: 1px solid var(--a-base-9);
}

.apos-input-wrapper {
  margin: 20px 0 0 19px;
}

.apos-input-object ::deep .apos-schema .apos-field {
  margin-bottom: 30px;
}

.span-right {
  float: right;
}
</style>
```

  <template v-slot:caption>
    modules/color-gradient/ui/apos/components/InputColorGradientField.vue
  </template>
</AposCodeBlock>

For this example, we aren't going to explain every single line of the code. We are only going to point out major differences from the first example.

```vue
<template>
  <AposInputWrapper :field="field" :error="effectiveError" :uid="uid" :display-options="displayOptions" :modifiers="modifiers">
    <template #body>
      <div class="apos-input-object">
        <div class="apos-input-wrapper">
          <div
            id="color-square"
            :style="{ background: gradient }"
            class="gradient-preview"
          />
          <AposSchema
            :schema="gradientSchema"
            :trigger-validation="triggerValidation"
            :generation="generation"
            v-model="gradientSchemaInput"
          >
          </AposSchema>
        </div>
      </div>
    </template>
  </AposInputWrapper>
</template>
```
For the template section of our custom schema field, the only notable difference is `<div id="color-square" :style="{ background: gradient }" />`. This line of markup adds the output of our selections above the input fields. It binds the style of that `div` to the computed `gradient` value.

The `AposInputWrapper` is taking the same props as were passed in the first example. The `AposSchema` is also receiving the same props, but with color gradient-specific `:schema` and `v-model` values supplied by the `setup` method.

```vue
import { ref, computed, watch, onMounted, nextTick } from 'vue';
import AposInputMixin from 'apostrophe/modules/@apostrophecms/schema/ui/apos/mixins/AposInputMixin';
import AposInputWrapper from 'apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposInputWrapper.vue';
import AposSchema from 'apostrophe/modules/@apostrophecms/schema/ui/apos/components/AposSchema.vue';
```

The identical files for mixins and components are being imported. Again, if you are adding buttons, you can also elect to import that file from the `@apostrophecms/ui` module. From the `vue` package we are importing the same functions as with the last component.

```vue
const getNext = () => {
      return props.modelValue.data ?? (props.field.def || {
        angle: 90,
        colors: [
          { color: '#d0021bff', stop: 0 },
          { color: '#4a11ffff', stop: 100 }
        ]
      });
    }
    const next = ref(getNext());
```

As compared with the first example, the `getNext()` method has been slightly expanded. Instead of returning an empty array or the field default if the field hasn't been saved yet, it returns data with the `angle` field set to `90` and two colors with the color and stop values already set. This way, as soon as the editing modal is opened there is already a gradient displayed. We are creating a reactive reference called `next` and initializing it using the `getNext()` method we just created.

```vue
const gradient = computed(() => {
  if (!next.value.colors || !next.value.angle) {
    return '';
  }
  const gradientString = next.value.colors.reduce((acc, curr, i, colors) => {
    acc += `${curr.color} ${curr.stop}%`;
    // Add comma between color stops, or close parenthesis for the last stop
    if (i !== colors.length - 1) {
      acc += ', ';
    } else {
      acc += ')';
    }
    return acc;
  }, `linear-gradient(${next.value.angle}deg, `);
  return gradientString;
});
```

The `gradient` computed property dynamically constructs a CSS linear gradient string based on the `colors` and `angle` values in `next`. It iterates through the colors array, appending each color and its stop position to the gradient string. If the colors and angle are defined, it returns the complete gradient string; otherwise, it returns an empty string. Note that this method can easily be modified and added to the `async components(self)` method of any module to deliver this same string to a template.

## Summary

Creating a custom schema that utilizes existing fields in Apostrophe is fairly easy once you get the pattern.

On the server-side, you need to expose the schema for use with the `getBrowserData()` method. Then you register the field with `self.apos.schema.addFieldType()`. Finally, you provide a function to launder and store the returned data that is identical for any custom field.

On the browser-side, you need to provide a template with an `AposInputWrapper` component wrapping an `AposSchema` field. The inputs to each are virtually identical between any custom fields, except for the two state value inputs, `:schema` and `v-model`. Depending on the desired appearance, some changes in HTML markup might be necessary. The remainder of the script code is going to be essentially identical unless you add extra computed properties, as was the case with the second example.

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Building a JSX Widget
DOC_PATH: tutorials/using-jsx-in-apostrophe.md
URL: https://apostrophecms.com/docs/tutorials/using-jsx-in-apostrophe
================================================================================
# Using JSX in Apostrophe with Vite

ApostropheCMS offers a robust and flexible platform for building content-rich websites, and it now comes with a powerful built-in Vite build system that caters to most development needs out of the box. This system streamlines the process of managing assets, optimizing performance, and ensuring a smooth developer experience. However, there are times when you may want to extend its capabilities by customizing the build process. One common scenario is integrating React components into your ApostropheCMS project for browser-side rendering, which involves customizing Vite to support JSX (JavaScript XML). By leveraging JSX and React, you can enhance the interactivity and maintainability of your front-end JavaScript components, providing a richer user experience while still taking advantage of the features offered by ApostropheCMS.

### Why Customize Your Vite Build?

Vite is a modern build tool that offers a lightning-fast development experience and optimized production builds. Customizing your Vite configuration can offer several benefits:

1. **Enhanced Development Workflow**: Customizing Vite allows you to integrate modern browser-side JavaScript frameworks like React, Vue, and Svelte, enabling a more component-based architecture.
2. **Performance Optimization**: By customizing Vite, you can take advantage of advanced features such as code splitting, tree shaking, and caching to optimize the performance of your application.
3. **Extended Functionality**: Vite's plugin system allows you to extend its functionality to handle various types of assets (e.g., images, fonts, SVGs) and preprocessors for client-side assets.
4. **Improved Maintainability**: A customized Vite build can help maintain a cleaner and more modular codebase, making it easier to manage and scale your project.

### Advantages of Using JSX for a Dynamic Component

ApostropheCMS uses Nunjucks as its server-side templating engine to handle the initial HTML rendering of your pages. To complement this server-side rendering, you can use JSX with React to add interactive and dynamic components that run entirely in the browser. This combination gives you several advantages:

1. **Component-Based Architecture**: JSX allows you to build reusable components, encapsulating both the markup and logic. This modularity makes it easier to manage complex UIs and promotes code reusability.
2. **State Management**: React's state management capabilities enable you to handle dynamic data changes efficiently. This means you can easily manage and update the state as new data is fetched.
3. **Enhanced Interactivity**: With React and JSX running in the browser, you can create highly interactive UIs with real-time updates and smooth user experiences, such as automatically updating elements without a full page reload.

### Building a Weather App with JSX

![Screenshot of the react weather widget with Philadelphia set to the default city](../images/react-weather-app.png)

In this tutorial, we'll walk through the process of customizing your Vite configuration to support JSX in an ApostropheCMS project for browser-side rendering. We'll build a weather widget that leverages the power of React components for a dynamic and interactive user interface. The code for this widget is based on a basic React tutorial that you can find [here](https://github.com/ayushkul/react-weather-app). By the end of this tutorial, you'll understand how to set up a custom Vite build and take advantage of JSX to enhance your ApostropheCMS projects with client-side interactivity.

> [!IMPORTANT] With ApostropheCMS's switch to Vite, we now encourage the use of ECMAScript Modules (ESM) for all new projects. This tutorial uses ESM syntax throughout. It's important to note that you should not mix CommonJS (CJS) and ESM syntax at the project level, as this can lead to compatibility issues. Choose one module system for your entire project.

## Adding the Weather Widget to your Project

We will start this tutorial by creating a new widget in an already created starter kit project using the [Apostrophe CLI](https://apostrophecms.com/extensions/apos-cli) tool. At the root of your project, run the following on the command line:

```sh
apos add widget react-weather-widget --player
```

The `--player` flag is important here because we'll need a browser-side JavaScript player to initialize our React components.

Next, add the new widget to the `app.js` file.

<AposCodeBlock>

```javascript
import apostrophe from 'apostrophe';

export default apostrophe({
  shortName: 'jsx-project',
  modules: {
    // other modules
    'react-weather-widget': {}
  }
});
```

  <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

You can choose to add this widget to any area, but for this tutorial we will add it to the default page-type.

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/page-type',
  options: {
    label: 'Default Page'
  },
  fields: {
    add: {
      main: {
        type: 'area',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {},
            '@apostrophecms/image': {},
            '@apostrophecms/video': {},
            'react-weather': {}
          }
        }
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: ['title', 'main']
      }
    }
  }
};
```

  <template v-slot:caption>
    modules/default-page/index.js
  </template>

</AposCodeBlock>

## Adding JSX to Our Project

Now that we have our widget added, we'll turn our attention to modifying the project's Vite configuration. In ApostropheCMS, Vite configuration can either be handled through a project level Vite configuration file - `apos.vite.config.js`, or through individual modules. Each module can specify their Vite configuration requirements in their `index.js` files under the `build.vite` property.

 For our React widget, we'll use the module-level configuration since we only need React support for this specific front-end component. Open the `modules/react-weather-widget/index.js` file and add the following:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'React Weather Widget'
  },
  build: {
    vite: {
      bundles: {
        'weather-react': {}
      }
    }
  }
};
```
<template v-slot:caption>
  modules/react-weather-widget/index.js
</template>

</AposCodeBlock>

This simple configuration tells ApostropheCMS that we want the Vite build process to add the `weather-react.js` code and all of its dependencies to be processed and bundled for use in the browser. We will add that code to the `ui/src` folder of this widget next. This configuration is similar to how [Webpack bundling](/reference/modules/asset.html#bundles) worked in previous versions of ApostropheCMS. But, you don't need to specify additional loaders or rules as you would with Webpack - Vite automatically handles different file types, including JSX, CSS, and SVG files. The empty object (`{}`) as the value for `weather-react` is where you could add advanced configuration if needed, but for most use cases, the default settings are sufficient.

This configuration is specific to this module, but ApostropheCMS will merge this with the project-wide Vite configuration.

In order for our new Vite build to function, we need to add the new development dependency. Navigate to the root of your project in your terminal and issue the following command:

```sh
npm install @vitejs/plugin-react --save-dev
```

## Creating the Weather App Component

Now that we are able to use JSX in our project, we need to create a component that utilizes it for front-end rendering. We'll place our app component files into the widget module `ui/src` folder and import them through the `weather-react.js` file we just specified in our `vite.build`. That file is also going to act to bootstrap our app.

<AposCodeBlock>

```javascript
import { createRoot } from 'react-dom/client';
import { createElement } from 'react';
import App from './jsx-components/App.jsx';

export default () => {
  apos.util.widgetPlayers.reactWeather = {
    selector: '[data-react-weather-widget]',
    player(el) {
      if (!el) {
        return;
      }
      const rootElement = el.querySelector('#react-weather-root');
      if (rootElement && !rootElement.hasAttribute('data-react-mounted')) {
        const defaultCity = rootElement.getAttribute('data-default-city');
        const app = createElement(App, { defaultCity });
        createRoot(rootElement).render(app);

        // Mark as mounted to prevent multiple rendering
        rootElement.setAttribute('data-react-mounted', 'true');
      }
    }
  };
};

```

  <template v-slot:caption>
    modules/react-weather-widget/ui/src/weather-react.js
  </template>

</AposCodeBlock>

At the top of this file we are importing `createElement` from the `react` package and the `createRoot` function from `react-dom/client`. This will allow us to use the React framework in our project. We are also importing the main entry point `App`. To use these packages we need to add them to our project dependencies. Since they are being used on the front-end in the browser, not during the Vite build, we need to add them as regular dependencies. Navigate to the root of your project in your terminal and issue the following command:

```sh
npm install react react-dom
```

The remainder of this file is a [standard widget player](/guide/custom-widgets.html#client-side-javascript-for-widgets). This player is attached to the `[data-react-weather-widget]` attribute that we will need to add to the widget Nunjucks template. Within that element, it selects an element with an id of `react-weather-root` to create the root for our React component. We are also passing a prop we are getting from the `data-default-city` attribute on our `rootElement`. We will need to set the value of this attribute using the data passed to the template from the widget schema.

### Adding the widget Nunjucks template

The markup for this widget on the Nunjucks side (server-side template) is going to be simple. We require an attribute for the player to identify the code our client-side JavaScript player should target, a target where React will render our component root, and another attribute for passing data between the widget schema fields and the React app.

<AposCodeBlock>

```nunjucks
<section data-react-weather-widget>
  <div id="react-weather-root" data-default-city="{{ data.widget.defaultCity or '' }}"></div>
</section>
```

  <template v-slot:caption>
    modules/react-weather-widget/views/widget.html
  </template>

</AposCodeBlock>

Briefly, the attribute on the `section` tag is what we are passing into the `selector` property of the player. This section contains a single `div` element that will be used as the root for our browser-side React application. Finally, on that same element we are setting the `data-default-city` attribute value to data passed from the widget `defaultCity` schema field, or an empty string if the content manager hasn't added a string to that field.

### Modifying the widget schema fields

We have already added our Vite configuration changes to the `modules/react-weather-widget/index.js` file, but now we also want to add the `defaultCity` schema field.

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'React Weather Widget'
  },
  fields: {
    add: {
      defaultCity: {
        type: 'string',
        label: 'Default City'
      }
    }
  },
  vite: {
    // vite configuration here
  }
};
```

  <template v-slot:caption>
    modules/react-weather-widget/index.js
  </template>

</AposCodeBlock>

As we will see when we cover the JSX code files, this default city will cause the widget to be prepopulated with data from a selected city that can then be replaced with user input.

### Adding the main `App.jsx` component

Since this tutorial is mainly focused on how you use React in the browser in an ApostropheCMS project, we aren't going to go through the fine points of the React code we are adding.

<AposCodeBlock>

```jsx
/* eslint-disable no-unused-vars */
import { useState, useEffect } from 'react';
import styled from 'styled-components';
import CityComponent from './CityComponent';
import WeatherComponent from './WeatherComponent';

// Move styled components outside the functional component
const Container = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 380px;
  padding: 20px 10px;
  margin: auto;
  border-radius: 4px;
  box-shadow: 0 3px 6px 0 #555;
  background: white;
  font-family: Montserrat;
`;

const AppLabel = styled.span`
  color: black;
  margin: 20px auto;
  font-size: 18px;
  font-weight: bold;
`;

function App({ defaultCity }) {
  const [city, updateCity] = useState(defaultCity || '');
  const [weather, updateWeather] = useState(null);

  useEffect(() => {
    if (defaultCity) {
      fetchWeather(defaultCity);
    }
  }, [defaultCity]);

  const fetchWeather = async (cityName) => {
    try {
      const response = await fetch(
        '/api/v1/react-weather-widget/fetch-weather?' +
          new URLSearchParams({
            city: cityName
          })
      );
      const weather = await response.json();
      updateWeather(weather);
    } catch (error) {
      console.error('Error fetching weather data:', error);
    }
  };

  const handleFetchWeather = (e) => {
    e.preventDefault();
    fetchWeather(city);
  };

  return (
    <Container>
      <AppLabel>React Weather App</AppLabel>
      <CityComponent
        updateCity={updateCity}
        fetchWeather={handleFetchWeather}
      />
      {weather && <WeatherComponent weather={weather} city={city} />}
    </Container>
  );
}

export default App;

```

  <template v-slot:caption>
    modules/react-weather-widget/ui/src/jsx-components/App.jsx
  </template>

</AposCodeBlock>

It should be noted that the two components used by this React app are being imported in the `App.jsx` file that is imported in the base `ui/src/weather-react.js` file. Vite automatically processes the JSX syntax and imports the necessary components for front-end use. The only other part of this code we need to focus on is the `fetchWeather()` function. In this app we have elected to use the [OpenWeatherMap](https://openweathermap.org/) API to retrieve the weather for each city. At the time of this writing it had a generous free tier, and easy geolocation from a city name. However, it does require an API key. We don't want to directly add this key into our `App.jsx` code since it will be exposed client-side. Instead, we are going to create a proxy endpoint in our project that will fetch the data and pass it back to our front-end component.

```javascript
const response = await fetch(
  '/api/v1/react-weather-widget/fetch-weather?' +
    new URLSearchParams({
      city: cityName
  })
);
```

This line in that function performs a fetch on the `/fetch-weather` endpoint from JavaScript running in the browser, passing in the city name as a parameter.

<AposCodeBlock>

```javascript
import dotenv from 'dotenv';
dotenv.config();

export default {
  extend: '@apostrophecms/widget-type',
  options: {
    label: 'React Weather Widget'
  },
  fields: {
    // schema field code
  },
  vite: {
    // vite configuration code
  },
  apiRoutes(self) {
    return {
      get: {
        async fetchWeather(req, res) {
          const { city } = req.query;
          const apiKey = process.env.OPENWEATHERMAP_API_KEY;
          try {
            const response = await fetch(
              'https://api.openweathermap.org/data/2.5/weather?' +
                new URLSearchParams({
                  q: city,
                  appid: apiKey
                })
            );
            const weather = await response.json();
            return weather;
          } catch (error) {
            return { error: error.message };
          }
        }
      }
    };
  }
};
```

  <template v-slot:caption>
    modules/react-weather-widget/index.js
  </template>

</AposCodeBlock>

There are several ways we can add endpoints to an ApostropheCMS project. In this case we are using the [`apiRoutes(self)` customization function](/reference/module-api/module-overview.html#customization-functions). This code creates a single `GET` route that can be accessed at the URL `/api/v1/react-weather-widget/fetch-weather`. Note that the function name automatically gets converted to kebab case, so `fetchWeather` becomes `fetch-weather`. If the function name for the route starts with a slash, we would use that directly when we are calling it from our components. This is useful when you need a public facing URL.

The remainder of this code should be fairly self-explanatory. We are getting the `city` value from the request object and the API key from the environment variable that should be passed when starting our project, `OPENWEATHERMAP_API_KEY=XXXXXX npm run dev`.

Next the function passes this information to the Open Weather Map API and gets back data that is returned to the browser-side component.

### Creating the `CityComponent` component

Again, we aren't going to focus on most of the JSX component code.

<AposCodeBlock>

```jsx
import styled from 'styled-components';
import PerfectDay from '../icons/perfect-day.svg';

const SearchBox = styled.form`
  display: flex;
  flex-direction: row;
  justify-content: space-evenly;
  margin: 20px;
  border: black solid 1px;
  border-radius: 2px;

  & input {
    padding: 10px;
    font-size: 14px;
    border: none;
    outline: none;
    font-family: Montserrat;
    font-weight: bold;
  }
  & button {
    background-color: black;
    font-size: 14px;
    padding: 0 10px;
    color: white;
    border: none;
    outline: none;
    cursor: pointer;
    font-family: Montserrat;
    font-weight: bold;
  }
`;
const ChooseCityLabel = styled.span`
  color: black;
  margin: 10px auto;
  font-size: 18px;
  font-weight: bold;
`;
const WelcomeWeatherLogo = styled.img`
  width: 140px;
  height: 140px;
  margin: 40px auto;
`;
const CityComponent = (props) => {
  const { updateCity, fetchWeather } = props;
  return (
    <>
      <WelcomeWeatherLogo src={PerfectDay} />
      <ChooseCityLabel>Find Weather of your city</ChooseCityLabel>
      <SearchBox onSubmit={fetchWeather}>
        <input
          onChange={(e) => updateCity(e.target.value)}
          placeholder='City'
        />
        <button type='submit'>Search</button>
      </SearchBox>
    </>
  );
};
export default CityComponent;
```

  <template v-slot:caption>
    modules/react-weather-widget/ui/src/jsx-components/CityComponent.jsx
  </template>

</AposCodeBlock>

We have already installed `react` as a dependency of our project, but we are also utilizing the `styled-components` package in this component. Again, this will be front-end, so it should be a normal, not development dependency. Navigate to the root of your project in your terminal and issue the following command:

```sh
npm install styled-components
```

One of the key advantages of Vite is its built-in support for various asset types. Unlike Webpack which needed specific loaders, Vite automatically handles SVG imports: `import PerfectDay from '../icons/perfect-day.svg';`. We'll place all our SVG files from the original demo in the `modules/react-weather-widget/ui/src/icons` folder.

### Creating the `WeatherComponent` component

Again, we won't touch much on the JSX code.

<AposCodeBlock>

```javascript
import styled from 'styled-components';
import SunsetIcon from '../icons/sunset.svg';
import SunriseIcon from '../icons/sunrise.svg';
import HumidityIcon from '../icons/humidity.svg';
import WindIcon from '../icons/wind.svg';
import PressureIcon from '../icons/pressure.svg';

const WeatherInfoIcons = {
  sunset: SunsetIcon,
  sunrise: SunriseIcon,
  humidity: HumidityIcon,
  wind: WindIcon,
  pressure: PressureIcon
};

const Location = styled.span`
  margin: 15px auto;
  text-transform: capitalize;
  font-size: 28px;
  font-weight: bold;
`;

const Condition = styled.span`
  margin: 20px auto;
  text-transform: capitalize;
  font-size: 14px;
  & span {
    font-size: 28px;
  }
`;

const WeatherInfoLabel = styled.span`
  margin: 20px 25px 10px;
  text-transform: capitalize;
  text-align: start;
  width: 90%;
  font-weight: bold;
  font-size: 14px;
`;

const WeatherIcon = styled.img`
  width: 100px;
  height: 100px;
  margin: 5px auto;
`;

const WeatherContainer = styled.div`
  display: flex;
  width: 100%;
  margin: 30px auto;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
`;

const WeatherInfoContainer = styled.div`
  display: flex;
  width: 90%;
  flex-direction: row;
  justify-content: space-evenly;
  align-items: center;
  flex-wrap: wrap;
`;

const InfoContainer = styled.div`
  display: flex;
  margin: 5px 10px;
  flex-direction: row;
  justify-content: space-evenly;
  align-items: center;
`;

const InfoIcon = styled.img`
  width: 36px;
  height: 36px;
`;

const InfoLabel = styled.span`
  display: flex;
  flex-direction: column;
  font-size: 14px;
  margin: 15px;
  & span {
    font-size: 12px;
    text-transform: capitalize;
  }
`;

const WeatherInfoComponent = (props) => {
  const { name, value } = props;
  return (
    <InfoContainer>
      <InfoIcon src={WeatherInfoIcons[name]} />
      <InfoLabel>
        {value}
        <span>{name}</span>
      </InfoLabel>
    </InfoContainer>
  );
};

const WeatherComponent = (props) => {
  const { weather } = props;
  const isDay = weather?.weather[0].icon?.includes('d');
  const getTime = (timeStamp) => {
    return `${new Date(timeStamp * 1000).getHours()} : ${new Date(
      timeStamp * 1000
    ).getMinutes()}`;
  };
  return (
    <>
      <Location>{`${weather?.name}, ${weather?.sys?.country}`}</Location>
      <WeatherContainer>
        <Condition>
          <span>{`${Math.floor(weather?.main?.temp - 273)}¬∞C`}</span>
          {`  |  ${weather?.weather[0].description}`}
        </Condition>
        <WeatherIcon
          src={`https://openweathermap.org/img/wn/${weather?.weather[0].icon}@2x.png`}
        />
      </WeatherContainer>

      <WeatherInfoLabel>Weather Info</WeatherInfoLabel>
      <WeatherInfoContainer>
        <WeatherInfoComponent
          name={isDay ? 'sunset' : 'sunrise'}
          value={`${getTime(weather?.sys[isDay ? 'sunset' : 'sunrise'])}`}
        />
        <WeatherInfoComponent
          name={'humidity'}
          value={weather?.main?.humidity}
        />
        <WeatherInfoComponent name={'wind'} value={weather?.wind?.speed} />
        <WeatherInfoComponent
          name={'pressure'}
          value={weather?.main?.pressure}
        />
      </WeatherInfoContainer>
    </>
  );
};

export default WeatherComponent;
```

  <template v-slot:caption>
    modules/react-weather-widget/ui/src/jsx-components/WeatherComponent.jsx
  </template>

</AposCodeBlock>

As with the `CityComponent.jsx` file, we are importing the `styled-components` package. We are also importing five SVG weather info icons from the `modules/react-weather-widget/ui/src/icons` folder. The OpenWeatherMap site makes the remainder of the images we need available on their site.

## Adding Hot Module Replacement for React

At this point, your React weather widget is fully functional! You can add it to pages in the ApostropheCMS admin UI, configure the default city, and users can interact with it to search for weather data in different locations. However, there's one more enhancement we can make to improve the development experience.

While Vite provides excellent built-in Hot Module Replacement (HMR) capabilities for many frameworks, integrating React's HMR functionality in an ApostropheCMS project requires a few extra steps. This is because React's "Fast Refresh" needs specific runtime code injected into the page to properly maintain component state during development.

With proper HMR support, you can make changes to your React components and see them instantly reflected in the browser without losing the current state of your application or requiring a full page reload‚Äîmaking your development workflow much more efficient.

### Adding the Vite-React Module from the Demo Repository

Instead of creating this module from scratch, we can leverage the work already done in the official ApostropheCMS Vite demo repository (https://github.com/apostrophecms/vite-demo). This repository contains a ready-to-use `vite-react` module that we can copy into our project.

Clone or download the demo repository, then copy the `modules/vite-react` directory into your project:

```sh
# Clone the repository (if you haven't already)
git clone https://github.com/apostrophecms/vite-demo.git

# Copy the vite-react module to your project
cp -r vite-demo/modules/vite-react your-project/modules/
```
Next, register the module in your `app.js` file:

<AposCodeBlock>

```javascript
export default apostrophe({
  shortName: 'jsx-project',
  modules: {
    // other modules
    'react-weather-widget': {},
    'vite-react': {}
  }
});
```

  <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

Let's take a quick look at the code this module adds to our project, starting with the `index.js` file:

<AposCodeBlock>

```javascript
import { defineConfig } from '@apostrophecms/vite/vite';
import react from '@vitejs/plugin-react';

export default {
  build: {
    vite: {
      extensions: {
        enableReact: defineConfig({
          plugins: [ react() ]
        })
      }
    }
  },
  init(self) {
    // Add the React Refresh runtime to the head of the page
    // but only in HMR mode.
    self.apos.template.prepend({
      where: 'head',
      when: 'hmr:public',
      bundler: 'vite',
      component: 'vite-react:reactRefresh'
    });
  },
  components(self) {
    return {
      // Our async server component for the React refresh runtime
      reactRefresh(req, data) {
        return {};
      }
    };
  }
};
```

  <template v-slot:caption>
    modules/vite-react/index.js
  </template>

</AposCodeBlock>

This code extends Vite's configuration by adding the official React plugin, which provides Fast Refresh capabilities for React applications.

The most interesting part is how this module connects to ApostropheCMS's templating system. In the `init` function, we use `self.apos.template.prepend` to inject code into the `<head>` section of our pages, but only when running in development mode with HMR enabled (specified by `when: 'hmr:public'`). The `component: 'vite-react:reactRefresh'` line creates the connection between this insertion point and the actual content to be inserted.

That connection works through ApostropheCMS's component system. When we define `reactRefresh` in the `components(self)` method, we're telling ApostropheCMS, "When you see `vite-react:reactRefresh`, run this function and then look for a template with the same name." The system then finds and renders the `reactRefresh.html` template from the `views` directory.

The rendered template contains the JavaScript needed to connect React's Fast Refresh with Vite's HMR system. This script imports the React Refresh runtime directly from the Vite dev server and sets up the necessary global hooks that React's Fast Refresh mechanism requires for maintaining component state during updates.

Now, let's take a quick look at the component template that will inject the React Fast Refresh runtime into our page:

<AposCodeBlock>

```html
<script type="module">
  import RefreshRuntime from '{{ apos.asset.devServerUrl("/@react-refresh") }}'
  RefreshRuntime.injectIntoGlobalHook(window)
  window.$RefreshReg$ = () => {}
  window.$RefreshSig$ = () => (type) => type
  window.__vite_plugin_react_preamble_installed__ = true
</script>
```

  <template v-slot:caption>
    modules/vite-react/views/reactRefresh.html
  </template>

</AposCodeBlock>


Unlike Vue or Svelte, which have HMR capabilities more directly integrated with Vite out of the box, React requires this additional runtime code to properly preserve component state during hot updates. The code we're adding essentially bridges Vite's HMR API with React's Fast Refresh system for front-end development.

I highly recommend checking out the full Vite demo repository at https://github.com/apostrophecms/vite-demo for more examples of how to leverage Vite in your ApostropheCMS projects. The repository contains additional patterns and techniques that might be helpful as you continue to build more complex applications with React and other frontend frameworks.

## Conclusions

In this tutorial, we covered the basics of how to create a widget powered by React and JSX components running in the browser using Vite as the build tool. One of the biggest advantages of migrating from Webpack to Vite is the simplified configuration and the improved developer experience. With Vite:

1. **Less Configuration**: Vite requires minimal configuration compared to Webpack, handling most common use cases out of the box.
2. **Native ES Module Support**: Vite leverages native ES modules in the browser during development, resulting in faster startup times, and also allows for better tree-shaking and provides a more modern development experience.
3. **Automatic Asset Handling**: Vite automatically handles various file types including SVGs, images, and CSS files without additional loaders for browser-side assets.
4. **Hot Module Replacement (HMR)**: Vite offers lightning-fast HMR which updates your browser instantly without a full page reload.

Similar steps can be used to allow you to use Vue, Svelte, or Angular components in your project. You need to identify the correct Vite plugins for the framework you want to use, add them to your configuration, and ensure that your component files are properly structured. Remember that with Vite, ECMAScript Modules (ESM) are the preferred module format, which means using `import`/`export` syntax instead of CommonJS `require()`/`module.exports`.

For this widget, we only added a single render root. But to add additional components, we simply need to make sure that each element passed from the DOM to the `createRoot()` function is unique. Whether it is passed through a widget player, added as a fragment, or directly into the Nunjucks template. Note that if you are adding front-end JavaScript to create and render your root element outside a widget player, make sure to wrap your script in an [`apos.util.onReady()`](/guide/front-end-helpers.html#onready-fn) listener so that it triggers a re-render when the page content is updated during editing.

> [!IMPORTANT] The approach shown in this tutorial is specifically for enhancing your ApostropheCMS site with interactive browser-side components using React. This is not an alternative to ApostropheCMS's server-side Nunjucks templating system but rather a complementary approach for adding rich client-side interactivity to your pages.

Remember the clear separation of concerns:

- **Server-side templates (Nunjucks)**: Handle the initial HTML rendering and provide the structure of your pages. This is where ApostropheCMS shines with its powerful CMS capabilities.
- **Browser-side components (React/JSX)**: Enhance specific parts of your pages with rich interactivity that happens entirely in the user's browser after the initial page load.

This hybrid approach gives you the best of both worlds: the content management capabilities and server-rendered performance of ApostropheCMS, plus the rich interactive experiences possible with React running in the browser.

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Local Extension Development
DOC_PATH: tutorials/local-extension-development.md
URL: https://apostrophecms.com/docs/tutorials/local-extension-development
================================================================================
# Local Development of ApostropheCMS Extensions

> [!TIP]
> This guide is for developers creating reusable ApostropheCMS extensions (npm packages) that can be installed across multiple projects. If you're just adding custom modules to a single ApostropheCMS project, you don't need this - simply create your modules directly in the project's `modules/` folder.

## Why This Matters

ApostropheCMS extensions are standalone npm packages that add functionality to multiple sites. When building these extensions, you need a reliable way to develop and test them locally before publishing to npm. However, ES Modules in Node.js handle symlinks differently than CommonJS, and ApostropheCMS's use of Vite for bundling creates additional complexity that breaks many traditional local development approaches.

This guide shows you proven methods for local extension development that work reliably with the modern ApostropheCMS toolchain.

## The Problem üîç

ES Modules have stricter rules for resolving module paths through symlinks compared to CommonJS. Additionally, Vite's dependency resolution system can fail when:
- Extensions are linked using traditional `npm link`
- File-based dependencies create circular resolution paths
- Symlinks don't properly resolve nested dependencies

These issues manifest as import errors, missing dependencies, or build failures that can be frustrating to debug.

## Recommended Solutions ‚úÖ

### 1. Manual Symbolic Links (Most Reliable)

Based on extensive testing with ApostropheCMS projects, manual symbolic links provide the most reliable development experience with Vite:

#### For Published Extensions

When working on an extension that's already published to npm, you'll need to clone the extension's repository and link to your local git checkout:

**Step 1: Clone and prepare the extension repository**

<AposCodeBlock>

```bash
# Clone the extension's repository
git clone https://github.com/your-org/your-extension.git
cd your-extension

# Install the extension's dependencies
npm install
```

</AposCodeBlock>

**Step 2: Link to your ApostropheCMS project**

<AposCodeBlock>

```bash
# In your ApostropheCMS project directory
# Install the extension normally to add it as a dependency
npm install @your-org/your-extension

# Remove the installed npm version
rm -rf node_modules/@your-org/your-extension

# Create symbolic link to your git checkout
ln -s /absolute/path/to/your-extension-repo node_modules/@your-org/your-extension
```

</AposCodeBlock>

> [!IMPORTANT]
> Always use absolute paths when creating symbolic links. Relative paths are resolved from the symlink's location, not your current directory. For example, if you use `ln -s ../form node_modules/@apostrophecms/form`, the symlink will look for `../form` relative to `node_modules/@apostrophecms/`, which would be `node_modules/form` (likely non-existent). This creates a broken symlink that appears as an empty file icon.

**After linking, restart your ApostropheCMS development server** to ensure all changes are properly detected.

#### For New (Unpublished) Extensions

When developing a brand-new extension:

<AposCodeBlock>

```bash
# In your extension directory
npm install

# In your ApostropheCMS project
mkdir -p node_modules/@your-org

# Create the symbolic link
ln -s /absolute/path/to/your/extension node_modules/@your-org/your-extension

# Install any peerDependencies listed in your extension's package.json
npm install dependency-a dependency-b
```

</AposCodeBlock>

> [!IMPORTANT]
> Always use absolute paths when creating symbolic links. Relative paths can cause resolution issues with Vite's dependency scanning.

**After linking, restart your ApostropheCMS development server** to ensure all changes are properly detected.

### 2. npm Workspaces (For Monorepos)

Workspaces work well when both your project and extension live in the same repository, providing automatic dependency linking without manual symlink management. You *may* require Vite configuration adjustments for complex setups::

<AposCodeBlock>

```
apostrophe-monorepo/
‚îú‚îÄ‚îÄ package.json              # Workspace root
‚îú‚îÄ‚îÄ my-website/               # Your ApostropheCMS project
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îî‚îÄ‚îÄ packages/
    ‚îî‚îÄ‚îÄ your-extension/       # Your extension
        ‚îú‚îÄ‚îÄ package.json
        ‚îî‚îÄ‚îÄ index.js
```
  <template v-slot:caption>
    Project Structure
  </template>
</AposCodeBlock>

**Step 1: Configure the workspace root**

<AposCodeBlock>

```json
{
  "name": "apostrophe-monorepo",
  "private": true,
  "workspaces": [
    "my-website",
    "packages/*"
  ]
}
```
  <template v-slot:caption>
    package.json
  </template>
</AposCodeBlock>

**Step 2: Reference the extension in your ApostropheCMS project**

<AposCodeBlock>

```json
{
  "name": "my-website",
  "dependencies": {
    "apostrophe": "^4.0.0",
    "@your-org/your-extension": "*"
  }
}
```
  <template v-slot:caption>
    my-website/package.json
  </template>
</AposCodeBlock>

**Step 3: Install and run**

<AposCodeBlock>

```bash
# From the workspace root
npm install

# Start your ApostropheCMS project
cd my-website
npm run dev
```

</AposCodeBlock>

npm workspaces automatically creates symbolic links between your extension and ApostropheCMS project, eliminating the need for manual linking. Changes to your extension code are immediately available in your project without restarting the development server.

## Approaches to Avoid ‚ùå

### `npm link`

Standard `npm link` typically fails with ApostropheCMS and Vite due to:
- Dependency resolution conflicts
- Vite unable to properly scan linked dependencies
- Import path resolution errors in ES Modules

### `file:` Dependencies

Using `file:` references often causes Vite build errors:
```
Rollup failed to resolve import "[dependency]" from "[path]"
```

### `--preserve-symlinks` Flag

This Node.js flag doesn't resolve the Vite-specific dependency scanning issues in ApostropheCMS.

## Troubleshooting Tips

### Extension Not Found After Linking

1. Verify the symbolic link was created correctly:
   ```bash
   ls -la node_modules/@your-org/
   ```

2. Check that your extension's `package.json` has the correct `name` field

3. Restart the ApostropheCMS development server

### Vite Build Errors

If you encounter Vite build errors after linking:

1. Clear node_modules and reinstall:
   ```bash
   rm -rf node_modules package-lock.json
   npm install
   # Recreate your symbolic links
   ```

2. Check for conflicting dependency versions between your extension and main project

3. Ensure your extension's dependencies are also installed in the main project

### Module Resolution Issues

If imports fail to resolve:

1. Verify your extension exports are properly defined in `package.json`:
   ```json
   {
     "type": "module",
     "main": "index.js",
     "exports": {
       ".": "./index.js"
     }
   }
   ```

2. Check that file extensions are included in import statements if required

## Best Practices

**Use Absolute Paths**: Always use absolute paths when creating symbolic links to avoid resolution ambiguity.

**Restart Development Server**: After linking or unlinking extensions, restart your ApostropheCMS development server to ensure proper module resolution.

**Version Alignment**: Keep dependency versions aligned between your extension and main project to avoid conflicts.

**Test Before Publishing**: Always test your extension in a clean environment before publishing to npm to catch dependency issues early.

## Conclusion

Manual symbolic links provide the most reliable approach for local ApostropheCMS extension development. While workspaces can work for monorepo setups, the symbolic link approach gives you the flexibility to develop extensions independently while maintaining compatibility with Vite's build system.

Remember to restart your development server after making linking changes, and always test in a clean environment before publishing your extensions.

================================================================================
COLLECTION: tutorials
NAV_PATH: Recipes > Creating Command Line Tasks
DOC_PATH: tutorials/creating-command-line-tasks.md
URL: https://apostrophecms.com/docs/tutorials/creating-command-line-tasks
================================================================================
# Creating Command-Line Tasks in ApostropheCMS

## Why This Matters

Command-line tasks are essential tools for any content management system. They allow you to automate repetitive operations, generate test data, perform maintenance, run migrations, and execute batch operations without tying up your web server. In ApostropheCMS, tasks have full access to your data models and business logic, making them powerful tools for developers and site administrators.

Common use cases for command-line tasks include:
- **Data generation**: Creating sample content for development and testing
- **Maintenance operations**: Cleaning up orphaned data or optimizing content
- **Reporting**: Generating analytics or export files
- **Batch operations**: Bulk updates to content or user accounts

## Understanding ApostropheCMS Tasks

Tasks in ApostropheCMS are defined in your module's configuration and can be invoked from the command line using this pattern:

```bash
node app module-name:task-name --arguments
```

When a task runs, Apostrophe fully initializes (connecting to the database, loading all modules, etc.) but doesn't start listening for web connections. This means you have complete access to all your module methods, database queries, and business logic.

## Before Creating Custom Tasks

ApostropheCMS includes several built-in tasks that may already solve your needs:

- **Content generation**: All piece types have a basic [`generate` task](/reference/modules/piece-type.html#generate) built-in (`node app [piece-type-name]:generate --total=10`)
- **CSV import/export**: The [Import/Export extension](https://apostrophecms.com/extensions/import-export) provides CSV export functionality
- **Database operations and other built-in tasks**: Many core modules provide specialized tasks documented in their reference pages. For example, the [Express module](/reference/modules/express.html) and [Migration module](/reference/modules/migration.html) include tasks for their specific domains. Check the reference documentation for any module you're working with, and exploring the source code of core modules can also reveal useful task patterns and implementation techniques.

## Creating Your First Task

Let's create a practical example: a task that generates sample article content for testing purposes. While ApostropheCMS already includes a basic version of this functionality for all piece types (`node app [piece-type-name]:generate --total=[integer]`), building our own version demonstrates the key concepts you'll use in any custom task.

### Step 1: Define the Task in Your Module

In your article module (or any piece-type module), add a `tasks` section:

<AposCodeBlock>

```javascript
export default {
  extend: '@apostrophecms/piece-type',
  options: {
    label: 'Article',
    pluralLabel: 'Articles'
  },
  fields: {
    add: {
      subtitle: {
        type: 'string',
        label: 'Subtitle'
      },
      body: {
        type: 'area',
        label: 'Body',
        options: {
          widgets: {
            '@apostrophecms/rich-text': {}
          }
        }
      }
    },
    group: {
      basics: {
        label: 'Basics',
        fields: [ 'title', 'subtitle', 'body' ]
      }
    }
  },
  tasks(self) {
    return {
      generate: {
        usage: 'Generate sample articles for testing.\nUsage: node app article:generate --total=20',
        async task(argv) {
          // Get a request object with admin privileges
          const req = self.apos.task.getReq();

          // Determine how many articles to create
          const total = argv.total || 10;

          console.log(`Generating ${total} sample articles...`);

          for (let i = 1; i <= total; i++) {
            const article = {
              title: `Sample Article ${i}`,
              subtitle: `This is subtitle number ${i}`,
              body: {
                items: [
                  {
                    _id: self.apos.util.generateId(),
                    type: '@apostrophecms/rich-text',
                    content: `<p>This is the body content for article ${i}. It contains sample text to demonstrate the article structure.</p>`
                  }
                ]
              }
            };

            try {
              await self.insert(req, article);
              console.log(`‚úì Created: ${article.title}`);
            } catch (error) {
              console.error(`‚úó Failed to create article ${i}:`, error.message);
            }
          }

          console.log(`\nCompleted! Generated ${total} articles.`);
        }
      }
    };
  }
};
```
<template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

Let's break down this task structure:

**The `tasks(self)` function** returns an object where each property defines a task. In this example, we're defining a single task named `generate`. The property name becomes the task name, so this task is invoked as `article:generate` (module name + colon + task name).

Each task definition is an object with two key properties:
- **`usage`**: A string that describes the task and shows how to use it. This is displayed when someone runs `node app help article:generate`, making your task self-documenting.
- **`task`**: The async function that actually runs when the task is invoked. It receives an `argv` parameter containing all the command-line arguments and options.

You can define multiple tasks in a single module by adding more properties to the returned object:

```javascript
tasks(self) {
  return {
    generate: { /* ... */ },
    export: { /* ... */ },
    cleanup: { /* ... */ }
  };
}
```

### Step 2: Run Your Task

Once you've defined the task, you can run it from the command line:

```bash
# Generate 10 articles (the default)
node app article:generate

# Generate a specific number of articles
node app article:generate --total=50

# Get help about the task
node app help article:generate
```

The `usage` property you defined will be displayed when someone runs `node app help article:generate`, making your task self-documenting.

## Understanding Request Objects in Tasks

Notice the line `const req = self.apos.task.getReq()` in our example. This is a crucial concept for working with tasks.

**Why do tasks need request objects?** In ApostropheCMS, all database operations require a request object (`req`) to determine:
- **Permissions**: What content can be accessed or modified
- **Locale**: Which language/localization context to use
- **Context**: Additional request-specific data

When you're handling a web request, the `req` object comes from Express. But in a command-line task, there's no web request, so you need to create a mock request object.

### Choosing the Right Request Type

ApostropheCMS provides several methods for creating request objects with different permission levels:

<AposCodeBlock>

```javascript
tasks(self) {
  return {
    listAll: {
      usage: 'List all articles, including unpublished ones',
      async task(argv) {
        // getReq() or getAdminReq() - Full admin permissions
        // Use this when you need to access ALL content regardless of publish state
        const req = self.apos.task.getReq();
        const articles = await self.find(req).toArray();

        console.log(`Found ${articles.length} total articles (published and unpublished)`);
        for (const article of articles) {
          console.log(`- ${article.title} (${article.aposMode})`);
        }
      }
    },
    listPublished: {
      usage: 'List only published articles (what anonymous visitors see)',
      async task(argv) {
        // getAnonReq() - Anonymous visitor permissions
        // Use this to see content as an unauthenticated user would
        const req = self.apos.task.getAnonReq();
        const articles = await self.find(req).toArray();

        console.log(`Found ${articles.length} published articles`);
        for (const article of articles) {
          console.log(`- ${article.title}`);
        }
      }
    },
    simulateEditor: {
      usage: 'Demonstrate editor-level permissions',
      async task(argv) {
        // getEditorReq() - Editor role permissions
        // Useful for testing content visibility at different permission levels
        const req = self.apos.task.getEditorReq();
        const articles = await self.find(req).toArray();

        console.log(`Editor can see ${articles.length} articles`);
      }
    }
  };
}
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

**Rule of thumb**: Use `getReq()` (admin permissions) for most tasks unless you specifically need to test how content appears to users with lower permissions.

## Working with Task Arguments

Tasks can accept both positional arguments and named options. Let's enhance our article generator to demonstrate this:

<AposCodeBlock>

```javascript
tasks(self) {
  return {
    generate: {
      usage: 'Generate sample articles.\nUsage: node app article:generate [category] --total=20 --published=true',
      async task(argv) {
        const req = self.apos.task.getReq();

        // Access positional arguments from argv._
        // argv._ is an array: [0] is the task name, [1] is first positional arg, etc.
        const category = argv._[1] || 'general';

        // Access named options with -- syntax
        const total = parseInt(argv.total) || 10;
        const published = argv.published !== 'false'; // defaults to true

        console.log(`Generating ${total} articles in category "${category}"...`);

        for (let i = 1; i <= total; i++) {
          const article = {
            title: `${category} Article ${i}`,
            subtitle: `Sample article in ${category} category`,
            body: {
              items: [
                {
                  _id: self.apos.util.generateId(),
                  type: '@apostrophecms/rich-text',
                  content: `<p>Sample content for ${category} category.</p>`
                }
              ]
            },
            // Set publish state based on argument
            aposMode: published ? 'published' : 'draft'
          };

          try {
            await self.insert(req, article);
            console.log(`‚úì Created: ${article.title} (${article.aposMode})`);
          } catch (error) {
            console.error(`‚úó Failed to create article ${i}:`, error.message);
          }
        }

        console.log(`\nCompleted! Generated ${total} ${published ? 'published' : 'draft'} articles.`);
      }
    }
  };
}
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

Now you can run your task with more flexibility:

```bash
# Generate 20 published articles in the "technology" category
node app article:generate technology --total=20 --published=true

# Generate 5 draft articles in the "news" category
node app article:generate news --total=5 --published=false
```

## Advanced Example: Data Export and Cleanup Tasks

Let's create two more advanced tasks that demonstrate additional patterns you'll commonly need:

1. **Export task**: Demonstrates file system operations, JSON generation, query builders (like `sort()`), and the pattern of using different permission levels based on flags (`--published-only`).

2. **Cleanup task**: Shows how to perform destructive operations safely with database deletion, MongoDB query operators (regex), and the critical dry-run pattern for previewing changes before executing them.

Together, these examples show how tasks can both export data for external use and maintain your database by removing unwanted content.

<AposCodeBlock>

```javascript
import fs from 'fs';
import path from 'path';

export default {
  extend: '@apostrophecms/piece-type',
  // ... fields configuration ...
  tasks(self) {
    return {
      export: {
        usage: 'Export articles to JSON.\nUsage: node app article:export --output=articles.json --published-only',
        async task(argv) {
          // Use getAnonReq if --published-only flag is set
          const req = argv['published-only']
            ? self.apos.task.getAnonReq()
            : self.apos.task.getReq();

          const outputPath = argv.output || 'articles.json';

          console.log('Fetching articles...');
          const articles = await self.find(req)
            .sort({ createdAt: -1 })
            .project({
              title: 1,
              subtitle: 1,
              slug: 1,
              createdAt: 1,
              updatedAt: 1,
              aposMode: 1
            })
            .toArray();

          console.log(`Found ${articles.length} articles. Creating JSON export...`);

          // Create the export object with metadata
          const exportData = {
            exportDate: new Date().toISOString(),
            totalArticles: articles.length,
            publishedOnly: argv['published-only'] || false,
            articles: articles.map(article => ({
              title: article.title,
              subtitle: article.subtitle || '',
              slug: article.slug,
              createdAt: article.createdAt,
              updatedAt: article.updatedAt,
              status: article.aposMode
            }))
          };

          // Write to file
          const fullPath = path.join(process.cwd(), outputPath);
          fs.writeFileSync(fullPath, JSON.stringify(exportData, null, 2));

          console.log(`‚úì Export complete! File saved to: ${fullPath}`);
          console.log(`  Total articles exported: ${articles.length}`);
        }
      },
      cleanup: {
        usage: 'Delete all articles with "Sample" in the title.\nUsage: node app article:cleanup --dry-run',
        async task(argv) {
          const req = self.apos.task.getReq();
          const dryRun = argv['dry-run'] || false;

          console.log('Searching for sample articles...');
          const articles = await self.find(req, {
            title: { $regex: /sample/i }
          }).toArray();

          console.log(`Found ${articles.length} sample articles.`);

          if (dryRun) {
            console.log('\nDRY RUN - No articles will be deleted:');
            for (const article of articles) {
              console.log(`- Would delete: ${article.title}`);
            }
            console.log('\nRun without --dry-run to actually delete these articles.');
          } else {
            console.log('\nDeleting articles...');
            for (const article of articles) {
              try {
                await self.delete(req, article);
                console.log(`‚úì Deleted: ${article.title}`);
              } catch (error) {
                console.error(`‚úó Failed to delete ${article.title}:`, error.message);
              }
            }
            console.log(`\nCompleted! Deleted ${articles.length} articles.`);
          }
        }
      }
    };
  }
};
```
  <template v-slot:caption>
    modules/article/index.js
  </template>
</AposCodeBlock>

Run these tasks like this:

```bash
# Export all articles to JSON
node app article:export --output=all-articles.json

# Export only published articles
node app article:export --output=published.json --published-only

# Preview what would be deleted (dry run)
node app article:cleanup --dry-run

# Actually delete the sample articles
node app article:cleanup
```

> [!NOTE]
> **Why JSON instead of CSV?** JSON export is more robust for complex data structures and eliminates escaping concerns. For CSV export functionality, consider using the [Import/Export extension](https://apostrophecms.com/extensions/import-export) or a dedicated CSV library like `csv-stringify` if you need custom CSV generation.

## Best Practices for Command-Line Tasks

### 1. Always Provide Clear Usage Strings

Your `usage` property should explain what the task does and show examples:

```javascript
usage: 'Generate sample articles for testing.\nUsage: node app article:generate --total=20'
```

### 2. Provide Meaningful Console Output

Keep users informed about progress:

```javascript
console.log(`Processing ${total} articles...`);
// During processing
console.log(`‚úì Completed article ${i}/${total}`);
// On completion
console.log(`\nFinished! Processed ${total} articles.`);
```

### 3. Handle Errors Gracefully

Catch errors and provide helpful messages:

```javascript
try {
  await self.insert(req, article);
} catch (error) {
  console.error(`Failed to create article: ${error.message}`);
  // Continue processing other items or exit if critical
}
```

### 4. Include a Dry Run Option for Destructive Operations

For tasks that delete or modify data, add a `--dry-run` option:

```javascript
const dryRun = argv['dry-run'] || false;
if (dryRun) {
  console.log('DRY RUN - No changes will be made');
}
```

### 5. Use the Right Permission Level

Choose the appropriate `getReq` method based on what your task needs:
- `getReq()` or `getAdminReq()` - Most tasks (full access)
- `getAnonReq()` - Testing public visibility
- `getEditorReq()`, `getContributorReq()`, etc. - Testing specific permission levels

### 6. Validate Arguments

Check that required arguments are provided:

```javascript
if (!argv.filename) {
  console.error('Error: --filename argument is required');
  console.log(this.usage);
  process.exit(1);
}
```

## Invoking Tasks from Code

Sometimes you need to run a task from within your application code rather than from the command line. ApostropheCMS provides the `apos.task.invoke()` method for this:

<AposCodeBlock>

```javascript
// In an event handler or API route
async handler(req) {
  // Invoke a task with positional arguments
  await self.apos.task.invoke('@apostrophecms/user:add', [ 'username', 'admin' ]);

  // Invoke a task with options
  await self.apos.task.invoke('article:generate', { total: 50 });

  // Invoke with both positional arguments and options
  await self.apos.task.invoke('article:generate', [ 'technology' ], { total: 20 });
}
```
  <template v-slot:caption>
    Example of programmatic task invocation
  </template>
</AposCodeBlock>

::: info
While `invoke` is available, it's generally better to call the module's methods directly when possible. Use `invoke` only when you need to execute a task that's specifically designed as a CLI task or when you don't have direct access to the module's methods.

## Conclusion

Command-line tasks are powerful tools that give you direct access to your ApostropheCMS data and business logic. By understanding how to create tasks, work with request objects, and handle arguments, you can automate maintenance operations, generate test data, perform migrations, and build custom tooling for your project.

The key concepts to remember:
- Define tasks in the `tasks(self)` section of your module
- Use `self.apos.task.getReq()` to create a request object with appropriate permissions
- Access arguments through the `argv` parameter
- Provide clear usage strings and helpful console output
- Handle errors gracefully and validate inputs

---

**Related Resources:**
- [Task Module Reference Documentation](/reference/modules/task.md)
- [Module Configuration - tasks(self) Section](/reference/module-api/module-overview.md#tasks-self)
- [Database Queries Guide](/guide/database-queries.md)

================================================================================
COLLECTION: tutorials
NAV_PATH: Pro Topics
DOC_PATH: tutorials/pro.md
URL: https://apostrophecms.com/docs/tutorials/pro
================================================================================
# Pro Topics

In-depth tutorials for teams using ApostropheCMS‚Äôs commercial modules and advanced capabilities. These guides support complex implementations, from multisite setups to enterprise-grade integrations and workflows.

<AposTwoColumns>
  <template #leftColumn>
    <AposCtaButton
    detail-heading="Pro"
    title="Using Advanced Permissions"
    content="The Advanced Permission module is a Pro extension that adds more granular control over content permissions. It provides the ability to create custom groups and assign them to users directly in the admin UI."
    url="/docs/tutorials/setting-up-the-advanced-permission-pro-extension.html"
    />
  </template>
  <template #rightColumn>
    <AposCtaButton
    detail-heading="Pro"
    title="Multisite Site Data"
    url="/docs/tutorials/passing-site-data-in-multisite.html"
    content="Learn how to configure site-specific settings through the dashboard that automatically flow to individual sites, giving content managers control over site behavior without requiring code changes."
    />
  </template>
</AposTwoColumns>

================================================================================
COLLECTION: tutorials
NAV_PATH: Pro Topics > Using Advanced Permissions
DOC_PATH: tutorials/setting-up-the-advanced-permission-pro-extension.md
URL: https://apostrophecms.com/docs/tutorials/setting-up-the-advanced-permission-pro-extension
================================================================================
# How To Set Up the Advanced Permission Pro Extension
The [Advanced Permission](https://apostrophecms.com/extensions/advanced-permission) module is a Pro extension that adds more granular control over content permissions. It provides the ability to create custom groups and assign them to users directly in the admin UI. 

A group is a set of rules that specify how users can create, edit, delete, and publish content, including creating new users and groups. The module provides granular control, allowing admins to give a group *Create*, *Edit*, *Delete*, and *Publish* permissions for each piece type on the site. Those four core permissions can be extended with new custom permissions.

The Advanced Permission extension also enables admins to give groups and individual users granular per-document permissions on specific pages and pieces.

::: info
The name of the npm package of the Advanced Permission module is `@apostrophecms-pro/advanced-permission`.

## Prerequisites

The requirements for setting up the Advanced Permission module are:

- **An Apostrophe 3+ application**: If you don‚Äôt already have one, make sure you meet the requirements and then follow the instructions in the [development setup guide](/guide/setting-up.md).
- **An Apostrophe Pro or Apostrophe Assembly subscription**: To gain access to the Advanced Permission module, you first need to join [Apostrophe Pro](https://apostrophecms.com/pro) or [Apostrophe Assembly](https://apostrophecms.com/assembly). 
## Installing the Advanced Permission Module

After joining Apostrophe Pro or Apostrophe Assembly, you'll be added to the `@apostrophecms-pro` npm organization. This gives you the ability to install the Advanced Permission module in your Apostrophe project. 

::: warning
If you try to add `@apostrophecms-pro/advanced-permission` to your project's dependency before being added to `@apostrophecms-pro`, you‚Äôll get the following error:

`'@apostrophecms-pro/advanced-permission' is not in this registry.`

`@apostrophecms-pro/advanced-permission` is a private npm package. You must authenticate in npm before installing it. The recommended authentication method changes depending on whether you‚Äôre in a development or production environment.

**Development Setup**
In a development environment, run the following command to start the npm authentication procedure:

::: raw
npm login

This will produce an output as below:

::: raw
Login at:<br>
https://www.npmjs.com/login?next=/login/cli/<NPM_HASH><br>
Press ENTER to open in the browser...

Press ENTER to open the npm login page in your default browser. Type in your credentials, sign in, and return to the CLI.

After logging in successfully, you‚Äôll receive the following message: 

::: raw
Logged in on https://registry.npmjs.org/`

::: info
To keep the session alive, npm will create a global `.npmrc` configuration file containing your access token in the following line:

::: raw
//registry.npmjs.org/:_authToken=<YOUR_NPM_ACCESS_TOKEN>

`cd` to your project folder and then install the Advanced Permission Pro extension with the command below:

::: raw
npm install @apostrophecms-pro/advanced-permission

npm will use the authenticated URL in `.npmrc` to download the private `@apostrophecms-pro/advanced-permission` package. It will then install it as per usual.

**Production Setup**
In a production environment, authenticate npm commands by setting up a granular token related to the `@apostrophecms-pro` organization. Follow the [official guide](https://docs.npmjs.com/creating-and-viewing-access-tokens#creating-granular-access-tokens-on-the-website) for guidance. 

After setting up an npm granular token, add a `.npmrc` file to the root folder of your Apostrophe project. Initialize it with the following line:

//registry.npmjs.org/:_authToken=${NPM_TOKEN}

When launching an npm command, `${NPM_TOKEN}` will be replaced with the value read from the `NPM_TOKEN` environment variable. That URL will be used to retrieve packages from the npm registry as an authenticated user.

::: warning
Adding a local `.npmrc` file will override your global `.npmrc` file npm created on `npm login`. To avoid authorization issues while installing private packages from the `@apostrophecms-pro` npm organization, set the `NPM_TOKEN` environment variable on your local machine when working with a project that has a `.npmrc` defined as above. You can do that in your `.bashrc` file using `EXPORT NPM_TOKEN=``"``<YOUR_PERSONAL_NPM_TOKEN>``"`

In the production server, set the `NPM_TOKEN` env to the value of your npm granular token:

::: raw
export NPM_TOKEN="<YOUR_NPM_GRANULAR_TOKEN>"

When launching `npm install`, the production environment will now be able to install the `"@apostrophecms-pro/doc-template-library"` dependency in `package.json`.

## Enable the Module in Apostrophe

Enable the Advanced Permission extension by adding the following two modules to the `[app.js](/tutorials/code-organization.md#app-js)` file:

<AposCodeBlock>

```javascript
require('apostrophe')({
  shortName: 'my-project',
  modules: {
    // other modules...

    // enable the Advanced Permission extension
    '@apostrophecms-pro/advanced-permission-group': {},
    '@apostrophecms-pro/advanced-permission': {}
  },
  // remaining configs...
});
```
  <template v-slot:caption>
    app.js
  </template>

</AposCodeBlock>

::: info
To use Advanced Permission in a multisite project, you can add the two modules outlined above to both the `site/index.js` and `dashboard/index.js` files. Adding the modules to the two files will enable the Pro extension for both the dashboard and all individual sites. It‚Äôs also possible to enable the extension only for the dashboard on individual sites. Before starting to use the Advanced Permission module in the dashboard, make sure the `privateDashboards` feature is set to `false`. This setting won‚Äôt affect individual sites.

On the first run of your project after enabling the Advanced Permission module, some database migrations will automatically occur. These create a group for each role found in existing users and link them to the group corresponding to their `[role](/guide/users.md#user-roles)` field.

After adding the Advanced Permission extension, a ‚ÄúGroups‚Äù item will appear in the top left menu in the admin bar.

## Adding Custom Permissions

In addition to the *Create*, *Edit*, *Delete*, and *Publish* core permissions, new custom permissions can be defined through the `permissions` object in a piece-type `index.js` file for an individual piece or in `[@apostrophecms/page-type/index.js](/reference/modules/page-type.md#apostrophecms-page-type)` for all pages. You can‚Äôt define custom permissions in individual page types.

Much like the `fields` object, the `permissions` object takes an `add` property. This accepts permission properties with objects having the following three properties:

- `label`: A string that describes the new permission to the user. It determines what is shown in the group and per-document permission grids.
- `requires`: An optional string with the name of an existing permission or an object with multiple permissions (e.g., `requires: { $or: [ 'edit', 'create' ] }`). It determines whether the new permission is dependent on any other permission in the grid. For example, `requires: 'publish'` would require the admin to select the "Publish" permission for the document or document type before they could select the new permission.
- `perDoc`: An optional boolean to define whether the new permission should appear in the user and group per-document permission matrices. The default value is `false`.

For example, you can define a custom `decriptionField` permission with:

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  fields: {
    // ...
  },
  // ...
  permissions: {
    add: {
      decriptionField: {
        label: 'Description',
        requires: 'publish',
        perDoc: false
      }
    }
  }
};
```

</AposCodeBlock>

::: tip
By using `permissions` in an Apostrophe core module at the project level, you can add a new custom permission to multiple document types. For example, extending the `[@apostrophecms/piece-type](/reference/modules/piece-type.md#apostrophecms-piece-type)` module with the `permissions` object would add the custom permissions to all pieces.

`**editPermission**`**: Limiting Access to a Single Field**
After defining a custom permission, you can assign it to a specific field of a piece type by using `editPermission`. This schema field property takes an object with the following two properties:

- `action`: A string with the name of one of the built-in permissions (e.g., `'create'`) or a custom permission.
- `type`: A string with the name of the module that permission is associated with. For core modules, make sure to prefix the module name with `@apostrophecms/` or `@apostrophecms-pro/`.

For example, you can assign the custom `decriptionField` permission to the `description` field of a `product` as below:

<AposCodeBlock>

```javascript
module.exports = {
  // ...
  fields: {
    add: {
      description: {
        type: 'string',
        label: 'Description',
        textarea: true,
        editPermission: {
          action: 'descriptionField', // custom permission
          type: 'product'
        }
      },
      // other fields...
    },
  },
  // ...
};
```

</AposCodeBlock>

Only users who have been granted the *Create* and/or *Modify* permissions as well as the `descriptionField` permission will now be able to edit the description of `product` pieces.

::: info
`perDoc: true` isn‚Äôt compatible with the `editPermission` feature. To grant a user per-document custom permission on a given field of a piece, follow this procedure instead:

1. Define a custom permission with `perDoc: false`.
2. Use `editPermission` to assign the custom permission to the desired field of the given piece.
3. Define a group with the selected custom permission for the given piece.
4. Assign the group to the user.
5. Grant the user per-document permission to *Modify* the documents of the given piece.

**A complete example: defining the custom ‚ÄúPricing‚Äù permission**
Suppose your project has a `service` piece. You want to add a custom ‚ÄúPricing‚Äù permission so that only users with this permission can edit the price of services on your site. That can be achieved with the `permissions` and `editPermission` objects in `modules/service/index.js` as below:

<AposCodeBlock>

```javascript
    module.exports = {
      extend: '@apostrophecms/piece-type',
      options: {
        label: 'Service'
      },
      fields: {
        add: {
          title: {
            type: 'string',
            label: 'Title'
          },
          description: {
            type: 'string',
            label: 'Description',
            textarea: true
          },
          price: {
            type: 'float',
            label: 'Price',
            editPermission: {
              action: 'pricingField',
              type: 'service'
            }
          }
        },
        group: {
          basics: {
            label: 'Basics',
            fields: [
              'title',
              'description',
              'price'
            ]
          }
        }
      },
      permissions: {
        add: {
          pricingField: {
            label: 'Pricing'
          }
        }
      }
    };
```

</AposCodeBlock>

**Customized permission checks**
`editPermission` is not the only way to take advantage of custom permissions. You can also verify if a particular user has a custom permission (including per-document permissions) when coding your own routes and methods server-side with the following line:

::: raw
self.apos.permission.can(req, '<custom_permission_name>', doc)

The function returns `true` if the user has the custom permission, `false` otherwise. This approach opens the door to custom use cases involving permission verification.

================================================================================
COLLECTION: tutorials
NAV_PATH: Pro Topics > Passing Site Data in Multisite
DOC_PATH: tutorials/passing-site-data-in-multisite.md
URL: https://apostrophecms.com/docs/tutorials/passing-site-data-in-multisite
================================================================================
# Passing Dashboard Data to Sites in the Multisite Pro extension

<!-- INSERT VIDEO HERE-->

## Why This Matters & Core Principles

Content managers shouldn't need developers to change basic site settings like email addresses, API keys, or feature toggles. In a multisite environment, the dashboard becomes your configuration interface - any field you add to the dashboard's `site` piece automatically becomes available when individual sites initialize.

This transforms routine configuration tasks from code deployments into simple form updates, reducing support tickets while giving content managers the autonomy they need.

When implementing dashboard-to-site data flow, prioritize:
- **Self-service configuration**: Enable site settings through familiar CMS interfaces
- **Reduced deployment overhead**: Configuration changes shouldn't require code releases
- **Consistent patterns**: Use predictable approaches for passing data to modules
- **Clear editor guidance**: Write helpful field labels and provide sensible defaults

## Understanding Multisite Project Structure

A multisite project has two key areas that work together:

- **`dashboard/`** - Contains the admin interface where editors manage all sites. The `dashboard/modules/site/index.js` file defines what fields editors see when configuring individual sites.
- **`sites/`** - Contains the configuration that generates individual sites. The `sites/index.js` file receives the data editors entered and uses it to configure modules and features.

The data flow is straightforward: editors fill out forms in the dashboard ‚Üí that data gets passed to the sites configuration function ‚Üí individual sites launch with the specified settings.

## How Data Flows from Dashboard to Sites

The multisite module passes the entire `site` object as a parameter to your sites configuration function. Any fields you add to the dashboard's `site` module become immediately available:

<AposCodeBlock>

```javascript
// At the dashboard level add configuration fields
export default {
  fields: {
    add: {
      fromAddress: {
        type: 'email',
        label: 'From Email Address',
        help: 'Default sender address for outgoing emails'
      },
      theme: {
        type: 'select',
        label: 'Site Theme',
        choices: [
          { label: 'Default', value: 'default' },
          { label: 'Demo', value: 'demo' }
        ]
      }
    }
  }
};
```
  <template v-slot:caption>
    dashboard/modules/site/index.js
  </template>
</AposCodeBlock>

<AposCodeBlock>

```javascript
// At the site level use the data to configure modules
export default async function (site) {
  const config = {
    theme: site.theme,
    modules: {
      '@apostrophecms/email': {
        options: {
          from: site.fromAddress || ''
        }
      },
      '@apostrophecms/form': {
        options: {
          email: {
            from: site.fromAddress
          }
        }
      }
    }
  };

  // Load theme-specific configuration
  const { default: theme } = await import(`./lib/theme-${site.theme}.js`);
  theme(site, config);

  return config;
};
```
  <template v-slot:caption>
    sites/index.js
  </template>
</AposCodeBlock>

## Theme-Based Module Loading

Using separate theme files keeps your main configuration clean while allowing themes to enable different module sets. Each theme function receives the site data and the base configuration object, then adds theme-specific modules and settings:

<AposCodeBlock>

```javascript
// Simple theme with minimal modules
export default function(site, config) {
  // The theme function modifies the config object by adding modules
  config.modules = {
    ...config.modules,
    'theme-default': {}
  };
};
```
  <template v-slot:caption>
    sites/lib/theme-default.js
  </template>
</AposCodeBlock>

<AposCodeBlock>

```javascript
// Feature-rich theme with additional modules
export default function (site, config) {
  config.modules = {
    ...config.modules,
    'theme-demo': {
      options: {
        shortName: site.shortName
      }
    },
    'advanced-gallery': {},
    'portfolio-showcase': {},
    'animation-widgets': {}
  };
};
```
  <template v-slot:caption>
    sites/lib/theme-demo.js
  </template>
</AposCodeBlock>

## Practical Configuration Examples

**API Keys and Service Configuration:**
```javascript
// Dashboard field
mailchimpApiKey: {
  type: 'string',
  label: 'Mailchimp API Key',
  help: 'Used for newsletter signups'
}

// Site usage
'newsletter-signup': {
  options: {
    apiKey: site.mailchimpApiKey
  }
}
```

**Feature Toggles:**
```javascript
// Dashboard field
enableBlog: {
  type: 'boolean',
  label: 'Enable Blog Features'
}

// Site usage
// Conditionally add blog modules if enabled
...(site.enableBlog && {
  article: {},
  'article-page': {},
  'blog-widget': {}
})
```

**Conditional Module Loading:**
```javascript
// Theme file can check site properties
export default function (site, config) {
  config.modules = {
    ...config.modules,
    'theme-corporate': {},

    // Only enable e-commerce for premium sites
    ...(site.planLevel === 'premium' && {
      'shopping-cart': {},
      'payment-processor': {}
    })
  };
};
```

## Site Updates and Reinitialization

When content managers update site settings in the dashboard, the affected site automatically reinitializes on the next request with the new configuration. No server restart required - changes take effect immediately.

## Conclusion

Dashboard-to-site data passing transforms the multisite management experience from a developer-centric workflow to a content manager-empowered system. By thoughtfully designing your site piece schema in the dashboard with clear labels, helpful guidance, and sensible defaults, you create powerful self-service capabilities that reduce support overhead while maintaining the security and consistency your applications require.

---

**Related Resources:**
- [ApostropheCMS Multisite Extension Documentation](https://apostrophecms.com/extensions/multisite-apostrophe-assembly)
- [ApostropheCMS Multisite Dashboard Documentation](https://apostrophecms.com/extensions/multisite-dashboard)
